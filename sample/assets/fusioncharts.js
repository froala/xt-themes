(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("FusionCharts", [], factory);
	else if(typeof exports === 'object')
		exports["FusionCharts"] = factory();
	else
		root["FusionCharts"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	var parentJsonpFunction = window["webpackJsonpFusionCharts"];
/******/ 	window["webpackJsonpFusionCharts"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [], result;
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules, executeModules);
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/ 		if(executeModules) {
/******/ 			for(i=0; i < executeModules.length; i++) {
/******/ 				result = __webpack_require__(__webpack_require__.s = executeModules[i]);
/******/ 			}
/******/ 		}
/******/ 		return result;
/******/ 	};
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// objects to store loaded and loading chunks
/******/ 	var installedChunks = {
/******/ 		14: 0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		var installedChunkData = installedChunks[chunkId];
/******/ 		if(installedChunkData === 0) {
/******/ 			return new Promise(function(resolve) { resolve(); });
/******/ 		}
/******/
/******/ 		// a Promise means "currently loading".
/******/ 		if(installedChunkData) {
/******/ 			return installedChunkData[2];
/******/ 		}
/******/
/******/ 		// setup Promise in chunk cache
/******/ 		var promise = new Promise(function(resolve, reject) {
/******/ 			installedChunkData = installedChunks[chunkId] = [resolve, reject];
/******/ 		});
/******/ 		installedChunkData[2] = promise;
/******/
/******/ 		// start chunk loading
/******/ 		var head = document.getElementsByTagName('head')[0];
/******/ 		var script = document.createElement('script');
/******/ 		script.type = 'text/javascript';
/******/ 		script.charset = 'utf-8';
/******/ 		script.async = true;
/******/ 		script.timeout = 120000;
/******/
/******/ 		if (__webpack_require__.nc) {
/******/ 			script.setAttribute("nonce", __webpack_require__.nc);
/******/ 		}
/******/ 		script.src = __webpack_require__.p + "" + chunkId + ".js";
/******/ 		var timeout = setTimeout(onScriptComplete, 120000);
/******/ 		script.onerror = script.onload = onScriptComplete;
/******/ 		function onScriptComplete() {
/******/ 			// avoid mem leaks in IE.
/******/ 			script.onerror = script.onload = null;
/******/ 			clearTimeout(timeout);
/******/ 			var chunk = installedChunks[chunkId];
/******/ 			if(chunk !== 0) {
/******/ 				if(chunk) {
/******/ 					chunk[1](new Error('Loading chunk ' + chunkId + ' failed.'));
/******/ 				}
/******/ 				installedChunks[chunkId] = undefined;
/******/ 			}
/******/ 		};
/******/ 		head.appendChild(script);
/******/
/******/ 		return promise;
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 277);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(311), __esModule: true };

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(329), __esModule: true };

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(331), __esModule: true };

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(333), __esModule: true };

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(335), __esModule: true };

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.PROJECT_VERSION = exports.datasetFactory = exports.componentFactory = exports.dropHash = exports.BGRATIOSTRING = exports.VISIBLE = exports.MOUSEMOVE = exports.MOUSEOUT = exports.FIT = exports.FILL = exports.TILE = exports.COMMA = exports.animationObjStr = exports.configStr = exports.ROUND = exports.BLANK = exports.POINTER = exports.HAND = exports.BOLD = exports.NORMAL = exports.mathRound = exports.mathAbs = exports.animHelperFN = exports.xssEncode = exports.MathExt = exports.defaultGaugePaletteOptions = exports.crispBound = exports.hasAttribDefs = exports.setAttribDefs = exports.parseConfiguration = exports.attribDefs = exports.canvasBorderColorStr = exports.defined = exports.pInt = exports.attrTypeBool = exports.canvasBGAlphaStr = exports.attrTypeNum = exports.DASH_DEF = exports.chartPaletteStr = exports.TRACKER_FILL = exports.capitalizeString = exports.handleContainerResize = exports.getContainerBackgroundColor = exports.priorityList = exports.appliedCSS = exports.graphics = exports.convertColor = exports.pseudoEval = exports.executeJS = exports.componentConfigurer = exports.componentDispose = exports.createDialog = exports.chartAPI = exports.axisLabelAdder = exports.getDashStyle = exports.createTrendLine = exports.getAxisLimits = undefined;
exports.supportedStyle = exports.parsexAxisStyles = exports.setLineHeight = exports.setImageDisplayMode = exports.getLinkAction = exports.lineHeightFactor = exports.isIE = exports.CREDIT_REGEX = exports.hasSVG = exports.stableSort = exports.stubFN = exports.preDefStr = exports.getCripValues = exports.getCrispValue = exports.isArray = exports.getImageURL = exports.regReplaceEscape = exports.regescape = exports.getSentenceCase = exports.CREDIT_STRING = exports.CREDIT_HREF = exports.hasTouch = exports.toPrecision = exports.parseTooltext = exports.parseUnsafeString = exports.parsePointValue = exports.getFirstAlpha = exports.trimString = exports.gradientify = exports.toRaphaelColor = exports.clampNumber = exports.pluckColor = exports.getColorCodeString = exports.getFirstColor = exports.getFirstValue = exports.getDefinedColor = exports.fcEach = exports.bindSelectionEvent = exports.getViewPortDimension = exports.getPosition = exports.getValidValue = exports.pluckFontSize = exports.getComparatorFN = exports.dehashify = exports.hashify = exports.createElement = exports.getFirstDefinedValue = exports.pluckNumber = exports.pluck = exports.imprint = exports.deltend = exports.extend2 = exports.getTouchEvent = exports.getMouseCoordinate = exports.getEventCoordinate = exports.plotEventHandler = exports.regex = exports.CLICK_THRESHOLD_PIXELS = exports.TOUCH_THRESHOLD_PIXELS = exports.visibleStr = exports.hiddenStr = exports.TEXTANCHOR = exports.COMMASPACE = exports.PXSTRING = exports.HUNDREDSTRING = exports.SHAPE_RECT = exports.FC_CONFIG_STRING = exports.POSITION_END = exports.POSITION_START = exports.POSITION_MIDDLE = exports.POSITION_CENTER = exports.POSITION_LEFT = exports.POSITION_BOTTOM = exports.POSITION_RIGHT = exports.POSITION_TOP = exports.STRINGUNDEFINED = exports.DECIMALSTRING = exports.ONESTRING = exports.TESTSTR = exports.SAMPLESTRING = exports.ZEROSTRING = exports.COMMASTRING = exports.OBJECTSTRING = exports.STRINGSTRING = exports.BREAKSTRING = exports.HASHSTRING = exports.COLOR_TRANSPARENT = exports.COLOR_WHITE = exports.COLOR_GLASS = exports.COLOR_BLACK = exports.BLANKSTRING = exports.UNDERSCORE = exports.UNDEF = exports.BLANKSTRINGPLACEHOLDER = exports.getLineHeightFactor = exports.setLineHeightFactor = exports.getEmptyConstractor = exports.addInterActiveEvtName = exports.isInterActiveEvt = exports.setVCanvas = undefined;

var _iterator = __webpack_require__(9);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(10);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2['default'] === "function" && typeof _iterator2['default'] === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2['default'] === "function" && obj.constructor === _symbol2['default'] && obj !== _symbol2['default'].prototype ? "symbol" : typeof obj; }; /* ?
                                                                                                                                                                                                                                                                                                                                         // metascript to check license status for creditLabel
                                                                                                                                                                                                                                                                                                                                         var licenseActive = (!global.licensed + " &&"),
                                                                                                                                                                                                                                                                                                                                         resellerLicenseText = "'" + (global.resellerLicense ? 'FusionCharts XT - Only For Resale': 'FusionCharts XT Trial')
                                                                                                                                                                                                                                                                                                                                                                +"' ||";
                                                                                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                                                                                         */
/**
 * @private
 * @module fusioncharts.renderer.javascript.lib
 * @requires fusioncharts.renderer.javascript.polyfill
 * @requires fusioncharts.renderer.javascript
 * @requires ../../../../vendors/svgtocanvas/build/svgdecanvo-fusioncharts.js
 * @requires fusioncharts.renderer.javascript.lib-attr
 */
/* global escape: false */

var _package = __webpack_require__(314);

var _package2 = _interopRequireDefault(_package);

var _libAttr = __webpack_require__(184);

var _domEvent = __webpack_require__(34);

var _domEvent2 = _interopRequireDefault(_domEvent);

var _libExtend = __webpack_require__(185);

var _libExtend2 = _interopRequireDefault(_libExtend);

var _eventApi = __webpack_require__(7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var PROJECT_VERSION = _package2['default'].version;

var win = window,
    lib = {},
    fcGlobal = {},
    BGRATIOSTRING,

// The default value for stroke-dash attribute.
DASH_DEF = 'none',

// eslint-disable-next-line no-empty-function
EMPTYFN = function EMPTYFN() {},
    getEmptyConstractor = function getEmptyConstractor() {
  // eslint-disable-next-line no-empty-function
  return function () {};
},
    doc = win.document,
    nav = win.navigator,
    hasSVG = Boolean(win.SVGAngle || doc.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1')),
    isIE = /msie/i.test(nav.userAgent) && !win.opera,
    attrTypeNum = 1,
    attrTypeBool = 2,
    TRACKER_FILL = 'rgba(192,192,192,' + (isIE ? 0.002 : 0.000001) + ')',
    POSITION_RIGHT = 'right',
    POSITION_LEFT = 'left',
    POSITION_CENTER = 'center',
    UNDEF,
    BLANKSTRINGPLACEHOLDER = '#BLANK#',
    SAMPLESTRING = 'Ay0',
    COLOR_BLACK = '000000',
    COLOR_GLASS = 'rgba(255, 255, 255, 0.3)',
    COLOR_WHITE = 'FFFFFF',
    COLOR_TRANSPARENT = 'rgba(0,0,0,0)',
    HASHSTRING = '#',
    BREAKSTRING = '<br />',
    STRINGSTRING = 'string',
    OBJECTSTRING = 'object',
    BLANK = '',
    BLANKSTRING = BLANK,
    COMMASTRING = ',',
    COMMA = ',',
    COLON = ':',
    HYPHEN = '-',
    ZEROSTRING = '0',
    MOUSEOUT = 'mouseout',
    MOUSEMOVE = 'mousemove',
    TESTSTR = 'Ag',
    ONESTRING = '1',
    DECIMALSTRING = '.',
    STRINGUNDEFINED = 'undefined',
    POSITION_TOP = 'top',
    POSITION_BOTTOM = 'bottom',
    POSITION_MIDDLE = 'middle',
    POSITION_START = 'start',
    POSITION_END = 'end',
    FC_CONFIG_STRING = '_FCconf',
    SHAPE_RECT = 'rect',
    HUNDREDSTRING = '100',
    VISIBLE = 'visible',

// SEVENTYSTRING = '70',
// NINETYSTRING = '90',
PXSTRING = 'px',
    COMMASPACE = ', ',
    TEXTANCHOR = 'text-anchor',
    canvasBGAlphaStr = 'canvasBgAlpha',

// AUTOSTRING = 'auto',
ROUND = 'round',

// PERCENTAGESTRING = '%',
// PLOTFILLCOLOR_STR = 'plotFillColor',
UNDERSCORE = '_',
    NORMAL = 'normal',
    BOLD = 'bold',
    POINTER = 'pointer',
    HAND = POINTER,
    TILE = 'tile',
    FILL = 'fill',
    FIT = 'fit',

// DEFAULT = 'default',
CREDIT_HREF = 'http://www.fusioncharts.com?BS=FCHSEvalMark&utm_source=FCS_trial' + '&pver=' + escape(PROJECT_VERSION),
    CREDIT_STRING = /* ?=resellerLicenseText */'',
    canvasBorderColorStr = 'canvasBorderColor',
    TOUCH_THRESHOLD_PIXELS = 15,
    CLICK_THRESHOLD_PIXELS = 5,


// defaultFontStr = 'Verdana,sans',
lineHeightFactor = 1.2,

// line = 'line',
// bar = 'bar',
// column = 'column',
// volume = 'volume',
configStr = 'config',
    animationObjStr = 'animationObj',

// showHoverEffectStr = 'showHoverEffect',
hiddenStr = 'hidden',
    visibleStr = 'visible',
    toFloat = parseFloat,
    CREDIT_REGEX = /fusioncharts\.com|fusioncharts\.github\.io$/i,

// Regular Expressions
breakPlaceholder = /\{br\}\s*/ig,
    stripWhitespace = /\s+/g,
    dropHash = /^#?/,
    startsRGBA = /^rgba/i,
    cleanColorCode = /[#\s]/ig,
    hexcode = /^#?[0-9a-f]{6}/i,
    validhexcolor = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i,
    mathAbs = Math.abs,
    mathPow = Math.pow,
    mathRound = Math.round,
    EPSILON = mathPow(2, -24),
    objectToStrFn = Object.prototype.toString,
    touchEnabled = 'ontouchstart' in doc,
    hasTouch = touchEnabled && !(nav.maxTouchPoints || nav.msMaxTouchPoints),
    creditLabel = /* ?=licenseActive */!CREDIT_REGEX.test(win.location.hostname),
    math = Math,
    mathMax = math.max,
    mathMin = math.min,
    round = math.round,
    stubEvent = {
  pageX: 0,
  pageY: 0
},
    M = 'M',
    l = 'l',
    Z = 'Z',
    gaugePaletteColors = ['8BBA00', 'F6BD0F', 'FF654F', 'AFD8F8', 'FDB398', 'CDC309', 'B1D0D2', 'FAD1B9', 'B8A79E', 'D7CEA5', 'C4B3CE', 'E9D3BE', 'EFE9AD', 'CEA7A2', 'B2D9BA'],
    defaultGaugePaletteOptions = {
  paletteColors: [gaugePaletteColors, gaugePaletteColors, gaugePaletteColors, gaugePaletteColors, gaugePaletteColors],

  bgColor: ['CBCBCB,E9E9E9', 'CFD4BE,F3F5DD', 'C5DADD,EDFBFE', 'A86402,FDC16D', 'FF7CA0,FFD1DD'],
  bgAngle: [270, 270, 270, 270, 270],
  bgRatio: ['0,100', '0,100', '0,100', '0,100', '0,100'],
  bgAlpha: ['50,50', '60,50', '40,20', '20,10', '30,30'],

  toolTipBgColor: ['FFFFFF', 'FFFFFF', 'FFFFFF', 'FFFFFF', 'FFFFFF'],
  toolTipBorderColor: ['545454', '545454', '415D6F', '845001', '68001B'],
  baseFontColor: ['555555', '60634E', '025B6A', 'A15E01', '68001B'],

  tickColor: ['333333', '60634E', '025B6A', 'A15E01', '68001B'],
  trendDarkColor: ['333333', '60634E', '025B6A', 'A15E01', '68001B'],
  trendLightColor: ['f1f1f1', 'F3F5DD', 'EDFBFE', 'FFF5E8', 'FFD1DD'],

  pointerBorderColor: ['545454', '60634E', '415D6F', '845001', '68001B'],
  pointerBgColor: ['545454', '60634E', '415D6F', '845001', '68001B'],

  canvasBgColor: ['FFFFFF', 'FFFFFF', 'FFFFFF', 'FFFFFF', 'FFFFFF'],
  canvasBgAngle: [0, 0, 0, 0, 0],
  canvasBgAlpha: ['100', '100', '100', '100', '100'],
  canvasBgRatio: ['', '', '', '', ''],
  canvasBorderColor: ['545454', '545454', '415D6F', '845001', '68001B'],
  canvasBorderAlpha: [100, 100, 100, 90, 100],

  altHGridColor: ['EEEEEE', 'D8DCC5', '99C4CD', 'DEC49C', 'FEC1D0'],
  altHGridAlpha: [50, 35, 10, 20, 15],
  altVGridColor: ['767575', 'D8DCC5', '99C4CD', 'DEC49C', 'FEC1D0'],
  altVGridAlpha: [10, 20, 10, 15, 10],

  borderColor: ['767575', '545454', '415D6F', '845001', '68001B'],
  borderAlpha: [50, 50, 50, 50, 50],
  legendBgColor: ['ffffff', 'ffffff', 'ffffff', 'ffffff', 'ffffff'],
  legendBorderColor: ['545454', '545454', '415D6F', '845001', 'D55979'],
  plotFillColor: ['767575', 'D8DCC5', '99C4CD', 'DEC49C', 'FEC1D0'],
  plotBorderColor: ['999999', '8A8A8A', '6BA9B6', 'C1934D', 'FC819F'],
  msgLogColor: ['717170', '7B7D6D', '92CDD6', '965B01', '68001B'],

  TrendLightShadeOffset: 30
},
    xssEncode = function xssEncode(s) {
  if (s === null || typeof s === 'undefined' || typeof s.toString !== 'function') {
    return '';
  }

  // do we convert to numerical or html entity?
  s = s.toString().replace(/&/g, '&amp;').replace(/\'/g, '&#39;') // no HTML equivalent as &apos is not cross browser supported
  .replace(/\"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

  return s;
},
    MathExt = {
  /**
   * Returns the number of decimal places provided
   * in the given number.
   *  @param  {number} num Number for which we've to find the decimal places.
   *  @return {number}     Number of decimal places found.
   */
  numDecimals: function numDecimals(num) {
    // Fix for upperLimits or lowerLimits given in decimal
    num = toPrecision(num, 10);
    // Absolute value (to avoid floor disparity for negative num)
    num = Math.abs(num);
    // Get decimals
    var decimal = toPrecision(num - Math.floor(num), 10),

    // Number of decimals
    numDecimals = String(decimal).length - 2;
    // For integral values
    numDecimals = numDecimals < 0 ? 0 : numDecimals;
    // Return the length of string minus '0.'
    return numDecimals;
  },
  /**
   * toRadians method converts angle from degrees to radians
   * @param  {number} angle The numeric value of the angle in degrees
   * @return {number}       The numeric value of the angle in radians
   */
  toRadians: function toRadians(angle) {
    return angle / 180 * Math.PI;
  },
  /**
   * toDegrees method converts angle from radians to degrees
   * @param  {number} angle The numeric value of the angle in radians
   * @return {number}       The numeric value of the angle in degrees
   */
  toDegrees: function toDegrees(angle) {
    return angle / Math.PI * 180;
  },
  /**
   * flashToStandardAngle method converts angles from Flash angle to normal angles (0-360).
   *  @param  {number}  ang Angle to be converted
   *  @return {number}      Converted angle
   */
  flashToStandardAngle: function flashToStandardAngle(ang) {
    return -1 * ang;
  },
  /**
   * standardToFlashAngle method converts angles from normal angle to Flash angles
   *  @param  {number} ang Angle to be converted
   *  @return {number}     Converted angle
   */
  standardToFlashAngle: function standardToFlashAngle(ang) {
    return -1 * ang;
  },
  /**
   * flash180ToStandardAngle method changes a Flash angle (-180Â° to 180Â°) into standard
   * angle (0Â° to 360Â° CCW) wrt the positive x-axis using angle input.
   * @param  {number} ang Angle in degrees (-180Â° to 180Â°).
   * @return {number}     Angle in degrees (0Â° to 360Â° CCW).
   */
  flash180ToStandardAngle: function flash180ToStandardAngle(ang) {
    var a = 360 - ((ang %= 360) < 0 ? ang + 360 : ang);
    return a == 360 ? 0 : a;
  },
  /**
   * getAngularPoint method calculates a point at a given angle
   * and radius from the given point.
   *  @param {number} fromX    From point's X co-ordinate
   *  @param {number} fromY    From point's Y co-ordinate
   *  @param {number} distance How much distance (pixels) from current point?
   *  @param {number} angle    At what angle (degrees - standard) from current point
   *
   * @return {Object}          Object containing the x and y values with respect to given input
   */
  getAngularPoint: function getAngularPoint(fromX, fromY, distance, angle) {
    // Convert the angle into radians
    angle = angle * (Math.PI / 180);
    var xPos = fromX + distance * Math.cos(angle),
        yPos = fromY - distance * Math.sin(angle);
    return {
      x: xPos,
      y: yPos
    };
  },
  /**
   * remainderOf method calculates the remainder in
   * a division to the nearest twip.
   * @param   {number} a   dividend in a division
   * @param   {number} b   divisor in a division
   *
   * @return  {number}     Remainder in the division rounded to the nearest twip.
   */
  remainderOf: function remainderOf(a, b) {
    return Math.ceil(a % b);
  },
  /**
   * boundAngle method converts any angle in degrees
   * to its equivalent in the range of 0 to 360 degrees.
   * @param  {number} angle Angle in degrees to be procesed. Can take negetive values.
   * @return {number}       Equivalent non-negetive angle in degrees less than or equal to
   *                        360 degrees.
   */
  boundAngle: function boundAngle(angle) {
    if (angle >= 0) {
      return MathExt.prototype.remainderOf(angle, 360);
    } else {
      return 360 - MathExt.prototype.remainderOf(Math.abs(angle), 360);
    }
  },
  /**
   * toNearestTwip method converts a numeric value by
   * rounding it to the nearest twip value ( one twentieth
   * of a pixel ) for propermost rendering in flash.
   * @param  {number} num Number to rounded
   *
   * @return {number}     Number rounded upto 2 decimal places and
   *                      second significant digit right of decimal
   *                      point, if exists at all is 5.
   */
  toNearestTwip: function toNearestTwip(num) {
    var n = num,
        s = n < 0 ? -1 : 1,
        k = Math.abs(n),
        r = Math.round(k * 100),
        b = Math.floor(r / 5),
        t = Number(String(r - b * 5)),
        m = t > 2 ? b * 5 + 5 : b * 5;
    return s * (m / 100);
  },
  /**
   * roundUp method is used to format trailing decimal
   * places to the required precision, with default base 2.
   * @param  {number} num  number to be formatted
   * @param  {number} base number of precision digits
   * @return {number}      formatted number
   * @private
   */
  roundUp: function roundUp(num, base) {
    // precise to number of decimal places
    base = !base ? 2 : base;
    var factor = Math.pow(10, base);
    num *= factor;
    num = Math.round(Number(String(num)));
    num /= factor;
    return num;
  }
},
    canvasBaseColor3DStr = 'canvasBaseColor3D',
    chartPaletteStr = {
  chart2D: {
    bgColor: 'bgColor',
    bgAlpha: 'bgAlpha',
    bgAngle: 'bgAngle',
    bgRatio: 'bgRatio',
    canvasBgColor: 'canvasBgColor',
    canvasBaseColor: 'canvasBaseColor',
    divLineColor: 'divLineColor',
    legendBgColor: 'legendBgColor',
    legendBorderColor: 'legendBorderColor',
    toolTipbgColor: 'toolTipbgColor',
    toolTipBorderColor: 'toolTipBorderColor',
    baseFontColor: 'baseFontColor',
    anchorBgColor: 'anchorBgColor'
  },
  chart3D: {
    bgColor: 'bgColor3D',
    bgAlpha: 'bgAlpha3D',
    bgAngle: 'bgAngle3D',
    bgRatio: 'bgRatio3D',
    canvasBgColor: 'canvasBgColor3D',
    canvasBaseColor: canvasBaseColor3DStr,
    divLineColor: 'divLineColor3D',
    divLineAlpha: 'divLineAlpha3D',
    legendBgColor: 'legendBgColor3D',
    legendBorderColor: 'legendBorderColor3D',
    toolTipbgColor: 'toolTipbgColor3D',
    toolTipBorderColor: 'toolTipBorderColor3D',
    baseFontColor: 'baseFontColor3D',
    anchorBgColor: 'anchorBgColor3D'
  }
},
    supportedStyle = {
  font: 'font',
  fontFamily: 'font-family',
  'font-family': 'font-family',
  fontWeight: 'font-weight',
  'font-weight': 'font-weight',
  fontSize: 'font-size',
  'font-size': 'font-size',
  lineHeight: 'line-height',
  'line-height': 'line-height',
  textDecoration: 'text-decoration',
  'text-decoration': 'text-decoration',
  color: 'color',
  whiteSpace: 'white-space',
  'white-space': 'white-space',
  padding: 'padding',
  margin: 'margin',
  background: 'background',
  backgroundColor: 'background-color',
  'background-color': 'background-color',
  backgroundImage: 'background-image',
  'background-image': 'background-image',
  backgroundPosition: 'background-position',
  'background-position': 'background-position',
  backgroundPositionLeft: 'background-position-left',
  'background-position-left': 'background-position-left',
  backgroundPositionTop: 'background-position-top',
  'background-position-top': 'background-position-top',
  backgroundRepeat: 'background-repeat',
  'background-repeat': 'background-repeat',
  border: 'border',
  borderColor: 'border-color',
  'border-color': 'border-color',
  borderStyle: 'border-style',
  'border-style': 'border-style',
  borderThickness: 'border-thickness',
  'border-thickness': 'border-thickness',
  borderTop: 'border-top',
  'border-top': 'border-top',
  borderTopColor: 'border-top-color',
  'border-top-color': 'border-top-color',
  borderTopStyle: 'border-top-style',
  'border-top-style': 'border-top-style',
  borderTopThickness: 'border-top-thickness',
  'border-top-thickness': 'border-top-thickness',
  borderRight: 'border-right',
  'border-right': 'border-right',
  borderRightColor: 'border-right-color',
  'border-right-color': 'border-right-color',
  borderRightStyle: 'border-right-style',
  'border-right-style': 'border-right-style',
  borderRightThickness: 'border-right-thickness',
  'border-right-thickness': 'border-right-thickness',
  borderBottom: 'border-bottom',
  'border-bottom': 'border-bottom',
  borderBottomColor: 'border-bottom-color',
  'border-bottom-color': 'border-bottom-color',
  borderBottomStyle: 'border-bottom-style',
  'border-bottom-style': 'border-bottom-style',
  borderBottomThickness: 'border-bottom-thickness',
  'border-bottom-thickness': 'border-bottom-thickness',
  borderLeft: 'border-left',
  'border-left': 'border-left',
  borderLeftColor: 'border-left-color',
  'border-left-color': 'border-left-color',
  borderLeftStyle: 'border-left-style',
  'border-left-Style': 'border-left-style',
  borderLeftThickness: 'border-left-thickness',
  'border-left-thickness': 'border-left-thickness'
},
    supportsTouch = 'createTouch' in doc,


// The devices which both touch and pointer.
supportsOnlyTouch = supportsTouch && !(win.navigator.maxTouchPoints || win.navigator.msMaxTouchPoints),
    crispFixer = hasSVG ? 0 : 0.5,
    crispBound = function crispBound(x, y, w, h, s) {
  var at = {},
      normalizer = void 0;

  x = x || 0;
  y = y || 0;
  w = w || 0;
  h = h || 0;
  s = s || 0;
  normalizer = s % 2 / 2 + crispFixer;

  // normalize for crisp edges
  at.x = round(x + normalizer) - normalizer;
  at.y = round(y + normalizer) - normalizer;
  at.width = round(x + w + normalizer) - normalizer - at.x;
  at.height = round(y + h + normalizer) - normalizer - at.y;
  at['stroke-width'] = s;

  // adjust to single pixel if resultant dimension is zero.
  at.width === 0 && w !== 0 && (at.width = 1);
  at.height === 0 && h !== 0 && (at.height = 1);

  return at;
},
    animHelperFN = {
  getTimeByValue: function getTimeByValue(timeRange, pixelRange, plotRange) {
    var timePixelRatio = (timeRange.end - timeRange.start) / (pixelRange.endPx - pixelRange.startPx);
    return {
      start: timeRange.start + timePixelRatio * (plotRange.startPx - pixelRange.startPx),
      end: timeRange.start + timePixelRatio * (plotRange.endPx - pixelRange.startPx)
    };
  },
  animByIndex: function animByIndex(i, len, mul, startIn, endIn, totalInc) {
    var start = (i + (startIn || 0)) / len * (mul || 1),
        end = (i + (endIn || 0)) / len * (mul || 1),
        lim = (mul || 1) + (totalInc || 0);
    lim > 1 && (lim = 1);
    lim && start > lim && (start = lim);
    lim && end > lim && (end = lim);
    return {
      start: start + (totalInc || 0),
      end: end + (totalInc || 0)
    };
  },
  animByWeight: function animByWeight(i, len, weight, mul, shift) {
    mul = mul || 1;
    len--;
    shift = shift || 0;
    return {
      start: i / len * weight * mul + shift,
      end: i / len * weight * mul + weight + shift
    };
  },
  isAttrDiff: function isAttrDiff(a, b) {
    var key,
        valA,
        valB,
        toStringArr = [].toString;
    a.attrs && (a = a.attrs);
    for (key in b) {
      if (!b.hasOwnProperty(key)) {
        continue;
      }
      if (Array.isArray(a) || Array.isArray(b)) {
        valA = toStringArr.call(valA);
        valB = toStringArr.call(valB);
      } else {
        valA = a[key] && a[key].toString();
        valB = b[key] && b[key].toString();
      }
      if (valA !== valB) {
        return true;
      }
    }
    return false;
  }
},


/**
 * This function is used to create html DOM
 *
 * @param {string} tagName the name of the HTML tag
 * @param {Object} attributes Object contain all attribute name and value
 * @param {DOMobject} parentElement parent node of the newly created element
 */
createElement = function createElement(tagName, attributes, parentElement) {
  var elem = doc.createElement(tagName),
      x;
  // apply all attribute
  for (x in attributes) {
    elem.setAttribute(x, attributes[x]);
  }
  // append in parent element
  parentElement && parentElement.appendChild && parentElement.appendChild(elem);
  return elem;
},

// lib = global.hcLib || (fcGlobal.hcLib = {}),
// interactiveEvents = {
//   'mousedown': true
// },
// SvgDeCanvo = lib.SvgDeCanvo,
/**
 * Check whether an object is Array or not
 * @type Boolean
 * @param {Object} subject is the variable that is
 * tested for Array identity check
 */
isArray = function () {
  // Use compiler's own isArray when available
  if (Array.isArray) {
    return Array.isArray;
  }

  // Retain references to variables for performance optimization
  var objectToStringFn = Object.prototype.toString,
      arrayToStringResult = objectToStringFn.call([]);

  return function (subject) {
    return objectToStringFn.call(subject) === arrayToStringResult;
  };
}(),

/**
 * This function ensures that the event object always has pageX and pageY irrespective of the
 * browser. Older IE browsers do not support pageXY.
 *
 * @param {MouseEvent} event
 * @return {MouseEvent} This function updates the events `pageX` and `pageY` properties when
 * they're missing and also returns the same event for the sexy programming styles.
 */
getEventCoordinate = function () {
  return function (event) {
    // If `pageX` is UNDEF, it is certain that we need to fallback to `clientX`.
    // There is no point separately checking for `pageY`.
    if (event.pageX === UNDEF) {
      // We store reference to body while accessing so that future references are fast.
      event.pageX = event.clientX + doc.body.scrollLeft + doc.documentElement.scrollLeft;
      event.pageY = event.clientY + doc.body.scrollTop + doc.documentElement.scrollTop;
    }
    return event;
  };
}(),
    getViewPortDimension = function () {
  var pw = 'innerWidth',
      ph = 'innerHeight',
      docEl = doc.documentElement || doc.body,
      vpEl = docEl;

  if (!('innerWidth' in win)) {
    pw = 'clientWidth';
    ph = 'clientHeight';
  } else {
    vpEl = win;
  }

  return function () {
    return {
      width: vpEl[pw],
      height: vpEl[ph],
      scrollTop: docEl.scrollTop,
      scrollLeft: docEl.scrollLeft
    };
  };
}(),

/**
 * This function call multylevel js function given as STR
 */
limitedEvalParser = function () {
  var DOT = '.',
      windowPropIdentifier = /^@window_/g;

  return function (expr, args, multipleParams) {
    var pattern = expr.replace(/\[[\'\"]/g, DOT).replace(/[\'\"]\]/g, BLANK) // remove all quotations.
    // replace all opening '[' with identifier that it is a
    // variable in global scope.
    .replace(/\[/g, '.@window_').replace(/\]/g, BLANK),
        // romove all closing ']'
    tokens = pattern.split(DOT),
        obj = win,
        boxObj,
        windowProp,
        tokenEx = BLANK,
        token,
        l,
        i;

    l = tokens.length;
    for (i = 0; i < l; i += 1) {
      token = tokens[i];
      boxObj = obj;
      if (token.match(windowPropIdentifier)) {
        windowProp = win[token.replace(windowPropIdentifier, BLANK)];
        obj = obj[windowProp];
      } else if (obj === UNDEF || obj === null) {
        // eslint-disable-next-line no-throw-literal
        throw (tokenEx || token).replace(windowPropIdentifier, BLANK) + ' is not defined';
      } else {
        obj = obj[token];
      }
      tokenEx = token;
    }

    if (obj && (typeof obj.call === 'function' || obj === win.alert)) {
      if (obj === win.alert) {
        // for IE6 bug
        obj(args);
      } else {
        multipleParams ? obj.apply(boxObj, args.split('-')) : obj.call(boxObj, args);
      }
    } else if (tokenEx === 'void') {
      return void args;
    } else {
      setTimeout(function () {
        // eslint-disable-next-line no-throw-literal
        throw token.replace(windowPropIdentifier, BLANK) + '() is not a function';
      }, 0);
    }
  };
}(),
    toRaphaelColor = function () {
  var cache = {};

  return function (obj) {
    obj = obj || this;
    var o = obj && obj.FCcolor || obj,
        colors = o.color,
        ratio = o.ratio,
        angle = o.angle,
        opacities = o.alpha,
        r = o.r,
        cx = o.cx,
        cy = o.cy,
        fx = o.fx,
        fy = o.fy,
        units = o.gradientUnits,
        x1 = o.x1,
        y1 = o.y1,
        x2 = o.x2,
        y2 = o.y2,
        radialGradient = o.radialGradient,
        opacity = 1,
        str,
        i,
        l,
        color,
        hash;

    if (typeof obj === 'string') {
      return cache[hash = '~' + obj] || (cache[hash] = obj.replace(/^#?([a-f0-9]{3,6})/ig, '#$1'));
    }

    colors = colors || BLANK;

    if (!colors) {
      return str;
    }

    hash = [colors, opacities, ratio, angle, r, cx, cy, units, fx, fy, x1, x2, y1, y2, radialGradient].join(UNDERSCORE).replace(/[\(\)\s,\xb0#]/g, UNDERSCORE);
    if (cache[hash]) {
      return cache[hash];
    }

    ratio = ratio && (ratio + BLANK).split(COMMA) || [];
    opacities = (opacities || opacities === 0) && (opacities + BLANK).split(COMMA) || [];

    if (colors = colors.split(COMMA)) {
      str = BLANK;
      if (colors.length === 1) {
        color = colors[0].replace(/^#?([a-f0-9]{3,6})/ig, '$1');
        if (opacities.length) {
          str = 'rgba(' + hexToRgb(color).join(COMMA) + ',' + toFloat(opacities[0]) * 0.01 + ')';
        } else {
          str = color.replace(/^#?([a-f0-9]{3,6})/ig, '#$1');
        }
      } else {
        for (i = 0, l = colors.length; i < l; i++) {
          color = colors[i].replace(/^#?([a-f0-9]{3,6})/ig, '$1');
          if (!isNaN(ratio[i])) {
            ratio[i] = toFloat(ratio[i]);
            color += COLON + ratio[i];
            if (!isNaN(ratio[i + 1])) {
              ratio[i + 1] = toFloat(ratio[i + 1]) + ratio[i];
            }
          }
          if (!isNaN(opacities[i]) && opacities[i] !== BLANK) {
            opacity = opacities[i] * 0.01;
          }
          colors[i] = 'rgba(' + hexToRgb(color).join(COMMA) + ',' + opacity + ')';
          if (!isNaN(ratio[i])) {
            if (ratio[i] === ratio[i - 1]) {
              ratio[i] += 0.001;
            }
            colors[i] = colors[i] + COLON + ratio[i];
          }
        }
        str += colors.join(HYPHEN);

        if (r !== UNDEF || fx !== UNDEF || cx !== UNDEF || o.radialGradient) {
          str = 'xr(' + [fx, fy, r, cx, cy, units].join(',') + ')' + str;
        } else {
          str = HYPHEN + str;
          if (x1 !== UNDEF || y1 !== UNDEF || x2 !== UNDEF || y2 !== UNDEF) {
            str = '(' + [x1, y1, x2, y2, units].join(',') + ')' + str;
          }
          if (angle === UNDEF) {
            angle = 0;
          }
          str = 360 - toFloat(angle) % 360 + str;
        }
      }
    }
    return cache[hash] = str;
  };
}(),
    gradientify = function () {
  return function () {
    var attr = '';

    return attr;
  };
}(),
    symbolStr = {
  circle: 'circle',
  triangle: 'triangle',
  square: 'square',
  diamond: 'diamond',
  poly: 'poly_',
  spoke: 'spoke_'
},

/*
 *manager to add axis labels
 */
axisLabelAdder = function () {
  var TEXTPOSITION = {
    top: {
      align: 'center',
      verticalAlign: 'top',
      textAlign: 'center'
    },
    right: {
      align: 'right',
      verticalAlign: 'middle',
      textAlign: 'left'
    },
    bottom: {
      align: 'center',
      verticalAlign: 'bottom',
      textAlign: 'center'
    },
    left: {
      align: 'left',
      verticalAlign: 'middle',
      textAlign: 'right'
    }
  },
      alphaRetriveRegx = /([^\,^\s]+)\)$/g,
      labelAdder = function labelAdder(defaultSeries, FCchartObj) {
    var labelStep;
    /** @todo add all series type for which the axis will be like bar(xChanged position) */
    if (/^(bar|bar3d)$/.test(defaultSeries)) {
      this.isBar = true;
      this.yPos = 'bottom';
      this.yOppPos = 'top';
      this.xPos = 'left';
      this.xOppPos = 'right';
    }
    // steping attr
    labelStep = parseInt(FCchartObj.labelstep, 10);
    this.labelStep = labelStep > 1 ? labelStep : 1;
    this.showLabel = pluckNumber(FCchartObj.showlabels, FCchartObj.shownames, 1);
    this.is3D = /3d$/.test(defaultSeries);
  };

  labelAdder.prototype = {
    isBar: false,
    yPos: 'left',
    yOppPos: 'right',
    xPos: 'bottom',
    xOppPos: 'top',
    // Note: linecolor must be in rgba str
    addAxisGridLine: function addAxisGridLine(axisObj, value, text, width, dashStyle, lineColor, zIndex, isXxis) {
      var hasText = text !== '',
          hasVisibleLine = !!(width > 0 || lineColor.match(alphaRetriveRegx)[1] > 0),
          axisPos,
          textAttrs,
          gridLine;
      if (hasText || hasVisibleLine) {
        if (!hasVisibleLine) {
          lineColor = COLOR_TRANSPARENT;
          width = 0.1;
        }
        gridLine = {
          isGrid: true,
          width: width,
          dashStyle: dashStyle,
          color: lineColor,
          value: value,
          zIndex: zIndex === UNDEF ? 2 : zIndex
        };
        if (hasText) {
          axisPos = axisObj.opposite ? isXxis ? this.xOppPos : this.yOppPos : isXxis ? this.xPos : this.yPos;
          textAttrs = TEXTPOSITION[axisPos];
          gridLine.label = {
            text: text,
            style: axisObj.labels.style,
            textAlign: textAttrs.textAlign,
            align: textAttrs.align,
            verticalAlign: textAttrs.verticalAlign,
            rotation: 0,
            x: 0,
            y: 0
          };
        }
        axisObj.plotLines.push(gridLine);
      }
      return gridLine;
    },
    addAxisAltGrid: function addAxisAltGrid(axisObj, currentValue) {
      if (!this.is3D) {
        var lastValue = pluckNumber(axisObj._lastValue, axisObj.min),
            altGrid = pluck(axisObj._altGrid, false);
        if (altGrid) {
          axisObj.plotBands.push({
            isGrid: true,
            color: axisObj.alternateGridColor,
            to: currentValue,
            from: lastValue,
            zIndex: 1
          });
        }
        axisObj._lastValue = currentValue;
        axisObj._altGrid = !altGrid;
      }
    },
    addXaxisCat: function addXaxisCat(axisObj, value, index, label, data, catObj, chartObj, dataColor) {
      var axisPosition = axisObj.opposite ? this.xOppPos : this.xPos,
          textAttrs = TEXTPOSITION[axisPosition],
          gridLine = {
        isGrid: true,
        isDataLabel: true,
        width: 0.1,
        color: COLOR_TRANSPARENT,
        value: value,
        label: {
          text: label,
          link: pluck(data.labellink, catObj.link, chartObj.labellink),
          style: parsexAxisStyles(data, catObj, chartObj, axisObj.labels.style, dataColor),
          textAlign: textAttrs.textAlign,
          align: textAttrs.align,
          verticalAlign: textAttrs.verticalAlign,
          rotation: 0,
          x: 0,
          y: 0
        }
      };

      if (index % this.labelStep !== 0) {
        gridLine.stepped = true;
        gridLine.label.style = axisObj.steppedLabels.style;
      }
      axisObj.plotLines.push(gridLine);
    },
    addVline: function addVline(axisObj, dataObj, index, hcObj) {
      // Extract attributes
      var conf = hcObj[FC_CONFIG_STRING],
          isBar = conf.isBar,
          divlineStyle = conf.divlineStyle,
          label = parseUnsafeString(dataObj.label),
          showLabelBorder = Boolean(pluckNumber(dataObj.showlabelborder, conf.showVLineLabelBorder, 1)),
          showLabelBackground = Boolean(pluckNumber(dataObj.showlabelbackground, 1)),
          labelHAlign = pluck(dataObj.labelhalign, isBar ? POSITION_LEFT : POSITION_CENTER),
          labelVAlign = pluck(dataObj.labelvalign, isBar ? POSITION_MIDDLE : POSITION_BOTTOM).toLowerCase(),

      // TODO: Need to calculate in px, to set y
      labelPosition = pluckNumber(dataObj.labelposition, 0),
          linePosition = pluckNumber(dataObj.lineposition, 0.5),
          showVLines = pluckNumber(dataObj.showvlines, conf.showVLines, 1),
          alpha = pluckNumber(dataObj.alpha, conf.vLineAlpha, 80),
          color = pluck(dataObj.color, conf.vLineColor).replace(/^#?/, '#'),
          bgColor = showLabelBackground ? pluck(dataObj.labelbgcolor, conf.vLineLabelBgColor, '333333').replace(/^#?/, '#') : BLANK,
          labelColor = pluck(dataObj.labelcolor, conf.vLineLabelColor, dataObj.color, conf.vLineColor).replace(/^#?/, '#'),
          thickness = pluckNumber(dataObj.thickness, conf.vLineThickness, 1),
          halfThickness = thickness * 0.5,
          isDashed = Boolean(Number(pluck(dataObj.dashed, 0))),
          dashLen = pluckNumber(dataObj.dashlen, 5),
          dashGap = pluckNumber(dataObj.dashgap, 2),
          smartLabel = conf.smartLabel,
          fontSizeInt = parseInt(divlineStyle.fontSize, 10),
          y = fontSizeInt + 2,
          x = 0,
          smartText,
          labelRotation = pluckNumber(dataObj.rotatelabel, conf.rotateVLineLabels) ? 270 : 0;

      linePosition = linePosition < 0 || linePosition > 1 ? 0.5 : linePosition;
      labelPosition = labelPosition < 0 || labelPosition > 1 ? 0 : labelPosition;
      smartLabel.setStyle(divlineStyle);
      smartText = smartLabel.getOriSize(label);

      color = convertColor(color, showVLines ? alpha : '0');

      if (!isBar) {
        switch (labelVAlign) {
          case POSITION_TOP:
            y = -smartText.height * 0.5 + 1;
            // TODO retain this line for future reference
            // y -= smartText.height + 2 + (plotBorderWidth || 1) *
            //     (1 - labelPosition) + labelPosition;
            break;
          case POSITION_MIDDLE:
            y = 0;
            // TODO retain this line for future reference
            // y -= (smartText.height * 0.5) + plotBorderWidth * (1 - labelPosition * 2);
            break;
          default:
            y = smartText.height * 0.5;
          // TODO retain this line for future reference
          // y += (plotBorderWidth - pbwMod2) * labelPosition;
        }
        switch (labelHAlign) {
          case POSITION_LEFT:
            x += thickness;
            break;
          case POSITION_RIGHT:
            x -= thickness + 1;
            break;
        }
      } else {
        switch (labelVAlign) {
          case POSITION_TOP:
            y -= smartText.height + halfThickness + 2;
            break;
          case POSITION_MIDDLE:
            y -= smartText.height * 0.5 + 1;
            break;
          default:
            y += halfThickness;
        }

        if (!dataObj.labelhalign) {
          x -= smartText.width * labelPosition;
        }
      }

      axisObj.plotLines.push({
        isVline: true,
        color: color,
        width: thickness,
        value: index - 1 + linePosition,
        zIndex: pluckNumber(dataObj.showontop, conf.showVLinesOnTop) ? 5 : 3, // extra for js charts
        dashStyle: isDashed ? getDashStyle(dashLen, dashGap) : DASH_DEF,
        label: {
          text: label,
          align: isBar ? POSITION_LEFT : POSITION_CENTER,
          offsetScale: labelPosition,
          rotation: labelRotation,
          y: y,
          x: x,
          textAlign: labelHAlign,
          backgroundColor: bgColor,
          borderWidth: showVLines && showLabelBorder ? 1 : 0,
          borderType: showVLines && showLabelBorder ? 'solid' : BLANK,
          borderColor: showVLines && showLabelBorder ? labelColor : BLANK,
          backgroundOpacity: showVLines && showLabelBackground ? pluck(dataObj.labelbgalpha, conf.vLineLabelBgAlpha) / 100 : 0,
          style: {
            color: showVLines ? labelColor : color,
            fontSize: divlineStyle.fontSize,
            fontFamily: divlineStyle.fontFamily,
            lineHeight: divlineStyle.lineHeight,
            backgroundColor: bgColor
          }
        }
      });
    }
  };
  labelAdder.prototype.constructor = labelAdder;
  return labelAdder;
}(),


/*
 * parser for tooltip macros
 *
 */
parseTooltext = function () {
  var macroList = [{ // 0- cleanValue
    regex: /((^|[^\\])((\\)\\)*\$cleanvalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$cleanvalue))/ig,
    argIndex: 2,
    argKey: 'cleanvalue'
  }, { // 1- dataValue
    regex: /((^|[^\\])((\\)\\)*\$datavalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$datavalue))/ig,
    argIndex: 2,
    argKey: 'formattedValue'
  }, { // 2- value
    regex: /((^|[^\\])((\\)\\)*\$value)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$value))/ig,
    argIndex: 3,
    argKey: 'value'
  }, { // 3- label
    regex: /((^|[^\\])((\\)\\)*\$label)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$label))/ig,
    argIndex: 2,
    argKey: 'label'
  }, { // 4- seriesName
    regex: /((^|[^\\])((\\)\\)*\$seriesname)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$seriesname))/ig,
    argIndex: 5,
    argKey: 'seriesname'
  }, { // 5- yAxisName
    regex: /((^|[^\\])((\\)\\)*\$yaxisname)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$yaxisname))/ig,
    argIndex: 2,
    argKey: 'yaxisName'
  }, { // 6- xAxisName
    regex: /((^|[^\\])((\\)\\)*\$xaxisname)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$xaxisname))/ig,
    argIndex: 2,
    argKey: 'xaxisName'
  }, { // 7- displayValue
    regex: /((^|[^\\])((\\)\\)*\$displayvalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$displayvalue))/ig,
    argIndex: 3,
    argKey: 'displayvalue'
  }, { // 8- xDataValue
    regex: /((^|[^\\])((\\)\\)*\$xdatavalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$xdatavalue))/ig,
    argIndex: 2,
    argKey: 'xDataValue'
  }, { // 9- yDataValue
    regex: /((^|[^\\])((\\)\\)*\$ydatavalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$ydatavalue))/ig,
    argIndex: 2,
    argKey: 'yDataValue'
  }, { // 10- xValue
    regex: /((^|[^\\])((\\)\\)*\$xvalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$xvalue))/ig,
    argIndex: 3,
    argKey: 'x'
  }, { // 11- yValue
    regex: /((^|[^\\])((\\)\\)*\$yvalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$yvalue))/ig,
    argIndex: 3,
    argKey: 'y'
  }, { // 12- zValue
    regex: /((^|[^\\])((\\)\\)*\$zvalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$zvalue))/ig,
    argIndex: 3,
    argKey: 'z'
  }, { // 13- name
    regex: /((^|[^\\])((\\)\\)*\$name)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$name))/ig,
    argIndex: 3,
    argKey: 'name'
  }, { // 14- percentValue
    regex: /((^|[^\\])((\\)\\)*\$percentValue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$percentValue))/ig,
    argIndex: 2,
    argKey: 'percentValue'
  }, { // 15- startValue
    regex: /((^|[^\\])((\\)\\)*\$startValue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$startValue))/ig,
    argIndex: 2,
    argKey: 'startValue'
  }, { // 16- startDataValue
    regex: /((^|[^\\])((\\)\\)*\$startDataValue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$startDataValue))/ig,
    argIndex: 2,
    argKey: 'startDataValue'
  }, { // 17- endValue
    regex: /((^|[^\\])((\\)\\)*\$endValue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$endValue))/ig,
    argIndex: 2,
    argKey: 'endValue'
  }, { // 18- endDataValue
    regex: /((^|[^\\])((\\)\\)*\$endDataValue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$endDataValue))/ig,
    argIndex: 2,
    argKey: 'endDataValue'
  }, { // 19- axisName
    regex: /((^|[^\\])((\\)\\)*\$axisName)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$axisName))/ig,
    argIndex: 2,
    argKey: 'axisName'
  }, { // 20- cumulativeValue
    regex: /((^|[^\\])((\\)\\)*\$cumulativevalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$cumulativevalue))/ig,
    argIndex: 2,
    argKey: 'cumulativeValue'
  }, { // 21- cumulativeDataValue
    regex: /((^|[^\\])((\\)\\)*\$cumulativedatavalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$cumulativedatavalue))/ig,
    argIndex: 2,
    argKey: 'cumulativeDataValue'
  }, { // 22- cumulativePercentValue
    regex: /((^|[^\\])((\\)\\)*\$cumulativePercentValue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$cumulativePercentValue))/ig,
    argIndex: 2,
    argKey: 'cumulativePercentValue'
  }, { // 23- cumulativePercentDataValue
    regex: /((^|[^\\])((\\)\\)*\$cumulativepercentdatavalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$cumulativepercentdatavalue))/ig,
    argIndex: 2,
    argKey: 'cumulativePercentDataValue'
  }, { // 24- sum
    regex: /((^|[^\\])((\\)\\)*\$sum)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$sum))/ig,
    argIndex: 2,
    argKey: 'sum'
  }, { // 25- unformattedSum
    regex: /((^|[^\\])((\\)\\)*\$unformattedsum)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$unformattedsum))/ig,
    argIndex: 2,
    argKey: 'unformattedSum'
  },
  // widgets
  { // 26- targetValue
    regex: /((^|[^\\])((\\)\\)*\$targetvalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$targetvalue))/ig,
    argIndex: 2,
    argKey: 'targetValue'
  }, { // 27- targetDataValue
    regex: /((^|[^\\])((\\)\\)*\$targetdatavalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$targetdatavalue))/ig,
    argIndex: 2,
    argKey: 'targetDataValue'
  }, { // 28- processName
    regex: /((^|[^\\])((\\)\\)*\$processname)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$processname))/ig,
    argIndex: 2,
    argKey: 'processName'
  }, { // 29- start
    regex: /((^|[^\\])((\\)\\)*\$start)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$start))/ig,
    argIndex: 2,
    argKey: 'start'
  }, { // 30- end
    regex: /((^|[^\\])((\\)\\)*\$end)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$end))/ig,
    argIndex: 2,
    argKey: 'end'
  }, { // 31- percentComplete
    regex: /((^|[^\\])((\\)\\)*\$percentcomplete)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$percentcomplete))/ig,
    argIndex: 2,
    argKey: 'percentComplete'
  }, { // 32- taskPercentComplete
    regex: /((^|[^\\])((\\)\\)*\$taskpercentcomplete)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$taskpercentcomplete))/ig,
    argIndex: 2,
    argKey: 'taskPercentComplete'
  }, { // 33- taskStartDate
    regex: /((^|[^\\])((\\)\\)*\$taskstartdate)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$taskstartdate))/ig,
    argIndex: 2,
    argKey: 'taskStartDate'
  }, { // 34- taskEndDate
    regex: /((^|[^\\])((\\)\\)*\$taskenddate)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$taskenddate))/ig,
    argIndex: 2,
    argKey: 'taskEndDate'
  }, { // 35- taskLabel
    regex: /((^|[^\\])((\\)\\)*\$tasklabel)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$tasklabel))/ig,
    argIndex: 2,
    argKey: 'taskLabel'
  }, { // 36- date
    regex: /((^|[^\\])((\\)\\)*\$date)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$date))/ig,
    argIndex: 2,
    argKey: 'date'
  }, { // 37- percentOfPrevValue
    regex: /((^|[^\\])((\\)\\)*\$percentofprevvalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$percentofprevvalue))/ig,
    argIndex: 2,
    argKey: 'percentOfPrevValue'
  },
  // maps
  { // 38- sName
    regex: /((^|[^\\])((\\)\\)*\$sname)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$sname))/ig,
    argIndex: 2,
    argKey: 'sName'
  }, { // 39- lName
    regex: /((^|[^\\])((\\)\\)*\$lname)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$lname))/ig,
    argIndex: 2,
    argKey: 'lName'
  }, { // 40- fromId
    regex: /((^|[^\\])((\\)\\)*\$fromid)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$fromid))/ig,
    argIndex: 2,
    argKey: 'fromId'
  }, { // 41- fromLabel
    regex: /((^|[^\\])((\\)\\)*\$fromlabel)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$fromlabel))/ig,
    argIndex: 2,
    argKey: 'fromLabel'
  }, { // 42- toId
    regex: /((^|[^\\])((\\)\\)*\$toid)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$toid))/ig,
    argIndex: 2,
    argKey: 'toId'
  }, { // 43- toLabel
    regex: /((^|[^\\])((\\)\\)*\$tolabel)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$tolabel))/ig,
    argIndex: 2,
    argKey: 'toLabel'
  },
  // Power Charts
  { // 44- fromXValue
    regex: /((^|[^\\])((\\)\\)*\$fromxvalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$fromxvalue))/ig,
    argIndex: 2,
    argKey: 'fromXValue'
  }, { // 45- fromYValue
    regex: /((^|[^\\])((\\)\\)*\$fromyvalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$fromyvalue))/ig,
    argIndex: 2,
    argKey: 'fromYValue'
  }, { // 46- fromXDataValue
    regex: /((^|[^\\])((\\)\\)*\$fromxdatavalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$fromxdatavalue))/ig,
    argIndex: 2,
    argKey: 'fromXDataValue'
  }, { // 47- fromYDataValue
    regex: /((^|[^\\])((\\)\\)*\$fromydatavalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$fromydatavalue))/ig,
    argIndex: 2,
    argKey: 'fromYDataValue'
  }, { // 48- fromLabel
    regex: /((^|[^\\])((\\)\\)*\$fromlabel)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$fromlabel))/ig,
    argIndex: 2,
    argKey: 'fromLabel'
  }, { // 49- toXValue
    regex: /((^|[^\\])((\\)\\)*\$toxvalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$toxvalue))/ig,
    argIndex: 2,
    argKey: 'toXValue'
  }, { // 50- toYValue
    regex: /((^|[^\\])((\\)\\)*\$toyvalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$toyvalue))/ig,
    argIndex: 2,
    argKey: 'toYValue'
  }, { // 51- toXDataValue
    regex: /((^|[^\\])((\\)\\)*\$toxdatavalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$toxdatavalue))/ig,
    argIndex: 2,
    argKey: 'toXDataValue'
  }, { // 52- toYDataValue
    regex: /((^|[^\\])((\\)\\)*\$toydatavalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$toydatavalue))/ig,
    argIndex: 2,
    argKey: 'toYDataValue'
  }, { // 53- toLabel
    regex: /((^|[^\\])((\\)\\)*\$tolabel)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$tolabel))/ig,
    argIndex: 2,
    argKey: 'toLabel'
  },
  // Spark Charts
  { // 54- openValue
    regex: /((^|[^\\])((\\)\\)*\$openvalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$openvalue))/ig,
    argIndex: 2,
    argKey: 'openValue'
  }, { // 55- closeValue
    regex: /((^|[^\\])((\\)\\)*\$closevalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$closevalue))/ig,
    argIndex: 2,
    argKey: 'closeValue'
  }, { // 56- highValue
    regex: /((^|[^\\])((\\)\\)*\$highvalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$highvalue))/ig,
    argIndex: 2,
    argKey: 'highValue'
  }, { // 57- lowValue
    regex: /((^|[^\\])((\\)\\)*\$lowvalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$lowvalue))/ig,
    argIndex: 2,
    argKey: 'lowValue'
  }, { // 58- openDataValue
    regex: /((^|[^\\])((\\)\\)*\$opendatavalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$opendatavalue))/ig,
    argIndex: 2,
    argKey: 'openDataValue'
  }, { // 59- closeDataValue
    regex: /((^|[^\\])((\\)\\)*\$closedatavalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$closedatavalue))/ig,
    argIndex: 2,
    argKey: 'closeDataValue'
  }, { // 60- highDataValue
    regex: /((^|[^\\])((\\)\\)*\$highdatavalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$highdatavalue))/ig,
    argIndex: 2,
    argKey: 'highDataValue'
  }, { // 61- lowDataValue
    regex: /((^|[^\\])((\\)\\)*\$lowdatavalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$lowdatavalue))/ig,
    argIndex: 2,
    argKey: 'lowDataValue'
  }, { // 62 - maxValue
    regex: /((^|[^\\])((\\)\\)*\$maxvalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$maxvalue))/ig,
    argIndex: 2,
    argKey: 'maxValue'
  }, { // 63 - maxDataValue
    regex: /((^|[^\\])((\\)\\)*\$maxdatavalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$maxdatavalue))/ig,
    argIndex: 2,
    argKey: 'maxDataValue'
  }, { // 64 - minValue
    regex: /((^|[^\\])((\\)\\)*\$minvalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$minvalue))/ig,
    argIndex: 2,
    argKey: 'minValue'
  }, { // 65 - minDataValue
    regex: /((^|[^\\])((\\)\\)*\$mindatavalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$mindatavalue))/ig,
    argIndex: 2,
    argKey: 'minDataValue'
  }, { // 66 - Q1
    regex: /((^|[^\\])((\\)\\)*\$q1)/ig,
    argIndex: 2,
    argKey: 'Q1'
  }, { // 67 - unformattedQ1
    regex: /((^|[^\\])((\\)\\)*\$unformattedQ1)/ig,
    argIndex: 2,
    argKey: 'unformattedQ1'
  }, { // 68 - Q3
    regex: /((^|[^\\])((\\)\\)*\$q3)/ig,
    argIndex: 2,
    argKey: 'Q3'
  }, { // 69 - unformattedQ3
    regex: /((^|[^\\])((\\)\\)*\$unformattedQ3)/ig,
    argIndex: 2,
    argKey: 'unformattedQ3'
  }, { // 70 - median
    regex: /((^|[^\\])((\\)\\)*\$median)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$median))/ig,
    argIndex: 2,
    argKey: 'median'
  }, { // 71 - unformattedMedian
    regex: /((^|[^\\])((\\)\\)*\$unformattedMedian)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$unformattedMedian))/ig,
    argIndex: 2,
    argKey: 'unformattedMedian'
  }, { // 72 - SD
    regex: /((^|[^\\])((\\)\\)*\$SD)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$SD))/ig,
    argIndex: 2,
    argKey: 'SD'
  }, { // 73 - unformattedSD
    regex: /((^|[^\\])((\\)\\)*\$unformattedsd)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$unformattedsd))/ig,
    argIndex: 2,
    argKey: 'unformattedsd'
  }, { // 74 - QD
    regex: /((^|[^\\])((\\)\\)*\$QD)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$QD))/ig,
    argIndex: 2,
    argKey: 'QD'
  }, { // 75 - unformattedQD
    regex: /((^|[^\\])((\\)\\)*\$unformattedQD)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$unformattedQD))/ig,
    argIndex: 2,
    argKey: 'unformattedQD'
  }, { // 76 - MD
    regex: /((^|[^\\])((\\)\\)*\$MD)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$MD))/ig,
    argIndex: 2,
    argKey: 'MD'
  }, { // 77 - unformattedMD
    regex: /((^|[^\\])((\\)\\)*\$unformattedMD)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$unformattedMD))/ig,
    argIndex: 2,
    argKey: 'unformattedMD'
  }, { // 78 - mean
    regex: /((^|[^\\])((\\)\\)*\$mean)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$mean))/ig,
    argIndex: 2,
    argKey: 'mean'
  }, { // 79 - unformattedMean
    regex: /((^|[^\\])((\\)\\)*\$unformattedMean)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$unformattedMean))/ig,
    argIndex: 2,
    argKey: 'unformattedMean'
  }, { // 80 - unformattedMean
    regex: /((^|[^\\])((\\)\\)*\$unformattedMean)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$unformattedMean))/ig,
    argIndex: 2,
    argKey: 'unformattedMean'
  }, { // 81 - volumeValue
    regex: /((^|[^\\])((\\)\\)*\$volumeValue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$volumeValue))/ig,
    argIndex: 2,
    argKey: 'volumeValue'
  }, { // 82 - volumeDataValue
    regex: /((^|[^\\])((\\)\\)*\$volumeDataValue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$volumeDataValue))/ig,
    argIndex: 2,
    argKey: 'volumeDataValue'
  }, { // 83 - fromXValue
    regex: /((^|[^\\])((\\)\\)*\$fromXValue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$fromXValue))/ig,
    argIndex: 2,
    argKey: 'fromXValue'
  }, { // 84 - fromYValue
    regex: /((^|[^\\])((\\)\\)*\$fromYValue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$fromYValue))/ig,
    argIndex: 2,
    argKey: 'fromYValue'
  }, { // 85 - fromXDataValue
    regex: /((^|[^\\])((\\)\\)*\$fromXDataValue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$fromXDataValue))/ig,
    argIndex: 2,
    argKey: 'fromXDataValue'
  }, { // 86 - fromYDataValue
    regex: /((^|[^\\])((\\)\\)*\$fromYDataValue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$fromYDataValue))/ig,
    argIndex: 2,
    argKey: 'fromYDataValue'
  }, { // 87 - fromLabel
    regex: /((^|[^\\])((\\)\\)*\$fromLabel)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$fromLabel))/ig,
    argIndex: 2,
    argKey: 'fromLabel'
  }, { // 88 - toXValue
    regex: /((^|[^\\])((\\)\\)*\$toXValue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$toXValue))/ig,
    argIndex: 2,
    argKey: 'toXValue'
  }, { // 89 - toYValue
    regex: /((^|[^\\])((\\)\\)*\$toYValue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$toYValue))/ig,
    argIndex: 2,
    argKey: 'toYValue'
  }, { // 90 - toXDataValue
    regex: /((^|[^\\])((\\)\\)*\$toXDataValue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$toXDataValue))/ig,
    argIndex: 2,
    argKey: 'toXDataValue'
  }, { // 91 - toYDataValue
    regex: /((^|[^\\])((\\)\\)*\$toYDataValue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$toYDataValue))/ig,
    argIndex: 2,
    argKey: 'toYDataValue'
  }, { // 92 - toLabel
    regex: /((^|[^\\])((\\)\\)*\$tolabel)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$tolabel))/ig,
    argIndex: 2,
    argKey: 'toLabel'
  }, { // 93 - tlLabel
    regex: /((^|[^\\])((\\)\\)*\$tlLabel)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$tlLabel))/ig,
    argIndex: 5,
    argKey: 'tlLabel'
  }, { // 94 - trLabel
    regex: /((^|[^\\])((\\)\\)*\$trlabel)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$trlabel))/ig,
    argIndex: 5,
    argKey: 'trLabel'
  }, { // 95 - blLabel
    regex: /((^|[^\\])((\\)\\)*\$bllabel)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$bllabel))/ig,
    argIndex: 5,
    argKey: 'blLabel'
  }, { // 96 - brLabel
    regex: /((^|[^\\])((\\)\\)*\$brlabel)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$brlabel))/ig,
    argIndex: 5,
    argKey: 'brLabel'
  }, { // 97 - rowLabel
    regex: /((^|[^\\])((\\)\\)*\$rowlabel)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$rowlabel))/ig,
    argIndex: 5,
    argKey: 'rowLabel'
  }, { // 98 - columnLabel
    regex: /((^|[^\\])((\\)\\)*\$columnlabel)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$columnlabel))/ig,
    argIndex: 5,
    argKey: 'columnLabel'
  }, { // 99 - errorValue
    regex: /((^|[^\\])((\\)\\)*\$errorvalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$errorvalue))/ig,
    argIndex: 2,
    argKey: 'errorValue'
  }, { // 100 - errorDataValue
    regex: /((^|[^\\])((\\)\\)*\$errordatavalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$errordatavalue))/ig,
    argIndex: 2,
    argKey: 'errorDataValue'
  }, { // 101 - errorPercentValue
    regex: /((^|[^\\])((\\)\\)*\$errorpercentvalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$errorpercentvalue))/ig,
    argIndex: 2,
    argKey: 'errorPercentValue'
  }, { // 102 - errorPercentDataValue
    regex: /((^|[^\\])((\\)\\)*\$errorpercentdatavalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$errorpercentdatavalue))/ig,
    argIndex: 2,
    argKey: 'errorPercentDataValue'
  }, { // 103 - horizontalErrorValue
    regex: /((^|[^\\])((\\)\\)*\$horizontalErrorValue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$horizontalErrorValue))/ig,
    argIndex: 2,
    argKey: 'horizontalErrorValue'
  }, { // 104 - horizontalErrorDataValue
    regex: /((^|[^\\])((\\)\\)*\$horizontalErrorDataValue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$horizontalErrorDataValue))/ig,
    argIndex: 2,
    argKey: 'horizontalErrorDataValue'
  }, { // 105 - verticalErrorValue
    regex: /((^|[^\\])((\\)\\)*\$verticalErrorValue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$verticalErrorValue))/ig,
    argIndex: 2,
    argKey: 'verticalErrorValue'
  }, { // 106 - verticalErrorDataValue
    regex: /((^|[^\\])((\\)\\)*\$verticalErrorDataValue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$verticalErrorDataValue))/ig,
    argIndex: 2,
    argKey: 'verticalErrorDataValue'
  }, { // 107 - horizontalErrorPercent
    regex: /((^|[^\\])((\\)\\)*\$horizontalErrorPercent)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$horizontalErrorPercentValue))/ig,
    argIndex: 2,
    argKey: 'horizontalErrorPercentValue'
  }, { // 108 - horizontalErrorPercentDataValue
    regex: /((^|[^\\])((\\)\\)*\$horizontalErrorPercentDataValue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$horizontalErrorPercentDataValue))/ig,
    argIndex: 2,
    argKey: 'horizontalErrorPercentDataValue'
  }, { // 109 - verticalErrorPercent
    regex: /((^|[^\\])((\\)\\)*\$verticalErrorPercent)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$verticalErrorPercentValue))/ig,
    argIndex: 2,
    argKey: 'verticalErrorPercentValue'
  }, { // 110 - verticalErrorPercentDataValue
    regex: /((^|[^\\])((\\)\\)*\$verticalErrorPercentDataValue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$verticalErrorPercentDataValue))/ig,
    argIndex: 2,
    argKey: 'verticalErrorPercentDataValue'
  },
  // Mactros that are added later
  { // 111- xAxisPercentValue
    regex: /((^|[^\\])((\\)\\)*\$xaxispercentvalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$xaxispercentvalue))/ig,
    argIndex: 2,
    argKey: 'xAxisPercentValue'
  }, { // 112- percentDataValue
    regex: /((^|[^\\])((\\)\\)*\$percentdatavalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$percentdatavalue))/ig,
    argIndex: 2,
    argKey: 'percentDataValue'
  }, { // 113- trType
    regex: /((^|[^\\])((\\)\\)*\$trType)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$trType))/ig,
    argIndex: 4,
    argKey: 'trtype'
  }, { // 114- tlType
    regex: /((^|[^\\])((\\)\\)*\$tlType)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$tlType))/ig,
    argIndex: 4,
    argKey: 'tltype'
  }, { // 115- brType
    regex: /((^|[^\\])((\\)\\)*\$brType)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$brType))/ig,
    argIndex: 4,
    argKey: 'brtype'
  }, { // 116- blType
    regex: /((^|[^\\])((\\)\\)*\$blType)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$blType))/ig,
    argIndex: 4,
    argKey: 'bltype'
  }, { // 117- colorRangeLabel
    regex: /((^|[^\\])((\\)\\)*\$colorRangeLabel)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$colorRangeLabel))/ig,
    argIndex: 5,
    argKey: 'colorRangeLabel'
  }, { // 118- zDataValue
    regex: /((^|[^\\])((\\)\\)*\$zdatavalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$zdatavalue))/ig,
    argIndex: 2,
    argKey: 'zDataValue'
  }, { // 119- sValue
    regex: /((^|[^\\])((\\)\\)*\$svalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$svalue))/ig,
    argIndex: 3,
    argKey: 'svalue'
  }, { // 120- positiveErrorValue
    regex: /((^|[^\\])((\\)\\)*\$positiveErrorValue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$positiveErrorValue))/ig,
    argIndex: 2,
    argKey: 'positiveErrorValue'
  }, { // 121- negativeErrorValue
    regex: /((^|[^\\])((\\)\\)*\$negativeErrorValue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$negativeErrorValue))/ig,
    argIndex: 2,
    argKey: 'negativeErrorValue'
  }, { // 122- datasValue
    regex: /((^|[^\\])((\\)\\)*\$datasvalue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$datasvalue))/ig,
    argIndex: 2,
    argKey: 'formattedsValue'
  }],
      defAllMacroIndices = [],
      replaceConstant = '$2$4',
      escapeReplaceStr = '$2$4$5',
      i,
      l = macroList.length;

  // preaper defApplyAllArr
  for (i = 0; i < l; i += 1) {
    defAllMacroIndices.push(i);
  }

  return function () {
    var returnText = arguments[0],
        ApplicableMacroIndices = arguments[1],
        replaceStr,
        argObj,
        macroObj,
        i,
        l;
    if (!isArray(ApplicableMacroIndices)) {
      ApplicableMacroIndices = defAllMacroIndices;
    }
    if (returnText) {
      l = ApplicableMacroIndices.length;
      for (i = 0; i < l; i += 1) {
        macroObj = macroList[ApplicableMacroIndices[i]];
        if (macroObj) {
          replaceStr = regReplaceEscape(getValidValue((argObj = arguments[macroObj.argIndex]) && argObj[macroObj.argKey], BLANK) + BLANK);
          returnText = returnText.replace(macroObj.regex, replaceConstant + (macroObj.parsingMethod ? macroObj.parsingMethod(replaceStr) : replaceStr));
          returnText = returnText.replace(macroObj.escapeRegex, escapeReplaceStr);
        }
      }
    }
    return returnText;
  };
}(),


// /////// *********Linear Axis Min Max module****** ////////////
getAxisLimits = function () {
  var getDivisibleRange, numDecimals, isRangeDivisible;
  getDivisibleRange = function getDivisibleRange(yMin, yMax, numDivLines, interval, interceptRange) {
    // Get the range division for current yMin, yMax and numDivLines
    var range = Math.abs(yMax - yMin),
        rangeDiv = range / (numDivLines + 1),
        checkLimit;
    // Now, the range is not divisible
    if (!isRangeDivisible(range, numDivLines, interval)) {
      // We need to get new rangeDiv which can be equally distributed.
      // If intercept range is set to true
      if (interceptRange) {
        // Re-adjust interval so that gap is not much (conditional)
        // Condition check limit based on value
        checkLimit = interval > 1 ? 2 : 0.5;
        if (Number(rangeDiv) / Number(interval) < checkLimit) {
          // Decrease power of ten to get closer rounding
          interval = interval / 10;
        }
      }
      // Adjust range division based on new interval
      rangeDiv = (Math.floor(rangeDiv / interval) + 1) * interval;
      // Get new range
      range = rangeDiv * (numDivLines + 1);
    }
    // Return range
    return range;
  };

  /**
   * numDecimals method returns the number of decimal places provided
   * in the given number.
   * @param num Number for which we've to find the decimal places.
   * @return Number of decimal places found.
   */
  numDecimals = function numDecimals(num) {
    // Absolute value (to avoid floor disparity for negative num)
    num = Math.abs(num);
    // Convert to string and find the position of dot.
    var strNum = String(num),
        decimals = 0,
        dotPos = strNum.indexOf(DECIMALSTRING);
    // See if the number has decimal at all
    if (dotPos != -1) {
      // Find the position of decimal.
      decimals = strNum.length - dotPos - 1;
    }
    // Return the number of decimal digits
    return decimals;
  };
  /**
   * isRangeDivisible method helps us judge whether the given range is
   * perfectly divisible for specified y-interval, numDivLines, yMin and yMax.
   * To check that, we divide the given range into (numDivLines+1) section.
   * If the decimal places of this division value is <= that of interval,
   * that means, this range fits in our purpose. We return a boolean value
   * accordingly.
   * @param range  Range of y-axis (Max - Min). Absolute value
   * @param numDivLines Number of div lines to be plotted.
   * @param interval Y-axis Interval (power of ten).
   * @return   Boolean value indicating whether this range is divisible
   *      by the given number of div lines.
   */
  isRangeDivisible = function isRangeDivisible(range, numDivLines, interval) {
    // Get range division
    var rangeDiv = range / (numDivLines + 1);
    // Now, if the decimal places of rangeDiv and interval do not match,
    // it's not divisible, else it's divisible
    if (numDecimals(rangeDiv) > numDecimals(interval)) {
      return false;
    } else {
      return true;
    }
  };

  /**
   * getAxisLimits method helps calculate the axis limits based
   * on the given maximum and minimum value.
   * @param maxValue  Maximum numerical value present in data
   * @param minValue  Minimum numerical value present in data
   * @param stopMaxAtZero Flag indicating whether maximum value can
   *       be less than 0.
   * @param setMinAsZero Whether to set the lower limit as 0 or a greater
   * appropriate value (when dealing with positive numbers)
   */

  return function (maxValue, minValue, yAxisMaxValue, yAxisMinValue, stopMaxAtZero, setMinAsZero, numDivLines, adjustDiv) {
    // write the variable which are added as an param in as object
    var yMaxGiven,
        yMinGiven,
        yMax,
        yMin,
        range,
        interval,
        maxPowerOfTen,
        minPowerOfTen,
        powerOfTen,
        yInterval,
        rangePowerOfTen,
        rangeInterval,
        yTopBound,
        yLowerBound,
        deltaRange,
        found,
        adjInterval,
        rangeD,
        nextRange,
        rangeDiv,
        mf,
        smallArm,
        extSmallArm,
        i,
        adjRange,
        divLines,

    // bigArm,
    divInterval,
        extBigArm,
        addToRange = 0,
        evalNumDivlines;
    // First check if both maxValue and minValue are proper numbers.
    // Else, set defaults as 90,0
    maxValue = isNaN(maxValue) === true || maxValue === UNDEF ? 0.1 : maxValue;
    minValue = isNaN(minValue) === true || minValue === UNDEF ? 0 : minValue;
    // Or, if only 0 data is supplied
    if (maxValue === minValue && maxValue === 0) {
      maxValue = 0.1;
    }
    // Defaults for stopMaxAtZero and setMinAsZero
    stopMaxAtZero = typeof stopMaxAtZero === 'undefined' ? true : stopMaxAtZero;
    setMinAsZero = typeof setMinAsZero === 'undefined' ? true : setMinAsZero;
    // Get the maximum power of 10 that is applicable to maxvalue
    // The Number = 10 to the power maxPowerOfTen + x (where x is another number)
    // For e.g., in 99 the maxPowerOfTen will be 1 = 10^1 + 89
    // And for 102, it will be 2 = 10^2 + 2
    maxPowerOfTen = Math.floor(Math.log(Math.abs(maxValue)) / Math.LN10);
    // Get the minimum power of 10 that is applicable to maxvalue
    minPowerOfTen = Math.floor(Math.log(Math.abs(minValue)) / Math.LN10);
    // Find which powerOfTen (the max power or the min power) is bigger
    // It is this which will be multiplied to get the y-interval
    powerOfTen = Math.max(minPowerOfTen, maxPowerOfTen);
    yInterval = Math.pow(10, powerOfTen);
    // For accomodating smaller range values (so that scale doesn't represent too large an interval
    if (Math.abs(maxValue) / yInterval < 2 && Math.abs(minValue) / yInterval < 2) {
      powerOfTen--;
      yInterval = Math.pow(10, powerOfTen);
    }
    // If the y_interval of min and max is way more than that of range.
    // We need to reset the y-interval as per range
    rangePowerOfTen = Math.floor(Math.log(maxValue - minValue) / Math.LN10);
    rangeInterval = Math.pow(10, rangePowerOfTen);
    // Now, if rangeInterval is 10 times less than y_interval, we need to re-set
    // the limits, as the range is too less to adjust the axis for max,min.
    // We do this only if range is greater than 0 (in case of 1 data on chart).
    if (maxValue - minValue > 0 && yInterval / rangeInterval >= 10) {
      yInterval = rangeInterval;
      powerOfTen = rangePowerOfTen;
    }
    // Calculate the y-axis upper limit
    yTopBound = (Math.floor(maxValue / yInterval) + 1) * yInterval;
    // Calculate the y-axis lower limit
    // yLowerBound;
    // Delta in range
    // deltaRange;
    // If the min value is less than 0
    if (minValue < 0) {
      // Then calculate by multiplying negative numbers with y-axis interval
      yLowerBound = -1 * ((Math.floor(Math.abs(minValue / yInterval)) + 1) * yInterval);
    } else {
      // Else, simply set it to 0.
      if (setMinAsZero) {
        yLowerBound = 0;
      } else {
        yLowerBound = Math.floor(Math.abs(minValue / yInterval) - 1) * yInterval;
        // Now, if minValue>=0, we keep x_lowerBound to 0 - as for values like minValue 2
        // lower bound goes negative, which is not required.
        yLowerBound = yLowerBound < 0 ? 0 : yLowerBound;
      }
    }
    // MaxValue cannot be less than 0 if stopMaxAtZero is set to true
    if (stopMaxAtZero && maxValue <= 0) {
      yTopBound = 0;
    }
    // Now, we need to make a check as to whether the user has provided an upper limit
    // and lower limit.
    // Code before JSlint: if (yAxisMaxValue == null || yAxisMaxValue == UNDEF || yAxisMaxValue == BLANK)
    if (!yAxisMaxValue && yAxisMaxValue !== 0) {
      yMaxGiven = false;
    } else {
      yMaxGiven = true;
    }
    if (!yAxisMinValue && yAxisMinValue !== 0) {
      yMinGiven = false;
    } else {
      yMinGiven = true;
    }
    // If he has provided it and it is valid, we leave it as the upper limit
    // Else, we enforced the value calculate by us as the upper limit.
    if (yMaxGiven === false || yMaxGiven === true && Number(yAxisMaxValue) < maxValue && maxValue - Number(yAxisMaxValue) > EPSILON) {
      yMax = yTopBound;
    } else {
      yMax = Number(yAxisMaxValue);
    }
    // Now, we do the same for y-axis lower limit
    if (yMinGiven === false || yMinGiven === true && Number(yAxisMinValue) > minValue && Number(yAxisMinValue) - minValue > EPSILON) {
      yMin = yLowerBound;
    } else {
      yMin = Number(yAxisMinValue);
    }
    // Store axis range
    range = Math.abs(yMax - yMin);
    // Store interval
    interval = yInterval;
    // }

    /**
     * There can be four cases of yMin, yMax.
     * 1. User doesn't specify either. (our program calculates it).
     * 2. User specifies both in XML. (which our program still validates)
     * 3. User specifies only yMin. (we provide missing data)
     * 4. User specifies only yMax. (we provide missing data)
     *
     * Apart from this, the user can specify numDivLines (which if not specified takes a
     * default value of 4). Also, the user can specify adjustDiv (which can be 1 or 0).
     * adjustDiv works in all four cases (1,2,3,4).
     * Case 1 is modified to occur as under now: User doesn't specify either yMin or yMax
     * and adjustDiv is set to true (by default). If the user doesn't specify either yMin or
     * yMax, but adjustDiv is set to false, it doesn't appear as Case 1. However, if adjustDiv
     * is set to true and yMin,yMax is automatically calculated by FusionCharts, we adjust the
     * calculated yMin,yMax so that the given number of div lines can be well adjusted within.
     *
     * In case 2,3,4, we adjust numDivLines so that they space up equally based on the interval
     * and decimals required.
     *
     * So, the difference between Case 1 and Case 2,3,4 is that in Case 1, we adjust limits
     * to accomodate specified number of div lines. In Case 2,3,4, we adjust numDivLines to
     * accomodate within the given limits (y-axis range).
     *
     * numDivLines is always our primary focus when calculating them in all cases. In Case 1,
     * it's kept constant as center of calculation. In Case 2, it's modified to get a best
     * value.
     *
     * Now, for case 1, we can have three sub cases:
     * 1.1. yMax, yMin >=0
     * 1.2. yMin, yMax <=0
     * 1.3. yMax > 0 and yMin <0.
     * Case 1.1 and 1.2 are simple, as we just need to adjust the range between two positive
     * or two negative numbers such that the range can be equally divided into (numDivLines+1)
     * division.
     * Case 1.3 is tricky, as here, we additionally need to make sure that 0 plane is included
     * as a division.
     * We use two different methods to solved Case 1.1,1.2 and Case 1.3.
     * Note that in all Cases (1.1, 1.2 & 1.3), we adjust the auto-calculated yMax and yMin
     * to get best div line value. We do NOT adjust numDivLines here.
     */
    // Check condition for case 1 first - limits not specified and adjustDiv is true
    if (yMinGiven === false && yMaxGiven === false && adjustDiv) {
      // Means neither chart max value nor min value has been specified and adjustDiv is true
      // Now, if it's case 1.3 (yMax > 0 & yMin <0)
      if (yMax > 0 && yMin < 0) {
        // Case 1.3
        /**
         * Here, in this case, we start by generating the best fit range
         * for the given yMin, yMax, numDivLines and interval. We generate
         * range by adding sequential increments (rangeDiv * (ND+1) * interval).
         * Interval has been adjusted to smaller interval for larger values.
         * Now, for each divisible range generated by the program, we adjust the
         * yMin and yMax to check if 0 can land as a division in between them on
         * a proper distance.
         * We divide the y-axis range into two parts - small arm and big arm.
         * Say y-axis range is from 1 to -5. So, small arm is 1 and big arm is -5.
         * Or, if its from 16 to -3, small arm is -3 and big arm is 16.
         * Now, we try and get a value for extended small arm, which is multiple
         * of rangeDiv. Say chart min,max is 16,-3. So range becomes 19.
         * Let's assume numDivLines to be 2. So for 2 numDivLines, we get closest
         * adjusted range value as 21. Delta range = 21 - 19 (original range) = 2
         * Also, range division value = 21 / (ND + 1) = 21 / 3 = 7
         * We now get values for extended small arm as i*range division, where i
         * runs from 1 to (numDivLines+1)/2. We go only halfway as it's the smaller
         * arm and so cannot extend to a division beyond half way - else it would have
         * been the bigger arm.
         * So, first extended small arm = -7 * 1 = -7.
         * We get the difference between extended small arm and original small arm.
         * In this case it's 7 - 3 = 4 (all absolute values now - to avoid sign disparities).
         * We see that delta arm > delta range. So, we ignore this range and get a new range.
         * So, next range comes as = prev Range (21) + (numDivLines + 1)*interval
         * = 21 + (2+1)*1 = 24
         * Since the increment is sequential as a multiplication factor of
         * (numDivLines + 1)*interval, it is also a valid divisible range.
         * So we again check whether 0 can appear as a division. In this case, we
         * get rangeDiv as 8 and extended smaller arm as 8. For this extended smaller
         * arm, we get bigger arm as 16. Both of these are divisible by rangeDiv. That
         * means, this range can include 0 as division line. So, we store it and proceed.
         */
        // Flag to indicate whether we've found the perfect range or not.
        found = false;
        // We re-calculate the interval to get smaller increments for large values.
        // For example, for 300 to -100 (with ND as 2), if we do not adjust interval, the min
        // max come as -200, 400. But with adjusted intervals, it comes as -150, 300, which is
        // more appropriate.
        adjInterval = interval > 10 ? interval / 10 : interval;
        // Get the first divisible range for the given yMin, yMax, numDivLines and interval.
        // We do not intercept and adjust interval for this calculation here.
        rangeD = getDivisibleRange(yMin, yMax, numDivLines, adjInterval, false);
        // Now, deduct delta range from nextRange initially, so that in while loop,
        // there's a unified statement for increment instead of 2 checks.
        nextRange = rangeD - (numDivLines + 1) * adjInterval;

        // Now, we need to search for a range which is divisible in (numDivLines+1)
        // segments including 0. Run a while loop till that is found.
        while (found === false) {
          // Get range
          nextRange = nextRange + (numDivLines + 1) * adjInterval;
          // If it's divisible for the given range and adjusted interval, proceed
          if (isRangeDivisible(nextRange, numDivLines, adjInterval)) {
            // Delta Range
            deltaRange = nextRange - range;
            // Range division
            rangeDiv = nextRange / (numDivLines + 1);
            // Get the smaller arm of axis
            smallArm = Math.min(Math.abs(yMin), yMax);
            // Bigger arm of axis.
            // bigArm = range - smallArm;
            // Get the multiplication factor (if smaller arm is negative, set -1);
            mf = smallArm == Math.abs(yMin) ? -1 : 1;
            // If num div lines ==0, we do not calculate anything
            if (numDivLines === 0) {
              // Set flag to true to exit loop
              found = true;
            } else {
              // Now, we need to make sure that the smaller arm of axis is a multiple
              // of rangeDiv and the multiplied result is greater than smallArm.
              for (i = 1; i <= Math.floor((numDivLines + 1) / 2); i++) {
                // Get extended small arm
                extSmallArm = rangeDiv * i;
                // If extension is more than original intended delta, we move to next
                // value of loop as this range is smaller than our intended range
                if (extSmallArm - smallArm > deltaRange) {
                  // Iterate to next loop value
                  continue;
                }
                // Else if extended arm is greater than smallArm, we do the 0 div test
                if (extSmallArm > smallArm) {
                  // Get extended big arm
                  extBigArm = nextRange - extSmallArm;
                  // Check whether for this range, 0 can come as a div
                  // By checking whether both extBigArm and extSmallArm
                  // are perfectly divisible by rangeDiv
                  if (extBigArm / rangeDiv == Math.floor(extBigArm / rangeDiv) && extSmallArm / rangeDiv == Math.floor(extSmallArm / rangeDiv)) {
                    // Store in global containers
                    range = nextRange;
                    yMax = mf == -1 ? extBigArm : extSmallArm;
                    yMin = mf == -1 ? -extSmallArm : -extBigArm;
                    // Set found flag to true to exit loop
                    found = true;
                  }
                } else {
                  // Iterate to next loop value, as we need the arm to be greater
                  // than original value.
                  continue;
                }
              }
            }
          }
        }
      } else {
        // Case 1.1 or 1.2
        // In this case, we first get apt divisible range based on yMin, yMax,
        // numDivLines and the calculated interval. Thereby, get the difference
        // between original range and new range and store as delta.
        // If yMax>0, add this delta to yMax. Else substract from yMin.
        // Get the adjusted divisible range
        adjRange = getDivisibleRange(yMin, yMax, numDivLines, interval, true);
        // Get delta (Calculated range minus original range)
        deltaRange = adjRange - range;
        // Update global range storage
        range = adjRange;
        // Now, add the change in range to yMax, if yMax > 0, else deduct from yMin
        if (yMax > 0) {
          yMax = yMax + deltaRange;
        } else {
          yMin = yMin - deltaRange;
        }
      }
    } else {
      //  Here, we've to handle the following cases
      //  2. User specifies both yMin, yMax in XML. (which our program still validates)
      //  3. User specifies only yMin. (we provide yMax)
      //  4. User specifies only yMax. (we provide yMin)
      //  Now, for each of these, there can be two cases. If the user has opted to
      //  adjust div lines or not. If he has opted to adjustDiv, we calculate the best
      //  possible number of div lines for the given range. If not, we simply divide
      //  the given (or semi-calculated) axis limits by the number of div lines.
      if (adjustDiv) {
        // We iterate from given numDivLines to 0,
        // Count helps us keep a counter of how many div lines we've checked
        // For the sake of optimization, we check only 25 div lines values
        // From (numDivLines to 0) and (numDivLines to (25-numDivLines))
        // We do it in a yoyo order - i.e., if numDivLines is set as 5,
        // we first check 6 and then 4. Next would be (8,3), (9,2), (10,1),
        // (11, (no value here, as we do not check for 0), 12, 13, 14, 15, 16,
        // 17,18,19,20. So, in this way, we check for 25 possible numDivLines and
        // see if any one them fit in. If yes, we store that value. Else, we set it
        // as 0 (indicating no div line feasible for the given value).
        // Perform only if numDivLines>0
        evalNumDivlines = function evalNumDivlines(numDivLines, range, interval) {
          var counter = 0,
              multiplyFactor = 1,
              divLines;

          while (1) {
            // Increment,Decrement numDivLines
            divLines = numDivLines + counter * multiplyFactor;
            // Cannot be 0
            divLines = divLines === 0 ? 1 : divLines;
            // Check whether this number of numDivLines satisfy our requirement
            if (isRangeDivisible(range, divLines, interval)) {
              // Exit loop
              break;
            }
            // Each counter comes twice: one for + count, one for - count
            counter = multiplyFactor == -1 || counter > numDivLines ? ++counter : counter;
            if (counter > 25) {
              // We do not go beyond 25 count to optimize.
              // If the loop comes here, it means that divlines
              // counter is not able to achieve the target.
              // So, we assume no div lines are possible and exit.
              divLines = 0;
              break;
            }
            // Switch to increment/decrement mode. If counter
            multiplyFactor = counter <= numDivLines ? multiplyFactor * -1 : 1;
          }
          return divLines;
        };

        if (numDivLines > 0) {
          divLines = evalNumDivlines(numDivLines, range, interval);
          if (divLines === 0) {
            divLines = evalNumDivlines(numDivLines, range + 1, interval);
            addToRange = 1;
          }
          // Store the value in params
          numDivLines = divLines;
        }
      }
    }
    // Set flags pertinent to zero plane
    // if (yMax > 0 && yMin < 0)
    // {
    //  zeroPRequired = true;
    // } else
    // {
    //  zeroPRequired = false;
    // }
    // Div interval
    divInterval = (yMax - yMin + addToRange) / (numDivLines + 1);
    /* //Flag to keep a track whether zero plane is included
     zeroPIncluded = false;
     //We now need to store all the div line segments in the array this.divLines
     //We include yMin and yMax too in div lines to render in a single loop
     var divLineValue = yMin - divInterval;
     //Keeping a count of div lines
     var count = 0;
     while (count <= (numDivLines + 1))
     {
     //Converting to string and back to number to avoid Flash's rounding problems.
     divLineValue = Number (String (divLineValue + divInterval));
     //Check whether zero plane is included
     zeroPIncluded = (divLineValue == 0) ? true : zeroPIncluded;
     //Add the div line to this.divLines
     this.divLines [count] = this.returnDataAsDivLine (divLineValue);
     //Based on yAxisValueStep, we need to hide required div line values
     if (count % yAxisValuesStep == 0)
     {
     divLines [count].showValue = true;
     } else
     {
     divLines [count].showValue = false;
     }
     //Increment counter
     count ++;
     }
     //Now, the array this.divLines contains all the divisional values. But, it might
     //not contain 0 value in Case 2,3,4 (i.e., when the user manually sets things).
     //So, if zero plane is required but not included, we include it.
     if (zeroPRequired == true && zeroPIncluded == false)
     {
     //Include zero plane at the right place in the array.
     divLines.push (returnDataAsDivLine (0));
     //Now, sort on value so that 0 automatically appears at right place
     divLines.sortOn ('value', Array.NUMERIC);
     //Also increase numDivLines
     numDivLines ++;
     }
     //We finally have the sorted div lines in this.divLines  */

    // ////fix of error in renderer for infinite loop

    return {
      Max: yMax,
      Min: yMin,
      Range: range,
      interval: interval,
      divGap: divInterval
    };
  };
}(),

// HC compatiable JSON to Show a message in Chart
// store blank Chart to show message
// /special configuration
/** @todo have to check whether style for text are applicable in FC or not
 //then we have to implement the font style also */
createDialog = function () {
  var api = function api(container, text, chartObj) {
    var smartLabel = chartObj.jsVars && chartObj.jsVars.smartLabel,
        chartWidth = container.offsetWidth,
        chartHeight = container.offsetHeight,
        chart = this.chart,
        title = this.title,
        imgStyle = chartObj._chartMessageImageStyle,
        // styles for image as chart msg
    strObj = getImageURL(text),
        smartText;

    title.y = chartHeight / 2;
    title.x = chartWidth / 2;

    // Clear previous title and background image if any, in order to ignore the cache.
    chart.bgSWF = title.text = UNDEF;
    text = strObj.string;

    // If the chart message string is an URL to image set the URL and other properties as
    // chart background image.
    if (strObj.image) {
      chart.bgSWF = text;
      chart.bgImageHAlign = imgStyle.imageHAlign;
      chart.bgImageVAlign = imgStyle.imageVAlign;
      chart.bgImageScale = imgStyle.imageScale;
      chart.bgSWFAlpha = imgStyle.imageAlpha;
    } else if (text !== UNDEF) {
      if (smartLabel) {
        setLineHeight(title.style);
        smartLabel.setStyle(title.style);
        smartText = smartLabel.getSmartText(parseUnsafeString(text), chartWidth, chartHeight);
        title.text = smartText.text;
      } else {
        title.text = parseUnsafeString(text);
      }
      title.verticalAlign = 'middle';
    }

    title.style = chartObj._chartMessageStyle;

    delete chartObj._chartMessageImageStyle;
    delete chartObj._chartMessageStyle;
  };

  api.prototype = { // jsonstructutr for a blank chart which will be used to show a messege
    chart: {
      events: {},
      margin: [0, 0, 0, 0],
      backgroundColor: {
        FCcolor: {
          alpha: 0
        }
      }
    },
    credits: {
      href: CREDIT_HREF,
      text: CREDIT_STRING,
      enabled: creditLabel
    },
    legend: {
      enabled: false
    },
    title: {
      text: '',
      style: {
        fontFamily: 'Verdana,sans',
        fontSize: '10px',
        color: '#666666'
      }
    },
    plotOptions: {
      series: {}
    },
    series: [{}],
    exporting: {
      enabled: false
    },
    nativeMessage: true
  };

  return api.prototype.constructor = api;
}(),


// [zone][!inverse][start < end]
trendLineLabelPositionHoriz = {
  'true': {
    'true': {
      'true': POSITION_CENTER,
      'false': POSITION_CENTER
    },
    'false': {
      'true': POSITION_CENTER,
      'false': POSITION_CENTER
    }
  },
  'false': {
    // Relative value position: start < end
    'true': {
      // Axis oppositality
      'true': POSITION_RIGHT,
      'false': POSITION_LEFT
    },
    'false': {
      // Axis oppositality
      'true': POSITION_LEFT,
      'false': POSITION_RIGHT
    }
  }
},

// Function to insart trend Line
/** @todo
 * - pading will be added as per axis label padding
 * - have to import style
 * - have to optimize
 * - implement tooltip on trendlines
 */
createTrendLine = function () {
  return function (trendObj, axis, hcConf, isDY, isBar, isVtrend, isInverse) {
    var x,
        trendStyle = hcConf.trendStyle,
        z,
        l,
        m,
        trendLineObj,
        isOpp,
        isZone,
        displayvalue,
        trendLabelObj,
        toolText,
        labelColor,
        axisObj,
        width,
        trendStartValue,
        trendEndValue,

    // slopeDirection,
    slopeDirectionHoriz,
        max,
        min,
        axisIndex,
        trendLines,
        NFMethodName = isVtrend ? 'xAxis' : 'dataLabels';

    if (isVtrend ? !hcConf.showVLines : !hcConf.showTrendlines) {
      return;
    }
    for (x = 0, l = trendObj.length; x < l; x += 1) {
      trendLines = trendObj[x];
      if (trendLines && trendLines.line) {
        for (z = 0, m = trendLines.line.length; z < m; z += 1) {
          trendLineObj = trendLines.line[z];

          trendStartValue = hcConf.numberFormatter.getCleanValue(pluck(trendLineObj.startvalue, trendLineObj.value, 0));
          trendEndValue = hcConf.numberFormatter.getCleanValue(pluck(trendLineObj.endvalue, pluck(trendLineObj.startvalue, trendLineObj.value, 0)));

          // check which axis object will be added
          if (isVtrend) {
            axisObj = axis;
          } else if (isDY && trendLineObj.parentyaxis && /^s$/i.test(trendLineObj.parentyaxis)) {
            axisObj = axis[1];
            axisIndex = 1;
          } else {
            axisObj = axis[0];
          }
          max = axisObj.max;
          min = axisObj.min;
          // isOpp variable needs to be re-evaluated in each iteration
          // as trendlines might be of different axis.
          isOpp = false;
          if (max >= trendStartValue && max >= trendEndValue && min <= trendStartValue && min <= trendEndValue) {
            // for secondary y axis we have to place its trendlines on right
            // by default. attribute valueonleft for secondary y axis is not
            // documented. So its usage at this moment will be a hack
            if (isDY && trendLineObj.parentyaxis && /^s$/i.test(trendLineObj.parentyaxis)) {
              isOpp = pluck(trendLineObj.valueonleft, hcConf.trendlineValuesOnOpp) !== ONESTRING;
            } else if (!isDY) {
              // But for any DY axis chart trendlines should not be placed on
              // right.
              isOpp = pluck(trendLineObj.valueonright, hcConf.trendlineValuesOnOpp) === ONESTRING;
            }

            /* isOpp = (trendLineObj.valueonright === ONESTRING ||
             (trendLineObj.parentyaxis && /^s$/i.test(trendLineObj.parentyaxis))) ? true : false; */

            // Calculate from input values whether the object would
            // be trendline or trendzone
            isZone = Boolean(pluckNumber(trendLineObj.istrendzone, isVtrend ? 1 : 0));

            // if there has a display value the create it
            if (!(isVtrend ? hcConf.showVLineLabels : hcConf.showTrendlineLabels)) {
              displayvalue = BLANK;
            } else {
              displayvalue = parseUnsafeString(pluck(trendLineObj.displayvalue, hcConf.numberFormatter[NFMethodName](isOpp ? trendEndValue : trendStartValue, axisIndex)));
            }

            if (displayvalue) {
              // slopeDirection = (trendStartValue > trendEndValue);
              slopeDirectionHoriz = trendStartValue < trendEndValue;
              trendLabelObj = {
                text: displayvalue,
                textAlign: isBar ? POSITION_CENTER : isOpp ? POSITION_LEFT : POSITION_RIGHT,
                align: isBar ? trendLineLabelPositionHoriz[isZone][!isInverse][slopeDirectionHoriz] : isOpp ? POSITION_RIGHT : POSITION_LEFT,
                /* verticalAlign: isBar ? POSITION_BOTTOM :
                 trendLineLabelPosition[isZone][!isInverse][slopeDirection][isOpp], */
                verticalAlign: isBar ? POSITION_BOTTOM : POSITION_MIDDLE,
                rotation: 0,
                x: 0,
                y: 0, // isBar ? halfFontSize : 2,
                style: trendStyle
              };
              labelColor = pluck(trendLineObj.color, hcConf.trendlineColor);
              trendLineObj.alwaysVisible = isZone; // always show zones (even if 0 width)
              if (labelColor) {
                trendLabelObj.style = (0, _libExtend2['default'])({}, trendStyle);
                trendLabelObj.style.color = convertColor(labelColor, pluckNumber(trendLineObj.alpha, 100));
              }
            } else {
              trendLabelObj = UNDEF;
            }
            // add options for tooltext
            toolText = getValidValue(parseUnsafeString(pluck(trendLineObj.tooltext, trendLines.tooltext, hcConf.trendLineToolText)));
            toolText = parseTooltext(toolText, [7, 15, 16, 17, 18, 19], {
              startValue: trendStartValue,
              startDataValue: hcConf.numberFormatter[NFMethodName](trendStartValue, axisIndex),
              endValue: trendEndValue,
              endDataValue: hcConf.numberFormatter[NFMethodName](trendEndValue, axisIndex),
              axisName: axisObj.title && axisObj.title.text
            }, trendLineObj);

            width = pluckNumber(trendLineObj.thickness, hcConf.trendlineThickness, 1);

            if (isZone) {
              axisObj.plotBands.push({
                isTrend: true,
                color: convertColor(pluck(trendLineObj.color, hcConf.trendlineColor), pluck(trendLineObj.alpha, hcConf.trendlineAlpha, 40)),
                from: trendStartValue,
                to: trendEndValue,
                label: trendLabelObj,
                // for 3d series never will be on top
                zIndex: !hcConf.is3d && pluck(trendLineObj.showontop, hcConf.showTrendlinesOnTop) === ONESTRING ? 5 : 3,
                tooltext: toolText,
                alwaysVisible: trendLineObj.alwaysVisible
              });
            } else {
              axisObj.plotLines.push({
                isTrend: true,
                color: convertColor(pluck(trendLineObj.color, hcConf.trendlineColor, hcConf.trendlineColor), pluck(trendLineObj.alpha, hcConf.trendlineAlpha, 99)),
                value: trendStartValue,
                to: trendEndValue,
                width: width,
                dashStyle: pluck(trendLineObj.dashed, hcConf.trendlinesAreDashed) == ONESTRING ? getDashStyle(pluckNumber(trendLineObj.dashlen, hcConf.trendlinesDashLen), pluckNumber(trendLineObj.dashgap, hcConf.trendlinesDashGap)) : DASH_DEF,
                label: trendLabelObj,
                // for 3d series never will be on top
                zIndex: !hcConf.is3d && pluck(trendLineObj.showontop, hcConf.showTrendlinesOnTop) === ONESTRING ? 5 : 3,
                tooltext: toolText
              });
            }
          }
        }
      }
    }
  };
}(),
    chartAPI,
    interActiveEvtList = {
  click: true,
  dragstart: true,
  dragmove: true,
  dragend: true,
  dblclick: true,
  mousedown: true,
  mousemove: true,
  mouseout: true,
  mouseover: true,
  mouseup: true,
  touchstart: true,
  touchmove: true,
  touchend: true,
  touchcancel: true
},
    regex = {
  stripWhitespace: stripWhitespace,
  dropHash: dropHash,
  startsRGBA: startsRGBA,
  cleanColorCode: cleanColorCode,
  breakPlaceholder: breakPlaceholder,
  hexcode: hexcode
},
    preDefStr = {
  // Please set the color key in capitals without hash when adding new color string
  colors: {
    B90000: 'B90000',
    FFFFFF: 'FFFFFF',
    AAAAAA: 'AAAAAA',
    c000000: '000000'
  },
  BLANK: '',
  DATASET: 'dataset',
  NORMALSTRING: 'normal',
  PX: 'px',
  INPUT: 'input',
  LABEL: 'label',
  BLANKSPACE: ' ',
  COMMA: ',',
  OBJECTBOUNDINGBOX: 'objectBoundingBox',
  GROUPID: 'groupId',
  EVENTARGS: 'eventArgs',
  CIRCLE: 'circle',
  POLYGON: 'polygon',
  RECTANGLE: 'rectangle',
  ROLLOUT: 'rollout',
  ROLLOVER: 'rollover',
  DATAPLOTCLICK: 'dataplotclick',
  defaultFontStr: 'Verdana,sans',
  line: 'line',
  bar: 'bar',
  column: 'column',
  volume: 'volume',
  HUNDREDSTRING: '100',
  SEVENTYSTRING: '70',
  NINETYSTRING: '90',
  AUTOSTRING: 'auto',
  configStr: 'config',
  animationObjStr: 'animationObj',
  showHoverEffectStr: 'showHoverEffect',
  hiddenStr: 'hidden',
  visibleStr: 'visible',

  columnStr: 'columns',
  barStr: 'bars',
  barHotStr: 'bar-hot',
  colHotStr: 'col-hot',
  shadowStr: 'shadow',
  dataLabelStr: 'datalabel',
  errorBarStr: 'errorBar',
  errorHotStr: 'error-hot',
  errorShadowStr: 'error-shadow',

  negativeValueStr: 'negative-values',
  positiveValueStr: 'positive-values',
  zeroPlaneStr: 'zero-plane',
  categoryPlotsStr: 'categoryplots',
  noneStr: 'none',
  setRolloverAttrStr: 'setRolloverAttr',
  setRolloutAttrStr: 'setRolloutAttr',
  elementStr: 'element',
  hotElementStr: 'hotElement',
  strokeWidthStr: 'stroke-width',
  strokeDashStr: 'stroke-dasharray',
  strokeLineJoinStr: 'stroke-linejoin',
  miterStr: 'miter',
  visiblilityStr: 'visibility',
  ROUND: 'round',
  PERCENTAGESTRING: '%',
  pStr: 'p',
  sStr: 's',
  divLineAlpha3DStr: 'divLineAlpha3D',
  divLineAlphaStr: 'divLineAlpha',
  altVGridColorStr: 'altVGridColor',
  altVGridAlphaStr: 'altVGridAlpha',
  altHGridColorStr: 'altHGridColor',
  altHGridAlphaStr: 'altHGridAlpha',
  PLOTFILLCOLOR_STR: 'plotFillColor',
  UNDERSCORE: UNDERSCORE,
  gaugeFillColorStr: 'gaugeFillColor',
  gaugeBorderColorStr: 'gaugeBorderColor',
  NORMAL: 'normal',
  BOLD: 'bold',
  POINTER: 'pointer',
  DEFAULT: 'default',

  POSITION_MIDDLE: 'middle',
  POSITION_START: 'start',
  POSITION_TOP: 'top',
  POSITION_BOTTOM: 'bottom',
  POSITION_END: 'end'
},
    graphics = {
  parseAlpha: parseAlpha,
  convertColor: convertColor,
  getDarkColor: getDarkColor,
  getLightColor: getLightColor,
  mapSymbolName: mapSymbolName,
  getColumnColor: getColumnColor,
  getPointColor: getPointColor,
  getAngle: getAngle,
  parseColor: parseColor,
  getValidColor: getValidColor,
  HSBtoRGB: HSBtoRGB,
  RGBtoHSB: RGBtoHSB,
  RGBtoHex: RGBtoHex,
  rawRGBtoHEX: rawRGBtoHEX,
  HEXtoRGB: hexToRgb,
  getCubePathOutline: getCubePathOutline
},
    priorityList = {
  instant: 1,
  render: 1,
  configure: 2,
  draw: 3,
  label: 4,
  animation: 5,
  entitydraw: 5,
  tracker: 6,
  kdTree: 6,
  postRender: 7
},
    appliedCSS = ['fontFamily', 'fontSize', 'fontWeight', 'fontStyle'],
    handleContainerResize = function () {
  var store = {},
      intervalId,
      trackResize = function trackResize() {
    var item,
        itemObj,
        itemVar,
        parentEle,
        count = 0,
        ref,
        s,
        offW,
        INTERVALMS = parseInt(fcGlobal.core.options.resizeTrackingInterval, 10) || 300,
        jsVars = {},
        storeContainerSize = function storeContainerSize() {
      jsVars.itemVar._containerOffsetW = jsVars.parentEle.offsetWidth;
      jsVars.itemVar._containerOffsetH = jsVars.parentEle.offsetHeight;
    },
        offH;

    for (item in store) {
      count += 1;
      itemObj = store[item];
      itemVar = itemObj.jsVars;
      ref = itemObj.ref;

      if (!itemObj.disposed && (parentEle = ref && ref.parentNode) && (s = ref.style) && (/\%/g.test(s.width) || /\%/g.test(s.height))) {
        offW = parentEle.offsetWidth;
        offH = parentEle.offsetHeight;

        if (!itemVar.resizeLocked && (offW && itemVar._containerOffsetW !== offW || offH && itemVar._containerOffsetH !== offH)) {
          itemObj.resizeTo && itemObj.resizeTo();

          // Store the parent container dimensions to jsVars
          jsVars.itemVar = itemVar;
          jsVars.parentEle = parentEle;
          setTimeout(storeContainerSize, 1);
        }
      } else {
        delete store[item];
        count -= 1;
      }
    }

    if (!count) {
      intervalId = clearTimeout(intervalId);
    } else {
      intervalId = setTimeout(trackResize, INTERVALMS);
    }
  };

  return function (sender, container) {
    var vars = sender.jsVars,
        element = container || sender.ref && sender.ref.parentNode || {};

    vars._containerOffsetW = element.parentNode.offsetWidth;
    vars._containerOffsetH = element.parentNode.offsetHeight;
    store[sender.id] = sender;

    if (!intervalId) {
      intervalId = setTimeout(trackResize, parseInt(fcGlobal.core.options.resizeTrackingInterval, 10) || 300);
    }
  };
}();

function defined(obj) {
  return typeof obj !== 'undefined' && obj !== null;
}

function pInt(s, mag) {
  return parseInt(s, mag || 10);
}

function getContainerBackgroundColor(chart) {
  var options = chart.options,
      color = options.containerBackgroundColor,
      opacity = options.containerBackgroundOpacity;

  if (defined(chart.jsVars.transparent)) {
    opacity = chart.jsVars.transparent ? 0 : 1;
  } else {
    opacity = parseFloat(opacity);
    if (opacity < 0) {
      opacity = 0;
    } else if (opacity > 1) {
      opacity = 1;
    }
  }

  if (!color) {
    color = '#ffffff';
  }

  if (isIE && !hasSVG) {
    return opacity ? color : 'transparent';
  } else {
    color = color.replace(/^#?([a-f0-9]+)/ig, '$1');
    color = hexToRgb(color);
    color[3] = opacity.toString();
    return 'rgba(' + color.join(',') + ')';
  }
}

function hashify(color) {
  return color && color.replace(/^#?([a-f0-9]+)/ig, '#$1') || 'none';
}

function addElScrollEvent(eveObj) {
  eveObj.data && (eveObj.data.elScroll = false);
}

// this function is to get the x y coordinate of element hovered
function getPosition(el, chart) {
  var pos = {
    top: 0,
    left: 0
  },
      elNode,
      position,
      chartConfig = chart && chart.config,

  // toolTipController = chart.getFromEnv('toolTipController'),
  eventListeners = chart && (chart.eventListeners || (chart.eventListeners = [])),
      isEvntAdded = chart && (chartConfig.isEvntAdded || (chartConfig.isEvntAdded = false));

  if (el) {
    pos.top = el.offsetTop;
    pos.left = el.offsetLeft;
    // get the parent node
    elNode = el;
    // get Element scroll position
    while ((elNode = elNode.parentNode) && elNode.tagName !== 'BODY') {
      position = win.getComputedStyle(elNode).getPropertyValue('position');
      if (/fixed/.test(position)) {
        if (chart) {
          chartConfig.itemFixed = true;
          // toolTipController.enableFixedPosition();
        }
      }
      pos.top -= elNode.scrollTop || 0;
      pos.left -= elNode.scrollLeft || 0;
      // add event to parent
      chart && !isEvntAdded && eventListeners.push(_domEvent2['default'].listen(elNode, 'scroll', addElScrollEvent, chartConfig));
    }
    // checking scroll for body and html
    while (elNode) {
      pos.top -= elNode.scrollTop || 0;
      pos.left -= elNode.scrollLeft || 0;
      elNode = elNode.parentNode;
    }
    // get element offset position\
    el = el.offsetParent;
    while (el) {
      pos.top += el.offsetTop;
      pos.left += el.offsetLeft;
      el = el.offsetParent;
    }
    // get window scroll position
    pos.top += win.pageYOffset || win.scrollY || doc.documentElement.scrollTop;
    pos.left += win.pageXOffset || win.scrollX || doc.documentElement.scrollLeft;

    chart && !isEvntAdded && eventListeners.push(_domEvent2['default'].listen(win, 'resize', addElScrollEvent, chartConfig));
    chart && !isEvntAdded && eventListeners.push(_domEvent2['default'].listen(win, 'scroll', addElScrollEvent, chartConfig));
    chart && !isEvntAdded && (chartConfig.isEvntAdded = true);
  }

  return pos;
}

/**
 * Sets a given number to a given lower bound or upper bound if the number exceeds those bounds
 * @param {number} number The number to be clamped
 * @param {number} [lowerBound=-Infinity] The upper bound at which to clamp the number
 * @param {number} [upperBound=Infinity] The lower bound at which to clamp the number
 * @return {number} The clamped number
 */
function clampNumber(number) {
  var lowerBound = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -Infinity;
  var upperBound = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;

  if (number <= lowerBound) {
    return lowerBound;
  } else if (number >= upperBound) {
    return upperBound;
  } else {
    return number;
  }
}

function pluckNumber() {
  var arg, i, l;

  for (i = 0, l = arguments.length; i < l; i += 1) {
    arg = arguments[i];
    if (!arg && arg !== false && arg !== 0) {
      continue;
    } else if (isNaN(arg = Number(arg))) {
      continue;
    }
    return arg;
  }
  return UNDEF;
}

function getTouchEvent(event) {
  var e = event && (event.sourceEvent || event.originalEvent || event);
  return touchEnabled && e && e.touches && e.touches[0] || e || stubEvent;
}

function fcEach(obj, fn, scope, data) {
  var i;

  if (!scope) {
    scope = obj;
  }

  if (!data) {
    data = {};
  }

  if (isArray(obj)) {
    for (i = 0; i < obj.length; i += 1) {
      if (fn.call(scope, obj[i], i, obj, data) === false) {
        return i;
      }
    }
  } else if (!(obj === null || obj === UNDEF)) {
    for (i in obj) {
      if (fn.call(scope, obj[i], i, obj, data) === false) {
        return i;
      }
    }
  }
}

function selectionEventHandler(evt) {
  var config = evt.data,
      chart = config.chart,
      paper = chart.getFromEnv('paper'),
      state = evt.state,
      event = getEventCoordinate(getTouchEvent(evt.originalEvent)),
      tgt = event.target || event.originalTarget || event.srcElement || event.relatedTarget || event.fromElement,
      canvas = chart.getChildren('canvas')[0],
      resizeBox = canvas.getGraphicalElement('resizeBox'),
      layerX = config.layerX = event.pageX - config.chartPosLeft,
      layerY = config.layerY = event.pageY - config.chartPosTop,
      dx = layerX - config.ox,
      dy = layerY - config.oy,
      bBox = config.bBox,
      x = config.ox,
      y = config.oy,
      zoomX = config.zoomX,
      zoomY = config.zoomY,
      canvasY = config.canvasY,
      canvasX = config.canvasX,
      canvasW = config.canvasW,
      canvasH = config.canvasH,
      canvasX2 = config.canvasX2,
      canvasY2 = config.canvasY2,
      strokeWidth = config.strokeWidth,
      attr = config.attr,
      container = this,
      chartPosition,
      selectionData;

  switch (state) {
    case 'start':
      // DragStart
      // Recalculate the container position and store it in the conf.
      chartPosition = getPosition(container);
      config.chartPosLeft = chartPosition.left;
      config.chartPosTop = chartPosition.top;
      layerX = event.pageX - config.chartPosLeft;
      layerY = event.pageY - config.chartPosTop;
      config.oy = layerY;
      config.ox = layerX;
      config.allowMove = false;
      // Create the resizable box
      if (!resizeBox) {
        resizeBox = canvas.addGraphicalElement('resizeBox', paper.rect(attr, chart.getChildContainer('trackerGroup')));
      }

      if (layerX > canvasX && layerX < canvasX2 && layerY > canvasY && layerY < canvasY2) {
        config.allowMove = true;
      }
      // do not receive event if the clicked target element is marked as
      // hot
      if (tgt && tgt.ishot) {
        config.allowMove = false;
      }

      resizeBox.attr({
        x: 0,
        y: 0,
        width: 0,
        height: 0
      }).show();
      break;

    case 'end':
      // DragEnd
      bBox = resizeBox.getBBox();
      selectionData = {
        chart: chart,
        selectionLeft: bBox.x,
        selectionTop: bBox.y,
        selectionHeight: bBox.height,
        selectionWidth: bBox.width,
        originalEvent: evt.originalEvent
      };
      if (config.isDragged) {
        config.selectionEnd && config.selectionEnd(selectionData);
        config.isDragged = 0;
      }
      resizeBox.hide();

      delete config.oy;
      delete config.ox;
      break;

    default:
      // DragMove
      if (!config.allowMove) {
        return;
      }
      dx = layerX - config.ox;
      dy = layerY - config.oy;
      bBox = config.bBox;
      x = config.ox;
      y = config.oy;

      if (!config.isDragged) {
        selectionData = {
          chart: chart,
          selectionLeft: (zoomX ? mathMin(x, x + dx) : canvasX) + strokeWidth * 0.5,
          selectionTop: (zoomY ? mathMin(y, y + dy) : canvasY) + strokeWidth * 0.5,
          selectionHeight: 0,
          selectionWidth: 0,
          originalEvent: evt.originalEvent
        };
        config.selectionStart && config.selectionStart(selectionData);
        config.isDragged = 1;
      }

      dx = -(x - mathMin(x - (x - mathMax(x + dx, canvasX)), canvasX2));
      dy = -(y - mathMin(y - (y - mathMax(y + dy, canvasY)), canvasY2));
      resizeBox.attr({
        x: (zoomX ? mathMin(x, x + dx) : canvasX) + strokeWidth * 0.5,
        y: (zoomY ? mathMin(y, y + dy) : canvasY) + strokeWidth * 0.5,
        width: zoomX ? mathAbs(dx) : canvasW,
        height: zoomY ? mathAbs(dy) : canvasH
      });

      break;
  }
}
function onXYCanvasClick(event) {
  var config = event.data,
      e = event.originalEvent,
      tgt = e.target || e.originalTarget || e.srcElement || e.relatedTarget || e.fromElement,
      eventType = e.type,
      layerX = e.layerX,
      layerY = e.layerY;

  if (layerX === UNDEF) {
    layerX = e.pageX - config.chartPosLeft;
    layerY = e.pageY - config.chartPosTop;
  }

  if (eventType === 'mousedown') {
    tgt.ishot = layerX > config.canvasX && layerX < config.canvasX2 && layerY > config.canvasY && layerY < config.canvasY2;
  }
  if (eventType === 'mouseup') {
    setTimeout(function () {
      tgt.ishot = false;
    }, 1);
  }
}

/**
 * Capitalizes first letter of a word
 */
function capitalizeString(str, all) {
  // eslint-disable-next-line no-unused-vars
  return str ? str.replace(all ? /(^|\s)([a-z])/g : /(^|\s)([a-z])/, function (m, p1, p2) {
    return p1 + p2.toUpperCase();
  }) : str;
}

function getFirstValue() {
  var arg, i, l;
  for (i = 0, l = arguments.length; i < l; i += 1) {
    arg = arguments[i];
    if (!arg && arg !== false && arg !== 0) {
      continue;
    }
    return arg;
  }
  return BLANK;
}

function bindSelectionEvent(chart, config) {
  config = config || {};
  var chartConfig = chart.config,
      container = chart.getFromEnv('chart-container'),
      zoomType = chartConfig.zoomType,
      attr = (0, _libExtend2['default'])({}, config.attr || {}),
      strokeWidth = attr['stroke-width'] = pluckNumber(attr.strokeWidth, attr['stroke-width'], 1),
      eventListeners = chart.eventListeners || (chart.eventListeners = []),
      chartPosition = getPosition(container, chart);

  config = (0, _libExtend2['default'])({
    chart: chart,
    zoomX: /x/.test(zoomType),
    zoomY: /y/.test(zoomType),
    canvasY: chartConfig.canvasTop,
    canvasX: chartConfig.canvasLeft,
    canvasW: chartConfig.canvasWidth,
    canvasH: chartConfig.canvasHeight,
    canvasX2: chartConfig.canvasLeft + chartConfig.canvasWidth,
    canvasY2: chartConfig.canvasTop + chartConfig.canvasHeight,
    strokeWidth: strokeWidth,
    chartPosLeft: chartPosition.left,
    chartPosTop: chartPosition.top,
    attr: attr
  }, config);

  attr.stroke = getFirstValue(attr.stroke, 'rgba(51,153,255,0.8)');
  attr.fill = getFirstValue(attr.fill, 'rgba(185,213,241,0.3)');
  attr.ishot = true;

  if (container) {
    _domEvent2['default'].unlisten(container, 'pointerdrag', selectionEventHandler);
    eventListeners.push(_domEvent2['default'].listen(container, 'pointerdrag', selectionEventHandler, config));
  }

  if (chartConfig.link) {
    _domEvent2['default'].unlisten(chart.getFromEnv('chart-container'), 'mouseup mousedown', onXYCanvasClick);
    eventListeners.push(_domEvent2['default'].listen(chart.getFromEnv('chart-container'), 'mouseup mousedown', onXYCanvasClick, config));
  }
}

function regescape(text) {
  return text && text.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&');
}

function regReplaceEscape(text) {
  return text && text.replace(/\$/g, '$$$$');
}

/**
 * Checks if a value sent as argument is 'valid' as per valid input
 * standards.
 * @param {any} arg The value to be checked
 * @param {any} value is the default value returned.
 * @return {any} If 'arg' is valid returns 'arg'. Else returns 'value'.
 */
function getValidValue(arg, value) {
  return !arg && arg !== false && arg !== 0 ? value : arg;
}

/**
 *  Return the defColor if color is UNDEF other wise always returns the color even if color
 *  is a blank string
 *  @param {string} color The color string to be checked
 *  @param {string} defColor The default color string
 *  @return {string} A valid color
 */
function getDefinedColor(color, defColor) {
  return !color && color !== 0 && color !== BLANK ? defColor : color;
}

/**
 * Returns the first argument that is a 'valid' value or undefined.
 * @return {number|undefined} A valid value from the arguents passed into it or undefined.
 */
function pluck() {
  var arg, i, l;
  for (i = 0, l = arguments.length; i < l; i += 1) {
    arg = arguments[i];
    if (!arg && arg !== false && arg !== 0) {
      continue;
    }
    return arg;
  }
  return UNDEF;
}

/**
 * Returns x,y coordinate WRT chart and page of mouse or touch
 * @param {Object} chart container ele
 * @param {Object} event data
 */
function getMouseCoordinate(el, event, chart) {
  event = getEventCoordinate(getTouchEvent(event));
  var pageX = event.pageX,
      pageY = event.pageY,
      chartConfig = chart && chart.config,
      pos,
      winY = chartConfig && chartConfig.itemFixed ? win.pageYOffset || win.scrollY || doc.documentElement.scrollTop : 0,
      winX = chartConfig && chartConfig.itemFixed ? win.pageXOffset || win.scrollX || doc.documentElement.scrollLeft : 0;

  if (chartConfig && chartConfig.elScroll) {
    pos = chartConfig.posOb;
  } else {
    chartConfig && (chartConfig.elScroll = true);
    pos = getPosition(el, chart);
    chartConfig && (chartConfig.posOb = pos);
  }

  return {
    chartX: pageX - pos.left - winX,
    chartY: pageY - pos.top - winY,
    pageX: pageX,
    pageY: pageY
  };
}

/**
 * Handle data plot click event
 * @param {Object} chart
 * @param {Object} event data
 * @param Sting event name
 */
function plotEventHandler(chart, event, eventName, eventArguments) {
  event = event || {};
  var eventType = event.type,
      coordinate = getMouseCoordinate(chart.getFromEnv('chart-container'), event, chart),
      eventArgs = this.data('eventArgs') || eventArguments,
      args = (0, _libExtend2['default'])(coordinate, eventArgs),
      fireGroupEvent = chart.fireGroupEvent,
      id = this.data('groupId'),

  // eslint-disable-next-line no-unused-vars
  cancelHover = function cancelHover(c, a) {
    event.FusionChartsPreventEvent = true;
    // Hack for IE as the global event object gets overwritten
    // causing the FusionChartsPreventEvent to be UNDEF.
    if (isIE && a.toolText && lib.toolTip) {
      lib.toolTip.preventTooltip();
    }
  },
      minTimeForNextClick = 400,
      lastClickTimeStamp;

  if ('index' in args && !('dataIndex' in args)) {
    args.dataIndex = args.index;
  }
  if ('value' in args && !('dataValue' in args)) {
    args.dataValue = args.value;
  }
  eventName = pluck(eventName, 'dataplotclick').toLowerCase();
  // preventDefault in DataPlotRollOver
  if (eventName === 'dataplotrollover') {
    event.FusionChartsPreventEvent = false;
    if (fireGroupEvent) {
      /**
       * @event FusionCharts#dataplotRollOver
       *
       * @param {number} chartX - x-coordinate of the pointer relative to the chart.
       * @param {number} chartY - y-coordinate of the pointer relative to the chart.
       * @param {number} pageX - x-coordinate of the pointer relative to the page.
       * @param {number} pageY - y-coordinate of the pointer relative to the page.
       * @param {number} datasetIndex - The position of the dataset in order of its definition in source
       * data.
       * @param {string} datasetName - The `seriesName` of the dataset.
       * @param {number} dataIndex - The position of the data-plot in order of its definition in source
       * dataset.
       * @param {number} dataValue - The value of the data-plot that trigerred this event
       * @param {string} displayValue - The `displayValue` attribute that has been set for the data-plot.
       * @param {string} categoryLabel - The x-axis label that corresponds to the data-plot
       * @param {string} toolText - The tooltext that is displayed when hovered over the data-plot
       */
      fcGlobal.raiseEventGroup(id, eventName, args, chart.chartInstance, UNDEF, UNDEF, cancelHover);
    } else {
      (0, _eventApi.triggerEvent)(eventName, chart.chartInstance, args, UNDEF, UNDEF, cancelHover);
    }
  } else {
    if (fireGroupEvent && eventName !== 'dataplotclick') {
      /**
       * @event FusionCharts#dataplotRollOut
       *
       * @param {number} chartX - x-coordinate of the pointer relative to the chart.
       * @param {number} chartY - y-coordinate of the pointer relative to the chart.
       * @param {number} pageX - x-coordinate of the pointer relative to the page.
       * @param {number} pageY - y-coordinate of the pointer relative to the page.
       * @param {number} datasetIndex - The position of the dataset in order of its definition in source
       * data.
       * @param {string} datasetName - The `seriesName` of the dataset.
       * @param {number} dataIndex - The position of the data-plot in order of its definition in source
       * dataset.
       * @param {number} dataValue - The value of the data-plot that trigerred this event
       * @param {string} displayValue - The `displayValue` attribute that has been set for the data-plot.
       * @param {string} categoryLabel - The x-axis label that corresponds to the data-plot
       * @param {string} toolText - The tooltext that is displayed when hovered over the data-plot
       */
      fcGlobal.raiseEventGroup(id, eventName, args, chart.chartInstance);
    } else {
      /**
       * @event FusionCharts#dataplotClick
       *
       * @param {number} chartX - x-coordinate of the pointer relative to the chart.
       * @param {number} chartY - y-coordinate of the pointer relative to the chart.
       * @param {number} pageX - x-coordinate of the pointer relative to the page.
       * @param {number} pageY - y-coordinate of the pointer relative to the page.
       * @param {number} datasetIndex - The position of the dataset in order of its definition in source
       * data.
       * @param {string} datasetName - The `seriesName` of the dataset.
       * @param {number} dataIndex - The position of the data-plot in order of its definition in source
       * dataset.
       * @param {number} dataValue - The value of the data-plot that trigerred this event
       * @param {string} displayValue - The `displayValue` attribute that has been set for the data-plot.
       * @param {string} categoryLabel - The x-axis label that corresponds to the data-plot
       * @param {string} toolText - The tooltext that is displayed when hovered over the data-plot
       */
      (0, _eventApi.triggerEvent)(eventName, chart.chartInstance, args);
    }
  }
  if ((eventType === 'click' || eventType === 'mouseup' || eventType === 'touchend') && /click/i.test(eventName)) {
    if (supportsTouch && !supportsOnlyTouch) {
      //
      // In chrome of hybrid touch devices (touch + mouse), click is getting fired twice for single touch
      // To prevent cancle click within very sort time
      //
      lastClickTimeStamp = new Date().getTime();
      if (this.lastClickTimeStamp && lastClickTimeStamp - this.lastClickTimeStamp < minTimeForNextClick) {
        event && (event.originalEvent || event).preventDefault();
        return;
      }

      // store current time stamp
      this.lastClickTimeStamp = lastClickTimeStamp;
    }

    chart.getFromEnv('linkClickFN') && chart.getFromEnv('linkClickFN').call({
      link: args.link
    }, chart);
  }
}

function getLightColor(color, offsetPercent) {
  offsetPercent = offsetPercent < 0 || offsetPercent > 100 ? 100 : offsetPercent;
  offsetPercent = offsetPercent / 100;
  // Removing spaces and # form color
  color = color.replace(cleanColorCode, BLANK);
  var sourceclrRGB = parseInt(color, 16),

  // Converting color in R B G
  R = Math.floor(sourceclrRGB / 65536),
      G = Math.floor((sourceclrRGB - R * 65536) / 256),
      B = sourceclrRGB - R * 65536 - G * 256;
  return (COLOR_BLACK + (256 - (256 - R) * offsetPercent << 16 | 256 - (256 - G) * offsetPercent << 8 | 256 - (256 - B) * offsetPercent).toString(16)).slice(-6);
}

function dehashify(color) {
  return color && color.replace(/^#?([a-f0-9]+)/ig, '$1') || 'none';
}

/**
 * Returns the first argument that is a 'valid' value even blankstring.
 */
function getFirstDefinedValue() {
  var arg, i, l;
  for (i = 0, l = arguments.length; i < l; i += 1) {
    arg = arguments[i];
    if (!arg && arg !== false && arg !== 0 && arg != BLANK) {
      continue;
    }
    return arg;
  }
  return UNDEF;
}

/**
 * Returns the first number in the argument array.
 *
 * @note
 * The expression here is same as getValidValue with isNaN check
 * added to it.
 */
function pluckFontSize() {
  var arg, i, l;

  for (i = 0, l = arguments.length; i < l; i += 1) {
    arg = arguments[i];
    if (!arg && arg !== false && arg !== 0) {
      continue;
    } else if (isNaN(arg = Number(arg))) {
      continue;
    }
    return arg < 1 ? 1 : arg;
  }
  return 1;
}

function parsePointValue(value, abs) {
  /** @todo optimize further. */
  value = !value && value !== false && value !== 0 ? NaN : Number(value);
  return isNaN(value) ? null : abs ? mathAbs(value) : value;
}

function parseUnsafeString(str) {
  /** @todo use to string method if its not a string */
  if (typeof str === 'string') {
    return str.replace(breakPlaceholder, BREAKSTRING);
  } else {
    return BLANK;
  }
}

function getFirstColor(color, index) {
  color = color.split(COMMA)[index || 0];
  color = color.replace(stripWhitespace, BLANK);
  if (color == BLANK) {
    color = COLOR_BLACK;
  }
  return color.replace(dropHash, HASHSTRING);
}

function getDarkColor(color, offsetPercent) {
  offsetPercent = offsetPercent < 0 || offsetPercent > 100 ? 100 : offsetPercent;
  offsetPercent = offsetPercent / 100;
  // Removing spaces and # form color
  color = color.replace(cleanColorCode, BLANK);
  var sourceclrRGB = parseInt(color, 16),

  // Converting color in R B G
  R = Math.floor(sourceclrRGB / 65536),
      G = Math.floor((sourceclrRGB - R * 65536) / 256),
      B = sourceclrRGB - R * 65536 - G * 256;
  return (COLOR_BLACK + (R * offsetPercent << 16 | G * offsetPercent << 8 | B * offsetPercent).toString(16)).slice(-6);
}

function getColorCodeString(color, fillString) {
  var returnString = '',
      colorEntry,
      len,
      i = 0,
      fillArray = fillString.split(COMMA);
  for (len = fillArray.length; i < len; i += 1) {
    colorEntry = fillArray[i].split('-');
    if (colorEntry.length === 2) {
      if (colorEntry[0].indexOf('dark') !== '-1') {
        returnString += getLightColor(color, 100 - parseInt(colorEntry[1], 10)) + COMMA;
      } else {
        returnString += getDarkColor(color, 100 - parseInt(colorEntry[1], 10)) + COMMA;
      }
    } else {
      returnString += fillArray[i] + COMMA;
    }
  }
  return returnString.substring(0, returnString.length - 1);
}

function pluckColor(color) {
  if (!getValidValue(color)) {
    return UNDEF;
  }
  color = color.split(COMMA)[0];
  color = color.replace(stripWhitespace, BLANK);
  if (color == BLANK) {
    color = COLOR_BLACK;
  }
  return color.replace(dropHash, HASHSTRING);
}

function getFirstAlpha(alpha) {
  alpha = parseInt(alpha, 10);
  if (isNaN(alpha) || alpha > 100 || alpha < 0) {
    alpha = 100;
  }
  return alpha;
}

function getSentenceCase(name) {
  name = name || BLANK;
  return name.charAt(0).toUpperCase() + name.substr(1);
}

function getCrispValue(position, distance, borderthickness) {
  var normalizer = borderthickness % 2 / 2,
      newposition = mathRound(position + normalizer) - normalizer,
      newdistance = mathRound(position + distance + normalizer) - normalizer - newposition;
  return { position: newposition, distance: newdistance };
}

function trimString(str) {
  str = str.replace(/^\s\s*/, '');
  var ws = /\s/,
      i = str.length;

  while (ws.test(str.charAt(i -= 1))) {/* jshint noempty:false */}
  return str.slice(0, i + 1);
}

// helper for deltend
function clean(obj1, obj2) {
  var item;
  // check whether obj2 is an array
  // if array then iterate through it's index
  //* *** MOOTOOLS precution
  if (obj2 instanceof Array) {
    for (item = obj2.length - 1; item >= 0; item -= 1) {
      if (_typeof(obj2[item]) !== 'object') {
        if (obj2[item] === true && obj1 && obj1.splice) {
          obj1.splice(item, 1);
        }
      } else {
        if (objectToStrFn.call(obj2[item]) === objectToStrFn.call(obj1[item])) {
          clean(obj1[item], obj2[item]);
        }
      }
    }
  } else {
    for (item in obj2) {
      if (_typeof(obj2[item]) !== 'object') {
        if (obj2[item] === true && obj1 && obj1.splice) {
          obj1.splice(item, 1);
        }
      } else {
        if (objectToStrFn.call(obj2[item]) === objectToStrFn.call(obj1[item])) {
          clean(obj1[item], obj2[item]);
        }
      }
    }
  }
  return obj1;
}
// special function to perform deleted extend
function deltend(obj1, obj2) {
  // if any of the arguments is not object then return back
  if ((typeof obj1 === 'undefined' ? 'undefined' : _typeof(obj1)) !== 'object' || (typeof obj2 === 'undefined' ? 'undefined' : _typeof(obj2)) !== 'object') {
    return null;
  }
  clean(obj1, obj2);
  return obj1;
}

function imprint(obj1, obj2, ignoreNull) {
  var item;

  if ((typeof obj1 === 'undefined' ? 'undefined' : _typeof(obj1)) !== 'object' || obj1 === null) {
    obj1 = obj2;
    return obj2;
  }

  if ((typeof obj2 === 'undefined' ? 'undefined' : _typeof(obj2)) !== 'object' || obj2 === null) {
    return obj1;
  }

  for (item in obj2) {
    if (obj1[item] === UNDEF || !ignoreNull && obj1[item] === null) {
      obj1[item] = obj2[item];
    }
  }

  return obj1;
}

function getLinkedChartDataJSON(linkedDataId, FCDataObj) {
  var linkedDataJSON = {
    'chart': {}
  },
      index,
      FcJSON = FCDataObj;

  linkedDataId = linkedDataId.toLowerCase();
  if (FcJSON.linkeddata) {
    for (index = 0; index < FcJSON.linkeddata.length; index += 1) {
      if (FcJSON.linkeddata[index].id.toLowerCase() === linkedDataId) {
        linkedDataJSON = FcJSON.linkeddata[index].linkedchart || FcJSON.linkeddata[index].linkedmap;
      }
    }
  }
  return linkedDataJSON;
}

function executeJS(strLink, multipleParams) {
  var dashPos;
  // We remove blank spaces between 'j' and '-' if any
  strLink = strLink.replace(/^j\s*\-/i, 'j-');

  dashPos = strLink.indexOf('-', 2);
  // If no arguments, just call the link
  if (dashPos === -1) {
    limitedEvalParser(strLink.slice(2));
  } else {
    // There could be multiple parameters.
    // We just pass them as a single string to JS method.
    limitedEvalParser(strLink.substr(2, dashPos - 2).replace(/\s/g, BLANK), strLink.slice(dashPos + 1), multipleParams);
  }
}

function pseudoEval(executionString) {
  var
  // Splitting the function and its parameters
  split1 = executionString.split('('),

  // Getting all the parameters of the function
  params = split1.pop().split(')')[0],

  // Separating the parameters.
  param = params.split(','),
      len = param.length,
      i,
      fnStr,
      fn = split1[0];

  fnStr = 'j-' + fn;
  for (i = 0; i < len; i++) {
    // First replacing any blank spaces before the parameter, after the parameter, followed by the quotes.
    fnStr += '-' + param[i].replace(/\s*/, BLANK).replace(/\s*$/, BLANK).replace(/[\'|\"]/g, BLANK);
  }
  executeJS(fnStr, true);
}

function getLinkAction(dataObj, chartInstance) {
  var secureLink = function secureLink(link) {
    return link;
  };

  return function (chart) {
    var chartAttrs = dataObj.chart || dataObj.map || {},
        unescapeLinks = pluckNumber(chartAttrs.unescapelinks, 1),
        clickURLOverridesPlotLinks = pluckNumber(chartAttrs.clickurloverridesplotlinks, 0),
        clickedEntity = this.entity || UNDEF,
        clickedEntityBox = this.entityBox || UNDEF,
        pointLink = getFirstValue(this.link, BLANK),
        chartLink = chart.config && chart.config.link || BLANK,
        strLink = clickURLOverridesPlotLinks ? pluck(chartLink, pointLink) : pluck(pointLink, chartLink),
        originalLink = strLink,
        dashPos,
        frameDetails,
        commaPos,
        linkURL,
        delimiter,
        linkType,
        linkedDataId,
        linkedData,
        alias,
        firstBreak;
    // We continue only if the link is not empty
    if (strLink !== UNDEF) {
      // first we decode the link
      // And we trim the link
      if (unescapeLinks) {
        strLink = win.decodeURIComponent ? win.decodeURIComponent(strLink) : win.unescape(strLink);
      }

      strLink = strLink.replace(/^\s+/, BLANK).replace(/\s+$/, BLANK);

      if (strLink.search(/^[a-z]*\s*[\-\:]\s*/i) !== -1) {
        delimiter = strLink.split(/\s*[\-\:]\s*/)[0].toLowerCase();
        firstBreak = delimiter.length;
      }

      // Now based on what the first character in the link is (N, F, P, S, J)
      // And (NEWCHART, JAVASCRIPT:)
      // we invoke the link.
      setTimeout(function () {
        var popupWin;

        switch (delimiter) {
          case 'j':
            executeJS(strLink);
            break;

          case 'javascript':
            // remove 'javascript:' prefix and evaluate expression.
            pseudoEval(strLink.replace(/^javascript\s*\:/i, BLANK));
            break;

          case 'n':
            strLink.replace(/^n\s*\-/i, 'n-');
            win.open(secureLink(strLink.slice(2), unescapeLinks));
            break;

          case 'f':
            strLink = strLink.replace(/^f\s*\-/i, 'f-');

            // strLink.slice(dashPos+1) indicates arguments if any
            // strLink.substr(2, dashPos-2) indicates link
            dashPos = strLink.indexOf('-', 2);
            // If no arguments, just call the link
            if (dashPos !== -1) {
              frameDetails = strLink.substr(2, dashPos - 2);
              if (frameDetails && win.frames[frameDetails]) {
                win.frames[frameDetails].location = secureLink(strLink.slice(dashPos + 1), unescapeLinks);
              } else {
                win.open(secureLink(strLink.slice(dashPos + 1), unescapeLinks), frameDetails);
              }
            } else {
              win.open(secureLink(strLink.slice(2), unescapeLinks));
            }
            break;

          case 'p':
            strLink = strLink.replace(/p\s*\-/i, 'p-');
            dashPos = strLink.indexOf('-', 2);
            commaPos = strLink.indexOf(COMMA, 2);
            if (dashPos === -1) {
              dashPos = 1;
            }

            linkURL = secureLink(strLink.slice(dashPos + 1), unescapeLinks);
            popupWin = win.open(linkURL, strLink.substr(2, commaPos - 2), strLink.substr(commaPos + 1, dashPos - commaPos - 1));

            popupWin && popupWin.focus();
            break;

          case 'newchart':
          case 'newmap':
            // Linked chart. if alias found
            if (strLink.charAt(firstBreak) === ':') {
              // find next '-'
              dashPos = strLink.indexOf('-', firstBreak + 1);
              alias = strLink.substring(firstBreak + 1, dashPos);
              firstBreak = dashPos;
            }

            // Find the second dash position
            dashPos = strLink.indexOf('-', firstBreak + 1);

            // Figure out whether the sub-linked chart is xml or url
            linkType = strLink.substring(firstBreak + 1, dashPos).toLowerCase();

            switch (linkType) {
              case 'xmlurl':
              case 'jsonurl':
                linkedData = strLink.substring(dashPos + 1, strLink.length);
                break;
              case 'xml':
              case 'json':
                // Extract linked data identifier
                linkedDataId = strLink.substring(dashPos + 1, strLink.length);
                // Get the data for the linked chart
                linkedData = getLinkedChartDataJSON(linkedDataId, dataObj);
                // If linkedData is empty string, it means
                // data identifier or linked data was not found.
                linkType = 'json';
                break;
            }
            /**
             * Clicking the data plot of a parent chart opens the linked items associated with it.
             * `LinkedChartInvoked` event is triggered after the
             * {@link FusionCharts#event:linkedItemOpened}event.
             *
             * A parent chart may have more than one linked chart associated with it.
             * The child linked charts may have linked charts of their own. Clicking on the data
             * plot items of any of these child linked charts which have other linked charts
             * associated with them fires the `linkedChartInvoked` event.
             *
             * @event FusionCharts#linkedChartInvoked
             * @group linked-charts
             * @private
             *
             * @param {string} alias It is the type of the chart invoked.For example, a data plot
             * item in a column2d chart might invoke another column2d chart or a pie chart.
             * @param {string} linkType Indicates whether the linked data is in JSON or XML format.
             * @param {Object} data  Contains the data related to the linkedchart to be opened.
             */
            (0, _eventApi.triggerEvent)('linkedChartInvoked', chartInstance, {
              alias: alias,
              linkType: linkType.toUpperCase(),
              data: linkedData,
              clickedEntity: clickedEntity,
              clickedEntityBox: clickedEntityBox
            });
            break;

          default:
            win.location.href = secureLink(strLink, unescapeLinks);
            break;
        }
        /**
         * FusionCharts  allows you to configure the data plot items to respond to user's click
         * interaction by specifying the `link` attribute on the data item. You can configure it to
         * perform various actions on click such as:
         *
         * - open an url
         * - call a JavaScript function
         * - drill-down to a new chart.
         *
         * Other than data-plots, links can be applied to the entire chart using the  attribute
         * `clickUrl`, on chart external-logo and a number of other  objects.
         *
         * @event FusionCharts#linkClicked
         * @group chart
         *
         * @param {string} linkProvided - This will contain the link which contains the newchart-xml-id
         * of the XML of the linked chart item
         * @param {string} linkInvoked - This will contain the link which contains the newchart-xml-id
         * of the XML of the linked chart item
         * @param {Object} linkAction - Indicates what the link click will do. In case of opening a new
         * chart it is 'newchart'.
         */
        (0, _eventApi.triggerEvent)('linkClicked', chartInstance, {
          linkProvided: originalLink,
          linkInvoked: strLink,
          linkAction: delimiter && delimiter.toLowerCase()
        });
      }, 0);
    }
  };
}

/**
 * getImageURL determine whether the argument string is an image URL or simply a string
 * and returns an object having two properties image: boolean and string: string
 * if the string begins with "i-" then the string is an URL to image and also if the
 * string starts with "\\i-" it assumes its a string which starts with "i-" and so on
 * if the string starts with "\\\\i-" it return the string starts with "\i-"
 *
 * @param  str The string to image url or a simple string.
 * @return Object containing the boolean value image and string containing string.
 */
function getImageURL(str) {
  var strObj = {
    image: false
  };
  if (str !== UNDEF) {
    // Remove the white space at the beginning and end of the string.
    str = str.replace(/^\s+/, BLANK).replace(/\s+$/, BLANK);
    // Check whether the string start with "i-"
    if (/^i\s*[\-]\s*/i.test(str)) {
      // Remove "i-" at the beginning of the string and make image as true
      strObj.image = true;
      strObj.string = str.replace(/^i\s*[\-]\s*/i, BLANK);
    } else {
      // Remove single "\" at the beginning
      strObj.string = str.replace(/^\\/, BLANK);
    }
  }
  return strObj;
}

// GRAPHICS FUNCTION
function getAlpha(alpha, multiplyer) {
  alpha = Number(alpha);
  alpha = isNaN(alpha) ? 100 : alpha;
  if (multiplyer !== UNDEF) {
    alpha = alpha * multiplyer / 100;
  }
  return alpha % 101;
}

function getPointColor(color, alpha) {
  var colorObj, innerColor, outerColor;

  color = getFirstColor(color);
  alpha = getFirstAlpha(alpha);
  innerColor = getLightColor(color, 70);
  outerColor = getDarkColor(color, 50);
  colorObj = {
    FCcolor: {
      gradientUnits: 'objectBoundingBox',
      cx: 0.4,
      cy: 0.4,
      r: '100%',
      color: innerColor + COMMASTRING + outerColor,
      alpha: alpha + COMMASTRING + alpha,
      ratio: BGRATIOSTRING,
      radialGradient: true
    }
  };

  return colorObj;
}

function parseAlpha(alpha, length, multiplyer) {
  var alphaArr = alpha.split(COMMA),
      x;
  if (multiplyer !== UNDEF) {
    multiplyer = pluckNumber(multiplyer.split(COMMA)[0]);
  }
  alphaArr[0] = getAlpha(alphaArr[0], multiplyer);
  for (x = 1; x < length; x += 1) {
    alphaArr[x] = alphaArr[0] * getAlpha(alphaArr[x], multiplyer) / 100;
  }
  return alphaArr.join(COMMA);
}

// reduce gradient color take only first color
// converts color to compatable color format
//* *** rgba must be rgbs(r,g,b,a) format
/** @todo have to optimize
 Deprecated and may need reduction of logic. */
function convertColor(color, alpha, rgba) {
  var R = 0,
      G = 0,
      B = 0,
      colorStr,
      tempArr;

  if (rgba && rgba.match(startsRGBA)) {
    tempArr = rgba.split(COMMA);
    R = tempArr[0].slice(tempArr[0].indexOf('(') + 1);
    G = tempArr[1];
    B = tempArr[2];
    if (!alpha && alpha !== 0) {
      alpha = parseInt(tempArr[3].slice(0, tempArr[3].indexOf(')')) * 100, 10);
    }
  }
  if (color) {
    if (color.match(startsRGBA)) {
      tempArr = color.split(COMMA);
      R = tempArr[0].slice(tempArr[0].indexOf('(') + 1);
      G = tempArr[1];
      B = tempArr[2];
    } else {
      colorStr = color.replace(cleanColorCode, BLANK).split(COMMA)[0];
      switch (colorStr.length) {
        case 3:
          colorStr = colorStr.charAt(0) + colorStr.charAt(0) + colorStr.charAt(1) + colorStr.charAt(1) + colorStr.charAt(2) + colorStr.charAt(2);
          break;
        case 6:
          break;
        default:
          colorStr = (colorStr + COLOR_WHITE).slice(0, 6);
          break;
      }
      R = parseInt(colorStr.slice(0, 2), 16);
      G = parseInt(colorStr.slice(2, 4), 16);
      B = parseInt(colorStr.slice(4, 6), 16);
    }
  }

  if (!alpha && alpha !== 0) {
    alpha = 100;
  }
  if (typeof alpha === 'string') {
    alpha = alpha.split(COMMA)[0];
  }
  alpha = parseInt(alpha, 10) / 100;
  return 'rgba(' + R + COMMA + G + COMMA + B + COMMA + alpha + ')';
}

/**
 * hexToRgb method convert one hexColor string to HSB color
 * values.And return the value in an array, where the index value
 * containes Hue, saturaion and Brightness value of the provided
 * HexColor respectively.
 *
 * @param  sourceColor The hexadecimal Color string value.
 * @return  Array The HSB color values in respective order.
 */
function hexToRgb(sourceColor) {
  var sourceClrRGB = parseInt(sourceColor, 16),
      r = Math.floor(sourceClrRGB / 65536),
      g = Math.floor((sourceClrRGB - r * 65536) / 256),
      b = Math.floor(sourceClrRGB - r * 65536 - g * 256);

  return [r, g, b];
}

// Returns a color code including # before it
function parseColor(color) {
  return color.replace(cleanColorCode, BLANK).replace(dropHash, HASHSTRING);
}

// Returns a valid color or UNDEF
function getValidColor(color) {
  return validhexcolor.test(parseColor(color)) && color;
}

function getCubePathOutline(cubePathComand) {
  var w = cubePathComand[2] || 0,
      zw = cubePathComand[4] || 0,
      zh = cubePathComand[5] || 0;

  return [M, cubePathComand[0] || 0, cubePathComand[1] || 0, l, zw, -zh, w, 0, 0, cubePathComand[3] || 0, -zw, zh, -w, 0, Z];
}
/**
 * HSBtoRGB methods takes an array of HSB color values and convert them
 * RGB color values and return an array conatining the Red,Green and
 * Blue color value of the provided HSB color.
 *
 * @param   hsb Array The array of Hue,Saturation and Brightness property
 * of a color.
 *
 * @return  Array The Array of RGB color value of the specified color.
 */
function HSBtoRGB(hsb) {
  var h = hsb[0],
      s = hsb[1],
      v = hsb[2],
      r = 0,
      g = 0,
      b = 0,
      rgb = [],
      tempS = s / 100,
      tempV = v / 100,
      hi = Math.floor(h / 60) % 6,
      f = h / 60 - Math.floor(h / 60),
      p = tempV * (1 - tempS),
      q = tempV * (1 - f * tempS),
      t = tempV * (1 - (1 - f) * tempS);

  switch (hi) {
    case 0:
      r = tempV;
      g = t;
      b = p;
      break;
    case 1:
      r = q;
      g = tempV;
      b = p;
      break;
    case 2:
      r = p;
      g = tempV;
      b = t;
      break;
    case 3:
      r = p;
      g = q;
      b = tempV;
      break;
    case 4:
      r = t;
      g = p;
      b = tempV;
      break;
    case 5:
      r = tempV;
      g = p;
      b = q;
      break;
  }

  rgb = [mathRound(r * 255), mathRound(g * 255), mathRound(b * 255)];
  return rgb;
}

/**
 * RGBtoHSB methods takes an array of RGB color values and convert them
 * HSB color values and return an array conatining the Hue,Saturation and
 * Brightness of the specified RGB color.
 *
 * @param   rgb Array The array of RGB color values respective.The 0 index contains
 * Red color value, 1 index contains the Green color value and the
 * 2nd or the last index conatins the blue color value.
 *
 * @return  Array Color value array containing the Hue, Saturation and brightness of
 * The provided Color.
 */
function RGBtoHSB(rgb) {
  var r = rgb[0],
      g = rgb[1],
      b = rgb[2],
      max = Math.max(Math.max(r, g), b),
      min = Math.min(Math.min(r, g), b),
      hue = 0,
      saturation = 0;

  // get Hue
  if (max == min) {
    hue = 0;
  } else if (max == r) {
    hue = (60 * (g - b) / (max - min) + 360) % 360;
  } else if (max == g) {
    hue = 60 * (b - r) / (max - min) + 120;
  } else if (max == b) {
    hue = 60 * (r - g) / (max - min) + 240;
  }

  // get Saturation
  if (max === 0) {
    saturation = 0;
  } else {
    saturation = (max - min) / max;
  }

  return [mathRound(hue), mathRound(saturation * 100), mathRound(max / 255 * 100)];
}

/**
 * RGBtoHex methods takes an array of RGB color values and convert them to
 * a hexadecimal color value.And return the string.
 *
 * @param   rgb Array The array of RGB color values respective.The 0 index contains
 * Red color value, 1 index contains the Green color value and the
 * 2nd or the last index conatins the blue color value.
 *
 * @return  String The hexadecimal color string of the provided RGB value.
 */
function RGBtoHex(rgb) {
  return (COLOR_BLACK + (rgb[0] << 16 | rgb[1] << 8 | rgb[2]).toString(16)).slice(-6);
}

/**
 * RGBtoHex methods takes a string of RGB / RGBA color values and convert them to
 * a hexadecimal color value.And return the string.
 *
 * @param  rawRgb string of RGB / RGBA color values
 *
 * @return  String The hexadecimal color string of the provided RGB value.
 */
function rawRGBtoHEX(rawRgb) {
  var arr = rawRgb.match(/[\d+]+/g),
      rgb;

  rgb = arr.splice(0, 3);
  return (COLOR_BLACK + (rgb[0] << 16 | rgb[1] << 8 | rgb[2]).toString(16)).slice(-6);
}

// map FusionCharts anchor sides to HC anchor symbol
// anchorside > 4 will show the down triangle
function mapSymbolName(num, isSpoke) {
  var x = symbolStr.circle;
  num = parsePointValue(num);
  if (num >= 3) {
    x = (isSpoke ? symbolStr.spoke : symbolStr.poly) + num;
  }
  return x;
}

// helper fnction for draw3Drect
function getAngle(width, height, type) {
  var angle = Math.atan(height / width) * 180 / Math.PI;
  if (type == 2) {
    angle = 180 - angle;
  } else if (type == 3) {
    angle += 180;
  } else if (type == 4) {
    angle = 360 - angle;
  }
  return angle;
}

/** @todo send the color and alpha as rray so that they don't need split */
// this function create the column color depending upon the configuration
function getColumnColor(setColor, setAlpha, ratio, angle, isRoundEdges, bdColor, bdAlpha, isBar, is3d) {
  var bgColor, borderColor, colorArr, alphaArr, bdColorArr, color, alpha, bdAlphaArr;
  colorArr = setColor.split(COMMA);
  alphaArr = setAlpha.split(COMMA);
  bdColorArr = bdColor.split(COMMA);
  bdAlphaArr = bdAlpha.split(COMMA);
  // remove extra comma if there at the end.
  setColor = setColor.replace(/\s/g, BLANK).replace(/\,$/, BLANK);
  if (is3d) {
    bgColor = {
      FCcolor: {
        color: colorArr[0],
        alpha: alphaArr[0]
      }
    };
  } else if (isRoundEdges) {
    color = colorArr[0];
    alpha = alphaArr[0];
    bgColor = {
      FCcolor: {
        // [ColorExt.getDarkColor(this.color, 0.75),
        // ColorExt.getLightColor(this.color, 0.25),
        // ColorExt.getDarkColor(this.color, 0.8),
        // ColorExt.getLightColor(this.color, 0.65),
        // ColorExt.getDarkColor(this.color, 0.8)]
        color: getDarkColor(color, 75) + COMMA + getLightColor(color, 10) + COMMA + getDarkColor(color, 90) + COMMA + getLightColor(color, 55) + COMMA + getDarkColor(color, 80),
        alpha: alpha + COMMA + alpha + COMMA + alpha + COMMA + alpha + COMMA + alpha,
        ratio: '0,11,14,57,18',
        angle: isBar ? '90' : '0'
      }
    };
    bdColorArr = [getDarkColor(color, 70)];
  } else {
    setAlpha = parseAlpha(setAlpha, colorArr.length);
    bgColor = {
      FCcolor: {
        color: setColor,
        alpha: setAlpha,
        ratio: ratio,
        angle: isBar ? -angle : angle
      }
    };
  }
  borderColor = {
    FCcolor: {
      color: bdColorArr[0],
      alpha: bdAlphaArr[0]
    }
  };

  return [bgColor, borderColor];
}

function toPrecision(obj, value) {
  var tenPow = mathPow(10, value);
  return mathRound(obj * tenPow) / tenPow;
}

// Function to convert FC dash style to HC dash style
function getDashStyle(len, gap, apply) {
  return apply || apply === UNDEF ? [len, gap] : DASH_DEF;
}

/**
 * Sets the line height of a style object based upon its font-size. The present method does not touch DOM and
 * hence not accurate.
 *
 * @param {Object} styleObj
 * @param {number=} [baseFontSize]
 * @return {string} The line height calculated from the style object.
 */
function setLineHeight(styleObj, baseFontSize) {
  if ((typeof styleObj === 'undefined' ? 'undefined' : _typeof(styleObj)) !== 'object') {
    return BLANK;
  }

  // When the font size is specified recalculate line height
  if (styleObj.fontSize || styleObj['font-size']) {
    // Detect line height from font-size
    if (!styleObj.fontSize && styleObj['font-size']) {
      styleObj.fontSize = styleObj['font-size'];
      delete styleObj['font-size'];
    }
    styleObj.lineHeight = (parseFloat(styleObj.fontSize) || baseFontSize || 10) * getLineHeightFactor() + 'px';

    // Delete hyphen notation line height
    delete styleObj['line-height'];
  }
  // In case the hyphen notation is used, move it to camelCase notation
  if (!styleObj.lineHeight && styleObj['line-height']) {
    styleObj.lineHeight = styleObj['line-height'];
    delete styleObj['line-height'];
  }

  return styleObj.lineHeight;
}

function parsexAxisStyles(data, catObj, FCChartObj, style, dataColor) {
  // data label border color
  var fontBdrColor = getFirstValue(data.labelbordercolor, catObj.bordercolor, FCChartObj.labelbordercolor, BLANK),
      bgColor = pluck(data.labelbgcolor, catObj.bgcolor, FCChartObj.labelbgcolor),
      borderThickness = pluckNumber(data.labelborderthickness, catObj.borderthickness, FCChartObj.labelborderthickness, 1),
      defColor = pluckNumber(FCChartObj.usedataplotcolorforlabels, 0) ? dataColor || style.color : style.color,
      styleObj;

  fontBdrColor = fontBdrColor ? convertColor(fontBdrColor, pluckNumber(data.labelborderalpha, catObj.borderalpha, FCChartObj.labelborderalpha, data.labelalpha, catObj.alpha, FCChartObj.labelalpha, 100)) : BLANK;

  styleObj = {
    fontFamily: pluck(data.labelfont, catObj.font, FCChartObj.labelfont, style.fontFamily),
    fontSize: pluck(data.labelfontsize, catObj.fontsize, FCChartObj.labelfontsize, parseInt(style.fontSize, 10)) + PXSTRING,
    color: convertColor(pluck(data.labelfontcolor, catObj.fontcolor, FCChartObj.labelfontcolor, defColor), pluckNumber(data.labelfontalpha, catObj.fontalpha, FCChartObj.labelfontalpha, data.labelalpha, catObj.alpha, FCChartObj.labelalpha, 100)),
    fontWeight: pluckNumber(data.labelfontbold, catObj.fontbold, FCChartObj.labelfontbold) ? 'bold' : 'normal',
    fontStyle: pluckNumber(data.labelfontitalic, catObj.fontitalic, FCChartObj.labelfontitalic) ? 'italic' : 'normal',
    // Set border as empty string when not required,
    // since IE will stop js execution if it is UNDEF or null.
    border: fontBdrColor || bgColor ? borderThickness + 'px solid' : BLANK,
    borderColor: fontBdrColor,
    borderThickness: borderThickness,
    borderPadding: pluckNumber(data.labelborderpadding, catObj.borderpadding, FCChartObj.labelborderpadding, 2),
    borderRadius: pluckNumber(data.labelborderradius, catObj.borderradius, FCChartObj.labelborderradius, 0),
    backgroundColor: bgColor ? convertColor(bgColor, pluckNumber(data.labelbgalpha, catObj.bgalpha, FCChartObj.labelbgalpha, data.labelalpha, catObj.alpha, FCChartObj.labelalpha, 100)) : BLANK,
    borderDash: pluckNumber(data.labelborderdashed, catObj.borderdashed, FCChartObj.labelborderdashed, 0) ? getDashStyle(pluckNumber(data.labelborderdashlen, catObj.borderdashlen, FCChartObj.labelborderdashlen, 4), pluckNumber(data.labelborderdashgap, catObj.borderdashgap, FCChartObj.labelborderdashgap, 2)) : DASH_DEF
  };

  // set the line height
  styleObj.lineHeight = setLineHeight(styleObj);

  return styleObj;
}

/**
 * BG Image align attribute managing function
 */
function setImageDisplayMode(bgImageDisplayMode, bgImageVAlign, bgImageHAlign, bgImageScale, chartBorderWidth, chartWidth, chartHeight, imageEle) {
  var imageWidth = imageEle.width * (bgImageScale / 100),
      imageHeight = imageEle.height * (bgImageScale / 100),
      alignImage = {},
      imgAspectRatio,
      cAspectRatio,
      scaleFactor,
      xCount,
      yCount,

  // Consider the borderthickness and find out chart width and height
  cWidth = chartWidth - chartBorderWidth * 2,
      cHeight = chartHeight - chartBorderWidth * 2,
      alignObj,

  // Function to align the image
  // returns x y position of the image
  getImageAlignment = function getImageAlignment(bgImageVAlign, bgImageHAlign, imageWidth, imageHeight, chartWidth, chartHeight) {
    var alignObj = {};
    switch (bgImageVAlign) {
      case 'top':
        alignObj.y = chartBorderWidth;
        break;
      case 'bottom':
        alignObj.y = chartHeight - imageHeight - chartBorderWidth;
        break;
      case 'middle':
        alignObj.y = (chartHeight - imageHeight) / 2;
        break;
    }

    switch (bgImageHAlign) {
      case 'left':
        alignObj.x = chartBorderWidth;
        break;
      case 'right':
        alignObj.x = chartWidth - imageWidth - chartBorderWidth;
        break;
      case 'middle':
        alignObj.x = (chartWidth - imageWidth) / 2;
        break;
    }
    return alignObj;
  };

  switch (bgImageDisplayMode) {
    case 'center':
      alignImage.width = imageWidth;
      alignImage.height = imageHeight;
      alignImage.y = chartHeight / 2 - imageHeight / 2;
      alignImage.x = chartWidth / 2 - imageWidth / 2;
      break;

    case 'stretch':
      // Stretch Display Mode
      alignImage.width = chartWidth - chartBorderWidth * 2;
      alignImage.height = chartHeight - chartBorderWidth * 2;
      alignImage.y = chartBorderWidth;
      alignImage.x = chartBorderWidth;
      break;

    case 'tile':
      // Tile Display Mode
      alignImage.width = imageWidth;
      alignImage.height = imageHeight;
      alignImage.tileInfo = {};
      alignImage.tileInfo.xCount = xCount = Math.ceil(cWidth / imageWidth);
      alignImage.tileInfo.yCount = yCount = Math.ceil(cHeight / imageHeight);

      alignObj = getImageAlignment(bgImageVAlign, bgImageHAlign, imageWidth * xCount, imageHeight * yCount, chartWidth, chartHeight);

      alignImage.y = alignObj.y;
      alignImage.x = alignObj.x;
      break;

    case 'fit':
      // Fit Display Mode

      // Original image's aspect ratio.
      imgAspectRatio = imageWidth / imageHeight;
      // Chart's background aspect ratio
      cAspectRatio = cWidth / cHeight;
      scaleFactor = imgAspectRatio > cAspectRatio ? cWidth / imageWidth : cHeight / imageHeight;

      alignImage.width = imageWidth * scaleFactor;
      alignImage.height = imageHeight * scaleFactor;

      alignObj = getImageAlignment(bgImageVAlign, bgImageHAlign, alignImage.width, alignImage.height, chartWidth, chartHeight);

      alignImage.y = alignObj.y;
      alignImage.x = alignObj.x;
      break;

    case 'fill':
      // Fill Display Mode

      // Original image's aspect ratio.
      imgAspectRatio = imageWidth / imageHeight;
      // Chart's background aspect ratio
      cAspectRatio = cWidth / cHeight;
      // Find out scale factor
      scaleFactor = imgAspectRatio > cAspectRatio ? cHeight / imageHeight : cWidth / imageWidth;

      alignImage.width = imageWidth * scaleFactor;
      alignImage.height = imageHeight * scaleFactor;

      alignObj = getImageAlignment(bgImageVAlign, bgImageHAlign, alignImage.width, alignImage.height, chartWidth, chartHeight);

      alignImage.y = alignObj.y;
      alignImage.x = alignObj.x;

      break;

    default:
      // None
      // In none mode image only need alignment.
      alignObj = getImageAlignment(bgImageVAlign, bgImageHAlign, imageWidth, imageHeight, chartWidth, chartHeight);

      alignImage.width = imageWidth;
      alignImage.height = imageHeight;
      alignImage.y = alignObj.y;
      alignImage.x = alignObj.x;
  }

  return alignImage;
}

/** *************  Image Export Function Start  ******************/

/** *************  Image Export Function End  ********************/

function componentDispose() {
  var fcObj = this,
      childComponents,
      item,
      itemName,
      length,
      i,
      graphicComponents,
      graphicObj,
      graphics,
      group,
      groupEle,
      followerEle,
      nthItem;

  // childGraphics;
  if (fcObj && fcObj !== win) {
    // solve circular component chain
    fcObj.disposing = true;

    // delete the child compenents
    childComponents = fcObj.components;
    // if componenet exist dispose them first
    if (childComponents) {
      for (itemName in childComponents) {
        item = childComponents[itemName];
        // if component is an array, dispose all array elements
        if (item instanceof Array) {
          length = item.length;
          for (i = 0; i < length; i++) {
            nthItem = item[i];
            if (nthItem && !fcObj.disposing) {
              if (nthItem.dispose) {
                nthItem.dispose();
              } else {
                componentDispose.call(nthItem);
              }
            }
          }
        } else {
          if (item && !item.disposing) {
            if (item.dispose) {
              item.dispose();
            } else {
              componentDispose.call(item);
            }
          }
        }
      }
    }

    // temp code
    graphicComponents = fcObj.graphics;
    for (graphics in graphicComponents) {
      graphicObj = graphicComponents[graphics];
      if (graphicObj) {
        if (graphicObj.hide) {
          graphicObj.hide();
          if (graphicObj.followers && graphicObj.followers[0]) {
            followerEle = graphicObj.followers[0].el;
            followerEle && followerEle.hide && followerEle.hide();
          }
        } else {
          for (group in graphicObj) {
            groupEle = graphicObj[group];
            groupEle.hide && groupEle.hide();
          }
        }
      }
    }

    // delete the reamaining things
    for (itemName in fcObj) {
      delete fcObj[itemName];
    }
  }
}

function componentSortFn(a, b) {
  return (a.pIndex || 0) - (b.pIndex || 0);
}

function componentConfigurer(parent) {
  var components,
      component,
      tempComponentArr = [],
      i,
      l,
      key,
      customConfigFn,
      executedCustomConfigList = {};
  parent = parent || this;
  components = parent.components;
  // create a temp array of components to make a ordered list
  for (key in components) {
    component = components[key];
    // It is an array of component
    if (component instanceof Array) {
      l = component.length;
      for (i = 0; i < l; i += 1) {
        tempComponentArr.push(component[i]);
      }
    } else {
      tempComponentArr.push(component);
    }
  }
  // sort teh temp array as per priority / order
  tempComponentArr.sort(componentSortFn);
  // configure components as per their order
  l = tempComponentArr.length;
  for (i = 0; i < l; i += 1) {
    component = tempComponentArr[i];
    customConfigFn = component.customConfigFn;
    // todo - remove this check.
    if (customConfigFn === null) {
      continue;
    }
    if (customConfigFn && parent[customConfigFn]) {
      if (!executedCustomConfigList[customConfigFn]) {
        parent[customConfigFn]();
        executedCustomConfigList[customConfigFn] = true;
      }
    } else if (component.configure) {
      component.configure();
    }
  }
}

function isInterActiveEvt(name) {
  return !!interActiveEvtList[name];
}

function addInterActiveEvtName(name) {
  if (name && name.toLowerCase) {
    interActiveEvtList[name.toLowerCase()] = true;
  }
}

function comparatorAsc(a, b) {
  return a - b;
}

function comparatorDesc(a, b) {
  return b - a;
}

function getComparatorFN(isASC, key) {
  if (isASC) {
    return key ? function (a, b) {
      return a[key] - b[key];
    } : comparatorAsc;
  } else {
    return key ? function (a, b) {
      return b[key] - a[key];
    } : comparatorDesc;
  }
}

lib.lineHeightFactor = 1.2;
/**
 * Sets the internal line-height calculation factor
 * @param {number} factor
 * @memberOf FusionCharts~
 * @private
 */
function setLineHeightFactor(factor) {
  factor = toFloat(factor);

  if (!factor || factor < 0) {
    return;
  }
  lib.lineHeightFactor = factor;
}

function getLineHeightFactor() {
  return lib.lineHeightFactor;
}

/*
 * Utility method that sorts an object array and keeping the order of equal items.
 * ECMA script standard does not specify the behavior when items are equal.
 */
function stableSort(arr, sortFunction) {
  var length = arr.length,
      i;

  // Add index to each item
  for (i = 0; i < length; i++) {
    arr[i].ssI = i; // stable sort index
  }

  arr.sort(function (a, b) {
    var sortValue = sortFunction(a, b);
    return sortValue === 0 ? a.ssI - b.ssI : sortValue;
  });

  // Remove index from items
  for (i = 0; i < length; i++) {
    delete arr[i].ssI; // stable sort index
  }
}

function setVCanvas(iapi, datasetObj, datasetJSON) {
  var conf,
      parentYAxis,
      vCanvasArr = iapi.components.canvas.components.vCanvasArr;

  conf = datasetObj.config;
  if (iapi.isDual) {
    conf.parentYAxis = parentYAxis = pluck(datasetJSON.parentyaxis && datasetJSON.parentyaxis.toLowerCase(), 'p') === 's' ? 1 : 0;
  } else {
    conf.parentYAxis = parentYAxis = 0;
  }
  datasetObj.attachVcanvas(vCanvasArr[parentYAxis]);
  // datasetObj.setLinkedItem('vcanvas', vCanvasArr[parentYAxis]);
  // datasetObj.listenToVcanvas && datasetObj.listenToVcanvas();
  // conf.virtualCanvas = vCanvasArr[parentYAxis];

  // if (storeDS) {
  //   vCanvasArr[parentYAxis].addDataset(datasetObj);
  // }
}

/**
 * This method creates / update existing all childs of given type
 * If existing no of components are higher than what required now, then it will remove the extra components
 * Similarly will create new instance if required extra
 * @param { component } parent The parent on which these children will be created
 * @param  { Class } ChildClass The class definition of the child that will be created
 * @param  { string } childType type name by which the children will be attached to the parent
 * @param  { number } [count=1] How many children needs to be created
 * @param  { Array } [configArr=undefined] Array of configration objects of all these children
 */
var componentFactory = function componentFactory(parent, ChildClass, childType) {
  var count = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  var configArr = arguments[4];

  if (parent && ChildClass && childType) {
    var typedChildren = parent.getChildren(childType) || [],
        i = void 0,
        ll = void 0,
        childInstance = void 0;
    for (i = 0; i < count; i += 1) {
      // Update existing one if availabel elese create new one
      if (typedChildren && typedChildren[i] && !typedChildren[i].getState('removed')) {
        childInstance = typedChildren[i];
      } else {
        childInstance = new ChildClass();
        parent.attachChild(childInstance, childType);
        // TODO: remove init from all component. If there is something that needs to be called for once, add that in constructor
        if (childInstance.init) {
          try {
            childInstance.init();
            throw new Error('Error: remove init from all components.' + ' If there is something that needs to be called during initialization, add that in constructor method');
          } catch (e) {
            // eslint-disable-next-line no-console
            console && console.warn && console.warn(e);
          }
        }
      }
      if (configArr && configArr.length > i && childInstance.configure) {
        childInstance.configure(configArr[i]);
      }
    }
    // Remove all extra components
    ll = typedChildren && typedChildren.length;
    if (i < ll) {
      for (; i < ll; i += 1) {
        typedChildren[i] && typedChildren[i].remove && typedChildren[i].remove();
      }
    }
  }
},

/**
 * This method creates / update existing all datasets of given type
 * If existing no of components are higher than what required now, then it will remove the extra components
 * Similarly will create new instance if required extra
 * @param { component } parent The parent on which these datasets will be created
 * @param  { Class } DataSetClass The class definition of the dataset that will be created
 * @param  { string } dataSetType type name by which the datasets will be attached to the parent
 * @param  { number } [count=1] How many datasets needs to be created
 * @param  { Array } [configArr=undefined] Array of configration objects of all these datasets
 * @param  { Array } [indices=[]] Array of indices for all datasets
 */
datasetFactory = function datasetFactory(parent, DataSetClass, dataSetType) {
  var count = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  var configArr = arguments[4];
  var indices = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];

  if (parent && DataSetClass && dataSetType) {
    var typedDataset = parent.getChildren(dataSetType) || [],
        i = void 0,
        ll = void 0,
        dsInstance = void 0;
    for (i = 0; i < count; i += 1) {
      // Update existing one if availabel elese create new one
      if (typedDataset && typedDataset[i] && !typedDataset[i].getState('removed')) {
        dsInstance = typedDataset[i];
      } else {
        dsInstance = new DataSetClass();
        parent.attachChild(dsInstance, dataSetType);
      }

      dsInstance.setJSONIndex && dsInstance.setJSONIndex(indices[i] || i);
      if (configArr && configArr.length > i && dsInstance.configure) {
        dsInstance.configure(configArr[i]);
      }
    }
    // Remove all extra datasets
    ll = typedDataset && typedDataset.length;
    if (i < ll) {
      for (; i < ll; i += 1) {
        typedDataset[i] && typedDataset[i].remove && typedDataset[i].remove();
      }
    }
  }
};

exports.setVCanvas = setVCanvas;
exports.isInterActiveEvt = isInterActiveEvt;
exports.addInterActiveEvtName = addInterActiveEvtName;
exports.getEmptyConstractor = getEmptyConstractor;
exports.setLineHeightFactor = setLineHeightFactor;
exports.getLineHeightFactor = getLineHeightFactor;
exports.BLANKSTRINGPLACEHOLDER = BLANKSTRINGPLACEHOLDER;
exports.UNDEF = UNDEF;
exports.UNDERSCORE = UNDERSCORE;
exports.BLANKSTRING = BLANKSTRING;
exports.COLOR_BLACK = COLOR_BLACK;
exports.COLOR_GLASS = COLOR_GLASS;
exports.COLOR_WHITE = COLOR_WHITE;
exports.COLOR_TRANSPARENT = COLOR_TRANSPARENT;
exports.HASHSTRING = HASHSTRING;
exports.BREAKSTRING = BREAKSTRING;
exports.STRINGSTRING = STRINGSTRING;
exports.OBJECTSTRING = OBJECTSTRING;
exports.COMMASTRING = COMMASTRING;
exports.ZEROSTRING = ZEROSTRING;
exports.SAMPLESTRING = SAMPLESTRING;
exports.TESTSTR = TESTSTR;
exports.ONESTRING = ONESTRING;
exports.DECIMALSTRING = DECIMALSTRING;
exports.STRINGUNDEFINED = STRINGUNDEFINED;
exports.POSITION_TOP = POSITION_TOP;
exports.POSITION_RIGHT = POSITION_RIGHT;
exports.POSITION_BOTTOM = POSITION_BOTTOM;
exports.POSITION_LEFT = POSITION_LEFT;
exports.POSITION_CENTER = POSITION_CENTER;
exports.POSITION_MIDDLE = POSITION_MIDDLE;
exports.POSITION_START = POSITION_START;
exports.POSITION_END = POSITION_END;
exports.FC_CONFIG_STRING = FC_CONFIG_STRING;
exports.SHAPE_RECT = SHAPE_RECT;
exports.HUNDREDSTRING = HUNDREDSTRING;
exports.PXSTRING = PXSTRING;
exports.COMMASPACE = COMMASPACE;
exports.TEXTANCHOR = TEXTANCHOR;
exports.hiddenStr = hiddenStr;
exports.visibleStr = visibleStr;
exports.TOUCH_THRESHOLD_PIXELS = TOUCH_THRESHOLD_PIXELS;
exports.CLICK_THRESHOLD_PIXELS = CLICK_THRESHOLD_PIXELS;
exports.regex = regex;
exports.plotEventHandler = plotEventHandler;
exports.getEventCoordinate = getEventCoordinate;
exports.getMouseCoordinate = getMouseCoordinate;
exports.getTouchEvent = getTouchEvent;
exports.extend2 = _libExtend2['default'];
exports.deltend = deltend;
exports.imprint = imprint;
exports.pluck = pluck;
exports.pluckNumber = pluckNumber;
exports.getFirstDefinedValue = getFirstDefinedValue;
exports.createElement = createElement;
exports.hashify = hashify;
exports.dehashify = dehashify;
exports.getComparatorFN = getComparatorFN;
exports.pluckFontSize = pluckFontSize;
exports.getValidValue = getValidValue;
exports.getPosition = getPosition;
exports.getViewPortDimension = getViewPortDimension;
exports.bindSelectionEvent = bindSelectionEvent;
exports.fcEach = fcEach;
exports.getDefinedColor = getDefinedColor;
exports.getFirstValue = getFirstValue;
exports.getFirstColor = getFirstColor;
exports.getColorCodeString = getColorCodeString;
exports.pluckColor = pluckColor;
exports.clampNumber = clampNumber;
exports.toRaphaelColor = toRaphaelColor;
exports.gradientify = gradientify;
exports.trimString = trimString;
exports.getFirstAlpha = getFirstAlpha;
exports.parsePointValue = parsePointValue;
exports.parseUnsafeString = parseUnsafeString;
exports.parseTooltext = parseTooltext;
exports.toPrecision = toPrecision;
exports.hasTouch = hasTouch;
exports.CREDIT_HREF = CREDIT_HREF;
exports.CREDIT_STRING = CREDIT_STRING;
exports.getSentenceCase = getSentenceCase;
exports.regescape = regescape;
exports.regReplaceEscape = regReplaceEscape;
exports.getImageURL = getImageURL;
exports.isArray = isArray;
exports.getCrispValue = getCrispValue;
exports.getCripValues = getCrispValue;
exports.preDefStr = preDefStr;
exports.stubFN = EMPTYFN;
exports.stableSort = stableSort;
exports.hasSVG = hasSVG;
exports.CREDIT_REGEX = CREDIT_REGEX;
exports.isIE = isIE;
exports.lineHeightFactor = lineHeightFactor;
exports.getLinkAction = getLinkAction;
exports.setImageDisplayMode = setImageDisplayMode;
exports.setLineHeight = setLineHeight;
exports.parsexAxisStyles = parsexAxisStyles;
exports.supportedStyle = supportedStyle;
exports.getAxisLimits = getAxisLimits;
exports.createTrendLine = createTrendLine;
exports.getDashStyle = getDashStyle;
exports.axisLabelAdder = axisLabelAdder;
exports.chartAPI = chartAPI;
exports.createDialog = createDialog;
exports.componentDispose = componentDispose;
exports.componentConfigurer = componentConfigurer;
exports.executeJS = executeJS;
exports.pseudoEval = pseudoEval;
exports.convertColor = convertColor;
exports.graphics = graphics;
exports.appliedCSS = appliedCSS;
exports.priorityList = priorityList;
exports.getContainerBackgroundColor = getContainerBackgroundColor;
exports.handleContainerResize = handleContainerResize;
exports.capitalizeString = capitalizeString;
exports.TRACKER_FILL = TRACKER_FILL;
exports.chartPaletteStr = chartPaletteStr;
exports.DASH_DEF = DASH_DEF;
exports.attrTypeNum = attrTypeNum;
exports.canvasBGAlphaStr = canvasBGAlphaStr;
exports.attrTypeBool = attrTypeBool;
exports.pInt = pInt;
exports.defined = defined;
exports.canvasBorderColorStr = canvasBorderColorStr;
exports.attribDefs = _libAttr.attribDefs;
exports.parseConfiguration = _libAttr.parseConfiguration;
exports.setAttribDefs = _libAttr.setAttribDefs;
exports.hasAttribDefs = _libAttr.hasAttribDefs;
exports.crispBound = crispBound;
exports.defaultGaugePaletteOptions = defaultGaugePaletteOptions;
exports.MathExt = MathExt;
exports.xssEncode = xssEncode;
exports.animHelperFN = animHelperFN;
exports.mathAbs = mathAbs;
exports.mathRound = mathRound;
exports.NORMAL = NORMAL;
exports.BOLD = BOLD;
exports.HAND = HAND;
exports.POINTER = POINTER;
exports.BLANK = BLANK;
exports.ROUND = ROUND;
exports.configStr = configStr;
exports.animationObjStr = animationObjStr;
exports.COMMA = COMMA;
exports.TILE = TILE;
exports.FILL = FILL;
exports.FIT = FIT;
exports.MOUSEOUT = MOUSEOUT;
exports.MOUSEMOVE = MOUSEMOVE;
exports.VISIBLE = VISIBLE;
exports.BGRATIOSTRING = BGRATIOSTRING;
exports.dropHash = dropHash;
exports.componentFactory = componentFactory;
exports.datasetFactory = datasetFactory;
exports.PROJECT_VERSION = PROJECT_VERSION;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _lib = __webpack_require__(5);

var _eventApi = __webpack_require__(7);

var _schedular = __webpack_require__(41);

var _schedular2 = _interopRequireDefault(_schedular);

var _forEach = __webpack_require__(81);

var _forEach2 = _interopRequireDefault(_forEach);

var _findIndex = __webpack_require__(353);

var _findIndex2 = _interopRequireDefault(_findIndex);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */

var idCounterStore = {},

/**
 * This callback is displayed as part of the Requester class.
 * @callback ComponentInterface~childMapCallback
 * @param {Child} child the child component
 * @param {string} type the type of the child
 * @param {number} index the index of the child
 * @return {Boolean} in case of iterateComponents method, if the return is false, then the children of the child will not be traversed
 */

/**
 * This callback is invoked when the component's invoke factory method is called.
 * @callback ComponentInterface~factoryCallback
 * @param {Object} component The caller component which invoked the factory.
 */

/**
 * This method take an call back and execute the call back for each children
 * This methode iterates amond similar children in backward (last one first) way
 * @param {Object} sub the sub element on which the call back should be iterated
 * @param  {ComponentInterface~childMapCallback} callback the function that will be called for each child
 * @private
 */
_mapSubFnBackward = function _mapSubFnBackward(sub, callback) {
  if (sub && sub.hasOwnProperty && callback && callback.call) {
    var key = void 0,
        child = void 0,
        i = void 0;
    for (key in sub) {
      if (sub.hasOwnProperty(key)) {
        child = sub[key];
        if (child instanceof Array) {
          for (i = child.length - 1; i >= 0; i--) {
            callback(child[i], key, i);
          }
        } else {
          callback(child, key);
        }
      }
    }
  }
},

/**
 * This method take an call back and execute the call back for each children
 * This methode iterates among similar children in Forward (first one first) way
 * @param {Object} sub the sub element on which the call back should be iterated
 * @param  {ComponentInterface~childMapCallback} callback the function that will be called for each child
 * @private
 */
_mapSubFnForward = function _mapSubFnForward(sub, callback) {
  if (sub && sub.hasOwnProperty && callback && callback.call) {
    var key = void 0,
        child = void 0,
        i = void 0,
        length = void 0;
    for (key in sub) {
      if (sub.hasOwnProperty(key)) {
        child = sub[key];
        if (child instanceof Array) {
          length = child.length;
          for (i = 0; i < length; i++) {
            callback(child[i], key, i);
          }
        } else {
          callback(child, key);
        }
      }
    }
  }
};

/**
 * Helper method to add given event on all existing graphics
 * @private
 * @param  {Object} component The component whose graphic elements need the event attached
 * @param  {string} eventType The event name to be attached to every graphic element of the component
 * @param  {Function} listener The event's listener
 */
function addEventOnAllGraphics(component, eventType, listener) {
  var callBack;
  if (eventType && listener) {
    /**
     * This method will be clled for all elements and the event listeners will be added
     * @param {Graphic} element The graphic element
     * @private
     */
    callBack = function callBack(element) {
      element.on && element.on(eventType, listener);
    };
    // for all graphic elements
    _mapSubFnForward(component.getGraphicalElement(), callBack);
    // for all child containers
    _mapSubFnForward(component.getChildContainer(), callBack);
  }
}

/**
 * Helper method to remove given event-listener from all existing graphics
 * @private
 * @param  {Object} component The component from whose graphics all event listeners will be removed
 * @param  {string} eventType The event name using which will the events will be removed
 * @param  {Function} listener The event's listener
 */
function removeEventFromAllGraphics(component, eventType, listener) {
  var callBack;
  if (eventType && listener) {
    /**
     * This method will be clled for all elements and the event listeners will be added
     * @param {Graphic} element The graphic element
     * @private
     */
    callBack = function callBack(element) {
      element.off && element.off(eventType, listener);
    };
    // for all graphic elements
    _mapSubFnForward(component.getGraphicalElement(), callBack);
    // for all child containers
    _mapSubFnForward(component.getChildContainer(), callBack);
  }
}

/**
 * Helper method to add all existing events on given graphics
 * @private
 * @param  {Element} graphicElement The graphic element to which the events will be attached
 * @param {Object} listenersObj The object containing all listeners
 */
function addAllEventsOnGraphic(graphicElement, listenersObj) {
  var eventType, listeners;
  if (listenersObj && listenersObj.hasOwnProperty) {
    // for all middle-layer listeners
    for (eventType in listenersObj) {
      if (listenersObj.hasOwnProperty(eventType)) {
        listeners = (0, _eventApi.getListeners)(eventType, this);
        // If there is atleast one listeners attached to the component for this evenet type,
        // then, attach the middle-layer listener to the graphicElement
        if (listeners && listeners.length >= 1) {
          graphicElement && graphicElement.on(eventType, listenersObj[eventType]);
        }
      }
    }
  }
}

/**
 * Helper method to remove all existing events from given graphics
 * @private
 * @param  {Element} graphicElement The graphic element from which the listeners will be removed
 * @param {Object} listenersObj The object containing all listeners
 */
function removeAllEventsFromGraphic(graphicElement, listenersObj) {
  var eventType, listeners;
  if (listenersObj && listenersObj.hasOwnProperty) {
    // for all middle-layer listeners
    for (eventType in listenersObj) {
      if (listenersObj.hasOwnProperty(eventType)) {
        listeners = (0, _eventApi.getListeners)(eventType, this);
        // If there is atleast one listeners attached to the component for this evenet type,
        // then, remove the middle-layer listener from this graphicElement
        // Else it is already removed. No need to run the remove code
        if (listeners && listeners.length >= 1) {
          graphicElement && graphicElement.off(eventType, listenersObj[eventType]);
        }
      }
    }
  }
}

/**
 * Helper method to remove all existing events from given graphics
 * @private
 * @param  {Object} store The object containing all graphic elements
 */
function removeGraphics(store) {
  var graphic, elem;
  for (graphic in store) {
    elem = store[graphic];
    if (elem && elem.remove) {
      elem.remove();
    }
  }
}
/**
 * The base interface for all components
 * This interface has all the common methods
 */

var ComponentInterface = function () {
  /**
   * This method is the root constructor of all component.
   * This method create few place holders that are used later
   * Also, the "instantiated" event
   * This method set the default configurations of the component initially
   */
  function ComponentInterface() {
    _classCallCheck(this, ComponentInterface);

    var component = this;
    component.config = {};
    component._jobList = {};
    component._components = {};
    component._env = {};
    component._extListeners = {};
    component._state = {};
    component._factories = [];
    component._graphics = {};
    // Fire the first life cycle event named "instantiated"
    component.__setDefaultConfig && component.__setDefaultConfig();
  }

  /**
   * Generic configure function for every component.
   *
   * @param {any} dataObj The user provided JSON data which the component will use to configure
   * itself
   */


  ComponentInterface.prototype.configure = function configure(dataObj) {
    this.fireEvent('instantiated');
    this.preConfigure(dataObj);
    this.configureAttributes(dataObj);
    this.postConfigure(dataObj);
    this.invokeFactories();
  };

  /**
   * Generic preConfigure function for every component
   *
   * @param {any} dataObj The user provided JSON data which the component will use to configure
   * itself
   */


  ComponentInterface.prototype.preConfigure = function preConfigure(dataObj) {
    this.fireEvent('preconfigure', dataObj);
  };

  /**
   * Generic configureAttributes function for every component
   *
   * @param {any} dataObj The user provided JSON data which the component will use to configure
   * itself
   * @return {Object} An instance of the component
   */


  ComponentInterface.prototype.configureAttributes = function configureAttributes() {
    return this;
  };

  /**
   * Generic postConfigure function for every component
   *
   * @param {any} dataObj The user provided JSON data which the component will use to configure
   * itself
   */


  ComponentInterface.prototype.postConfigure = function postConfigure(dataObj) {
    this.fireEvent('postconfigure', dataObj);
  };
  /**
   * Method that return the name of the component
   * This method should be changed in each component's defination class with specific unic name of that component
   * @return {string} name of the component
   */


  ComponentInterface.prototype.getName = function getName() {
    return 'generic';
  };
  /**
   * Method that return the type of the component
   * This method should be changed in the base class of each type of component.
   * e.g. one base class of axis should have a getType method defined. Which wil be inherited into all subclass of the base class like CartesianAxis, PolarAxis etc
   * @return {string} type of the component
   */


  ComponentInterface.prototype.getType = function getType() {
    return 'generic';
  };

  /**
   * Gets the ID associated with the component
   * @return {string} The ID of the component
   */


  ComponentInterface.prototype.getId = function getId() {
    if (!this._id) {
      this.setId();
    }
    return this._id;
  };

  /**
   * Sets the given id as the id of the component
   * @param  {string} id The ID to be set as the ID of the component
   */


  ComponentInterface.prototype.setId = function setId(id) {
    var key;
    if (id === _lib.UNDEF) {
      key = this.getType() + _lib.UNDERSCORE + this.getName();
      if (!idCounterStore[key]) {
        idCounterStore[key] = 1;
      }
      id = key + _lib.UNDERSCORE + idCounterStore[key];
      idCounterStore[key] += 1;
    }
    this._id = id;
  };
  /**
   * This method iterates over all the components under this in DFS way
   * @param  {ComponentInterface~childMapCallback} callback this method
   */


  ComponentInterface.prototype.iterateComponents = function iterateComponents(callback) {
    /**
     * This method gets called for internal iteration, which calls the user givel call back internally
     * Also, checks if the return from the external call back is false, it will not go into the depth of that child
     * @param  {Component} child the child component that is being traverse
     * @param  {string}    key   the type of the child
     * @param  {number}    index the index of the child
     * @private
     */
    var childIteratorCallback = function childIteratorCallback(child, key, index) {
      var searchInDepth = callback(child, key, index);
      // if the return from teh call back is flase, don't search in the depth of this child
      if (searchInDepth !== false && child._mapChildren) {
        child._mapChildren(childIteratorCallback);
      }
    };
    this._mapChildren(childIteratorCallback);
  };
  /**
   * This method take an call back and execute the call back for each children
   * @param  {ComponentInterface~childMapCallback} callback the function that will be called for each child
   * @param  {boolean} backWord This argument defines whether the children will be iterated from the end or not
   * @private
   */


  ComponentInterface.prototype._mapChildren = function _mapChildren(callback, backWord) {
    if (backWord) {
      _mapSubFnBackward(this.getChildren(), callback);
    } else {
      _mapSubFnForward(this.getChildren(), callback);
    }
  };

  // ******* ENV APIs ******* //

  /**
   * This is a getter method to access members from enviroment
   * If no name is provided, then this ill return the whole environment object.
   * @param  {string} [name] name of the environment variable that will be returned
   * @return {*} The member from the environment with given name or the whole environment object
   */


  ComponentInterface.prototype.getFromEnv = function getFromEnv(name) {
    return name ? this._env[name] : this._env;
  };

  /**
   * Method to add members into environment
   * @param  {string} name name bu which the values will be accesed from the environment
   * @param  {Any} value value that will be added to the environment
   */


  ComponentInterface.prototype.addToEnv = function addToEnv(name, value) {
    if (name) {
      this._env[name] = value;
    }
  };

  /**
   * Method to remove members from environment
   * This method can remove members added this component only.
   * All members inherated from parent environments will not be deleted using this method.
   * @param  {string} name name of the environment member that will be deleted
   */


  ComponentInterface.prototype.deleteFromEnv = function deleteFromEnv(name) {
    delete this._env[name];
  };

  /**
   * This method set the inheritance link to parent environment.
   * Also, inform all child to uodate their link as well
   * This method get's called only when parent of a component got set / changed
   * @private
   */


  ComponentInterface.prototype._updateParentEnv = function _updateParentEnv() {
    var parent = this.getLinkedParent(),
        pEnv,
        EnvConstractor,
        oldEnv = this._env,
        env,
        key;

    if (parent) {
      pEnv = parent.getFromEnv();
      EnvConstractor = function EnvConstractor() {
        // EnvConstractor Class
      };
      EnvConstractor.prototype = pEnv;
      EnvConstractor.prototype.constructor = EnvConstractor;
      env = new EnvConstractor();
      if (oldEnv) {
        for (key in oldEnv) {
          if (oldEnv.hasOwnProperty(key)) {
            env[key] = oldEnv[key];
          }
        }
      }
      this._env = env;
      // inform all children to update thair link as well
      this._mapChildren(function (child) {
        child._updateParentEnv && child._updateParentEnv();
      });
    }
  };

  // ******* JOB schecdular APIs ******* //

  /**
   * This method add a job to the schedular
   * @param  {string} name name of the job
   * @param  {Function} job the job that will be executed
   * @param  {number} priority the priority of the job
   */


  ComponentInterface.prototype.addJob = function addJob(name, job, priority) {
    var component = this;
    component.removeJob(name);
    component._jobList[name] = _schedular2['default'].addJob(job, priority);
  };
  /**
   * This method removes any existing job
   * @param  {string} name name of the job
   */


  ComponentInterface.prototype.removeJob = function removeJob(name) {
    var jobId = this._jobList[name];
    if (jobId) {
      _schedular2['default'].removeJob(jobId);
      delete this._jobList[name];
    }
  };
  /**
   * This function remove all scheduled jobs
   * NOTE: this method does not check whether the JOB is already completed or not
   */


  ComponentInterface.prototype.removeAllJobs = function removeAllJobs() {
    var jobName = void 0,
        jobList = this._jobList;
    for (jobName in jobList) {
      if (jobList.hasOwnProperty(jobName)) {
        _schedular2['default'].removeJob(jobList[jobName]);
        delete jobList[name];
      }
    }
  };

  // ******* Draw APIs ******* //

  /**
   * Function to call the drawing of a component in  asyn manner
   */


  ComponentInterface.prototype.asyncDraw = function asyncDraw() {
    var component = this;

    component.addJob('draw', function () {
      component.syncDraw();
    }, _lib.priorityList && _lib.priorityList.draw);
  };

  /**
   * Method to call the drawing of a component synchronoously
   */


  ComponentInterface.prototype.syncDraw = function syncDraw() {
    var component = this;
    // fire the beforeDraw event
    component.fireEvent('beforedraw');
    // If the component has an pending drawing JOB then remove that job
    component.removeJob('draw');
    // Now call the drawing of the component in sync manner
    component.draw && component.draw();
    component.setState('dirty', false);
    component.setState('parentChanged', false);
    // TODO: make the draw capable of async. i.e. incase of havey draw, we will split it into multiple thread and at the end will call a call back sent from here to fire the "drawn" event
    // fire the drawn event asynchronously
    component.addJob('draw-complete', function () {
      component.fireEvent('drawn');
    }, _lib.priorityList.instant);
  };
  /**
   * Draw all children synchronoously
   */


  ComponentInterface.prototype.childrenSyncDraw = function childrenSyncDraw() {
    this._mapChildren(function (child) {
      child && child.syncDraw && child.syncDraw();
    });
  };

  /**
   * Function to configure compoenent externally
   * when the compoenent got configure from its prent scope it drirectly call configure fn
   * @param {Object} config this object contains configuration of the component
   */


  ComponentInterface.prototype.setData = function setData(config) {
    // @TODO add the second argument named noOverWrite:
    // {boolean} [noOverWrite = false] it can be choosen externally to over write its existing configure or not
    var component = this,
        changeInfo = void 0,
        parent = component.getLinkedParent();
    component.configure && component.configure(config);
    changeInfo = component.getState('change-info');
    changeInfo && changeInfo.hasNoExternalEffect || parent && parent.childChange && parent.childChange(changeInfo, component.getId());
    // if the component is dirty, then register a drawing job
    if (component.getState('dirty')) {
      component.asyncDraw();
    }
  };

  // ******* Event APIs ******* //

  /**
  * Attaches an event by the given name to the component. The callback is when the event
  * is fired.
  *
  * **NOTE:** DO NOT USE THIS TO ATTACH LISTENRES UNLESS YOU WANT TO CLEAN UP AFTER YOUR LSTENERS
  * YOURSELF. USE *ComponentInterface#addExtEventListener* INSTEAD.
  * @param  {string}   eventType The type of event to be attached
  * @param  {Function} callback  The callback to be executed when the event is fired
  * @return {Function|false} It returns the listener func when it is sucessful else it returns false
  */


  ComponentInterface.prototype.addEventListener = function addEventListener(eventType, callback) {
    var component = this,
        listeners;
    if (eventType && eventType.toLowerCase) {
      eventType = eventType.toLowerCase();
      // If the event listeners is not yet added
      if ((0, _eventApi.addListener)(eventType, callback, component)) {
        // if interactive event, create a middle layer listener that will be added to the raphael elements and fire component's event
        if ((0, _lib.isInterActiveEvt)(eventType)) {
          listeners = (0, _eventApi.getListeners)(eventType, component);
          if (listeners && listeners.length === 1) {
            // If the store for the middleLayer event listeners are not ready, create it
            if (!component._middleListeners) {
              component._middleListeners = {};
            }
            // If the middle layer Listeners are not ready create it
            if (!component._middleListeners[eventType]) {
              component._middleListeners[eventType] = function (e) {
                component.fireEvent(eventType, _lib.UNDEF, _lib.UNDEF, _lib.UNDEF, e);
              };
            }
            // Now add this event to all DOM elements
            addEventOnAllGraphics(component, eventType, component._middleListeners[eventType]);
          }
        }
        return callback;
      }
    }
    return false;
  };

  /**
   * Removes an event listener from the graphic elemnt of this component.
   *
   * **NOTE:** THERE IS NO NEED TO USE THIS UNLESS YOU'RE CLEANING UP AFTER YOUR OWN LISTENERS. USE
   * *ComponentInterface#removeExtEventListener* INSTEAD
   * @param  {string}   eventType The event type to be removed
   * @param  {Function} callback  The callback function
   */


  ComponentInterface.prototype.removeEventListener = function removeEventListener(eventType, callback) {
    var component = this,
        listeners;
    if (eventType && eventType.toLowerCase) {
      eventType = eventType.toLowerCase();
      (0, _eventApi.removeListener)(eventType, callback, this);

      // if interactive event, create a middle layer listener that will be added to the raphael elements and fire component's event
      if ((0, _lib.isInterActiveEvt)(eventType)) {
        listeners = (0, _eventApi.getListeners)(eventType, this);
        if (listeners && listeners.length === 0 && this._middleListeners && this._middleListeners[eventType]) {
          // Now add this event to all DOM elements
          removeEventFromAllGraphics(component, eventType, this._middleListeners[eventType]);
        }
      }
    }
  };

  /**
   * Method to fire an event of the component
   * @param  {string}   name          The name of the event
   * @param  {Object}   data          The object that will be available as `data` property of the
   *                                  event
   * @param  {Function} defaultFn     The function that will be called as the default action
   * @param  {Function} cancelledFn   The function that will be called if the listener prevents
   *                                  the default action
   * @param  {event}    originalEvent The event object that will be available as `originalEvent`
   *                                  property of the event
   */


  ComponentInterface.prototype.fireEvent = function fireEvent(name, data, defaultFn, cancelledFn, originalEvent) {
    (0, _eventApi.triggerEvent)(name, this, data, originalEvent, defaultFn, cancelledFn);
  };

  /**
   * This method adds event listeners on other components. It keeps track of all externally added
   * listeners and removes them when the component gets disposed.
   * @param  {string}    eventType    The type of event to be attached
   * @param  {Function}  callback     The callback to be executed when the event is fired
   * @param  {Object}    extComponent The component on which the listener will be added
   * @return {Function|false} It returns the listener func when it is sucessful else it returns false
   */


  ComponentInterface.prototype.addExtEventListener = function addExtEventListener(eventType, callback, extComponent) {
    var component = this;
    if (extComponent && extComponent.addEventListener) {
      // If the events are successfully attached store it
      if (extComponent.addEventListener(eventType, callback)) {
        if (!component._extListeners[eventType]) {
          component._extListeners[eventType] = [];
        }
        component._extListeners[eventType].push({
          fn: callback,
          component: extComponent
        });
        return callback;
      }
    }
    // return false as unsuccessful status
    return false;
  };

  /**
   * This method removes the specified event listener from another component.
   * @param  {string}    eventType    The type of event to be attached
   * @param  {Function}  callback     The listener function to be removed from the event
   * @param  {Object}    extComponent The component from which the listener will be removed
   */


  ComponentInterface.prototype.removeExtEventListener = function removeExtEventListener(eventType, callback, extComponent) {
    var component = this,
        i,
        l,
        listenersArr;
    if (extComponent && extComponent.addEventListener && component._extListeners && component._extListeners[eventType]) {
      listenersArr = component._extListeners[eventType];
      l = listenersArr.length;
      for (i = l - 1; i > 0; i -= 1) {
        if (listenersArr[i] && listenersArr[i].fn === callback && listenersArr[i].component === extComponent) {
          extComponent.removeEventListener(eventType, callback);
          listenersArr.splice(i, 1);
          return;
        }
      }
    }
  };

  // ******* Graphiccs APIs ******* //

  /**
   * Adds the given graphical element to the component
   * @param  {string}  name    The name of the graphical element
   * @param  {Element} element The Element to be added to this component
   * @param  {boolean} isArray Whether the element to be added should be part of an array or not
   * @param {number} arrayIndex index of array in which element will be pushed
   * @return {Element}         The element added to the component
   */


  ComponentInterface.prototype.addGraphicalElement = function addGraphicalElement(name, element, isArray, arrayIndex) {
    var graphics = this._graphics;

    isArray = isArray || false;

    if (element) {
      if (isArray) {
        graphics[name] === _lib.UNDEF && (graphics[name] = []);
        if (arrayIndex) {
          graphics[name][arrayIndex] = element;
        } else {
          graphics[name].push(element);
        }
      } else {
        graphics[name] = element;

        this.fireEvent('graphicalelementattached', {
          element: element
        });
        // Add all existing events to this
      }
      addAllEventsOnGraphic(element, this._middleListeners);
    }
    return element;
  };

  /**
   * Search among all graphical elements and if found, remove the element
   * @param {Element} element The Element needs to be removed from this component
   */


  ComponentInterface.prototype.removeGraphicalElement = function removeGraphicalElement(element) {
    var _this = this;

    var graphics = this._graphics,
        found = void 0;
    _mapSubFnForward(graphics, function (child, type, index) {
      if (child === element) {
        found = true;
        removeAllEventsFromGraphic(child, _this._middleListeners);
        child.remove();
        if (index !== _lib.UNDEF) {
          graphics[type].splice(index, 1);
        } else {
          delete graphics[type];
        }
      }
    });

    if (found) {
      this.fireEvent('graphicalelementremoved', {
        element: element
      });
    }
  };

  /**
   * Gets all graphic elements associated with this component
   * If the name is provided, it will return the graphic element assocoated with it or undefined if not found.
   * Else, it returns the object containing all graphic elements.
   * @param  {string} [name] The name of the container to be returned
   * @return {(Object|Element|undefined)} The a graphic element or an object containing all the graphic elements associated with this component
   */


  ComponentInterface.prototype.getGraphicalElement = function getGraphicalElement(name) {
    return name ? this._graphics[name] : this._graphics;
  };

  // TODO: Need the name to be finalized
  /**
   * Adds a container element for the children of this component.
   * A component creates place holders for it's child coponent's in this way
   * @param  {string}  name    The name by which to refer to this container
   * @param  {Element} element The container element to be added
   * @return {Element}         The container element that was added
   */


  ComponentInterface.prototype.addChildContainer = function addChildContainer(name, element) {
    var containerStore = this._childContainers;
    if (element) {
      if (containerStore === _lib.UNDEF) {
        containerStore = this._childContainers = {};
      }
      containerStore[name] = element;
      // Add all existing events to this
      addAllEventsOnGraphic(element, this._middleListeners);
    }
    return element;
  };

  /**
   * Removes a child-container element
   * @param  {string} name The name of the container to be removed
   */


  ComponentInterface.prototype.removeChildContainer = function removeChildContainer(name) {
    var containerStore = this._childContainers;
    if (containerStore && containerStore[name]) {
      // Remove all existing events from this
      removeAllEventsFromGraphic(containerStore[name], this._middleListeners);
      containerStore[name].remove();
      delete containerStore[name];
    }
  };

  /**
   * Returns the child containers associated with this element
   * If the name is provided, it will return the child-container assocoated with the name or undefined if not found.
   * Else, it returns an object containg all child-containers attached.
   * Each child component should call this method to get all containers and append graphic elements inside specific container
   * Among all this containers there must be a container named `default`.
   * If the child does not find container with specific name, it will apent it's graphics inside the default one.
   * @param  {string} [name] The name of the child-container to be returned
   * @return {(Object|Element|undefined)} The child-container or an object containing all child containers of this element
   */


  ComponentInterface.prototype.getChildContainer = function getChildContainer(name) {
    if (this._childContainers === _lib.UNDEF) {
      this._childContainers = {};
    }
    return name ? this._childContainers[name] : this._childContainers;
  };

  /**
   * Adds a container element to append the component's own graphics
   * @param  {string}  name    The name by which to refer to this container
   * @param  {Element} element The container element to be added
   * @return {Element}         The container element that was added
   */


  ComponentInterface.prototype.addContainer = function addContainer(name, element) {
    var containerStore = this._containers;
    if (element) {
      if (containerStore === _lib.UNDEF) {
        containerStore = this._containers = {};
      }
      containerStore[name] = element;
    }
    return element;
  };

  /**
   * Removes a container element from the component
   * @param  {string} name The name of the container to be removed
   */


  ComponentInterface.prototype.removeContainer = function removeContainer(name) {
    var containerStore = this._containers;
    if (containerStore && containerStore[name]) {
      containerStore[name].remove();
      delete containerStore[name];
    }
  };

  /**
   * Returns all conatiners as an object
   * If the name is provided, it will return the container assocoated with the name or undefined if not found.
   * Else, it returns an object containg all containers attached.
   * @param  {string} [name] The name of the container to be returned
   * @return {(Object|Element|undefined)} A container or the whole container store or undefined
   */


  ComponentInterface.prototype.getContainer = function getContainer(name) {
    if (this._containers === _lib.UNDEF) {
      this._containers = {};
    }
    return name ? this._containers[name] : this._containers;
  };

  // ******* Parent, child and linked-item linking APIs ******* //

  /**
   * Sets a component as the linked parent of this component
   * @param  {Object} parent The component to be set as the linked parent of this component
   * @private
   */


  ComponentInterface.prototype._setLinkedParent = function _setLinkedParent(parent) {
    var oldParent = this.linkedParent;
    this.linkedParent = parent;
    if (oldParent !== parent) {
      this.setState('parentChanged', true);
      if (oldParent) {
        // fire parentDetached event
        this.fireEvent('parentdetached', {
          oldParent: oldParent
        });
      }
      if (parent) {
        // fire parentDetached event
        this.fireEvent('parentAttached', {
          newParent: parent
        });
      }
    }
    this._updateParentEnv && this._updateParentEnv();
  };

  /**
   * Gets the linked parent of this component
   * @return {Object} The linked parent of this component
   */


  ComponentInterface.prototype.getLinkedParent = function getLinkedParent() {
    return this.linkedParent;
  };

  /**
   * Sets a component as as an item linked to this component
   * @param  {string} itemName The name by which the given item will be attached as a linked item
   * @param  {Object} item     The item to be attached as a linked item
   */


  ComponentInterface.prototype.setLinkedItem = function setLinkedItem(itemName, item) {
    if (!this.linkedItems) {
      this.linkedItems = {};
    }
    if (itemName !== _lib.UNDEF || item !== _lib.UNDEF) {
      this.linkedItems[itemName] = item;
    }
  };

  /**
   * Gets a specific linked item of thsi component
   * @param  {string} itemName The name of the linked item
   * @return {Object}          The linked item matching the given name
   */


  ComponentInterface.prototype.getLinkedItem = function getLinkedItem(itemName) {
    if (this.linkedItems && itemName !== _lib.UNDEF) {
      return this.linkedItems[itemName];
    }
  };

  /**
   * Gets all linked items of this component
   * @return {Object} An object containing all of linked items of this component
   */


  ComponentInterface.prototype.getLinkedItems = function getLinkedItems() {
    return this.linkedItems;
  };

  /**
   * Attaches a component as a child of this component, i.e., as a part of the 'components' object
   * of this component
   * @param  {Object}  component         The component to be attached as a child
   * @param  {string}  componentType     This categorise the child components
   * @param  {boolean} [componentIsArray=true]  Whether the component being attached is part of an array.
   *                                     E.g. dataset components are stored in arrays
   * @return {Object}                    The attached child component
   */


  ComponentInterface.prototype.attachChild = function attachChild(component, componentType, componentIsArray) {
    var type = componentType || component.getType(),
        components = this._components;

    if (componentIsArray === false) {
      components[type] = component;
    } else {
      if (!(components[type] && components[type] instanceof Array)) {
        components[type] = [];
      }
      components[type].push(component);
    }

    component._setLinkedParent(this);
    // fire childAttached event
    this.fireEvent('childattached', {
      attachedChild: component
    });
    return component;
  };

  /**
   * Gets a child component by ID
   * @param  {string} id The ID of the component that should be returned
   * @return {Object}    The found component
   */


  ComponentInterface.prototype.getChild = function getChild(id) {
    var attachedChildren = this._components,
        returnChild;
    if (id === _lib.UNDEF) {
      return attachedChildren;
    }
    this._searchChildren(id, function (foundChild) {
      returnChild = foundChild;
    });
    return returnChild;
  };

  /**
   * Searches the components object of a component for a given ID. Executes the callback when a
   * component is found.
   * @private
   * @param  {string}   id The ID of the component to search
   * @param  {Function} cb The callback to be executed once a component is found. The callback has
   *                       the found child in its first parameter. If the child is part of an
   *                       array, it has the index of the child and the array that it was part of
   *                       as the second and third parameters respectively
   * @return {any} The return of the returned value of the call back
   */


  ComponentInterface.prototype._searchChildren = function _searchChildren(id, cb) {
    var attachedChildren = this._components,
        attachedChild,
        key,
        i;
    for (key in attachedChildren) {
      if (attachedChildren.hasOwnProperty(key)) {
        attachedChild = attachedChildren[key];
        if (attachedChild.constructor === Array) {
          for (i = attachedChild.length - 1; i >= 0; i--) {
            if (attachedChild[i].getId && attachedChild[i].getId() === id) {
              return cb(attachedChild[i], i, attachedChild);
            }
          }
        } else {
          if (attachedChild.getId && attachedChild.getId() === id) {
            return cb(attachedChild);
          }
        }
      }
    }
  };

  /**
   * Detaches a child of the given ID from this component
   * @param  {string} id The ID of the component to be detached
   * @return {Obejct}    The detached child
   */


  ComponentInterface.prototype.detachChild = function detachChild(id) {
    var returnChild,
        component = this;

    if (id === _lib.UNDEF) {
      return _lib.UNDEF;
    }

    // TODO: Detach a child that is not part of an array
    // eslint-disable-next-line no-unused-vars
    component._searchChildren(id, function (foundChild, idx, children) {
      returnChild = children.splice(idx, 1)[0];
      returnChild._setLinkedParent(_lib.UNDEF);
      // fire childDetached event
      component.fireEvent('childdetached', {
        detachedChild: returnChild
      });
    });

    return returnChild;
  };

  /**
   * Gets all associated child components of this component
   * @param  {string}  [componentType]     This categorise the child components
   * @return {Object} An object containing all children attached to this component
   */


  ComponentInterface.prototype.getChildren = function getChildren(componentType) {
    return componentType ? this._components[componentType] : this._components;
  };

  // ******* Remove APIs ******* //

  /**
   * Disposes this component and all child components associated with it
   * For internal use. Use `remove({instant: true})` instead
   * @private
   */


  ComponentInterface.prototype._dispose = function _dispose() {
    var component = this,
        parent,
        childComponents,
        itemName,
        i,
        eventType,
        listenersArr;

    if (component && component !== window && component._disposing !== true) {
      // solve circular component chain
      component._disposing = true;
      // fire the beforeDispose event
      component.fireEvent('beforeremove');
      // detach it from parent
      parent = component.getLinkedParent();
      if (parent && parent.detachChild && !parent._disposing) {
        parent.detachChild(this.getId());
      }
      // dispose the child components first
      childComponents = component.getChildren();
      if (childComponents) {
        // if components exist dispose them first
        component._mapChildren(function (child) {
          if (child && !child._disposing && child._dispose) {
            child._dispose && child._dispose();
          }
        }, true);
      }

      // Remove all external event listeners
      if (component._extListeners) {
        for (eventType in component._extListeners) {
          listenersArr = component._extListeners[eventType];
          for (i = listenersArr.length - 1; i >= 0; i--) {
            if (listenersArr[i].component && listenersArr[i].component.addEventListener) {
              listenersArr[i].component.removeEventListener(eventType, listenersArr[i].fn);
            }
          }
        }
      }

      // remve all jobs
      component.removeAllJobs();

      // TODO: the graphics and containers will not be removed, if the paper is already disposed
      // remove child containers
      removeGraphics(component.getChildContainer());
      // remove graphic elements
      removeGraphics(component.getGraphicalElement());
      // remove containers
      removeGraphics(component.getContainer());

      // break the link of all properties / component of the component
      for (itemName in component) {
        if (component.hasOwnProperty(itemName)) {
          delete component[itemName];
        }
      }
      // fire the disposed event
      component.fireEvent('removed');
    }
  };

  /**
   * Marks a component for disposal during the next draw cycle
   * @param  {Object} config Has a 'instant' member to indicate whether the component should be
   *   immediately disposed or disposed later when animation completes
   */


  ComponentInterface.prototype.remove = function remove(config) {
    var component = this,
        instantDispose = config && config.instant,
        childComponents;
    // set the visiblity false so that the code dependent on visiblity does not break
    component.setState('visible', false);
    component.setState('removed', true);

    if (instantDispose) {
      component._dispose();
    } else {
      // TODO: test the events properly
      // @TODO : we should listen internal.animationComplete instead of drawn
      component.addEventListener('drawn', function () {
        component._dispose();
      });
    }

    // dispose the child components first
    childComponents = component.getChildren();
    if (childComponents) {
      // if components exist dispose them first
      component._mapChildren(function (child) {
        child && child.remove && child.remove(config);
      }, true);
    }
  };

  // ******* State APIs ******* //

  /**
   * Set a state of the component
   * @param  {string} name the name of the state
   * @param  {*} value the value of the state
   */


  ComponentInterface.prototype.setState = function setState(name, value) {
    this._state[name] = value;
  };

  /**
   * Return the calue of any specified sate of a component
   * @param  {string} name the name of the state
   * @return {*} Return the vaue of the given name's state
   */


  ComponentInterface.prototype.getState = function getState(name) {
    return this._state && this._state[name];
  };

  /**
   * This function is used to register a method which, when invoked will instantiate a component and
   * attach it as a child of the component against which it was invoked.
   *
   * @param {string} name The name of the component to be created.
   * @param {ComponentInterface~factoryCallback} callback The method which will create the
   * component. This method will receive an instance of the component which registered it as a
   * parameter.
   * @param {string} [insertAfter] If required, the factory may want to instantiate its component
   * after some other specific component. In that case, the name of the component after which the
   * factory should be invoked will be passed via this parameter.
   */


  ComponentInterface.prototype.registerFactory = function registerFactory(name, callback, insertAfter) {
    var factoryObj = {
      name: name,
      factory: callback
    },
        index = void 0;

    if (insertAfter) {
      index = _findIndex2['default'].call(this._factories, function (factoryOb) {
        return factoryOb.name === insertAfter;
      });
      this._factories.splice(index + 1, 0, factoryObj);
    } else {
      this._factories.push(factoryObj);
    }
  };

  /**
   * Removes a registered factory by searching for it with the given name
   *
   * @param   {string} name The name by which the factory was registered
   *
   * @return {Object} The deregistered factory method
   */


  ComponentInterface.prototype.deregisterFactory = function deregisterFactory(name) {
    var index = _findIndex2['default'].call(this._factories, function (factoryObj) {
      return factoryObj.name === name;
    });

    if (index > -1) {
      return this._factories.splice(index, 1)[0].factory;
    }
  };

  /**
   * Invokes all registered factories in the order that they were registered and passes an instance
   * of the caller component to it.
   */


  ComponentInterface.prototype.invokeFactories = function invokeFactories() {
    var _this2 = this;

    _forEach2['default'].call(this._factories, function (factoryObj) {
      return factoryObj.factory(_this2);
    });
  };

  return ComponentInterface;
}();

exports['default'] = ComponentInterface;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var UNDEF = void 0,

// A function to create an abstraction layer so that the try-catch /
// error suppression of flash can be avoided while raising events.
managedFnCall = function managedFnCall(item, scope, event, args) {
  // We change the scope of the function with respect to the
  // object that raised the event.
  try {
    item[0].call(scope, event, args || {});
  } catch (e) {
    // Call error in a separate thread to avoid stopping
    // of chart load.
    setTimeout(function () {
      throw e;
    }, 0);
  }
},

// Function that executes all functions that are to be invoked upon trigger
// of an event.
slotLoader = function slotLoader(slot, event, args) {
  // Initialize variables.
  var i = 0,
      scope;

  // If slot does not have a queue, we assume that the listener
  // was never added and halt method.
  if (!(slot instanceof Array) || event.cancelled) {
    // Statutory W3C NOT preventDefault flag
    return;
  }

  // Iterate through the slot and look for match with respect to
  // type and binding.
  for (; i < slot.length; i += 1) {
    // If there is a match found w.r.t. type and bind, we fire it.
    if (slot[i][1] === event.sender || slot[i][1] === UNDEF) {
      // Determine the sender of the event for global events.
      // The choice of scope differes depending on whether a
      // global or a local event is being raised.
      scope = slot[i][1] === event.sender ? event.sender : {};

      managedFnCall(slot[i], scope, event, args);

      // Check if the user wanted to detach the event
      if (event.detached === true) {
        slot.splice(i, 1);
        i -= 1;
        event.detached = false;
      }
    }

    // Check whether propagation flag is set to false and discontnue
    // iteration if needed.
    if (event.cancelled === true) {
      break;
    }
  }
},
    unpropagator = function unpropagator() {
  this.originalEvent && this.originalEvent.stopPropagation && this.originalEvent.stopPropagation.call && this.originalEvent.stopPropagation();
},
    unImdPropagator = function unImdPropagator() {
  this.cancelled = true;
  if (this.originalEvent && this.originalEvent.stopImmediatePropagation && this.originalEvent.stopImmediatePropagation.call) {
    this.originalEvent.stopImmediatePropagation();
  } else if (this.originalEvent && this.originalEvent.stopPropagation && this.originalEvent.stopPropagation.call) {
    this.originalEvent.stopPropagation();
  }
},
    detacher = function detacher() {
  return (this.detached = true) === false;
},
    undefaulter = function undefaulter() {
  this.defaultPrevented = true;
  this.originalEvent && this.originalEvent.preventDefault && this.originalEvent.preventDefault.call && this.originalEvent.preventDefault();
},

/**
 * This function checks whether the same listener is already added or not
 * @param  {Array} slot Store where the listeners are stored
 * @param  {Function} listener The listeners function that will be called
 * @param  {Object} bind the object on which this listeners are attached.
 */
isDuplicate = function isDuplicate(slot, listener, bind) {
  var i = void 0,
      l = slot.length;
  for (i = 0; i < l; i += 1) {
    if (slot[i][0] === listener && slot[i][1] === bind) {
      return true;
    }
  }
},


// Entire collection of listeners.
listeners = {},


// The last raised event id. Allows to calculate the next event id.
lastEventId = 0,
    addListener = function addListener(type, listener, bind) {
  var recurseReturn, i, slot;
  // In case type is sent as array, we recurse this function.
  if (type instanceof Array) {
    recurseReturn = [];
    // We look into each item of the 'type' parameter and send it,
    // along with other parameters to a recursed addListener
    // method.
    for (i = 0; i < type.length; i += 1) {
      recurseReturn.push(addListener(type[i], listener, bind));
    }
    return recurseReturn;
  }

  // Validate the type parameter. Listener cannot be added without
  // valid type.
  if (typeof type !== 'string') {
    /**
     * The event name has not been provided while adding an event listener. Ensure that you pass a
     * `string` to the first parameter of {@link FusionCharts.addEventListener}.
     *
     * @typedef {ParameterException} Error-03091549
     * @memberOf FusionCharts.debugger
     * @group debugger-error
     */
    raiseError(bind, '03091549', 'param', '::addListener', new Error('Unspecified Event Type'));
    return;
  }

  // Listener must be a function. It will not eval a string.
  if (typeof listener !== 'function') {
    /**
     * The event listener passed to {@link FusionCharts.addEventListener} needs to be a function.
     *
     * @typedef {ParameterException} Error-03091550
     * @memberOf FusionCharts.debugger
     * @group debugger-error
     */
    raiseError(bind, '03091550', 'param', '::addListener', new Error('Invalid Event Listener'));
    return;
  }

  // Desensitize the type case for user accessability.
  type = type.toLowerCase();

  // If it has a bind element, store the listeners within it
  if (bind) {
    if (!bind._evtListeners) {
      bind._evtListeners = {};
    }
    // If the insertion position does not have a queue, then create one.
    if (!(bind._evtListeners[type] instanceof Array)) {
      bind._evtListeners[type] = [];
    }
    slot = bind._evtListeners[type];
  } else {
    // If the insertion position does not have a queue, then create one.
    if (!(listeners[type] instanceof Array)) {
      listeners[type] = [];
    }
    slot = listeners[type];
  }
  // If the listener is already there, then don't add it again
  if (isDuplicate(slot, listener, bind)) {
    return false;
  }
  // Add the listener to the queue.
  slot.push([listener, bind]);
  return listener;
},
    removeListener = function removeListener(type, listener, bind) {
  var slot, i;

  // Listener must be a function. Else we have nothing to remove!
  if (typeof listener !== 'function') {
    /**
     * The event listener passed to {@link FusionCharts.removeEventListener} needs to be a function.
     * Otherwise, the event listener function has no way to know which function is to be removed.
     *
     * @typedef {ParameterException} Error-03091560
     * @memberOf FusionCharts.debugger
     * @group debugger-error
     */
    raiseError(bind, '03091560', 'param', '::removeListener', new Error('Invalid Event Listener'));
    return;
  }

  // In case type is sent as array, we recurse this function.
  if (type instanceof Array) {
    // We look into each item of the 'type' parameter and send it,
    // along with other parameters to a recursed addListener
    // method.
    for (i = 0; i < type.length; i += 1) {
      removeListener(type[i], listener, bind);
    }
    return;
  }

  // Create a reference to the slot for easy lookup in this method.
  slot = getListeners(type, bind);

  // If slot does not have a queue, we assume that the listener
  // was never added and halt method.
  if (!(slot instanceof Array && slot.length)) {
    return;
  }

  // Iterate through the slot and remove every instance of the
  // event handler.
  for (i = slot.length - 1; i >= 0; i -= 1) {
    // Remove all instances of the listener found in the queue.
    if (slot[i][0] === listener && slot[i][1] === bind) {
      slot.splice(i, 1);
    }
  }
},


// opts can have { async:true, omni:true }
triggerEvent = function triggerEvent(type, sender, args, originalEvent, defaultFn, cancelFn) {
  var eventObject, primarySlot, secondarySlot, tertiarySlot, quaternarySlot;

  // Event namer are case incencitive
  type = type.toLowerCase();

  primarySlot = getListeners(type, sender);
  secondarySlot = getListeners('*', sender);

  tertiarySlot = listeners[type];
  quaternarySlot = listeners['*'];

  if (primarySlot && primarySlot.length || secondarySlot && secondarySlot.length || tertiarySlot && tertiarySlot.length || quaternarySlot && quaternarySlot.length) {
    // Model the event as per W3C standards. Add the function to cancel
    // event propagation by user handlers. Also append an incremental
    // event id.
    eventObject = {
      type: type,
      eventType: type,
      eventId: lastEventId += 1,
      sender: sender || new Error('Orphan Event'),
      stopPropagation: unpropagator,
      stopImmediatePropagation: unImdPropagator,
      cancelled: false,
      preventDefault: undefaulter,
      defaultPrevented: false,
      originalEvent: originalEvent,
      detached: false,
      data: args,
      detachHandler: detacher
    };

    /**
     * Event listeners are used to tap into different stages of creating, updating, rendering or removing
     * charts. A FusionCharts instance fires specific events based on what stage it is in. For example, the
     * `renderComplete` event is fired each time a chart has finished rendering. You can listen to any such
     * event using {@link FusionCharts.addEventListener} or {@link FusionCharts#addEventListener} and bind
     * your own functions to that event.
     *
     * These functions are known as "listeners" and are passed on to the second argument (`listener`) of the
     * {@link FusionCharts.addEventListener} and {@link FusionCharts#addEventListener} functions.
     *
     * @callback FusionCharts~eventListener
     * @see FusionCharts.addEventListener
     * @see FusionCharts.removeEventListener
     *
     * @param {object} eventObject - The first parameter passed to the listener function is an event object
     * that contains all information pertaining to a particular event.
     *
     * @param {string} eventObject.type - The name of the event.
     *
     * @param {number} eventObject.eventId - A unique ID associated with the event. Internally it is an
     * incrementing counter and as such can be indirectly used to verify the order in which  the event was
     * fired.
     *
     * @param {FusionCharts} eventObject.sender - The instance of FusionCharts object that fired this event.
     * Occassionally, for events that are not fired by individual charts, but are fired by the framework,
     * will have the framework as this property.
     *
     * @param {boolean} eventObject.cancelled - Shows whether an  event's propagation was cancelled or not.
     * It is set to `true` when `.stopPropagation()` is called.
     *
     * @param {function} eventObject.stopPropagation - Call this function from within a listener to prevent
     * subsequent listeners from being executed.
     *
     * @param {boolean} eventObject.defaultPrevented - Shows whether the default action of this event has been
     * prevented. It is set to `true` when `.preventDefault()` is called.
     *
     * @param {function} eventObject.preventDefault - Call this function to prevent the default action of an
     * event. For example, for the event {@link FusionCharts#event:beforeResize}, if you do
     * `.preventDefault()`, the resize will never take place and instead
     * {@link FusionCharts#event:resizeCancelled} will be fired.
     *
     * @param {boolean} eventObject.detached - Denotes whether a listener has been detached and no longer
     * gets executed for any subsequent event of this particular `type`.
     *
     * @param {function} eventObject.detachHandler - Allows the listener to remove itself rather than being
     * called externally by {@link FusionCharts.removeEventListener}. This is very useful for one-time event
     * listening or for special situations when the event is no longer required to be listened when the
     * event has been fired with a specific condition.
     *
     * @param {object} eventArgs - Every event has an argument object as second parameter that contains
     * information relevant to that particular event.
     */
    // Facilitate the call of a global event listener.
    slotLoader(quaternarySlot, eventObject, args);
    slotLoader(tertiarySlot, eventObject, args);

    // Facilitate the call of a "*" event listener.
    slotLoader(getListeners('*', sender), eventObject, args);
    slotLoader(getListeners(type, sender), eventObject, args);
  }
  // Execute default action
  if (eventObject && eventObject.defaultPrevented) {
    if (cancelFn && typeof cancelFn === 'function') {
      cancelFn.call(sender, eventObject, args || {});
      // try {
      //   cancelFn.call(sender, eventObject, args || {});
      // } catch (err) {
      //   // Call error in a separate thread to avoid stopping
      //   // of chart load.
      //   setTimeout(function () {
      //     throw err;
      //   }, 0);
      // }
    }
  } else if (defaultFn && typeof defaultFn === 'function') {
    defaultFn.call(sender, eventObject, args || {});
    // try {
    //   defaultFn.call(sender, eventObject, args || {});
    // } catch (err) {
    //   // Call error in a separate thread to avoid stopping
    //   // of chart load.
    //   setTimeout(function () {
    //     throw err;
    //   }, 0);
    // }
  }

  // Statutory W3C NOT preventDefault flag
  return true;
},
    getListeners = function getListeners(type, bind) {
  // Validate the type parameter. Listener cannot be removed without
  // valid type.
  if (typeof type !== 'string') {
    /**
     * The event name passed to {@link FusionCharts.removeEventListener} needs to be a string.
     *
     * @typedef {ParameterException} Error-03091559
     * @memberOf FusionCharts.debugger
     * @group debugger-error
     */
    raiseError(bind, '03091559', 'param', '::removeListener', new Error('Unspecified Event Type'));
    return;
  }

  // Desensitize the type case for user accessability.
  type = type.toLowerCase();
  // return listeners[type];
  return bind ? bind._evtListeners && bind._evtListeners[type] : listeners[type];
},
    disposeEvents = function disposeEvents(target) {
  var type,
      evtListeners = target ? target._evtListeners : listeners;
  // Iterate through all events in the collection of listeners
  for (type in evtListeners) {
    evtListeners[type].length && (evtListeners[type].length = 0);
  }
},

/**
 * The debugging events {@link FusionCharts.debugger#event:error} and
 * {@link FusionCharts.debugger#event:warning} pass on the "nature" of the error/warning as its argument. The
 * value of this argument is one from the following list - giving a summary of the category of the error/warning
 * raised.
 *
 * <table>
 * <thead><tr><th>Name</th><th>Description</th></tr></thead>
 * <tbody>
 * <tr><td>`TypeException`</td>
 *     <td>Type mismatch of an input being processed. For example, `null` or `undefined` has been found in an
 *         operation where only `string` type of data is expected.</td>
 * </tr>
 * <tr><td>`ValueRangeException`</td>
 *     <td>The error or warning event was caused due to a critical value involved during an operation is outside
 *         the acceptable range.</td>
 * </tr>
 * <tr><td>`ParameterException`</td>
 *     <td>This exception is caused when a parameter passed on to a function is missing or is in an unacceptable
 *         format.</td>
 * </tr>
 * <tr><td>`RuntimeException`</td>
 *     <td>When a specific combination of inputs caused a process to reach a computational error such as
 *         division by zero, mathematical operation on non-numeric values, etc - this nature of warning or error
 *         is raised.</td>
 * </tr>
 * <tr><td>`DesignTimeException`</td>
 *     <td>Specific implementations of FusionCharts library may cause issues on
 *         specific browsers. Such issues (wherever detected) is notified as `DesignTimeException`. An example
 *         for the same would be having a chart's variable name exposed rootly and also be similar to the
 *         chart's Id - this causes issue on older versions of Internet Explorer browser.</td>
 * </tr>
 * <tr><td>`NotImplementedException`</td>
 *     <td>You've hit a jackpot! The operation  that caused this error or wanning is planned, but not yet
 *         implemented. Welcome to the future!</td>
 * </tr>
 * <tr><td>`UnspecifiedException`</td>
 *     <td>Exceptions that were trapped but specific cause of the same is not ascertained.</td>
 * </tr>
 * </tbody>
 * </table>
 *
 * @name FusionCharts.debugger~errorNatures
 */
errorNatures = {
  type: 'TypeException',
  range: 'ValueRangeException',
  impl: 'NotImplementedException',
  param: 'ParameterException',
  run: 'RuntimeException',
  comp: 'DesignTimeError',
  'undefined': 'UnspecifiedException'
},

/**
 * This function raises the error event after appropriately formatting the parameters.
 *
 * @param {FusionCharts} sender
 * @param {string} id Is the error reference id.
 * @param {string} nature Is a cue as to what category of error is this. The value of this param must be same as
 * one of the "keys" within the "errorNatures" collection.
 * @param {string} source Is a cue as to which object/module caused this error.
 * @param {Error} err
 * @param {string} level Indicates whether this error event is an error or warning event. Its values can be
 * "Error" or "Warning".
 * @private
 */
raiseEWEvent = function raiseEWEvent(sender, id, nature, source, err, level) {
  // We create a human-readable message for this error.
  var message = '#' + id + ' ' + (sender ? sender.id : 'unknown-source') + source + ' ' + level + ' >> ',
      args;

  // If err is sent as error object, we input more details to the error
  // object
  if (err instanceof Error) {
    err.name = errorNatures[nature];
    err.module = 'FusionCharts' + source;
    err.level = level;

    // Update the error message.
    err.message = message + err.message;
    message = err.message;

    // Throw error in a separate scope so that the execution of this script
    // is not blocked. Do this only when debugger is enabled
    setTimeout(function () {
      throw err;
    }, 0);
  } else {
    // Append the message string to the error message and sync with err.
    message = message + err;
  }

  // Prepare the event argument object.
  args = {
    id: id,
    nature: errorNatures[nature],
    source: 'FusionCharts' + source,
    message: message
  };

  triggerEvent(level, sender, args);
},


/**
 * This function raises an "Error" event based upon the parameters passed to it.
 *
 * @param {FusionCharts} sender
 * @param {string} id Is the error reference id.
 * @param {string} nature Is a cue as to what category of error is this. The value of this param must be same as one
 * of the "keys" within the "errorNatures" collection.
 * @param {string} source Is a cue as to which object/module caused this error.
 * @param {string} message
 */
raiseError = function raiseError(sender, id, nature, source, message) {
  /**
   * FusionCharts framework is designed to be non disruptive in execution. This means that in case of an error,
   * the library would attempt recovery or graceful fallback or not render a chart. It should ideally not raise
   * a JavaScript runtime error unless at places that is intended to raise error or when unexpected runtime errors
   * occur.
   *
   * For known error causing situations, this `error` event is raised with an error code and a message guiding to
   * the possible cause of error. In situtations where charts behave unexpectedly, this event can be subscribed
   * to discover possible errors.
   *
   * Furthermore, these events are forwarded to the {@link FusionCharts.debugger} output and when `debugger` is
   * enabled, any such error event would be visible.
   *
   * @event FusionCharts.debugger#error
   * @param {string} id - Reference ID of the error being raised.
   * @param {FusionCharts.debugger~errorNatures} nature - Is a cue as to what category of error is this.
   * The value of this param must be same as one from within  the {@link FusionCharts.debugger~errorNatures}
   * collection.
   * @param {string} source - source is a cue as to which object/module caused this error.
   * @param {string} message - The content of this argument is generally a human comprehensible message denoting
   * the cause of the error being raised.
   */
  raiseEWEvent(sender, id, nature, source, message, 'Error');
},


/**
 * This function raises an "Warning" event based upon the parameters passed to it.
 *
 * @param {FusionCharts} sender
 * @param {string} id Is the error reference id.
 * @param {string} nature Is a cue as to what category of error is this. The value of this param must be same as one
 * of the "keys" within the "errorNatures" collection.
 * @param {string} source Is a cue as to which object/module caused this error.
 * @param {string} message
 */
raiseWarning = function raiseWarning(sender, id, nature, source, message) {
  /**
   * Certain implementation setup, browser or combination of the both cause unexpected scenarios during the
   * rendering process of a chart. Whenever such situations are encountered that "may" cause issue but,
   * during the propagation of the event, has been compensated for. FusionCharts keeps the developer in the loop
   * by issuing this warning event.
   *
   * @event FusionCharts.debugger#warning
   *
   * @param {string} id - Reference ID of the warning being raised.
   * @param {FusionCharts.debugger~errorNatures} nature - Is a cue as to what category of warning is this.
   * The value of this param must be same as one from within  the {@link FusionCharts.debugger~errorNatures}
   * collection.
   * @param {string} source - source is a cue as to which object/module caused this error.
   * @param {string} message - The content of this argument is generally a human comprehensible cause of the error
   * being raised.
   */
  raiseEWEvent(sender, id, nature, source, message, 'Warning');
};

exports.addListener = addListener;
exports.removeListener = removeListener;
exports.triggerEvent = triggerEvent;
exports.getListeners = getListeners;
exports.disposeEvents = disposeEvents;
exports.raiseWarning = raiseWarning;
exports.raiseError = raiseError;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _stringify = __webpack_require__(42);

var _stringify2 = _interopRequireDefault(_stringify);

var _assign = __webpack_require__(13);

var _assign2 = _interopRequireDefault(_assign);

var _sign = __webpack_require__(183);

var _sign2 = _interopRequireDefault(_sign);

var _lib = __webpack_require__(5);

var _eventApi = __webpack_require__(7);

var _redraphael = __webpack_require__(17);

var _redraphael2 = _interopRequireDefault(_redraphael);

var _componentInterface = __webpack_require__(6);

var _componentInterface2 = _interopRequireDefault(_componentInterface);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */

// import tip from '../redraphael/redraphael.tooltip.js';


var UNDEF = void 0,
    ROLLOVER = 'DataPlotRollOver',
    ROLLOUT = 'DataPlotRollOut',
    plot1SKey = '_plot_1Start',
    plot1EKey = '_plot_1End',
    plot2SKey = '_plot_2Start',
    HTP = _lib.hasTouch ? _lib.TOUCH_THRESHOLD_PIXELS : _lib.CLICK_THRESHOLD_PIXELS,
    dropHash = _lib.regex.dropHash,
    PLOTBORDERCOLOR = 'plotBorderColor',
    PLOTGRADIENTCOLOR = 'plotGradientColor',
    SHOWSHADOW = 'showShadow',
    POINTER = 'pointer',
    EVENTARGS = 'eventArgs',
    DEFAULT_CURSOR = _lib.preDefStr.DEFAULT,
    showHoverEffectStr = _lib.preDefStr.showHoverEffectStr,
    visibleStr = _lib.preDefStr.visibleStr,
    SETROLLOVERATTR = _lib.preDefStr.setRolloverAttrStr,
    SETROLLOUTATTR = _lib.preDefStr.setRolloutAttrStr,
    math = Math,
    mathMin = math.min,
    mathMax = math.max,
    mathAbs = math.abs,
    mathCeil = math.ceil,
    mathRound = math.round,
    getLightColor = _lib.graphics.getLightColor,
    _rolloverResponseSetter = function _rolloverResponseSetter(chart, data, event, onlyHoverEffect) {
  var dataGraphics = data.graphics,
      elem = dataGraphics && dataGraphics.element,
      elData = elem && elem.getData();
  // Check whether the plot is in dragged state or not if
  // drag then dont fire rolloverevent
  if (elData.draged !== true) {
    elem && elData.showHoverEffect !== 0 && elem.attr(elem.getData().setRolloverAttr);
    !onlyHoverEffect && elem && _lib.plotEventHandler.call(elem, chart, event, ROLLOVER);
  }
},
    _rolloutResponseSetter = function _rolloutResponseSetter(chart, data, event, onlyHoverEffect) {
  var dataGraphics = data.graphics,
      elem = dataGraphics && dataGraphics.element,
      elData = elem && elem.getData();
  // Check whether the plot is in draggedstate or not if drag then dont fire rolloutevent
  if (elData.draged !== true) {
    elem && elData.showHoverEffect !== 0 && elem.attr(elem.getData().setRolloutAttr);
    !onlyHoverEffect && elem && _lib.plotEventHandler.call(elem, chart, event, ROLLOUT);
  }
},

/**
 * Helper function to create a RedRaphael group.
 * @param  {string} groupName                Name of the group to be created.
 * @param  {Paper} paper                     A RedRaphael paper element.
 * @param  {Element} parentContainer         The parent container in which the group will be appended.
 * @return {Element}                         The group that was created.
 */
createGroup = function createGroup(groupName, paper, parentContainer) {
  return paper.group(groupName, parentContainer);
},

// schedular = lib.schedular,
// componentDispose = lib.componentDispose,
plotSelfAnimRatio = 0.6,
    animStates = {
  appearing: function appearing(dataObj, options) {
    var dataSet = options.ds,
        attrObj = options.attr,
        chart = dataSet.getFromEnv('chart'),

    // TODO X axis should be also linked like yAxis
    len = chart.getChildren('xAxis')[0].getCategoryLen(),
        yAxis = dataSet.getFromEnv('yAxis'),
        yDepth = chart.config.yDepth || 0,
        zeroPos = yAxis.getAxisPosition(yAxis.getAxisBase()) + (chart.isBar ? -yDepth : yDepth),
        setElement = dataObj && dataObj.graphics && dataObj.graphics.element,
        yAttrKey = 'y',
        hAttrKey = 'height',
        initial = chart.state === 'initial',
        base2StartAttr = !initial && dataObj.prevDataObj && dataObj.prevDataObj.graphics.element.attr(),

    // base2StartAttr = dataObj.prevDataObj && dataObj.prevDataObj[plot2SKey],
    yBasePos,
        yAttrVal,
        hAttrVal,
        attr,
        animTimeOb,
        endPosWRT0,
        step2StartAttr;

    // To make it working for bar charts even just change the keys
    if (!yAxis.config.isVertical) {
      yAttrKey = 'x';
      hAttrKey = 'width';
    }
    // Store final y and h for later use
    yAttrVal = attrObj[yAttrKey];
    hAttrVal = attrObj[hAttrKey];
    endPosWRT0 = (0, _sign2['default'])(yAttrVal + hAttrVal / 2 - zeroPos);
    // If the plot is below zero plain, the base will be the y + h of the previousone
    // if it is stackked plot else y of the plot
    if (endPosWRT0 === 1) {
      yBasePos = base2StartAttr ? base2StartAttr[yAttrKey] + base2StartAttr[hAttrKey] : yAttrVal;
    } else {
      // the base will be the y of the previousone if it is stackked plot else y+h of itself
      yBasePos = base2StartAttr ? base2StartAttr[yAttrKey] : yAttrVal + hAttrVal;
    }
    // Replace the y and h with initial positions
    step2StartAttr = {};
    step2StartAttr[yAttrKey] = attrObj[yAttrKey] = yBasePos;
    step2StartAttr[hAttrKey] = attrObj[hAttrKey] = 0;
    // set the initial attributes
    setElement.attr(attrObj).hide();
    // preaper final y and h. ALso reset in the attrObj
    attr = {};
    attr[yAttrKey] = attrObj[yAttrKey] = yAttrVal;
    attr[hAttrKey] = attrObj[hAttrKey] = hAttrVal;

    // If the chart is getting rendered for the first time then the animation will be in accordian
    // style for the whole plot animation time
    if (initial) {
      animTimeOb = _lib.animHelperFN.getTimeByValue(_lib.animHelperFN.animByWeight(options.i, len, plotSelfAnimRatio), {
        startPx: zeroPos,
        endPx: endPosWRT0 === 1 ? dataSet.config.yAxisMaxPixel : dataSet.config.yAxisMinPixel
      }, {
        startPx: yBasePos,
        endPx: endPosWRT0 === 1 ? attrObj[yAttrKey] + attrObj[hAttrKey] : attrObj[yAttrKey]
      });
      dataObj.initialAnimObj = animTimeOb;
    } else {
      // Else it will take the 2nd half of the plot animation
      // as during the 1st half, other plots are getting changed to accomodate the place for the
      // new-one
      // TODO: implement the sequensial growth in the columns if they are at the to of the stack
      // of it is non stack charts
      animTimeOb = {
        start: dataSet.getFromEnv('numOfColumns') === 1 ? 0 : 0.5,
        end: 1
      };
      dataObj[plot2SKey] = step2StartAttr;
    }
    animTimeOb.hookFn = function () {
      if (dataObj.config.setValue) {
        dataSet.getState('visible') && this.show();
      } else {
        this.hide();
      }
    };
    // Set the final attributes
    options.anim.plot.data.push({
      el: setElement,
      attrs: attr,
      animType: 'linear',
      animConfig: [animTimeOb]
    });
    // Store the plots pos w.r.t axis 0 for future use
    dataObj._posWRT0 = endPosWRT0;
  },

  updating: function updating(dataObj, options) {
    var dataSet = options.ds,

    // groupManager = dataSet.groupManager,
    chart = dataSet.getFromEnv('chart'),
        xAxis = dataSet.getFromEnv('xAxis'),
        yAxis = dataSet.getFromEnv('yAxis'),
        attr = options.attr,
        animationConfig = chart.get('config', 'animConfig').column,
        setElement = dataObj && dataObj.graphics && dataObj.graphics.element,
        startY,
        startH,
        startYPlusH,
        startPlotCenter,
        endY,
        endH,
        endYPlusH,
        endPlotCenter,
        yDepth = chart.config.yDepth || 0,
        zeroPos = yAxis.getAxisPosition(yAxis.getAxisBase()) + (chart.isBar ? -yDepth : yDepth),
        start = 0,
        numColDiff = dataSet.getFromEnv('numColDiff'),
        step1Start = {},
        yAttrKey = 'y',
        hAttrKey = 'height',
        xAttrKey = 'x',
        wAttrKey = 'width',
        plot = options.anim.plot,
        hasPlot1Anim,
        step1End,
        // Stores the final attributes of plot's 1st step animation
    step2Start,
        // Stores the initial attributes of plot's 2nd step animation
    prevDataObj,
        base1StartAttr,
        base2StartAttr,
        oldPrevDataObj,
        oldBase1EndAttr,
        middleYplusH,
        hasTransitionDiff,
        base1EndAttr,
        startPosWRT0,
        endPosWRT0,
        step1EndBase,
        effectiveBasePos,
        step2HookFn,
        step1HookFn,
        preHookAttr;

    setElement.show();
    // Call the axis sync animation first
    animStates._axisSync(dataObj, options);

    // NOTE: old base might be modified during axisSync animation
    prevDataObj = dataObj.prevDataObj;
    base1StartAttr = prevDataObj && prevDataObj[plot1SKey];
    base1EndAttr = prevDataObj && prevDataObj[plot1EKey];
    base2StartAttr = prevDataObj && prevDataObj[plot2SKey];
    oldPrevDataObj = dataObj.oldPrevDataObj;
    oldBase1EndAttr = dataObj.oldPrevDataObj && dataObj.oldPrevDataObj[plot1EKey];

    // To make it working for bar charts even just change the keys
    if (xAxis.config.isVertical) {
      yAttrKey = 'x';
      hAttrKey = 'width';
      xAttrKey = 'y';
      wAttrKey = 'height';
    }

    step1Start = dataObj[plot1SKey];
    startY = step1Start[yAttrKey];
    startH = step1Start[hAttrKey];
    startYPlusH = startY + startH;
    startPlotCenter = startY + startH / 2;
    endY = attr[yAttrKey];
    endH = attr[hAttrKey];
    endYPlusH = endY + endH;
    endPlotCenter = endY + endH / 2;
    middleYplusH = (startYPlusH + endYPlusH) / 2;
    startPosWRT0 = (0, _sign2['default'])(startPlotCenter - zeroPos);
    endPosWRT0 = (0, _sign2['default'])(endPlotCenter - zeroPos);

    step1End = {};
    step2Start = {};
    // Calculate the value of step2Start and step2Start even if it is single step animation
    step2Start[yAttrKey] = step1End[yAttrKey] = (startY + endY) / 2;
    step2Start[hAttrKey] = step1End[hAttrKey] = (startH + endH) / 2;

    // ** Plot_1 [optional] animation step
    if (startH) {
      // if the plot is moving from one side of the zero plain to another
      if (startPosWRT0 !== endPosWRT0) {
        // Hight will decrease to 0 on the first half
        step2Start[hAttrKey] = step1End[hAttrKey] = 0;
        step1End[yAttrKey] = oldPrevDataObj && oldPrevDataObj._oldPosWRT0 === startPosWRT0 ? oldBase1EndAttr[yAttrKey] + (startPosWRT0 === 1 ? oldBase1EndAttr[hAttrKey] : 0) : zeroPos;
        // At the end of plot_1End it should jump to opposite direction [i.e plot_2Start]
        step2Start[yAttrKey] = base2StartAttr ? base2StartAttr[yAttrKey] + (endPosWRT0 === 1 ? base2StartAttr[hAttrKey] : 0) : zeroPos;
        // Set flags
        hasTransitionDiff = hasPlot1Anim = true;
      } else if (prevDataObj !== oldPrevDataObj) {
        step1EndBase = oldBase1EndAttr || (base1EndAttr && (0, _sign2['default'])(base1EndAttr[yAttrKey] + base1EndAttr[hAttrKey] / 2 - zeroPos) === startPosWRT0 ? base1EndAttr : false);
        effectiveBasePos = step1EndBase ? step1EndBase[yAttrKey] + (startPosWRT0 === 1 ? step1EndBase[hAttrKey] : 0) : zeroPos;
        if (startPosWRT0 === 1) {
          step2Start[yAttrKey] = step1End[yAttrKey] = effectiveBasePos;
          step2Start[hAttrKey] = step1End[hAttrKey] = middleYplusH - step1End[yAttrKey];
        } else {
          step2Start[hAttrKey] = step1End[hAttrKey] = effectiveBasePos - step1End[yAttrKey];
        }
        hasPlot1Anim = true;
      }
    } else {
      // If the plot is getting zero height after axis animation, then move it to new base
      // only if the base is already at the final side of the zero plane or it is the first
      // dataset of the stack
      if (prevDataObj && prevDataObj._oldPosWRT0 === endPosWRT0 || dataSet.stackIndex === 0) {
        preHookAttr = {};
        preHookAttr[hAttrKey] = 0;
        preHookAttr[yAttrKey] = base1StartAttr ? base1StartAttr[yAttrKey] + (prevDataObj._posWRT0 > 0 ? base1StartAttr[hAttrKey] : 0) : zeroPos;
        // Reset this so that plots on top of this will act lyke this was on the same side
        dataObj._posWRT0 = endPosWRT0;
        dataObj[plot1SKey] = preHookAttr;
        // step2HookFn = function () {
        //   setElement.attr(preHookAttr);
        // };
        // Reset the middle steps attributes
        step2Start[yAttrKey] = step1End[yAttrKey] = (preHookAttr[yAttrKey] + endY) / 2;
        step2Start[hAttrKey] = step1End[hAttrKey] = endH / 2;
      } else if (startPlotCenter === zeroPos) {
        // Datasets those are not at the bottom of the stack should wait for the next half to
        // complete the remaining animations others of that side
        if (endPosWRT0 != dataObj._posWRT0) {
          start = 0.5;
        } else {
          hasPlot1Anim = true;
          step1End[yAttrKey] = endPosWRT0 === 1 ? zeroPos : zeroPos - step1End[hAttrKey];
        }
      }
    }
    // If no of column is getting increased then reduce the width in the first half
    if (numColDiff < 0) {
      step1End[xAttrKey] = attr[xAttrKey];
      step1End[wAttrKey] = attr[wAttrKey];
      hasPlot1Anim = true;
    } else if (numColDiff > 0) {
      // else Animate the visible plot at the 2nd half
      start = 0.5;
    } else if (step1Start[xAttrKey] !== attr[xAttrKey] || step1Start[wAttrKey] != attr[wAttrKey]) {
      if (start === 0.5) {
        preHookAttr = {};
        preHookAttr[xAttrKey] = attr[xAttrKey];
        preHookAttr[wAttrKey] = attr[wAttrKey];
        step2HookFn = function step2HookFn() {
          if (hasTransitionDiff) {
            setElement.attr(step2Start);
          }
          setElement.attr(preHookAttr);
        };
      } else {
        step1End[xAttrKey] = attr[xAttrKey];
        step1End[wAttrKey] = attr[wAttrKey];
        hasPlot1Anim = true;
        if (step2HookFn) {
          step1HookFn = function step1HookFn() {
            setElement.attr(preHookAttr);
          };
          step2HookFn = UNDEF;
        }
      }
    }

    // If Plot_1Anim is their then set it
    if (hasPlot1Anim) {
      plot.data.push({
        el: setElement,
        attrs: step1End,
        animType: animationConfig.update.effect,
        animConfig: [{
          syncWith: 'plot',
          start: 0,
          end: 0.5,
          hookFn: step1HookFn
        }]
        // callback: function () {
        //   if (hasTransitionDiff && !chart.is3d) {
        //     setElement.attr(step2Start);
        //   }
        // }
      });
      start = 0.5;
    }
    !step2HookFn && (step2HookFn = function step2HookFn() {
      if (hasTransitionDiff) {
        setElement.attr(step2Start);
      }
    });
    plot.data.push({
      el: setElement,
      animType: animationConfig.update.effect,
      callback: function callback() {
        if (dataObj.config.setValue === null || dataObj.config.setValue === UNDEF) {
          this.hide();
        }
      },
      attrs: {
        x: attr.x,
        y: attr.y,
        width: attr.width,
        height: attr.height
      },
      animConfig: [{
        start: start,
        end: 1,
        hookFn: step2HookFn
      }]
    });

    delete attr.x;
    delete attr.y;
    delete attr.width;
    delete attr.height;
    plot.data.push({
      el: setElement,
      animType: animationConfig.update.effect,
      attrs: attr
    });

    // Store intermideate states
    dataObj[plot1EKey] = step1End;
    dataObj[plot2SKey] = step2Start;
    dataObj._oldPosWRT0 = dataObj._posWRT0;
    dataObj._posWRT0 = endPosWRT0;
  },

  _axisSync: function _axisSync(dataObj, options) {
    var dataSet = options.ds,
        chart = dataSet.getFromEnv('chart'),
        conf = dataSet.config,
        xAxis = dataSet.getFromEnv('xAxis'),
        yAxis = dataSet.getFromEnv('yAxis'),
        plot2EndAttr = options.attr,
        setElement,
        oldAttr,
        oldYVal,
        oldYPlusH,
        yDepth = chart.config.yDepth || 0,
        newZeroPos = yAxis.getAxisPosition(yAxis.getAxisBase()) + (chart.isBar ? -yDepth : yDepth),
        axisEndAttr = {},
        oldZeroAxisPos = conf.oldZeroAxisPos,
        yAttrKey = 'y',
        hAttrKey = 'height',
        xAttrKey = 'x',
        wAttrKey = 'width',
        axis = options.anim.axis,
        hasWithAxisAnim,
        crispingGutter = 0.7;

    // To make it working for bar charts even just change the keys
    if (xAxis.config.isVertical) {
      yAttrKey = 'x';
      hAttrKey = 'width';
      xAttrKey = 'y';
      wAttrKey = 'height';
    }

    setElement = dataObj.graphics.element;

    oldAttr = setElement.attr();
    axisEndAttr[yAttrKey] = oldYVal = oldAttr[yAttrKey];
    axisEndAttr[hAttrKey] = oldAttr[hAttrKey];
    axisEndAttr[xAttrKey] = oldAttr[xAttrKey];
    axisEndAttr[wAttrKey] = oldAttr[wAttrKey];
    oldYPlusH = oldAttr[yAttrKey] + oldAttr[hAttrKey];

    // ** yAxis Animation ** //
    if (newZeroPos !== oldZeroAxisPos) {
      // NOTE: (crispingGutter = 0.7) is a gutter to accomodate the displacement due to crisping
      if (oldZeroAxisPos - newZeroPos >= 0) {
        // Axis Base Moves Upword
        // If y stays in between
        if (oldYVal > newZeroPos && oldYVal <= oldZeroAxisPos + crispingGutter) {
          axisEndAttr[yAttrKey] = newZeroPos;
          if (oldYPlusH > oldZeroAxisPos) {
            axisEndAttr[hAttrKey] = oldYPlusH - axisEndAttr[yAttrKey];
          }
        }
        // If y + h stays in between
        if (oldYPlusH > newZeroPos && oldYPlusH <= oldZeroAxisPos + crispingGutter) {
          axisEndAttr[hAttrKey] = newZeroPos - (axisEndAttr[yAttrKey] || axisEndAttr[yAttrKey] === 0 ? axisEndAttr[yAttrKey] : oldYVal);
        }
      } else {
        // Axis Base Moves Downwords
        // If y stays in between
        if (oldYVal < newZeroPos && oldYVal >= oldZeroAxisPos - crispingGutter) {
          axisEndAttr[yAttrKey] = newZeroPos;
          if (oldYPlusH > newZeroPos) {
            axisEndAttr[hAttrKey] = oldYPlusH - axisEndAttr[yAttrKey];
          }
        }
        // If y + h stays in between
        if (oldYPlusH < newZeroPos && oldYPlusH >= oldZeroAxisPos - crispingGutter) {
          axisEndAttr[hAttrKey] = newZeroPos - (axisEndAttr[yAttrKey] || axisEndAttr[yAttrKey] === 0 ? axisEndAttr[yAttrKey] : oldYVal);
        }
      }
      hasWithAxisAnim = true;
    }

    // ** x-axis animation sync ** //

    if (dataSet.catDiff) {
      // TODO: need to fix this. This will not be exactly the final attr
      // Because there might me cases where the no of column got reduced as well as cat decreased
      axisEndAttr[xAttrKey] = plot2EndAttr[xAttrKey];
      axisEndAttr[wAttrKey] = plot2EndAttr[wAttrKey];
      hasWithAxisAnim = true;
    }

    if (hasWithAxisAnim) {
      // TODO: why this is pushed in axis instead of plot. ALso what is the significance of
      // syncwith here?
      axis.data.push({
        el: setElement,
        attrs: axisEndAttr,
        animConfig: [{
          syncWith: 'axis'
        }]
      });
    }
    // Store intermideate states
    dataObj[plot1SKey] = axisEndAttr;
  },
  hidding: function hidding(dataObj, options) {
    var dataSet = options.ds,
        yAxis = dataSet.getFromEnv('yAxis'),
        yDepth = dataSet.getFromEnv('chart').config.yDepth || 0,
        zeroPos = yAxis.getAxisPosition(yAxis.getAxisBase()) + (dataSet.getFromEnv('chart').isBar ? -yDepth : yDepth),
        setElement = dataObj && dataObj.graphics && dataObj.graphics.element,
        yAttrKey = 'y',
        hAttrKey = 'height',
        oldBase1EndAttr = dataObj.oldPrevDataObj && dataObj.oldPrevDataObj[plot1EKey],
        yBasePos,
        yAttrVal,
        attr,
        plot1StartAtt;

    if (!setElement) {
      return;
    }

    // Call the axis sync animation first
    animStates._axisSync(dataObj, options);

    // To make it working for bar charts even just change the keys
    if (!yAxis.config.isVertical) {
      yAttrKey = 'x';
      hAttrKey = 'width';
    }

    plot1StartAtt = dataObj[plot1SKey];
    // Store final y and h for later use
    yAttrVal = plot1StartAtt[yAttrKey];

    // If the plot is below zero plain, the base will be the y + h of the previousone
    // if it is stackked plot else y of the plot
    if (yAttrVal + plot1StartAtt[hAttrKey] / 2 > zeroPos) {
      yBasePos = oldBase1EndAttr ? oldBase1EndAttr[yAttrKey] + oldBase1EndAttr[hAttrKey] : yAttrVal;
    } else {
      // the base will be the y of the previous one if it is stackked plot else y+h of itself
      yBasePos = oldBase1EndAttr ? oldBase1EndAttr[yAttrKey] : zeroPos;
    }
    attr = {};
    // Replace the y and h with initial positions
    attr[yAttrKey] = yBasePos;
    attr[hAttrKey] = 0;
    options.anim.plot.data.push({
      el: setElement,
      // TODO: this should be taken from sume global config
      animType: 'linear',
      // TODO: Call back should be passed
      callback: function callback() {
        // TODO why for 2d ?
        this.hide();
        if (dataSet.removed) {
          dataSet.dispose();
          (0, _eventApi.triggerEvent)('datasetremoved', dataSet);
          dataSet.removed = false;
        }
      },
      attrs: attr,
      animConfig: [{
        syncWith: 'plot',
        start: 0,
        end: dataSet.getFromEnv('numOfColumns') < 1 ? 1 : 0.5
      }]
    });
    // Store the attributes at the end of 1st half plot animation
    dataObj[plot1EKey] = attr;
  },
  // Default animation
  'default': function _default(dataObj, options) {
    // TODO: this should apply the attr directly when there is no animation
    options.anim.plot.data.push({
      el: dataObj && dataObj.graphics && dataObj.graphics.element,
      animType: 'linear',
      attrs: options.attr,
      animConfig: [{
        syncWith: 'plot',
        start: 0,
        end: 1
      }]
    });
  },

  realTimeUpdating: function realTimeUpdating(dataObj, options) {
    var el = dataObj && dataObj.graphics && dataObj.graphics.element,
        attr = (0, _lib.extend2)({}, options.attr),
        y = attr.y,
        height = attr.height;

    delete attr.y;
    delete attr.height;

    options.anim.plot.data.push({
      el: el,
      animType: 'linear',
      attrs: {
        y: y,
        height: height
      },
      animConfig: [{
        syncWith: 'plot',
        hookFn: function hookFn() {
          el.attr(attr);
        }
      }]
    });
  }
};

/**
 * This is the base class(Column class) which is inhereited by the other classes.
 */

var ColumnDataset = function (_ComponentInterface) {
  _inherits(ColumnDataset, _ComponentInterface);

  /**
   * constructor function this class
   */
  function ColumnDataset() {
    _classCallCheck(this, ColumnDataset);

    var _this = _possibleConstructorReturn(this, _ComponentInterface.call(this));

    _this.type = 'column';
    _this.pIndex = 2;
    _this.customConfigFn = '_createDatasets';
    _this.components = {};

    _this.graphics = {};
    return _this;
  }
  /**
   * parse defualt configuration of the chart
   */


  ColumnDataset.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _ComponentInterface.prototype.__setDefaultConfig && _ComponentInterface.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    config.showvalues = UNDEF;
    config.includeinlegend = 1;
    config.plotfillalpha = UNDEF;
    config.plotfillangle = UNDEF;
    config.ratio = UNDEF;
  };

  /**
   * Returns the type of the component
   * @return {string} The type of the component, in this case a dataset.
   */


  ColumnDataset.prototype.getType = function getType() {
    return 'dataset';
  };
  /**
   * Returns the name of the component
   * @return {string} The name of the component, in this case 'column'.
   */


  ColumnDataset.prototype.getName = function getName() {
    return 'column';
  };

  /**
    * Function for parsing all the attributes and value given by the user at chart,dataset and set level.
    * This function is called once from the init() function of the Column class.
    * @param  {Object} datasetJSON JSON for dataset configurations
    * @return {boolean} Indicates whether the configuration was successful or not
    */


  ColumnDataset.prototype.configureAttributes = function configureAttributes(datasetJSON) {
    if (!datasetJSON) {
      return false;
    }
    this.trimData(datasetJSON);
    this.JSONData = datasetJSON;
    var dataSet = this,
        chart = dataSet.getFromEnv('chart'),
        conf = dataSet.config,
        JSONData = dataSet.JSONData,
        singleSeries = chart.singleseries,
        chartConfig = chart.config,
        chartAttr = chart.jsonData.chart,
        colorM = dataSet.getFromEnv('color-manager'),
        index = dataSet.getJSONIndex(),
        plotColor = conf.plotColor = colorM.getPlotColor(index),
        plotBorderDash = (0, _lib.pluckNumber)(JSONData.dashed, chartAttr.plotborderdashed),
        usePlotGradientColor = (0, _lib.pluckNumber)(chartAttr.useplotgradientcolor, 1),
        plotDashLen = void 0,
        plotDashGap = void 0,
        plotBorderThickness = void 0,
        plotFillAlpha = void 0,

    // getDashStyle = lib.getDashStyle,
    isBar = chart.isBar,
        is3D = chart.is3D;

    dataSet.chartGraphics = chart.getGraphicalElement();
    dataSet.__setDefaultConfig();
    conf.defaultPadding = {
      left: 0.5,
      right: 0.5
    };
    (0, _lib.parseConfiguration)(JSONData, conf, chartConfig, { data: true });
    conf.showplotborder = (0, _lib.pluckNumber)(chartAttr.showplotborder, is3D ? 0 : 1);
    plotDashLen = chartConfig.plotborderdashlen;
    plotDashGap = chartConfig.plotborderdashgap;
    conf.plotfillangle = (0, _lib.pluckNumber)(360 - chartAttr.plotfillangle, isBar ? 180 : 90);
    conf.plotfillalpha = plotFillAlpha = (0, _lib.pluck)(JSONData.alpha, chartAttr.plotfillalpha, _lib.HUNDREDSTRING);
    conf.plotColor = plotColor = (0, _lib.pluck)(JSONData.color, plotColor);
    conf.legendSymbolColor = conf.plotColor;
    conf.plotgradientcolor = (0, _lib.getDefinedColor)(chartAttr.plotgradientcolor, colorM.getColor(PLOTGRADIENTCOLOR));
    !usePlotGradientColor && (conf.plotgradientcolor = '');
    conf.plotborderalpha = (0, _lib.pluck)(chartAttr.plotborderalpha, plotFillAlpha, _lib.HUNDREDSTRING);
    conf.plotbordercolor = (0, _lib.pluck)(chartAttr.plotbordercolor, is3D && !singleSeries ? '#ffffff' : colorM.getColor(PLOTBORDERCOLOR));
    conf.plotborderdashstyle = plotBorderDash ? (0, _lib.getDashStyle)(plotDashLen, plotDashGap, plotBorderThickness) : 'none';
    conf.showShadow = is3D ? (0, _lib.pluckNumber)(chartAttr.showshadow, 1) : (0, _lib.pluckNumber)(chartAttr.showshadow, colorM.getColor(SHOWSHADOW));
    conf.definedGroupPadding = mathMax((0, _lib.pluckNumber)(chartAttr.plotspacepercent), 0);

    dataSet.setState('visible', (0, _lib.pluckNumber)(JSONData.visible, 1) === 1);

    if (dataSet.getState('visible') === true) {
      dataSet._conatinerHidden = false;
    } else {
      dataSet._containerHidden = true;
    }
    conf.legendInteractivity = false;
    dataSet.setState('visible', (0, _lib.pluckNumber)(dataSet.getState('visible'), dataSet.JSONData.visible, !Number(dataSet.JSONData.initiallyhidden), 1) === 1);
    dataSet._setConfigure();
    if (dataSet.getState('visible') && dataSet.oldVisible === false) {
      dataSet.appearing = true;
    }

    dataSet.oldVisible = dataSet.getState('visible');
    dataSet._realTimeConfigure && dataSet._realTimeConfigure();

    chart.hasLegend !== false && dataSet._addLegend();
    dataSet.ErrorValueConfigure && dataSet.ErrorValueConfigure();
    dataSet.setState('dirty', true);
  };
  /**
   * function to Remove data plots if the number of current data plots/categories
   * is more than the existing ones.
   * @param  {Object} datasetJSON JSON for dataset configurations
   */


  ColumnDataset.prototype.trimData = function trimData(datasetJSON) {
    if (!this.JSONData) {
      return;
    }
    var dataSet = this,
        config = dataSet.config,
        context = config && config.context,
        prevCatlen = context && context.prevCatlen,
        xAxis = dataSet.getFromEnv('xAxis'),
        currCatLen = xAxis.getCategoryLen(),
        catDiff = prevCatlen - currCatLen,
        prevData = dataSet.JSONData,
        prevDataLength = prevData.data && prevData.data.length,
        currDataLength = datasetJSON.data && datasetJSON.data.length || 0,
        dataDiff = prevDataLength - currDataLength,
        diff = void 0,
        startIndex = void 0;

    if (catDiff > dataDiff) {
      diff = catDiff;
      startIndex = currCatLen;
    } else {
      diff = dataDiff;
      startIndex = currDataLength;
    }

    // Removing data plots if the number of current data plots/categories
    // is more than the existing ones.
    if (diff > 0) {
      this.removeData(startIndex, diff, false);
    }
  };
  /**
   * Function for parsing all the attributes and value given by the user at set level.
   * This function is called once from the configure() function of the Column class.
   * @param  {Object} newDataset JSON for dataset configurations for new data only in a case of realtime chart
   * @param  {number} newIndex JSON for dataset configurations for new data only in a case of realtime chart
   */


  ColumnDataset.prototype._setConfigure = function _setConfigure(newDataset, newIndex) {
    var dataSet = this,
        chart = dataSet.getFromEnv('chart'),
        chartConfig = chart.config,
        conf = dataSet.config,
        JSONData = dataSet.JSONData,
        setDataArr = newDataset || JSONData.data,
        singleSeries = chart.singleseries,
        yAxis = dataSet.getFromEnv('yAxis'),
        xAxis = dataSet.getFromEnv('xAxis'),
        catLen = xAxis.getCategoryLen(),
        len = newDataset ? newDataset.data.length : catLen,
        chartAttr = chart.jsonData.chart,
        colorM = dataSet.getFromEnv('color-manager'),
        showplotborder = conf.showplotborder,
        plotColor = conf.plotColor,
        showTooltip = chartConfig.showtooltip,
        yAxisName = chartConfig.yaxisname,
        xAxisName = chartConfig.xaxisname,
        tooltipSepChar = chartConfig.tooltipsepchar,
        seriesNameInTooltip = chartConfig.seriesnameintooltip,

    // parseTooltext = parseTooltext,
    formatedVal,
        parserConfig,
        setTooltext,
        seriesname,
        macroIndices,
        tempPlotfillAngle,
        toolText,
        plotDashLen = chartConfig.plotborderdashlen,
        plotDashGap = chartConfig.plotborderdashgap,
        plotBorderThickness = chartConfig.plotborderthickness,
        isRoundEdges = (0, _lib.pluckNumber)(chartConfig.useroundedges, 0),
        showHoverEffect = chartConfig.plothovereffect,
        plotfillAngle = conf.plotfillangle,
        plotFillAlpha,
        plotFillRatio,
        plotBorderAlpha,
        plotBorderDashStyle,
        initailPlotBorderDashStyle = conf.plotborderdashstyle,
        setData,
        setValue,
        dataObj,
        config,
        label,
        colorArr,
        hoverColor,
        hoverAlpha,
        hoverGradientColor,
        hoverRatio,
        hoverAngle,
        hoverBorderColor,
        hoverBorderAlpha,
        hoverBorderThickness,
        hoverBorderDashed,
        hoverBorderDashGap,
        hoverBorderDashLen,
        hoverDashStyle,
        hoverColorArr,

    // getDashStyle = lib.getDashStyle,
    dataStore = dataSet.components.data,
        toolTipValue,
        setDisplayValue,
        isDrag = chartConfig.isDrag,
        isBar = chart.isBar,
        is3D = chart.is3D,
        setDataDashed,
        setDataPlotDashLen,
        setDataPlotDashGap,
        i,
        origLabel,
        labelObj,
        maxValue = -Infinity,
        minValue = +Infinity,
        use3dlighting = chartConfig.use3dlighting,
        useDataPlotColorForLabels = chartConfig.usedataplotcolorforlabels,
        tempIndex;

    chartConfig.dragTolerance = isDrag ? (showplotborder && plotBorderThickness > 5 ? plotBorderThickness / 2 + 1 : 5) + HTP : 0;

    if (!dataStore) {
      dataStore = dataSet.components.data = [];
    }

    // Parsing the attributes and values at set level.

    for (i = 0; i < len; i++) {
      if (newDataset) {
        setData = newDataset && newDataset.data[i] || {};

        if (newIndex !== UNDEF) {
          tempIndex = newIndex + i;
          dataObj = dataStore[tempIndex];
        } else {
          tempIndex = dataStore.length - len + i;
          dataObj = dataStore[tempIndex];
        }
      } else {
        dataObj = dataStore[i];
        setData = setDataArr && setDataArr[i] || {};
      }

      config = dataObj && dataObj.config;

      if (!dataObj) {
        dataObj = dataStore[i] = {};
      }

      if (!dataObj.config) {
        config = dataStore[i].config = {};
      }
      config.showValue = (0, _lib.pluckNumber)(setData.showvalue, conf.showvalues);
      config.setValue = setValue = yAxis.getCleanValue(setData.value, (0, _lib.pluckNumber)(chartConfig.stack100percent));
      config.setLink = (0, _lib.pluck)(setData.link);
      config.toolTipValue = toolTipValue = yAxis.dataLabels(setValue);
      config.setDisplayValue = setDisplayValue = (0, _lib.parseUnsafeString)(setData.displayvalue);
      config.displayValue = (0, _lib.pluck)(setDisplayValue, toolTipValue);
      setDataDashed = (0, _lib.pluckNumber)(setData.dashed);
      setDataPlotDashLen = (0, _lib.pluckNumber)(setData.dashlen, plotDashLen);
      setDataPlotDashGap = plotDashGap = (0, _lib.pluckNumber)(setData.dashgap, plotDashGap);

      if (setValue !== null) {
        maxValue = mathMax(maxValue, setValue);
        minValue = mathMin(minValue, setValue);
      }

      chartConfig.dataCount++;

      config.plotBorderDashStyle = plotBorderDashStyle = setDataDashed === 1 ? (0, _lib.getDashStyle)(setDataPlotDashLen, setDataPlotDashGap) : setDataDashed === 0 ? 'none' : initailPlotBorderDashStyle;
      if (singleSeries) {
        plotColor = colorM.getPlotColor((0, _lib.pluckNumber)(tempIndex - len, i));
        plotColor = (0, _lib.pluck)(setData.color, plotColor);
        useDataPlotColorForLabels && xAxis.updateCategory(i, {
          labelfontcolor: (0, _lib.convertColor)(plotColor)
        });
        plotBorderAlpha = (0, _lib.pluck)(setData.alpha, setData.borderalpha, conf.plotborderalpha, plotFillAlpha).toString();
      } else {
        plotColor = (0, _lib.pluck)(setData.color, conf.plotColor);
        plotBorderAlpha = (0, _lib.pluck)(setData.alpha, conf.plotborderalpha, plotFillAlpha).toString();
      }
      plotFillRatio = (0, _lib.pluck)(setData.ratio, conf.ratio);
      plotFillAlpha = (0, _lib.pluck)(setData.alpha, conf.plotfillalpha);

      config.shadow = {
        opacity: conf.showShadow ? plotFillAlpha / 100 : 0
      };
      // Setting the angle for plot fill for negative data
      if (setValue < 0 && !isRoundEdges) {
        tempPlotfillAngle = conf.plotfillangle;
        plotfillAngle = isBar ? 180 - plotfillAngle : 360 - plotfillAngle;
      }

      // Setting the color Array to be applied to the bar/column.
      config.colorArr = colorArr = _lib.graphics.getColumnColor(plotColor + ',' + conf.plotgradientcolor, plotFillAlpha, plotFillRatio, plotfillAngle, isRoundEdges, conf.plotbordercolor, plotBorderAlpha, isBar ? 1 : 0, !!is3D);
      config.originalPlotColor = plotColor;

      labelObj = xAxis.getLabel((0, _lib.pluckNumber)(tempIndex - len, i));
      config.origLabel = origLabel = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)(labelObj.label));
      label = config.label = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)(labelObj.tooltext)) || origLabel;

      // Parsing the hover effects only if showhovereffect is not 0.
      if (showHoverEffect !== 0) {
        hoverColor = (0, _lib.pluck)(setData.hovercolor, JSONData.hovercolor, chartAttr.plotfillhovercolor, chartAttr.columnhovercolor, plotColor);
        hoverAlpha = (0, _lib.pluck)(setData.hoveralpha, JSONData.hoveralpha, chartAttr.plotfillhoveralpha, chartAttr.columnhoveralpha, plotFillAlpha);
        hoverGradientColor = (0, _lib.pluck)(setData.hovergradientcolor, JSONData.hovergradientcolor, chartAttr.plothovergradientcolor, conf.plotgradientcolor);
        !hoverGradientColor && (hoverGradientColor = '');
        hoverRatio = (0, _lib.pluck)(setData.hoverratio, JSONData.hoverratio, chartAttr.plothoverratio, plotFillRatio);
        hoverAngle = (0, _lib.pluckNumber)(360 - setData.hoverangle, 360 - JSONData.hoverangle, 360 - chartAttr.plothoverangle, plotfillAngle);
        hoverBorderColor = (0, _lib.pluck)(setData.borderhovercolor, JSONData.borderhovercolor, chartAttr.plotborderhovercolor, conf.plotbordercolor);
        hoverBorderAlpha = (0, _lib.pluck)(setData.borderhoveralpha, JSONData.borderhoveralpha, chartAttr.plotborderhoveralpha, chartAttr.plotfillhoveralpha, chartAttr.columnhoveralpha, plotBorderAlpha, plotFillAlpha);
        hoverBorderThickness = (0, _lib.pluckNumber)(setData.borderhoverthickness, JSONData.borderhoverthickness, chartAttr.plotborderhoverthickness, conf.showplotborder && plotBorderThickness);
        hoverBorderDashed = setData.borderhoverdashed || JSONData.borderhoverdashed || chartAttr.plotborderhoverdashed;
        hoverBorderDashGap = (0, _lib.pluckNumber)(setData.borderhoverdashgap, JSONData.borderhoverdashgap, chartAttr.plotborderhoverdashgap, plotDashLen);
        hoverBorderDashLen = (0, _lib.pluckNumber)(setData.borderhoverdashlen, JSONData.borderhoverdashlen, chartAttr.plotborderhoverdashlen, plotDashGap);
        hoverDashStyle = hoverBorderDashed !== UNDEF ? Number(hoverBorderDashed) ? (0, _lib.getDashStyle)(hoverBorderDashLen, hoverBorderDashGap) : '' : plotBorderDashStyle;

        /* If no hover effects are explicitly defined and
          * showHoverEffect is not 0 then hoverColor is set.
          */
        if (chartConfig.drawTrendRegion || showHoverEffect == 1 && hoverColor === plotColor) {
          hoverColor = getLightColor(hoverColor, 70);
        }
        // setting the hover color array which is always applied except when showHoverEffect is not 0.
        hoverColorArr = _lib.graphics.getColumnColor(hoverColor + ',' + hoverGradientColor, hoverAlpha, hoverRatio, hoverAngle, isRoundEdges, hoverBorderColor, hoverBorderAlpha.toString(), isBar ? 1 : 0, !!is3D);
        config.setRolloutAttr = {
          fill: !is3D ? (0, _lib.toRaphaelColor)(colorArr[0]) : [(0, _lib.toRaphaelColor)(colorArr[0]), !use3dlighting],
          stroke: showplotborder && (0, _lib.toRaphaelColor)(colorArr[1]),
          'stroke-width': plotBorderThickness,
          'stroke-dasharray': plotBorderDashStyle
        };
        config.setRolloverAttr = {
          fill: !is3D ? (0, _lib.toRaphaelColor)(hoverColorArr[0]) : [(0, _lib.toRaphaelColor)(hoverColorArr[0]), !use3dlighting],
          stroke: showplotborder && (0, _lib.toRaphaelColor)(hoverColorArr[1]),
          'stroke-width': hoverBorderThickness,
          'stroke-dasharray': hoverDashStyle
        };
      }

      formatedVal = config.toolTipValue;
      // Parsing tooltext against various configurations provided by the user.
      config.origToolText = setTooltext = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(setData.tooltext, JSONData.plottooltext, chartAttr.plottooltext)));
      if (!showTooltip) {
        toolText = false;
      } else {
        if (formatedVal === null) {
          toolText = false;
        } else if (setTooltext !== UNDEF) {
          macroIndices = [1, 2, 3, 4, 5, 6, 7];
          parserConfig = {
            yaxisName: yAxisName,
            xaxisName: xAxisName,
            formattedValue: formatedVal,
            label: label
          };
          toolText = (0, _lib.parseTooltext)(setTooltext, macroIndices, parserConfig, setData, chartAttr, JSONData);
        } else {
          if (seriesNameInTooltip) {
            seriesname = (0, _lib.getFirstValue)(JSONData && JSONData.seriesname);
          }
          toolText = seriesname ? seriesname + tooltipSepChar : '';
          toolText += label ? label + tooltipSepChar : '';
        }
      }
      config.toolText = toolText;
      config.setTooltext = toolText;
      tempPlotfillAngle && (plotfillAngle = tempPlotfillAngle);

      tempIndex++;
      config._x = i;
      config._y = setValue;
    }
    conf.maxValue = maxValue;
    conf.minValue = minValue;
  };

  /**
   * Recalculate Y position of plot for stack
   */


  ColumnDataset.prototype.updateYForStack = function updateYForStack() {
    var dataSet = this,
        JSONData = dataSet.JSONData,
        chartAttr = dataSet.getFromEnv('chart').jsonData.chart,
        xAxis = dataSet.getFromEnv('xAxis'),
        dataObj,
        config,
        i,
        len = xAxis.getCategoryLen(),
        components = dataSet.components,
        dataStore = components.data,
        setTooltext,
        stackValues = dataSet.getFromEnv('stackValues'),
        stackSumValue;

    for (i = 0; i < len; i++) {
      dataObj = dataStore[i];
      config = dataObj && dataObj.config;

      if (dataObj === UNDEF) {
        continue;
      }

      setTooltext = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(config.origToolText, JSONData.plottooltext, chartAttr.plottooltext)));
      /*
        * If it is a stacked chart then the display value, tooltext value and data plots
        * (if stack 100percent is active) is recalculated.
        */
      stackSumValue = stackValues[i] && stackValues[i].positive + stackValues[i].negative || 1;
      config._b = dataSet._parseValues(i, config._b, stackSumValue, setTooltext);
      config._y = config.value + config._b;
    }
  };
  /**
   * This function is called from draw() of each data plot of a dataset if it is a stacked chart and
   * is used for setting proper data for the tooltip and display value.
   * @param {number} index          - index of the data plot for which variable values has to be calculated.
   * @param {number} previousY      - previous sum value of the stack from the current plot.
   * @param {number} stackSumValue  - the total of all the data plots in a stack in a dataset.
   * @param {string} setTooltext    - semi-formatted tooltext entered by the user.
   * @return {number} previousY      - previous sum value of the stack from the current plot.
   */


  ColumnDataset.prototype._parseValues = function _parseValues(index, previousY, stackSumValue, setTooltext) {
    var dataSet = this,
        chartConfig = dataSet.getFromEnv('chartConfig'),
        config = dataSet.components.data[index].config,
        showPercentValues = (0, _lib.pluckNumber)(chartConfig.showpercentvalues),
        showPercentInToolTip = (0, _lib.pluckNumber)(chartConfig.showpercentintooltip),
        visible = dataSet.getState('visible'),
        setValue = config.setValue,
        stack100Percent = (0, _lib.pluckNumber)(chartConfig.stack100percent),
        numberFormatter = dataSet.getFromEnv('number-formatter'),
        yAxis = dataSet.getFromEnv('yAxis'),
        setDisplayValue = config.setDisplayValue,
        formatedPercentValue,
        percentValue;

    percentValue = (visible ? setValue || 0 : 0) / stackSumValue * 100;
    formatedPercentValue = numberFormatter.percentValue(percentValue);

    if (stack100Percent) {
      config.value = percentValue;
      previousY = (previousY || 0) / stackSumValue * 100;
    }
    if (showPercentInToolTip) {
      config.toolTipValue = formatedPercentValue;
    }

    if (showPercentValues) {
      !setDisplayValue && (config.displayValue = formatedPercentValue);
    }

    // Applying macros at set level.
    if (setTooltext) {
      config.toolText = (0, _lib.parseTooltext)(config.setTooltext, [14, 24, 25, 112], {
        percentValue: formatedPercentValue,
        sum: yAxis.dataLabels(stackSumValue),
        unformattedSum: stackSumValue
      });
    }
    return previousY;
  };
  /**
   * Function to register datasets in the internal data store of legend class.
   */


  ColumnDataset.prototype._addLegend = function _addLegend() {
    var dataset = this,
        chart = dataset.getFromEnv('chart'),
        isBar = chart.isBar,
        chartAttr = dataset.getFromEnv('chart-attrib'),
        strokeColor,
        fillColor,
        lightColor,
        config,
        conf = dataset.config,
        color = (0, _lib.getFirstColor)(conf.legendSymbolColor),
        legend = dataset.getFromEnv('legend'),
        use3DLighting = (0, _lib.pluckNumber)(chartAttr.use3dlighting, chartAttr.useplotgradientcolor, 1);
    strokeColor = getLightColor(color, 60).replace(dropHash, _lib.HASHSTRING);
    if (use3DLighting) {
      lightColor = getLightColor(color, 40);
      fillColor = {
        FCcolor: {
          color: color + ',' + color + ',' + lightColor + ',' + color + ',' + color,
          ratio: '0,30,30,30,10',
          angle: isBar ? 0 : 270,
          alpha: '100,100,100,100,100'
        }
      };
    } else {
      fillColor = {
        FCcolor: {
          color: color,
          angle: isBar ? 0 : 270,
          ratio: '0',
          alpha: '100'
        }
      };
    }
    config = {
      enabled: conf.includeinlegend,
      type: dataset._plotType || dataset.type,
      fillColor: (0, _lib.toRaphaelColor)(fillColor),
      strokeColor: (0, _lib.toRaphaelColor)(strokeColor),
      rawFillColor: color,
      rawStrokeColor: color,
      label: (0, _lib.getFirstValue)(dataset.JSONData.seriesname)
    };
    dataset.legendItemId = legend.addItems(dataset, dataset.legendInteractivity, config);
  };

  /**
   * Fuction to be fired on legend click
   * @param  {Object} dataSet    on which dataset legend interaction occured
   * @param  {Object} legendItem which legend is clicked
   */


  ColumnDataset.prototype.legendInteractivity = function legendInteractivity(dataSet, legendItem) {
    var legend = this,
        chart = legend.getFromEnv('chart'),
        legendConfig = legend.config,
        visible = dataSet.getState('visible'),
        dsConfig = dataSet.config,
        config = legendItem.config,
        legendGraphics = legendItem.graphics,
        itemHiddenStyle = legendConfig.itemHiddenStyle,
        hiddenColor = itemHiddenStyle.color,
        itemStyle = legendConfig.itemStyle,
        itemTextColor = itemStyle.color,
        color = config.fillColor,
        attrObj,
        type,
        element,
        stroke = config.strokeColor;

    chart.state = 'legendInteraction';
    dsConfig.legendInteractivity = true;
    visible ? dataSet.hide() : dataSet.show();
    attrObj = {
      'legendItemSymbol': {
        fill: visible ? hiddenColor : color,
        'stroke': visible ? hiddenColor : stroke
      },
      legendItemText: {
        fill: visible ? hiddenColor : itemTextColor
      },
      legendItemLine: {
        'stroke': visible ? hiddenColor : stroke
      }
    };

    for (type in legendGraphics) {
      element = legendGraphics[type];
      if (element && attrObj[type]) {
        element.attr(attrObj[type]);
      }
    }
    if (!dsConfig.drawnEvtListenerAttached) {
      dsConfig.drawnEvtListenerAttached = true;
      dataSet.addEventListener('drawn', function () {
        dsConfig.legendInteractivity = false;
      });
    }
  };
  /**
   * Creates Pinnable graphics of a dataset for Pin feature
   */


  ColumnDataset.prototype.createPinElem = function createPinElem() {
    var dataset = this,
        chart = dataset.getFromEnv('chart'),
        group = arguments[1].group,
        dataStore = dataset.components.data,
        element,
        pinElems = dataset.graphics.pinElems || (dataset.graphics.pinElems = []),
        columnGroup = dataset.getLinkedItems().vcanvas.getChildContainer().columnVcanvasGroup,
        i,
        pinEl,
        dataObj;

    for (i = pinElems.length - 1; i >= 0; i--) {
      pinElems[i].remove();
      pinElems.pop();
    }

    if (dataset.getState('visible')) {
      for (i = dataset.config.scrollMinVal; i < dataset.config.scrollMaxVal; i++) {
        dataObj = dataStore[i];
        if (dataObj && dataObj.graphics) {
          element = dataObj.graphics.element;
          pinEl = element.clone().attr({
            'transform': ['T', -(chart.config._visx + mathAbs(columnGroup.transform()[0][1])), -chart.config.canvasBottom]
          });
          group.appendChild(pinEl);
          pinElems.push(pinEl);
        }
      }
    }
  };

  /**
   * function to check if given x,y coordiante is over a column plot or not
   * @param  {number} pX     index of column
   * @param  {number} chartX x co-ordinate
   * @param  {number} chartY y co-ordinate
   * @return {Object}        hovered information
   */


  ColumnDataset.prototype._checkPointerOverColumn = function _checkPointerOverColumn(pX, chartX, chartY) {
    var dataset = this,
        chart = dataset.getFromEnv('chart'),
        chartConfig = chart.config,

    // xAxis = dataset.getFromEnv('xAxis'),
    // xAxisRange = xAxis.getAxisConfig('axisRange'),
    // xAxisTotalRange = xAxisRange.max - xAxisRange.min,
    // xAxisVisibleConfig = xAxis.getVisibleConfig(),
    // xAxisVisibleRange = xAxisVisibleConfig.maxValue - xAxisVisibleConfig.minValue,
    plotBorderThickness = chartConfig.plotborderthickness,
        showPlotBorder = chartConfig.showplotborder,
        components = dataset.components,
        dataStore = components.dataRT || components.data,
        pointObj /* = dataStore[pX] */
    ,
        pY,
        dx,
        dy,
        hovered,
        halfPlotBorderThickness,

    // viewPortConfig = chartConfig.viewPortConfig,
    // x = xAxis.getPixel(xAxisRange.min) - xAxis.getPixel(xAxisVisibleConfig.minValue),
    // scaleX = xAxisTotalRange / xAxisVisibleRange,
    plotsPerBin = dataset.config.plotsPerBin || 1,
        lenDataStore = dataStore && dataStore.length,
        i,
        heightTolerance = 0,
        widthTolerance = 0,
        numBin = mathCeil(pX / plotsPerBin),
        binStrtIndex = (numBin - 1) * plotsPerBin + 1,
        binStopIndex = binStrtIndex + plotsPerBin - 1,
        dragTolerance = chartConfig.dragTolerance || 0;

    binStopIndex = binStopIndex < lenDataStore ? binStopIndex : lenDataStore;
    for (i = binStopIndex; i >= binStrtIndex; i--) {
      pointObj = dataStore[i];
      if (!pointObj) {
        return;
      }

      // Setting the tolerance incase of small height or width of column/bar
      if (pointObj._height < HTP) {
        heightTolerance = HTP;
      }
      if (pointObj._width < HTP) {
        widthTolerance = HTP;
      }

      if (!pointObj._xPos && !pointObj._yPos) {
        continue;
      }
      pY = pointObj.config.setValue;

      if (showPlotBorder && plotBorderThickness !== UNDEF) {
        halfPlotBorderThickness = plotBorderThickness / 2;

        // halfPlotBorderThickness = halfPlotBorderThickness % 2 === 0 ? halfPlotBorderThickness + 1 :
        //     Math.round(halfPlotBorderThickness);
      } else {
        plotBorderThickness = halfPlotBorderThickness = 0;
      }

      if (pY !== null) {
        dx = chartX - pointObj._xPos + halfPlotBorderThickness;
        dy = chartY - pointObj._yPos + halfPlotBorderThickness + (pY >= 0 ? dragTolerance : 0);
        hovered = dx >= -widthTolerance / 2 && dx <= (widthTolerance || pointObj._width) + plotBorderThickness && dy >= -heightTolerance / 2 && dy <= (heightTolerance || pointObj._height) + plotBorderThickness + (pY < 0 ? 2 * dragTolerance : dragTolerance);

        if (hovered) {
          return {
            pointIndex: i,
            hovered: hovered,
            pointObj: dataStore[i]
          };
        }
      }
    }
  };

  /**
   * Function that retunr the nearest plot details
   * @param {number} chartX x-axis position of the mouse cordinate
   * @param {number} chartY x-axis position of the mouse cordinate
   * @return {Object} return an object with details of nearest polt and whether it is hovered or not
   */


  ColumnDataset.prototype._getHoveredPlot = function _getHoveredPlot(chartX, chartY) {
    var dataset = this,
        chart = dataset.getFromEnv('chart'),
        isBar = chart.isBar,
        xAxis = dataset.getFromEnv('xAxis'),
        x,
        pX;

    chartX += xAxis.getTranslation();

    x = xAxis.getValue(isBar ? chartY : chartX);
    pX = Math.round(x);

    // Checking for overlap between two cosecutive column plots along x-axis
    return pX - x > 0 ? dataset._checkPointerOverColumn(pX, chartX, chartY) || dataset._checkPointerOverColumn(pX - 1, chartX, chartY) : dataset._checkPointerOverColumn(pX + 1, chartX, chartY) || dataset._checkPointerOverColumn(pX, chartX, chartY);
  };

  /**
   * Helper function of _firePlotEvent which decides single/consolidated tooltip
   * @param {number} plotIndex      plot index
   * @param {Object} e              reference of the original mouse event
   */


  ColumnDataset.prototype._decideTooltipType = function _decideTooltipType(plotIndex, e) {
    var dataset = this,

    // group = dataset.groupManager,
    chart = dataset.getFromEnv('chart'),
        drawTrendRegion = chart.config.drawTrendRegion,
        components = dataset.components,
        toolTipController = dataset.getFromEnv('toolTipController'),
        dataStore = components.dataRT || components.data,
        data = dataStore[plotIndex],
        toolText = data && (data.config.finalTooltext || data.config.toolText),
        element = data && (data.graphics.element || dataset.graphics.sharedAnchor.element),
        currentToolTip = dataset.config.currentToolTip,
        originalEvent = e.originalEvent;

    if (drawTrendRegion && element) {
      // @TODO validate this code after drawTrendRegion revamp
      // group._drawTooltip(plotIndex, datasetIndex, originalEvent);
    } else if (toolText && !drawTrendRegion) {
      if (currentToolTip) {
        toolTipController.draw(originalEvent, toolText, currentToolTip);
      } else {
        currentToolTip = dataset.config.currentToolTip = toolTipController.draw(originalEvent, toolText);
      }
      // tip.customDraw(toolText, paper, originalEvent, UNDEF, UNDEF, chart.chartInstance.id);
    }
  };

  /**
   * This method handles all mouse events of an dataset.
   * @param {string} eventType    name of the event
   * @param {number} plotIndex    index of the plot where this event has been occured
   * @param {Event}  e            reference of the original mouse event
   */


  ColumnDataset.prototype._firePlotEvent = function _firePlotEvent(eventType, plotIndex, e) {
    var dataset = this,
        chart = dataset.getFromEnv('chart'),
        components = dataset.components,
        toolTipController = dataset.getFromEnv('toolTipController'),
        dataStore = components.dataRT || components.data,
        data = dataStore[plotIndex],
        setElement = data.graphics.element,
        toolTip = dataset.config.currentToolTip,
        originalEvent = e.originalEvent,
        style = chart.getFromEnv('paper').canvas.style,
        config,
        setLink;

    if (setElement) {
      config = data.config;
      setLink = config.setLink;
      switch (eventType) {
        case 'mouseover':
          dataset._decideTooltipType(plotIndex, e);
          _rolloverResponseSetter(chart, data, originalEvent);
          setLink && (style.cursor = POINTER);
          break;
        case 'mouseout':
          toolTipController.hide(toolTip);
          _rolloutResponseSetter(chart, data, originalEvent);
          setLink && (style.cursor = DEFAULT_CURSOR);
          break;
        case 'click':
          _lib.plotEventHandler.call(setElement, chart, originalEvent);
          break;
        case 'mousemove':
          dataset._decideTooltipType(plotIndex, e);
      }
    }
  };
  /**
   * function to create group for dataset
   */


  ColumnDataset.prototype.createContainer = function createContainer() {
    var dataset = this,
        dsType = dataset.type,
        groupName = dataset.groupName,
        chart = dataset.getFromEnv('chart'),
        parent = dataset.getLinkedParent(),
        paper = dataset.getFromEnv('paper'),
        group = groupName || dataset.dsGroup || dsType,
        parentContainer,
        parentShadowContainer;

    !parent.getChildContainer(group + 'VcanvasGroup') && (group = 'default');
    parentContainer = parent.getChildContainer(group + 'VcanvasGroup');
    parentShadowContainer = parent.getChildContainer(group + 'ShadowVcanvasGroup');

    !dataset.getContainer('shadowGroup') && dataset.addContainer('shadowGroup', createGroup('shadow-group', paper, parentShadowContainer));

    !dataset.getContainer('errorShadowGroup') && dataset.addContainer('errorShadowGroup', createGroup('error-shadow-group', paper, parentShadowContainer));

    !dataset.getContainer('commonElemsGroup') && dataset.addContainer('commonElemsGroup', createGroup('common-elems-group', paper, parentContainer));

    !dataset.getContainer('plotGroup') && dataset.addContainer('plotGroup', createGroup('plot-group', paper, parentContainer));

    !dataset.getContainer('errorPlotGroup') && dataset.addContainer('errorPlotGroup', createGroup('error-plot-group', paper, parentContainer));
    chart.hasAnchor && dataset.getContainer('errorPlotGroup').insertBefore(dataset.getContainer('plotGroup'));
    !dataset.getContainer('labelGroup') && dataset.addContainer('labelGroup', createGroup('label-group', paper, parent.getChildContainer('vcanvasLabelGroup')).attr('class', 'fusioncharts-datalabels')).attr('opacity', 1);
  };

  /**
   * Create pixel coordinates for the plots
   */


  ColumnDataset.prototype.createCoordinates = function createCoordinates() {
    var dataSet = this,
        dsComponents = dataSet.components,
        dsData = dsComponents.data,
        chart = dataSet.getFromEnv('chart'),
        isBar = chart.isBar,
        yAxis = dataSet.getFromEnv('yAxis'),
        xAxis = dataSet.getFromEnv('xAxis'),
        yBase = yAxis.getAxisBase(),
        yBasePos = yAxis.getAxisPosition(yBase),
        isVertical = xAxis.config.isVertical,
        dataObj,
        config,
        previousY,
        i,
        Px,
        Py,
        Pb,
        xDepth = chart.config.xDepth || 0,
        yDepth = chart.config.yDepth || 0,
        len = dsData.length,
        components = dataSet.components,
        groupManager = dataSet.getLinkedParent(),
        stackConf = groupManager.getstackConf && groupManager.getstackConf(),
        dataStore = components.data;

    !isBar && (xDepth = -xDepth);
    isBar && (yDepth = -yDepth);

    for (i = 0; i < len; i++) {
      dataObj = dataStore[i];
      config = dataObj && dataObj.config;

      if (dataObj === UNDEF) {
        continue;
      }
      previousY = config._b;
      Px = xAxis.getAxisPosition(stackConf && stackConf[i].x || config._x) + xDepth;
      Py = yAxis.getAxisPosition(config._y) + yDepth;
      Pb = (previousY ? yAxis.getAxisPosition(previousY) : yBasePos) + yDepth;
      if (isVertical) {
        config._Px = Py;
        config._Py = Px;
        config._Pby = Px;
        config._Pbx = Pb;
      } else {
        config._Px = Px;
        config._Py = Py;
        config._Pby = Pb;
        config._Pbx = Px;
      }
      if (dataSet.getLineShift) {
        config._Py += dataSet.getLineShift('y');
      }
    }
  };

  /**
   * Set visibilty of containers
   * @param {boolean} show whether visible or not
   */


  ColumnDataset.prototype.setContainerVisibility = function setContainerVisibility(show) {
    var dataSet = this,

    // graphics = dataSet.graphics,
    containers = dataSet.getContainer(),
        container;

    for (container in containers) {
      if (containers.hasOwnProperty(container)) {
        if (dataSet.getState('visible') === false && (dataSet._conatinerHidden === false || dataSet._conatinerHidden === UNDEF) && !show) {
          containers[container].hide();
          dataSet._conatinerHidden = true;
        } else {
          containers[container].show();
          dataSet._conatinerHidden = false;
        }
      }
    }
  };

  // Function to judge if the labels can be draw immediately
  // drawLabelImmediately () {
  //   var dataset = this,
  //     chartConfig = dataset.getFromEnv('chart').config,
  //     drawLabelInitially = chartConfig.drawLabelInitially;
  //   return dataset.drawn || drawLabelInitially ||
  //     ((drawLabelInitially === UNDEF) && chartConfig.dataCount <= 1000);
  // },
  /**
   * Manages the animation of plot elements
   * @param {Object} dataObj reference of a specific data plot
   * @param {Object} attrObj reference of attr of the data plot
   * @param {Object} anim    object reference for animation manager
   * @param {number} i       index
   */


  ColumnDataset.prototype.plotAnimManager = function plotAnimManager(dataObj, attrObj, anim, i) {
    var dataSet = this,
        chart = dataSet.getFromEnv('chart'),
        realtimeUpdate = chart.state === 'realTimeUpdate',
        is3D = chart.is3d,
        chartConfig = chart.config,
        visible = dataSet.getState('visible'),
        paper = dataSet.getFromEnv('paper'),
        yAxis = dataSet.getFromEnv('yAxis'),
        plot2EndAttr = attrObj.position,

    // cosmeticAttr = attrObj.cosmetics,
    xPos = plot2EndAttr.x,
        components = dataSet.components,
        setElement,
        setValue,
        config,

    // TODO: need to have similar place in case of 3d as well
    container,
        pool = components.pool || (components.pool = {
      element: [],
      hotElement: [],
      label: []
    }),
        newZeroPos = yAxis.getAxisPosition(yAxis.getAxisBase()),
        isNegative,
        state = 'update',
        stateAnimator,
        attr;

    config = dataObj && dataObj.config;
    setValue = config && config.setValue;
    isNegative = setValue < 0;

    // For the 3d Chanrts the containers are different to make the 3D looks proper
    if (is3D) {
      container = (isNegative ? chart.datasetLayers.negativeGroupArray : chart.datasetLayers.positiveGroupAarray)[i];
    } else {
      container = dataSet.getContainer('plotGroup');
    }

    if (!(setElement = dataObj.graphics.element)) {
      // If any column graphics element is there in the pool then use it and position it.
      if (pool && pool.element.length) {
        setElement = dataObj.graphics.element = pool.element.pop();
      } else {
        setElement = dataObj.graphics.element = paper[is3D ? 'cubepath' : 'rect'](container);
      }
      realtimeUpdate && setElement.attr({
        x: plot2EndAttr.x,
        height: 0,
        y: newZeroPos,
        width: plot2EndAttr.width
      });
      state = 'appearing';
      // animStates.appearing.call(dataSet, dataObj, attrObj, anim, i, yBasePos);
    } else if (dataSet.appearing) {
      state = 'appearing';
      // animStates.appearing.call(dataSet, dataObj, attrObj, anim, i, yBasePos);
    } else {
      if (visible) {
        // For visible plots
        state = 'updating';
        // animStates.updating.call(dataSet, dataObj, attrObj, anim);
      } else {
        state = 'hidding';
        // animStates.hidding.call(dataSet, dataObj, attrObj, anim);
      }
    }

    if (is3D) {
      container.appendChild(setElement._.cubetop);
      container.appendChild(setElement._.cubeside);
      container.appendChild(setElement);
      if (chartConfig.isstacked && isNegative) {
        setElement.toBack();
      }
    }

    // TODO: update this function
    state = realtimeUpdate ? 'realTimeUpdating' : chartConfig.isSingleStepAnim ? 'default' : state;
    stateAnimator = animStates[state] ? animStates[state] : animStates['default'];
    // TODO: will remove this non-IE < 8 compitable code
    attr = (0, _assign2['default'])(attrObj.position, attrObj.cosmetics);
    stateAnimator(dataObj, {
      attr: attr,
      anim: anim,
      i: i,
      ds: dataSet
    });

    config._oldPx = config._Px;
    config._oldX = xPos;
    // TODO remove this code. Temporary code to make animation working
    // Also, for hiding datasets this should be UNDEF
    visible && (dataObj.oldPrevDataObj = dataObj.prevDataObj);
  };
  /**
   * function to reuse dataplots on scroll draw. When scrolling is apllied on a scroll chart then those
   * plots which are outside of the view port are reused to draw new plot by appliying new attribute.
   * So that when number of data plots is huge; the number of dom elements do not get increased.
   * @param {number} start  start index
   * @param {number} end    end index
   */


  ColumnDataset.prototype.reuseFN = function reuseFN(start, end) {
    var dataSet = this,
        components = dataSet.components,
        dataStore = components.data,
        pool = components.pool || (components.pool = {
      element: [],
      hotElement: [],
      label: []
    }),
        prop,
        graphics,
        i;

    for (i = start; i < end; i++) {
      graphics = dataStore[i] && dataStore[i].graphics || {};
      for (prop in graphics) {
        if (!pool[prop]) {
          pool[prop] = [];
        }
        if (graphics[prop]) {
          pool[prop].push(graphics[prop].hide());
          delete graphics[prop];
        }
      }
    }
  };
  /**
   * function to decide whether the plot should be drawn or skipped
   * @param {Object} dataObj reference of data plot object
   * @return {boolean}       whether skip or not
   */


  ColumnDataset.prototype.doSkip = function doSkip(dataObj) {
    var dataSet = this,
        chart = dataSet.getFromEnv('chart'),
        chartConfig = chart.config,
        config = dataObj && dataObj.config,
        isSkipped = config && config.isSkipped,
        isStacked = chartConfig.isstacked,
        isDrag = chartConfig.isDrag,
        tempGraphics,
        conf = dataSet.config,
        dataSkipped = conf.isSkippedData,
        legendInteractivity = conf.legendInteractivity,
        drawn = dataSet.drawn,
        visible = dataSet.getState('visible'),
        domElement;

    if (dataObj === UNDEF || isSkipped === true) {
      tempGraphics = dataObj && dataObj.graphics;
      if (tempGraphics) {
        tempGraphics.element && tempGraphics.element.hide();
      }
      config && delete config.isSkipped;
      return true;
    }

    domElement = dataObj.graphics && dataObj.graphics.element;
    // condition arises when data skipping logic applied for huge number of data
    if (dataSkipped !== false && drawn && !isStacked && !isDrag && legendInteractivity && (!visible && !domElement || visible && domElement && dataObj._width !== 0 && dataObj._height !== 0)) {
      return true;
    }

    return false;
  };
  /**
   * function to check if the context of dataset is chanegd or not
   * if changed then it will return staus true. It is for further infomormation to redraw a dataset
   * @return {boolean} status of context change
   */


  ColumnDataset.prototype._contextChanged = function _contextChanged() {
    if (!this.config.context) {
      this.config.context = {};
    }
    var dataset = this,
        context = dataset.config.context,
        oldShift = context.shift,
        xAxis = dataset.getFromEnv('xAxis'),
        yAxis = dataset.getFromEnv('yAxis'),
        stringifiedOldLimits = context.axisLimit,
        stringifiedNewLimits = void 0,
        status = false,
        newAxisLimit = {
      yAxis: {
        limit: yAxis.getVisibleConfig()
      },
      xAxis: {
        limit: xAxis.getVisibleConfig()
      }
    };
    newAxisLimit.yAxis.limitPixel = {
      min: yAxis.getPixel(newAxisLimit.yAxis.limit.min),
      max: yAxis.getPixel(newAxisLimit.yAxis.limit.max)
    };
    newAxisLimit.xAxis.limitPixel = {
      min: xAxis.getPixel(newAxisLimit.xAxis.limit.min),
      max: xAxis.getPixel(newAxisLimit.xAxis.limit.max)
    };

    stringifiedNewLimits = (0, _stringify2['default'])(newAxisLimit);

    if (stringifiedOldLimits !== stringifiedNewLimits) {
      context.axisLimit = stringifiedNewLimits;
      status = true;
    }
    if (oldShift !== dataset.getFromEnv('shift')) {
      context.shift = dataset.getFromEnv('shift');
      status = true;
    }
    if (context.prevColNum !== dataset.getFromEnv('numOfColumns')) {
      context.prevColNum = dataset.getFromEnv('numOfColumns');
      status = true;
    }

    if (context.prevCatlen !== xAxis.getCategoryLen()) {
      context.prevCatlen = xAxis.getCategoryLen();
      status = true;
    }
    if (this.getFromEnv('chart').isRealTime) {
      return true;
    }
    return status;
  };
  /**
   * calculate min and max position to scroll
   */


  ColumnDataset.prototype.calculateScrollPos = function calculateScrollPos() {
    var dataset = this,
        conf = dataset.config,
        xAxis = dataset.getFromEnv('xAxis'),
        len = xAxis.getCategoryLen();
    conf.scrollMinVal = mathMax(mathRound(xAxis.getVisibleConfig().minValue), 0) - 1;
    conf.scrollMaxVal = mathMin(mathRound(xAxis.getVisibleConfig().maxValue) + 1, len) + 1;
  };
  /**
   * functioto draw and update the graphics elements of plots
   * @param {Object} anim    - object reference of animation manager argument
   *                           consist of elements and their configuration
   */


  ColumnDataset.prototype.drawPlots = function drawPlots(anim) {
    var dataSet = this,
        JSONData = dataSet.JSONData,
        chart = dataSet.getFromEnv('chart'),
        chartAttr = chart.jsonData.chart,
        conf = dataSet.config,

    // legendInteractivity = conf.legendInteractivity,
    groupManager = dataSet.groupManager,
        datasetIndex = dataSet.getJSONIndex(),
        i,
        visible = dataSet.getState('visible'),
        chartConfig = chart.config,
        is3D = chart.is3d,
        xDepth = chartConfig.xDepth || 0,
        yDepth = chartConfig.yDepth || 0,

    // isDrag = chartConfig.isDrag,
    showHoverEffect = chartConfig.plothovereffect,
        yAxis = dataSet.getFromEnv('yAxis'),
        xAxis = dataSet.getFromEnv('xAxis'),
        xPos,
        yPos,
        crispBox,
        showTooltip = chartConfig.showtooltip,
        initialColumnWidth,
        xPosOffset,
        yPosOffset,
        initialColumnHeight,
        columnWidth,
        height,
        toolText,
        components = dataSet.components,
        dataStore = components.data,
        dataObj,
        setTooltext,
        setElement,
        setLink,
        setValue,
        displayValue,
        config,

    // drawn = dataSet.drawn,
    yBase = yAxis.getAxisBase(),
        yBasePos = yAxis.yBasePos = yAxis.getAxisPosition(yBase),
        plotBorderThickness = chartConfig.plotborderthickness,
        plotRadius = (0, _lib.pluckNumber)(chartConfig.useroundedges, 0),
        shadowContainer = dataSet.getContainer('shadowGroup'),
        colorArr,
        plotBorderDashStyle,
        trackerConfig,
        dataSkipped = conf.isSkippedData,
        attrObj,
        Px,
        Py,
        tempWidth,
        tempHeight,
        use3DLighting = conf.use3dlighting,
        yAxisLimit,
        currentYBaseTouched,
        scrollMinVal,
        scrollMaxVal,
        _oldStartIndex = conf._oldStartIndex,
        _oldEndIndex = conf._oldEndIndex,
        visibleStart,
        visibleEnd,
        maxPx,
        minPx,
        stackConf = groupManager && groupManager.stackConf,
        tunedAttr,
        outerAnimCallBack = function outerAnimCallBack() {
      dataSet.setContainerVisibility();
    },
        shift,
        shadow,
        viewPortConfig = chart.config.viewPortConfig,
        x = viewPortConfig.x,
        scaleX = viewPortConfig.scaleX,
        showPlotBorder = (0, _lib.pluckNumber)(chartConfig.showplotborder);

    dataSet.deleteFromEnv('columnWidth');

    dataSet.setColumnPosition();
    shift = dataSet.getFromEnv('columnXShift');
    yAxisLimit = yAxis.getLimit();
    maxPx = yAxis.getAxisPosition(yAxisLimit.max);
    minPx = yAxis.getAxisPosition(yAxisLimit.min);
    if (maxPx > minPx) {
      conf.yAxisMaxPixel = maxPx;
      conf.yAxisMinPixel = minPx;
    } else {
      conf.yAxisMaxPixel = minPx;
      conf.yAxisMinPixel = maxPx;
    }

    dataSet.calculateScrollPos();
    scrollMinVal = conf.scrollMinVal;
    scrollMaxVal = conf.scrollMaxVal;
    if (scrollMinVal > _oldStartIndex) {
      dataSet.reuseFN(_oldStartIndex, scrollMinVal > _oldEndIndex ? _oldEndIndex : scrollMinVal);
    }
    if (scrollMaxVal < _oldEndIndex) {
      dataSet.reuseFN(scrollMaxVal < _oldStartIndex ? _oldStartIndex : scrollMaxVal, _oldEndIndex);
    }

    visibleStart = scrollMinVal > _oldStartIndex ? scrollMinVal : _oldStartIndex;
    visibleEnd = scrollMaxVal < _oldEndIndex ? scrollMaxVal : _oldEndIndex;

    conf._oldStartIndex = scrollMinVal;
    conf._oldEndIndex = scrollMaxVal;

    for (i = scrollMinVal; i < scrollMaxVal; i++) {
      if (xAxis.getState('scrolling') && chart.hasScroll && i > visibleStart && i < visibleEnd) {
        continue;
      }

      dataObj = dataStore[i];

      if (!dataObj) {
        continue;
      }
      config = dataObj.config || {};
      // isSkipped = config && config.isSkipped;
      setValue = config.setValue;

      // if (dataSet.doSkip(dataObj)) {
      //   continue;
      // }

      setLink = config.setLink;
      colorArr = config.colorArr || [];
      if (xAxis.config.isVertical) {
        initialColumnHeight = dataSet.getFromEnv('columnWidth');
        yPosOffset = shift;
      } else {
        initialColumnWidth = dataSet.getFromEnv('columnWidth');
        xPosOffset = shift;
      }
      // Creating the data structure if not present for storing the graphics elements.
      if (!dataObj.graphics) {
        dataStore[i].graphics = {};
      }

      displayValue = config.displayValue;

      Px = mathMin(config._Px, config._Pbx) + (xPosOffset || 0) + x * scaleX;
      Py = mathMin(config._Py, config._Pby) + (yPosOffset || 0);
      stackConf && (Px -= initialColumnWidth / 2);

      tempWidth = initialColumnWidth || mathAbs(config._Px - config._Pbx);
      tempHeight = initialColumnHeight || mathAbs(config._Py - config._Pby);

      setTooltext = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(config.origToolText, JSONData.plottooltext, chartAttr.plottooltext)));

      if (dataSet.fineTunePlotDimension) {
        tunedAttr = dataSet.fineTunePlotDimension(Px, Py, tempHeight, i);
        Px = tunedAttr.xPos;
        Py = tunedAttr.yPos;
        tempWidth = tunedAttr.width;
        tempHeight = tunedAttr.height;
      }

      // Crisping the dataplots based on some condition determined by the column group manager.
      if (dataSkipped === false && dataSet.getFromEnv('isCrisp')) {
        crispBox = _redraphael2['default'].crispBound(Px, Py, tempWidth, tempHeight, plotBorderThickness);
        xPos = crispBox.x;
        yPos = crispBox.y;
        columnWidth = crispBox.width;
        height = crispBox.height;
      } else {
        xPos = Px;
        yPos = Py;
        columnWidth = tempWidth;
        height = tempHeight;
      }
      !isFinite(height) && (height = 0);
      shadow = config.shadow;
      // Setting the final tooltext.
      toolText = config.finalTooltext = config.toolText !== false ? config.toolText + (setTooltext ? '' : config.toolTipValue) : '';
      plotBorderDashStyle = config.plotBorderDashStyle;

      trackerConfig = dataObj.trackerConfig = {};

      // Setting the event arguments.
      trackerConfig.eventArgs = {
        index: i,
        link: setLink,
        value: setValue,
        displayValue: displayValue,
        categoryLabel: config.origLabel,
        toolText: toolText,
        id: '',
        datasetIndex: datasetIndex,
        datasetName: JSONData.seriesname,
        visible: visible
      };
      // !dataSet.newlyAdded && (groupConfig.lastYPos[i] = yPos);
      // todo- remove _ to make it public

      dataObj._xPos = xPos + xDepth;
      dataObj._yPos = yPos - yDepth;
      dataObj._height = height;
      dataObj._width = columnWidth;
      dataObj._index = i;
      // Need for crisping of removed plot
      dataObj._plotBorderThickness = plotBorderThickness;

      currentYBaseTouched = yBasePos === yPos + (setValue > 0 ? height : 0);
      attrObj = {
        position: {
          x: xPos || 0,
          y: yPos || 0,
          width: columnWidth || 0,
          height: height || 0,
          r: plotRadius,
          'stroke-linejoin': 'miter'
        },
        cosmetics: {
          ishot: !showTooltip,
          fill: (0, _lib.toRaphaelColor)(colorArr[0]) || '',
          noGradient: !use3DLighting,
          stroke: showPlotBorder && ((0, _lib.toRaphaelColor)(colorArr[1]) || ''),
          'stroke-width': showPlotBorder ? plotBorderThickness : 0,
          'stroke-dasharray': plotBorderDashStyle,
          'stroke-linejoin': 'miter',
          'visibility': visible,
          cursor: setLink ? POINTER : ''
        }
      };

      if (is3D) {
        attrObj.position.xDepth = xDepth;
        attrObj.position.yDepth = yDepth;
      }

      dataSet.plotAnimManager(dataObj, attrObj, anim, i);

      setElement = dataObj.graphics.element;
      // The shadow element is set for the dataplots.
      setElement.shadow(shadow, shadowContainer).data('BBox', crispBox);

      if (setLink || showTooltip) {
        // Fix for touch devices.
        if (height < HTP) {
          yPos -= (HTP - height) / 2;
          height = HTP;
        }

        // Setting attributes for the hotelement.
        trackerConfig.attr = {
          x: xPos,
          y: yPos,
          width: columnWidth,
          height: height,
          r: plotRadius,
          cursor: setLink ? POINTER : '',
          stroke: _lib.TRACKER_FILL,
          'stroke-width': showPlotBorder ? plotBorderThickness : 0,
          fill: _lib.TRACKER_FILL,
          ishot: true,
          visibility: visible
        };
      }

      // If algorithmic mouseTracking is enabled then attach these data to setElement
      // because tracker element will not be drawn
      chart.config.enablemousetracking && setElement.data(EVENTARGS, trackerConfig.eventArgs).data(showHoverEffectStr, showHoverEffect).data(SETROLLOVERATTR, config.setRolloverAttr || {}).data(SETROLLOUTATTR, config.setRolloutAttr || {});
      // .tooltip(trackerConfig.eventArgs && trackerConfig.eventArgs.toolText);

      config.oldValue = setValue;
      dataObj._oldYBaseTouched = currentYBaseTouched;
    }

    dataSet.newlyAdded = false;

    anim.plot.callback = outerAnimCallBack;

    dataSet.appearing && (dataSet.appearing = false);

    // chartComponents.animationManager.registerAnimation([{
    //     callback: newDS ? initAnimCallBack : outerAnimCallBack,
    //     animType: animType,
    //     data: dataArr
    // }], 'plot');
  };
  /**
   * function to calculate width, hieght and dataset shift
   */


  ColumnDataset.prototype.setColumnPosition = function setColumnPosition() {
    var dataSet = this,
        columnWidth = void 0,
        shift = void 0;

    if ((columnWidth = dataSet.getFromEnv('plotWidth')) === UNDEF) {
      var xAxis = dataSet.getFromEnv('xAxis'),
          chartAttr = this.getFromEnv('chart-attrib'),
          definedGroupPadding = mathMax((0, _lib.pluckNumber)(chartAttr.plotspacepercent), 0),
          plotSpacePercent = mathMax((0, _lib.pluckNumber)(definedGroupPadding, 20) % 100, 0),
          groupPadding = plotSpacePercent / 200,
          xAxisZeroPos = xAxis.getAxisPosition(0),
          xAxisFirstPos = xAxis.getAxisPosition(1),
          maxColWidth = 50,
          groupMaxWidth = mathAbs(xAxisFirstPos - xAxisZeroPos),
          groupNetWidth = void 0,
          xPosFirst = void 0,
          xPosNext = void 0,
          isCrisp = true,
          groupNetGapWidth = 4,
          groupNetHalfWidth = void 0,
          numOfColumns = 1;
      groupNetWidth = (1 - definedGroupPadding * 0.01) * groupMaxWidth || mathMin(groupMaxWidth * (1 - groupPadding * 2), maxColWidth * (numOfColumns || 1));
      columnWidth = numOfColumns === 0 ? groupNetWidth : groupNetWidth / numOfColumns;
      groupNetHalfWidth = groupNetWidth / 2;
      xPosFirst = xAxisZeroPos - groupNetHalfWidth;
      xPosNext = xAxisFirstPos - groupNetHalfWidth;
      if (xPosNext - (xPosFirst + groupNetWidth) < groupNetGapWidth) {
        isCrisp = false;
      }
      if (plotSpacePercent === 0) {
        isCrisp = true;
      }
      dataSet.addToEnv('isCrisp', isCrisp);
    }
    dataSet.addToEnv('columnWidth', columnWidth);
    shift = dataSet.getFromEnv('shift') || 0;
    dataSet.addToEnv('columnXShift', shift - dataSet.getFromEnv('columnWidth') / 2);
  };

  /**
   * Function for drawing 2D columns.
   * This function is called every time for each dataset when they are initially drawn or shown/hidden from
   * the drawGraph() function.
   */


  ColumnDataset.prototype.draw = function draw() {
    var dataSet = this,
        conf = dataSet.config,
        visible = dataSet.getState('visible'),
        xAxis = dataSet.getFromEnv('xAxis'),
        xAxisZeroPos = xAxis.getAxisPosition(0),
        xAxisFirstPos = xAxis.getAxisPosition(1),
        groupMaxWidth = dataSet.getFromEnv('groupMaxWidth'),
        chart = dataSet.getFromEnv('chart'),
        chartConfig = chart.config,
        dsChildren = dataSet.getChildren(),
        xDepth = chartConfig.xDepth || 0,
        yAxis = dataSet.getFromEnv('yAxis'),
        components = dataSet.components,
        drawn = dataSet.drawn,
        isStacked = chartConfig.isstacked,
        stack100Percent = Number(chartConfig.stack100percent),
        removeDataArr = components.removeDataArr,
        removeDataArrLen = removeDataArr && removeDataArr.length,
        yAxisMaxmin = yAxis.getLimit(),
        yMax = yAxisMaxmin.max,
        yMin = yAxisMaxmin.min,
        isPositiveNegative = yMax > 0 && yMin < 0,
        scrollMinVal,
        scrollMaxVal,
        child,
        children,
        i,
        ii,
        childName,
        isContextChanged = dataSet._contextChanged(),
        anim = {
      initial: {
        data: []
      },
      axis: {
        data: []
      },
      plot: {
        data: []
      },
      final: {
        data: []
      }
    },
        key = '';

    if (!groupMaxWidth) {
      groupMaxWidth = mathAbs(xAxisFirstPos - xAxisZeroPos);
      dataSet.addToEnv('groupMaxWidth', groupMaxWidth);
    }

    if (!dataSet.getState('removed') && !dataSet.getState('dirty') && !(isContextChanged && visible)) {
      return;
    }

    !drawn && dataSet.createContainer();
    dataSet.setContainerVisibility(true);

    // if (visible) {
    //     container.show();
    //     shadowContainer.show();
    // }

    // For Stack charts recalculate the y pos
    isStacked && stack100Percent && dataSet.updateYForStack();
    // For boxAndWhisker chart
    dataSet._updateBase && dataSet._updateBase();
    // Create all the pixel coordinates for drawing plots
    dataSet.createCoordinates();

    // Draw all the graphic elements
    dataSet.drawPlots(anim);

    dataSet.drawCommonElements && dataSet.drawCommonElements(anim);

    scrollMinVal = conf.scrollMinVal;
    scrollMaxVal = conf.scrollMaxVal;
    // Datalabels are drawn in a different thread for the first time and later drawn in the same thread.
    dataSet.drawn ? dataSet.drawLabel(scrollMinVal, scrollMaxVal) : dataSet.addJob('labelDrawID', function () {
      dataSet.drawLabel(scrollMinVal, scrollMaxVal);
    }, _lib.priorityList.label);

    // Hide the sumLabel layers if the dataSet is not drawn
    // !drawn && sumLabelsLayer.hide();
    /*
      * The sumValues are drawn incase of stacked column if the drawSumValueFlag flag is set by the column
      * manager and the drawSumLabel flag is set.
      */
    // if (groupManager && groupManager.drawSumValueFlag) {
    //     groupManager.drawSumValueFlag && groupManager.drawSumValue(scrollMinVal, scrollMaxVal);
    // }
    // Setting the drawn flag true to draw differently incase of real time draw.
    dataSet.drawn = true;
    removeDataArrLen && dataSet.removeElements(anim);
    conf.oldGroupMaxWidth = groupMaxWidth;
    conf.oldDataIsPositiveNegative = isPositiveNegative;
    conf.oldZeroAxisPos = yAxis.getAxisPosition(yAxis.getAxisBase()) + xDepth;
    // Registering the animations
    for (key in anim) {
      dataSet.getFromEnv('animationManager').registerAnimation([anim[key]], key);
    }
    dataSet.drawErrorValue && dataSet.drawErrorValue();
    dataSet.prevVisible = visible;
    dataSet.catDiff = 0;

    for (childName in dsChildren) {
      if (dsChildren.hasOwnProperty(childName)) {
        children = dsChildren[childName];
        for (i = 0, ii = children.length; i < ii; i++) {
          child = children[i];
          child.addToEnv('paper', dataSet.getFromEnv('paper'));
          child.draw();
        }
      }
    }
  };

  /**
   * This function is used to make a dataset visible when clicked on its respective legend.
   * This fucntion is called from drawGraph() every time a deactivated legend is clicked.
   */


  ColumnDataset.prototype.show = function show() {
    var dataSet = this,
        parent = dataSet.getLinkedParent(),
        is3D = dataSet.getFromEnv('chart').is3D,
        i,
        data = dataSet.components.data,
        dataSetLen = dataSet.JSONData.data && dataSet.JSONData.data.length,
        categories = dataSet.getFromEnv('chart').config.categories,

    // yAxis = dataSet.getFromEnv('yAxis'),
    // xAxis = dataSet.getFromEnv('xAxis'),
    catLen = categories && categories.length,
        chart = dataSet.getFromEnv('chart'),
        len = mathMin(dataSetLen, catLen);

    dataSet.setState('visible', true);
    dataSet.appearing = true;
    dataSet._conatinerHidden = false;

    if (is3D) {
      for (i = 0; i < len; i++) {
        data[i] && data[i].graphics && data[i].graphics.element && data[i].graphics.element.attr({
          'visibility': visibleStr
        });
        data[i] && data[i].graphics && data[i].graphics.hotElement && data[i].graphics.hotElement.attr({
          'visibility': visibleStr
        });
      }
    }

    dataSet.setContainerVisibility();
    dataSet.setState('dirty', true);
    parent.childChanged();
    dataSet.appearing = false;
    // Changes made to show proper tooltip in RTCharts
    chart.chartInstance.__state._rtPaused && chart._setRTdata();
    dataSet.asyncDraw();
  };
  /**
   * This function is used to make a dataset hidden when clicked on its respective legend.
   * This fucntion is fired from drawGraph() every time an activated legend is clicked.
   */


  ColumnDataset.prototype.hide = function hide() {
    var dataSet = this,
        parent = dataSet.getLinkedParent(),
        chart = dataSet.getFromEnv('chart');

    dataSet.setState('dirty', true);
    dataSet.setState('visible', false);

    parent.childChanged();
    // dataSet.hidding = false;
    // Changes made to show proper tooltip in RTCharts
    chart.chartInstance.__state._rtPaused && chart._setRTdata();
    dataSet.asyncDraw();
  };

  /**
    * This function is used for drawing the data labels.
    * This function is called once for each dataset when the are drawn and shown/hidden from the draw()
    * function of the Column class.
    * @param {number} start   start index
    * @param {number} end     end index
    */


  ColumnDataset.prototype.drawLabel = function drawLabel(start, end) {
    var dataSet = this,
        chart = dataSet.getFromEnv('chart'),
        resize = chart.state === 'resize',
        noAnim = chart.state === 'noAnim',
        realTimeUpdate = chart.state === 'realTimeUpdate',
        chartConfig = chart.config,

    // layers = chart.graphics,
    animationObj = chart.get('config', 'animationObj'),

    // dummyObj = animationObj.dummyObj,
    // animObj = animationObj.animObj,
    animType = animationObj.animType,

    // animationDuration = animationObj.duration,
    xAxis = dataSet.getFromEnv('xAxis'),
        paper = dataSet.getFromEnv('paper'),
        smartLabel = chart.getFromEnv('smartLabel'),
        style = chart.config.dataLabelStyle,
        conf = dataSet.config,
        legendInteractivity = conf.legendInteractivity,
        len = xAxis.getCategoryLen(),
        components = dataSet.components,
        dataStore = components.data,
        pool = components.pool,
        visible = dataSet.getState('visible'),
        dataObj,
        attr,
        i,
        displayValue,
        rotateValues = chartConfig.rotatevalues ? 270 : 0,
        bBoxObj,
        graphic,
        textY,
        textX,
        yPos,
        xPos,
        setValue,
        config,
        showValue,
        pos,
        attr2,
        label,
        tempGraphics,
        animCallBack = function animCallBack(attr) {
      return function () {
        !resize && this.attr(attr);
      };
    },
        dataArr = [],
        dataLabelContainer = dataSet.graphics.dataLabelContainer,
        labelDrawn = dataSet.labelDrawn,
        startIndex = (0, _lib.pluckNumber)(start, 0),
        endIndex = (0, _lib.pluckNumber)(end, len);

    dataLabelContainer = dataSet.getContainer('labelGroup');
    dataLabelContainer.css(style);
    dataLabelContainer.show();
    if (!resize && !noAnim && !realTimeUpdate) {
      dataArr.push({
        el: dataLabelContainer,
        attrs: {
          opacity: 0
        },
        callback: function callback() {
          if (!visible) {
            this.hide();
          }
        },
        animConfig: [{
          syncWith: 'initial'
        }]
      });
      dataArr.push({
        el: dataLabelContainer,
        attrs: {
          opacity: visible ? 1 : 0
        },
        animConfig: [{
          syncWith: 'final'
        }]
      });
    }

    smartLabel.useEllipsesOnOverflow(chart.config.useEllipsesWhenOverflow);
    smartLabel.setStyle(style);
    if (visible) {
      for (i = startIndex; i < endIndex; i++) {
        dataObj = dataStore[i];
        config = dataObj && dataObj.config;
        setValue = config && config.setValue;
        // Condition arises when user has removed data in real time update
        if (dataObj === UNDEF || setValue === UNDEF || setValue === null || config.labelSkip === true) {
          config && delete config.labelSkip;
          tempGraphics = dataObj && dataObj.graphics;
          if (tempGraphics) {
            tempGraphics.label && tempGraphics.label.hide();
          }
          continue;
        }
        graphic = dataObj.graphics;
        // Condition arises when feedData enters less number of data in a dataset compared to the other.
        if (!graphic) {
          continue;
        }
        yPos = dataObj._yPos;
        xPos = dataObj._xPos;
        displayValue = config.displayValue;
        showValue = config.showValue;
        if (!showValue || setValue === null) {
          if (graphic.label) {
            graphic.label.attr({ 'text-bound': [] });
            graphic.label.hide();
          }
          continue;
        }

        if (!legendInteractivity || !config._state) {
          bBoxObj = smartLabel.getOriSize(displayValue);
          if (rotateValues) {
            // If rotated values we use the width of
            // the text as height
            config._state = {
              labelWidth: bBoxObj.height,
              labelHeight: bBoxObj.width
            };
          } else {
            config._state = {
              labelWidth: bBoxObj.width,
              labelHeight: bBoxObj.height
            };
          }
        }

        pos = dataSet._getValuePosition({
          labelWidth: config._state.labelWidth,
          labelHeight: config._state.labelHeight,
          width: dataObj._width,
          height: dataObj._height,
          yPos: yPos,
          xPos: xPos,
          value: setValue
        });

        textX = pos.textX;
        textY = pos.textY;
        // These parameters can change on legendInteractivity.
        attr = {
          x: textX,
          y: textY,
          text: displayValue
        };

        if (!legendInteractivity) {
          // These parameters do not change on legendInteractivity, it is done to improve performance.
          attr = (0, _lib.extend2)(attr, {
            visibility: visibleStr,
            'line-height': style.lineHeight,
            fill: style.color,
            'text-bound': [style.backgroundColor, style.borderColor, style.borderThickness, style.borderPadding, style.borderRadius, style.borderDash, 1]
          });
        }

        // Positioning made for real time update.
        if (!graphic.label && labelDrawn && chart.isRealTime) {
          attr2 = (0, _lib.extend2)({}, attr);
          attr2.x = attr.x - xPos + (dataObj._newXPos || 0);
          attr2.transform = paper.getSuggestiveRotation(rotateValues, attr2.x, textY);
          if (pool && pool.label[0]) {
            graphic.label = pool.label[0].attr(attr2);
            pool.label.splice(0, 1);
          } else {
            graphic.label = paper.text(attr2, dataLabelContainer);
          }
        }

        attr.transform = paper.getSuggestiveRotation(rotateValues, textX, textY);

        if (!(label = graphic.label)) {
          if (pool && pool.label[0]) {
            label = graphic.label = pool.label[0].attr(attr);
            pool.label.splice(0, 1);
          } else {
            label = graphic.label = paper.text(attr, dataLabelContainer);
          }
          label.attr({
            opacity: 0,
            'text-bound': [style.backgroundColor, style.borderColor, style.borderThickness, style.borderPadding, style.borderRadius, style.borderDash, 0]
          });
        }

        label.show();
        // label.attr({
        //     opacity: 0
        // });

        dataArr.push({
          el: label,
          attrs: {
            opacity: 1
          },
          animConfig: [{
            syncWith: 'final',
            hookFn: animCallBack(attr)
          }]
        });

        if (labelDrawn) {
          if (chart.state === 'realTimeUpdate') {
            label.attr(attr);
          } else if (resize) {
            dataArr.push({
              el: label,
              attrs: attr,
              animConfig: [{
                syncWith: 'plot'
              }]
            });
          }
        }
      }
    }
    chart.getFromEnv('animationManager').registerAnimation([{
      animType: animType,
      data: dataArr
    }], 'final');

    dataSet.labelDrawn = true;
  };
  /**
   * function to calculate label position
   * @param {Object}    config   config reference of the data plot
   * @return {Object}            contains x,y co-ordinate
   */


  ColumnDataset.prototype._getValuePosition = function _getValuePosition(config) {
    var dataset = this,
        chart = dataset.getFromEnv('chart'),
        children = chart.getChildren(),
        chartConf = chart.config,
        canvasConf = children.canvas[0].config,
        yAxis = children.yAxis[0],
        xDepth = canvasConf.xDepth,
        yDepth = canvasConf.yDepth,
        canvasTop = chartConf.canvasTop,
        canvasHeight = chartConf.canvasHeight + yDepth,
        outsideColSpace,
        textX,
        textY,
        insideColSpace,
        isNegative,
        textHeight,
        yPos = config.yPos,
        is3D = chart.is3D,
        isStacked = chart.config.isstacked,
        valuePadding = chartConf.valuepadding + 2,
        height = config.height,
        width = config.width,
        yAdjust,
        placeValuesInside = chartConf.placevaluesinside,
        labelHeight = config.labelHeight,
        isInverseAxis = yAxis.getAxisConfig('isReverse'),
        limits = yAxis.getAxisConfig('axisRange'),
        max = limits.max,
        min = limits.min,
        value = config.value,
        isPositiveNegative = max > 0 && min < 0,
        valueBelowPlot,
        xPos = config.xPos,
        origTextHeight;

    if (!isInverseAxis) {
      if (isPositiveNegative) {
        if (value < 0) {
          valueBelowPlot = false;
        } else {
          valueBelowPlot = true;
        }
      }
    }

    isNegative = (0, _lib.pluck)(valueBelowPlot, value < 0);
    textHeight = origTextHeight = labelHeight + valuePadding;

    insideColSpace = height;
    yAdjust = origTextHeight * 0.5 + valuePadding;
    textY = yPos - yAdjust;

    textX = xPos + width * 0.5;

    if (isNegative) {
      outsideColSpace = canvasTop + canvasHeight - (yPos + height + yDepth);
      textY = yPos;
    } else {
      outsideColSpace = yPos - canvasTop;
    }

    if (isStacked) {
      textY = yPos + height * 0.5 + (yDepth || 0);
      // For stacked charts restrict the data values inside the canvas.
      textY = mathMin(canvasTop + canvasHeight - textHeight * 0.5, textY);
      textY = mathMax(canvasTop + textHeight * 0.5, textY);
      textX -= xDepth;
    } else {
      if (placeValuesInside) {
        // If space available inside column
        if (insideColSpace >= textHeight) {
          textY = yPos + (isNegative ? height - yAdjust : yAdjust);
          if (is3D) {
            textX -= xDepth;
            textY += yDepth;
          }
        } else if (outsideColSpace >= textHeight) {
          // If space not available inside column
          // Try to fit the label outside column
          textY = yPos + (isNegative ? height + yAdjust : -yAdjust);
          if (is3D && isNegative) {
            textX -= xDepth;
            textY += yDepth;
          }
        } else {
          textY = yPos + (isNegative ? height - yAdjust : yAdjust);
          if (is3D) {
            textX -= xDepth;
            textY += yDepth;
          }
        }
        // If space not available inside or outside column
        // find the larger space available and place the column
      } else {
        // If space is available inside column
        if (outsideColSpace >= textHeight) {
          textY = yPos + (isNegative ? height + yAdjust : -yAdjust);
          if (is3D) {
            if (isNegative) {
              textX -= xDepth;
              textY += yDepth;
            } else {
              textX -= xDepth / 2;
            }
          }
        } else if (insideColSpace >= textHeight + yAdjust) {
          textY = yPos + (isNegative ? height - yAdjust : yAdjust);
          if (is3D) {
            textX -= xDepth;
            textY += yDepth;
          }
        } else {
          textY = yPos + (isNegative ? height - yAdjust : yAdjust);
          if (is3D) {
            textX -= xDepth;
            textY += yDepth;
          }
        }
      }
    }
    return {
      textX: textX,
      textY: textY
    };
  };

  /**
   * Function to get the maximum and minimum from dataset
   * @return {Object}     contains max, min value
   */


  ColumnDataset.prototype.getDataLimits = function getDataLimits() {
    var dataSet = this,
        dataStore = dataSet.components.data,
        conf = dataSet.config,
        i,
        config,
        len = dataStore.length,
        setValue,
        maxValue = -Infinity,
        minValue = +Infinity;

    for (i = 0; i < len; i++) {
      if (!dataStore[i]) {
        continue;
      }
      config = dataStore[i].config;
      setValue = config.setValue;
      if (setValue !== UNDEF && setValue !== null) {
        maxValue = mathMax(maxValue, setValue);
        minValue = mathMin(minValue, setValue);
      }
    }

    conf.maxValue = maxValue;
    conf.minValue = minValue;
    return {
      max: conf.maxValue,
      min: conf.minValue
    };
  };
  /* REAL TIME FUNCTIONS */

  /**
   * Function to add dataset to the existing dataset.
   * @param {Object} dataObj new data to add into dataset
   * @param {number} index   from which index data would be added
   * @param {boolean} draw   whether call draw or not
   */


  ColumnDataset.prototype.addData = function addData(dataObj, index, draw) {
    var dataSet = this,
        components = dataSet.components,
        numberFormatter = dataSet.getFromEnv('number-formatter'),
        dataStore = components.data,
        data = dataObj.data,
        len = data.length,
        conf = dataSet.config,
        maxValue = conf.maxValue,
        minValue = conf.minValue,
        maxminFlag = dataSet.maxminFlag,
        dataValue,
        i;

    components.addDataArr = dataObj.data;

    // Storing the direction of input data for the type of animation to be done during draw.
    if (index === 0) {
      dataSet.startPosition = true;
    } else if (index + len === dataStore.length || index === UNDEF) {
      dataSet.startPosition = false;
    }
    for (i = 0; i < len; i++) {
      if (index !== UNDEF) {
        dataStore.splice(index + i, 0, {
          config: {}
        });
      } else {
        dataStore.push({
          config: {}
        });
      }
      if (!maxminFlag) {
        dataValue = numberFormatter.getCleanValue(data[i].value);
        if (dataValue > maxValue || dataValue < minValue) {
          maxminFlag = dataSet.maxminFlag = true;
        }
      }
    }

    dataSet._setConfigure(dataObj, index);
    maxminFlag && dataSet.getDataLimits && dataSet.getDataLimits();
    draw && dataSet.asyncDraw();
  };

  // Function to hide the graphics elements
  // hideElements (elem) {
  //   elem.hide();
  // }

  /**
   * Function to remove a data with a given index.
   * @param {number}  index     from which index data would be removed
   * @param {number}  stretch   delete count
   * @param {boolean} draw      whether draw or not
   */


  ColumnDataset.prototype.removeData = function removeData(index, stretch, draw) {
    var dataSet = this,
        chart = dataSet.getFromEnv('chart'),
        components = dataSet.components,
        dataStore = components.data,
        removeDataArr = components.removeDataArr || (components.removeDataArr = []),
        conf = dataSet.config,
        i,
        config,
        len,
        maxminFlag = dataSet.maxminFlag;

    stretch === UNDEF && (stretch = 1);
    index = index || 0;

    // Storing the direction of input data for the type of animation to be done during remove.
    if (index + stretch === dataStore.length || !chart.isRealTime) {
      dataSet.endPosition = true;
    } else if (index === 0 || index === UNDEF) {
      dataSet.endPosition = false;
    }
    components.removeDataArr = removeDataArr = removeDataArr.concat(dataStore.splice(index, stretch));
    len = removeDataArr.length;

    for (i = len - 1; i >= 0; i--) {
      if (!removeDataArr[i]) {
        removeDataArr.splice(i, 1);
        continue;
      }
      config = removeDataArr[i].config;
      if (config.setValue === conf.maxValue || config.setValue === conf.minValue) {
        maxminFlag = dataSet.maxminFlag = true;
      }
      // Update the x position for this removed elements outside of the canvas
      config._x -= stretch;
      if (maxminFlag) {
        break;
      }
    }
    dataSet.removeDataLen = len;
    dataSet.resetCatPos && dataSet.resetCatPos();
    maxminFlag && dataSet.getDataLimits && dataSet.getDataLimits();
    draw && dataSet.asyncDraw();
  };
  /**
   * Function to reset the _x position of plots when it is a changed due to RT update
   */


  ColumnDataset.prototype.resetCatPos = function resetCatPos() {
    var dataSet = this,
        dataStore = dataSet.components.data,
        len = dataStore.length,
        i;
    if (dataStore && len) {
      for (i = 0; i < len; i++) {
        if (dataStore[i] && dataStore[i].config) {
          dataStore[i].config._x = i;
        }
      }
    }
  };
  // @TODO have to remove this function after validation
  /**
   * Function to an existing data of a dataset.
   * @param {Object} dataObj data JSON
   * @param {integer} index The data index whoch needs to be updated
   * @param {boolean} draw  Indicates whether the chart should redraw itself or not
   */


  ColumnDataset.prototype.updateData = function updateData(dataObj, index, draw) {
    var dataSet = this,
        conf = dataSet.config,
        prevMax = conf.maxValue,
        prevMin = conf.prevMin,
        chart = dataSet.getFromEnv('chart'),
        drawManager = dataSet.groupManager || dataSet,
        chartComponents = chart.components,
        hasAxes = chartComponents.xAxis || chartComponents.yAxis,
        xAxis = hasAxes && chartComponents.xAxis[0],
        yAxis = hasAxes && chartComponents.yAxis[0];

    dataSet._setConfigure(dataObj, index);
    dataSet.getDataLimits();

    if (conf.maxValue !== prevMax || conf.minValue !== prevMin) {
      dataSet.maxminFlag = true;
    }

    if (draw) {
      chart._setAxisLimits();
      hasAxes && xAxis.asyncDraw();
      hasAxes && yAxis.asyncDraw();
      drawManager.asyncDraw();
    }
  };
  /**
   * hides the element to a specific position.
   * @return {Function}   returns a function which decides how to hide the plot
   */


  ColumnDataset.prototype.hidingPosition = function hidingPosition() {
    var dataSet = this,

    // groupConfig = dataSet.groupManager.config,
    // yAxis = dataSet.getFromEnv('yAxis'),
    xAxis = dataSet.getFromEnv('xAxis'),
        isVertical = xAxis.config.isVertical,
        components = dataSet.components,
        removeDataArr = components.removeDataArr,
        len = dataSet.catDiff || removeDataArr.length,
        conf = dataSet.config,
        returnObj,

    // R = lib.Raphael,
    Px,
        Py,
        columnWidth,
        height,

    // positionValue,
    crispBox,
        shift = conf.oldGroupMaxWidth;
    if (dataSet.endPosition === false) {
      return function (removeData) {
        return {
          x: removeData._xPos - shift * len,
          y: removeData._yPos

        };
      };
    } else if (dataSet.endPosition === true) {
      return function (removeData) {
        // positionValue = dataSet.groupManager.getDataSetPosition(dataSet, removeData._index);

        if (isVertical) {
          Px = removeData._xPos;
          Py = xAxis.getAxisPosition(removeData._index) + dataSet.getFromEnv('columnXShift');
          columnWidth = removeData._width;
          height = dataSet.getFromEnv('columnWidth');
        } else {
          Px = xAxis.getAxisPosition(removeData._index) + dataSet.getFromEnv('columnXShift');
          Py = removeData._yPos;
          columnWidth = dataSet.getFromEnv('columnWidth');
          height = removeData._height;
        }

        if (dataSet.config.isSkippedData === false && dataSet.getFromEnv('isCrisp')) {
          crispBox = (0, _lib.crispBound)(Px, Py, columnWidth, height, removeData._plotBorderThickness);
          Px = crispBox.x;
          Py = crispBox.y;
          columnWidth = crispBox.width;
          height = crispBox.height;
        }

        returnObj = {
          x: Px,
          y: Py,
          width: columnWidth,
          height: height
        };
        return returnObj;
      };
    } else {
      return function () {
        return {
          width: 0
        };
      };
    }
  };
  /**
   * Function to remove a data from a dataset
   * @param {Object} anim     - object reference of animation manager argument
   *                            consist of elements and their configuration
   */


  ColumnDataset.prototype.removeElements = function removeElements(anim) {
    var dataSet = this,
        components = dataSet.components,
        removeDataArr = components.removeDataArr,
        pool = components.pool || (components.pool = {
      element: [],
      hotElement: [],
      label: []
    }),
        chart = dataSet.getFromEnv('chart'),
        chartComponents = chart.components,
        animationObj = chart.get('config', 'animationObj'),
        animType = animationObj.animType,
        realtimeUpdate = chart.state === 'realTimeUpdate',

    // chartComponents = chart.components,
    dataArr = anim.plot.data,
        removeData,
        maxminFlag = dataSet.maxminFlag,
        ele,
        graphics,
        i,
        k,
        attr,
        paper = chart.getFromEnv('paper'),
        rotateValues = chart.config.rotatevalues,
        clear = dataSet.getFromEnv('chart').config.realTimeConfig && dataSet.getFromEnv('chart').config.realTimeConfig.clear,
        position = dataSet.hidingPosition(),

    // xAxis = dataSet.getFromEnv('xAxis'),
    _pos = function _pos(data) {
      return position(data);
    },
        errorEleCallback = function errorEleCallback() {
      this.hide();
      this.shadow({ opacity: 0 });
    },
        animCallBack = function animCallBack() {
      this.hide();
    };

    // if (xAxis.config.isVertical) {
    //   yAttrKey = 'x';
    //   hAttrKey = 'width';
    //   xAttrKey = 'y';
    //   wAttrKey = 'height';
    // }

    for (i = removeDataArr.length - 1; i >= 0; i--) {
      removeData = removeDataArr[i];
      removeDataArr.splice(i, 1);
      // In case of non existing data plot continue;
      if (!removeData || !removeData.graphics) {
        continue;
      }

      graphics = removeData.graphics;
      for (ele in graphics) {
        if (ele === 'label' && dataSet.startPosition === UNDEF && dataSet.endPosition === UNDEF) {
          graphics[ele].hide();
        }
        attr = _pos(removeData);
        if (ele === 'label') {
          attr.transform = paper.getSuggestiveRotation(rotateValues, attr.x, attr.y);
        }
        clear && graphics[ele].hide();

        if (realtimeUpdate) {
          graphics[ele].attr(attr);
        } else {
          // attr2 = extend2({}, attr);

          if (ele === 'label') {
            dataArr.push({
              el: graphics[ele],
              callback: animCallBack,
              attrs: {
                opacity: 0
              },
              animConfig: [{
                syncWith: 'initial'
              }]
            });
          } else if (ele === 'element') {
            animStates.hidding(removeData, {
              anim: anim,
              attr: attr,
              ds: dataSet
            });
          }
        }
      }

      for (k = 0; k < 4; k++) {
        graphics.error && graphics.error[k] && chartComponents.animationManager.registerAnimation([{
          animType: animType,
          data: [{
            el: graphics.error[k],
            callback: errorEleCallback,
            attrs: {
              opacity: 0
            }
          }]
        }], 'initial');
      }

      // Storing the graphic elements for reuse.
      removeData.graphics.element && (pool.element = pool.element.concat(removeData.graphics.element));
      removeData.graphics.hotElement && (pool.hotElement = pool.hotElement.concat(removeData.graphics.hotElement));
      removeData.graphics.label && (pool.label = pool.label.concat(removeData.graphics.label));
    }
    components.pool = pool;
    maxminFlag && dataSet.getDataLimits && dataSet.getDataLimits();
  };
  /**
   * function to return defalut value padding
   * @return {Object} default padding value for axis
   */


  ColumnDataset.prototype.getAxisValuePadding = function getAxisValuePadding() {
    return this.config.defaultPadding;
  };

  /**
   * This functions calculate the space required for a dataset and return that to the chart
   * @return {Object} dimention
   */


  ColumnDataset.prototype.getCanvasPadding = function getCanvasPadding() {
    var dataset = this,
        conf = dataset.config || (dataset.config = {}),
        components = dataset.components || {},
        chart = dataset.getFromEnv('chart'),
        rotateValues = chart.config.rotatevalues,
        xAxis = dataset.getFromEnv('xAxis'),
        yAxis = dataset.getFromEnv('yAxis'),
        dataLabelStyle = chart.config.dataLabelStyle,
        data = components.data || [],
        firstData = conf.leftMostData || data[0],
        lastData = conf.rightMostData || data[data.length - 1],
        dataConf,
        label,
        dataAnchorConf,
        labelDimEnd = {},
        labelDimStart = {},
        anchorSpace = 0,
        labelSpace = 0,
        showValue,
        startPixel = xAxis.getPixel(0),
        SmartLabel = dataset.getFromEnv('smartLabel'),
        retrunDimension = {
      paddingLeft: 0,
      paddingRight: 0,
      paddingTop: 0,
      paddingBottom: 0
    },
        labelWidth = 0,

    // getting column width
    dimensions,
        padding = dataset.getAxisValuePadding(),
        topMostData = conf.topMostData,
        bottomMostData = conf.bottomMostData;

    dataset.setColumnPosition();
    dimensions = {
      xPosOffset: dataset.getFromEnv('columnXShift'),
      columnWidth: dataset.getFromEnv('columnWidth'),
      height: UNDEF
    };
    if (firstData) {
      dataConf = firstData.config;
      showValue = dataConf.showValue;
      dataAnchorConf = dataConf && dataConf.anchorProps || {};
      if (showValue) {
        label = dataConf.displayValue;
        SmartLabel.useEllipsesOnOverflow(chart.config.useEllipsesWhenOverflow);
        SmartLabel.setStyle(dataLabelStyle);
        labelDimStart = SmartLabel.getOriSize(label);
        labelWidth = rotateValues ? labelDimStart.height : labelDimStart.width;
      }
      if (dataConf.setValue !== null) {
        anchorSpace = (0, _lib.pluckNumber)(dataAnchorConf.radius, 0) + (0, _lib.pluckNumber)(dataAnchorConf.borderThickness, 0) / 2;
        // Finding the overlap of data value label with canvas border of the first data.
        labelSpace = (labelWidth || 0) / 2 - (xAxis.getPixel(padding.left) - startPixel) - (dimensions && dimensions.xPosOffset + dimensions.columnWidth / 2 || 0);
        if (labelSpace < 0) {
          labelSpace = 0;
        }
      }

      retrunDimension.paddingLeft = mathMax(anchorSpace, labelSpace);
    }

    if (lastData) {
      dataConf = lastData.config;
      showValue = dataConf.showValue;
      dataAnchorConf = dataConf && dataConf.anchorProps || {};
      if (showValue && !rotateValues) {
        label = dataConf.displayValue;
        SmartLabel.setStyle(dataLabelStyle);
        labelDimEnd = SmartLabel.getOriSize(label);
        labelWidth = rotateValues ? labelDimEnd.height : labelDimEnd.width;
      }
      if (dataConf.setValue !== null) {
        anchorSpace = (0, _lib.pluckNumber)(dataAnchorConf.radius, 0) + (0, _lib.pluckNumber)(dataAnchorConf.borderThickness, 0) / 2;
        // Finding the overlap of data value label with canvas border of the last data.
        labelSpace = (labelWidth || 0) / 2 - (xAxis.getPixel(padding.right) - startPixel) + (dimensions && dimensions.xPosOffset + dimensions.columnWidth / 2 || 0);
        if (labelSpace < 0) {
          labelSpace = 0;
        }
      }

      retrunDimension.paddingRight = mathMax(anchorSpace, labelSpace);
    }

    if (topMostData) {
      dataConf = topMostData.config;
      showValue = dataConf.showValue;
      dataAnchorConf = dataConf && dataConf.anchorProps || {};
      if (dataConf.setValue !== null) {
        anchorSpace = (0, _lib.pluckNumber)(dataAnchorConf.radius, 0) + (0, _lib.pluckNumber)(dataAnchorConf.borderThickness, 0) / 2;
        labelSpace = Math.max(anchorSpace - (yAxis.getPixel(dataConf.setValue.y) - yAxis.getPixel(yAxis.getLimit().max)), 0);
      }
      retrunDimension.paddingTop = labelSpace;
    }

    if (bottomMostData) {
      dataConf = bottomMostData.config;
      dataAnchorConf = dataConf && dataConf.anchorProps || {};
      if (dataConf.setValue !== null) {
        anchorSpace = (0, _lib.pluckNumber)(dataAnchorConf.radius, 0) + (0, _lib.pluckNumber)(dataAnchorConf.borderThickness, 0) / 2;
        labelSpace = Math.max(anchorSpace - (yAxis.getPixel(yAxis.getLimit().min) - yAxis.getPixel(dataConf.setValue.y)), 0);
      }
      retrunDimension.paddingBottom = labelSpace;
    }
    return retrunDimension;
  };
  /**
   * function to get eventarg for this dataset
   * @return {Object}   arguement object for event
   */


  ColumnDataset.prototype.getEventArgs = function getEventArgs() {
    var dataset = this,
        config = dataset.config || {},
        JSONData = dataset.JSONData || {},
        eventArgs = {
      datasetName: JSONData.seriesname,
      datasetIndex: dataset.getJSONIndex(),
      id: config.userID,
      visible: dataset.getState('visible')
    };
    return eventArgs;
  };
  /**
   * return data in current datasets
   * @return {Object} [data of current dataset]
   */


  ColumnDataset.prototype.getData = function getData() {
    return this.components.data;
  };
  /**
   * function to set index for the dataset component
   * @param {number} index    index according to the index JSON
   */


  ColumnDataset.prototype.setJSONIndex = function setJSONIndex(index) {
    this.config.index = index;
  };

  /**
   * function to return index for the dataset component
   * @return {number}    index according to the index JSON
   */


  ColumnDataset.prototype.getJSONIndex = function getJSONIndex() {
    return this.config.index || 0;
  };
  /**
   * Marks this dataset for disposal during the next draw cycle
   * @param  {Object} config Has a 'instant' member to indicate whether the component should be
   *   immediately disposed or disposed later when animation completes
   */


  ColumnDataset.prototype.remove = function remove(config) {
    var dataset = this,
        legendItemId = dataset.legendItemId,
        legend = dataset.getFromEnv('legend');
    legend && legendItemId && legend.removeItem(legendItemId);
    _ComponentInterface.prototype.remove.call(this, config);
  };

  return ColumnDataset;
}(_componentInterface2['default']);

exports['default'] = ColumnDataset;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(279), __esModule: true };

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(294), __esModule: true };

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _area = __webpack_require__(20);

var _area2 = _interopRequireDefault(_area);

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */

/**
 * @typedef {Object} Range
 * @property {number} min The minimum value in the dataset
 * @property {number} max The maximum value in the dataset
 */

var UNDEF,
    math = Math,

// mathPow = math.pow,
mathAbs = math.abs,
    MAX_MITER_LINEJOIN = 2;
/**
 * Creates the Line Dataset
 * @class
 */

var LineDataset = function (_AreaDataset) {
  _inherits(LineDataset, _AreaDataset);

  /**
   * Constructor class for instantiation
   */
  function LineDataset() {
    _classCallCheck(this, LineDataset);

    var _this = _possibleConstructorReturn(this, _AreaDataset.call(this));

    _this.type = 'line';
    _this.updateYForStack = _lib.stubFN;
    return _this;
  }
  /**
   * Creates Pinnable graphics of a dataset for Pin feature
   */


  LineDataset.prototype.createPinElem = function createPinElem() {
    var dataset = this,
        chart = dataset.getFromEnv('chart'),
        group = arguments[1].group,
        lineOb = dataset.lineOb,
        element,
        pinElems = dataset.graphics.pinElems || (dataset.graphics.pinElems = []),
        paper = dataset.getFromEnv('paper'),
        lineGroup = dataset.getLinkedParent().getChildContainer('lineVcanvasGroup'),
        i,
        key;

    for (i = pinElems.length - 1; i >= 0; i--) {
      pinElems[i].remove();
      pinElems.pop();
    }

    if (dataset.getState('visible')) {
      for (key in lineOb) {
        element = lineOb[key].el;
        pinElems.push(paper.path(group).attr({
          'path': element.attrs.path,
          'transform': ['T', -(chart.config._visx + mathAbs(lineGroup.transform()[0][1])), -chart.config.canvasBottom]
        }).attr(dataset.config.pin));
      }
    }
  };

  /**
   * Add legend items for each Dataset
   */


  LineDataset.prototype._addLegend = function _addLegend() {
    var dataset = this,
        chart = dataset.getFromEnv('chart'),
        conf = dataset.config,
        legend = chart.getChildren('legend')[0],
        drawAnchors = (0, _lib.pluckNumber)(conf.drawanchors, 1),
        config = {
      enabled: conf.includeinlegend,
      type: dataset.type,
      /* In case of scatter (a child chartAPI of line),
      line is drawn in legend only when drawLine is set
      to true. */
      drawLine: (0, _lib.pluck)(conf.drawLine, true),
      fillColor: (0, _lib.toRaphaelColor)({
        color: conf.anchorbgcolor,
        alpha: conf.anchorbgalpha
      }),
      strokeColor: (0, _lib.toRaphaelColor)({
        color: conf.anchorbordercolor,
        alpha: '100'
      }),
      rawFillColor: conf.anchorbgcolor,
      rawStrokeColor: conf.anchorbordercolor,
      anchorSide: drawAnchors ? conf.anchorsides : 0,
      strokeWidth: conf.anchorborderthickness,
      label: (0, _lib.getFirstValue)(dataset.JSONData.seriesname),
      lineWidth: conf.linethickness
    };
    dataset.legendItemId = legend.addItems(dataset, dataset.legendInteractivity, config);
  };

  /**
   * Calculates and returns the data limit range of a dataset
   * @return {Range} Value Range of a dataset
   */


  LineDataset.prototype._getDataLimits = function _getDataLimits() {
    var dataset = this,
        conf = dataset.config,
        chart = dataset.getFromEnv('chart'),
        chartConfig = chart.config,
        max = conf.maxValue,
        min = conf.minValue,
        infMin = -Infinity,
        infMax = +Infinity,
        transposeAxis = chartConfig.transposeAxis;
    if (dataset.getState('visible') === false && transposeAxis) {
      max = infMin;
      min = infMax;
    }
    return {
      max: max,
      min: min
    };
  };

  /**
   * Animate the common elements,i.e., path of line
   * @param {Object} lineOb - Consists of the attributes of a path for a line
   * @param {Object} anim - Consists of animation slots for step animation
   * @param {Object} lim - Consists of Axis limits
   */


  LineDataset.prototype.animateCommonElements = function animateCommonElements(lineOb, anim, lim) {
    var dataset = this,
        key = '',
        item = {},
        chart = dataset.getFromEnv('chart'),
        paper = dataset.getFromEnv('paper'),

    // containers = dataset.graphics.containers,
    firstDraw = !dataset.drawn,
        dsConfig = dataset.config,
        legendInteractivity = dsConfig.legendInteractivity,
        appearingAnimation = legendInteractivity && dataset.getState('visible'),
        hidingAnimation = (legendInteractivity || dataset.removed) && !dataset.getState('visible'),
        chartConfig = chart.config,
        clear = chartConfig.realTimeConfig && chartConfig.realTimeConfig.clear,
        clipCanvas = dataset.getClip('canvas'),
        clipCanvasInit = dataset.getClip('init'),
        shadow = dsConfig.shadow,
        commonElemGroup = dataset.getContainer('commonElemsGroup'),
        removeEl = function removeEL(item) {
      item.el.remove();
    },
        applyAttr = function applyAttr(el, attr) {
      return function () {
        el.attr(attr);
      };
    },
        fullPath,
        fullOldPath,
        applyFullPath = function applyFullPath(fullPath) {
      this.attr({
        path: fullPath
      });
    },
        isSingleStepAnim = chart.config.isSingleStepAnim || chart.state === 'realTimeUpdate',
        isRealTimeUpdate = chart.state === 'realTimeUpdate',
        j,
        jj,
        hasDifferentColor;
    // Iterating over line storing Object
    for (key in lineOb) {
      item = lineOb[key];
      if (item.used) {
        // generate path and old path
        fullPath = [];
        fullOldPath = [];
        hasDifferentColor = !!item.hasDifferentColor;
        for (j = 0, jj = item.path.length; j < jj; ++j) {
          fullPath = fullPath.concat(item.path[j].getPathArr());
        }
        if (item.prevPath) {
          for (j = 0, jj = item.prevPath.length; j < jj; ++j) {
            fullOldPath = fullOldPath.concat(dataset.getOldPath(item.prevPath[j], lim).getPathArr());
          }
        }
        // create line if doesnt exist
        // @temp need to visit
        if (!item.el) {
          item.el = paper.path({
            path: fullPath
          }, commonElemGroup);
          !firstDraw && item.el.attr({
            opacity: 1
          });
        }
        // stopping previous animation
        item.el.stop();
        item.el.attr(item.attr);
        // Applying shadow
        item.el.shadow(shadow, commonElemGroup);
        // Putting line element before shadow
        item.el.toFront();

        if (clear) {
          item.el.hide();
        } else if (!legendInteractivity) {
          if (hasDifferentColor) {
            if (anim) {
              item.el.show();
              anim.initial.data.push({
                el: item.el,
                attrs: {
                  opacity: 0
                },
                callback: applyFullPath.bind(item.el, fullPath)
              });
              dataset.getState('visible') && anim['final'].data.push({
                el: item.el,
                attrs: {
                  opacity: 1
                }
              });
            } else {
              // while dragging
              applyFullPath.call(item.el, fullPath);
            }
          } else if (firstDraw) {
            item.el.attr({
              path: fullPath
            });
            item.el.attr({
              opacity: 1
            });
          } else if (anim) {
            // anim sync with axis
            !isSingleStepAnim && item.prevPath && anim.initial.data.push({
              el: item.el,
              attrs: {
                path: fullOldPath
              },
              animConfig: [{
                syncWith: 'axis'
              }]
            });
            // normal anim
            !isRealTimeUpdate && anim.plot.data.push({
              el: item.el,
              attrs: {
                path: fullPath
              },
              preAnimFn: applyAttr(item.el, {
                opacity: 1
              }),
              animConfig: [{
                smartMorph: {
                  divide: true
                }
              }]
            }) || anim.plot.data.push({
              el: item.el,
              attrs: {},
              preAnimFn: applyFullPath.bind(item.el, fullPath)
            });
          } else {
            // During drag
            item.el.attr({
              path: fullPath
            });
          }
        } else {
          item.el.attr('opacity', 1);
        }
        // Else if item not used
      } else {
        // Remove the element
        anim.initial.data.push({
          el: item.el,
          attrs: {
            opacity: 0
          },
          animConfig: [{
            start: 0,
            end: 1
          }],
          callback: removeEl.bind(null, item)
        });
        delete lineOb[key];
      }
      // Mark for next event that
      // this element was before
      item.old = true;
      item.used = false;
      item.prevPath = item.path;
      item.attrs = UNDEF;
      item.path = UNDEF;
    }
    // Stopping previous animation
    commonElemGroup.stop();

    if (anim) {
      // Initial or Appearing Animation from left to right
      if (firstDraw || appearingAnimation) {
        commonElemGroup.attr({
          'clip-rect': clipCanvasInit
        });

        // In case path was modified due to resize
        // set it to original first
        item.el.attr({
          path: fullPath
        });

        anim.plot.data.push({
          el: commonElemGroup,
          attrs: {
            'clip-rect': clipCanvas
          }
        });
      } else if (hidingAnimation) {
        commonElemGroup.attr({
          'clip-rect': clipCanvas
        });
        anim.plot.data.push({
          el: commonElemGroup,
          attrs: {
            'clip-rect': clipCanvasInit
          },
          animConfig: [{
            start: 0,
            end: 1
          }]
        });
      } else if (chart.state === 'noAnim') {
        commonElemGroup.attr({
          'clip-rect': null
        });
      } else if (chart.state === 'resize') {
        anim.plot.data.push({
          el: commonElemGroup,
          attrs: {
            'clip-rect': clipCanvas
          }
        });
      }
      // @temp - need to remove
      // else {
      //   commonElemGroup.attr({
      //     'clip-rect': null
      //   });
      // }
    }
  };

  /**
   * Calculate the shift of line plot for 2D, 3D charts
   * @param {string} type - Determines x axis or y axis
   * @return {number} Value of shift
   */


  LineDataset.prototype.getLineShift = function getLineShift(type) {
    var dataset = this,
        chart = dataset.getFromEnv('chart'),
        is3D = chart.is3D,
        use3dlineshift = chart.config.use3dlineshift,
        xDepth = is3D ? 10 : 0,
        yDepth = is3D ? use3dlineshift ? 0 : -10 : 0;
    return type === 'y' ? yDepth : xDepth;
  };

  /**
   * Function to draw line
   * @param {Object} anim The animation object which will be passed to animation manager. All
   *                      animation configuration should be pushed into this.
   * Line chart has a setLevel attribute 'color', thus line segments can have different colors,
   * but a line path can support only one color, so we are making multiple paths depending on the
   * color applied. lineOb is object having all line elements and key is the color and stroke combined,
   * thus all line segment having same color is grouped under one key. elements having different
   * line color is animated by fading in and out, on main color's line element transition is applied.
   */


  LineDataset.prototype.drawCommonElements = function drawCommonElements(anim) {
    var dataset = this,
        dataStore = dataset.components.data,
        dsConfig = dataset.config,
        xAxis = dataset.getFromEnv('xAxis'),
        yAxis = dataset.getFromEnv('yAxis'),

    // styles
    lineDashStyle = dsConfig.lineDashStyle,
        dashStyle,
        lineThickness = dsConfig.linethickness,
        colorObj,
        lineColorObj = {
      color: dsConfig.linecolor,
      alpha: dsConfig.alpha
    },
        lscthash = [(0, _lib.toRaphaelColor)(lineColorObj), lineDashStyle].join(':'),
        dataHash = lscthash,
        lim = {
      x: xAxis.getLimit(),
      y: yAxis.getLimit()
    },
        i,
        ii = dataStore.length,
        lineOb = dataset.lineOb || {},
        dataObj,
        colorHash,
        config,
        startIndex = 0,
        endIndex,
        connectorPath,
        connectorPathWithNulls,
        nullPointsArr,
        lineBreak = false,

    // function to add new line element depending on color
    // to the lineOb
    createLine = function createLine(key, path, pathwithnull) {
      var item = lineOb[key];
      if (!item) {
        item = lineOb[key] = {};
      }
      // Mark this item was used in this draw
      // function call
      if (key !== dataHash) {
        // Mark this line element as with a different color
        item.hasDifferentColor = true;
      }
      item.used = true;
      item.pathWithNull = pathwithnull;
      item.path = item.path || [];
      item.stroke = key.split(':')[0];
      item.dashStyle = key.split(':')[1];
      item.path.push(path);
      item.dashStyle = item.dashStyle && item.dashStyle.split(',');
      item.attr = {
        'stroke-dasharray': item.dashStyle,
        'stroke-width': lineThickness,
        'stroke': item.stroke,
        'stroke-linecap': 'round',
        'stroke-linejoin': lineThickness > MAX_MITER_LINEJOIN ? 'round' : 'miter'
      };
    },
        hasRegressionLine = dsConfig.showRegressionLine,
        regressionData,
        regressionOb = dataset.regressionOb = dataset.regressionOb || {},
        tempStore = [];

    if (hasRegressionLine) {
      regressionOb.attr = regressionOb.attr || {};
      regressionData = dsConfig.regressionData;
      regressionOb.attr.stroke = dsConfig.regressionLineColor;
      regressionOb.attr['stroke-opacity'] = dsConfig.regressionLineAlpha;
      regressionOb.attr['stroke-width'] = dsConfig.regressionLineThickness;
      regressionOb.attr.path = [['M', xAxis.getPixel(regressionData[0].x), yAxis.getPixel(regressionData[0].y)], ['L', xAxis.getPixel(regressionData[1].x), yAxis.getPixel(regressionData[1].y)]];
    }

    // Setting min and max pixels
    lim.x.minPixel = xAxis.getPixel(lim.x.min);
    lim.x.maxPixel = xAxis.getPixel(lim.x.max);
    lim.y.minPixel = yAxis.getPixel(lim.y.min);
    lim.y.maxPixel = yAxis.getPixel(lim.y.max);
    lim.y.base = yAxis.getPixel(0);
    lim.x.base = xAxis.getPixel(0);

    for (i = 0; i < ii; ++i) {
      dataObj = dataStore[i];
      if (!dataObj) {
        continue;
      }
      config = dataObj.config || {};
      config._Pbx = UNDEF;
      config._Pby = UNDEF;
      // Pushing configurations to save
      // reference for later
      tempStore[i] = {
        config: {
          _Px: config._Px,
          _Py: config._Py,
          setValue: config.setValue
        }
      };
      // Storing the color Object of this dat
      colorObj = {
        color: config.setColor,
        alpha: config.setAlpha
      };
      // xPos = config._Px,
      // yPos = config._Py;
      dashStyle = config.dashStyle;
      colorHash = [(0, _lib.toRaphaelColor)({
        color: (0, _lib.pluck)(colorObj.color, lineColorObj.color),
        alpha: (0, _lib.pluck)(colorObj.alpha, lineColorObj.alpha)
      }), dashStyle || lineDashStyle].join(':');

      if (lscthash !== colorHash) {
        lineBreak = true;
        endIndex = i;
        connectorPath = dataset.getLinePath(dataStore, {}, {
          begin: startIndex,
          end: endIndex + 1
        });
        connectorPathWithNulls = dataset.getLinePath(dataStore, {}, {
          begin: startIndex,
          end: endIndex + 1
        }, nullPointsArr);
        config.connStartIndex = startIndex;
        config.connEndIndex = endIndex;
        createLine(lscthash, connectorPath, connectorPathWithNulls.getPathArr());
        lscthash = colorHash;
        startIndex = i;
        endIndex = null;
      }
      lscthash = colorHash;
    }
    if (!colorHash) {
      return;
    }
    dsConfig.pathStartIndex = startIndex;
    dsConfig.pathEndIndex = endIndex;

    connectorPath = dataset.getLinePath(dataStore, {}, {
      begin: lineBreak ? startIndex : dsConfig.scrollMinVal,
      end: lineBreak ? endIndex : dsConfig.scrollMaxVal
    });
    connectorPathWithNulls = dataset.getLinePath(dataStore, {}, {
      begin: startIndex,
      end: endIndex
    }, nullPointsArr);
    createLine(colorHash, connectorPath, connectorPathWithNulls.getPathArr());
    dataset.animateCommonElements(lineOb, anim, lim);
    // Saving for next
    dataset.lineOb = lineOb;
    dsConfig.prevLim = lim;
    // Storing current datastore
    dsConfig.prevDataStore = tempStore;
  };

  /**
   * Returns the name of the component
   * @return {string} The name of the component, in this case 'line'.
   */


  LineDataset.prototype.getName = function getName() {
    return 'line';
  };

  /**
   * Function to show the dataset and raise an event
   */


  LineDataset.prototype.show = function show() {
    _AreaDataset.prototype.show.call(this);
    this.fireEvent('datasetVisibilityChanged', {
      dataset: this,
      state: 'show'
    });
  };

  /**
   * Function to hide the dataset and raise an event
   */


  LineDataset.prototype.hide = function hide() {
    _AreaDataset.prototype.hide.call(this);
    this.fireEvent('datasetVisibilityChanged', {
      dataset: this,
      state: 'hide'
    });
  };

  return LineDataset;
}(_area2['default']);

exports['default'] = LineDataset;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports._setDefaultConfig = undefined;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(23);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */

var UNDEF = void 0,
    SEVENTYSTRING = _lib.preDefStr.SEVENTYSTRING,
    _setDefaultConfig = void 0;

/**
 * Base class for area chart.
 */

var AreaBase = function (_MSColumn2D) {
  _inherits(AreaBase, _MSColumn2D);

  function AreaBase() {
    _classCallCheck(this, AreaBase);

    return _possibleConstructorReturn(this, _MSColumn2D.apply(this, arguments));
  }

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  AreaBase.getName = function getName() {
    return 'AreaBase';
  };

  /**
   * Parsing default chart configurations
   */


  AreaBase.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _MSColumn2D.prototype.__setDefaultConfig && _MSColumn2D.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    // Anchor related attributes
    config.anchorborderthickness = 1;
    config.anchorimageurl = UNDEF;
    config.anchorimagepadding = 1;
    config.anchorsides = 1;
    config.anchoralpha = UNDEF;
    config.anchorbgalpha = _lib.HUNDREDSTRING;
    config.anchorimagealpha = _lib.HUNDREDSTRING;
    config.anchorimagescale = 100;
    config.anchorstartangle = 90;
    config.anchorshadow = 0;
    config.anchorbgcolor = UNDEF;
    config.anchorbordercolor = UNDEF;
    config.anchorradius = 3;
    config.showvalues = 1;
    config.plotfillalpha = SEVENTYSTRING;
    config.linedashlen = 5;
    config.linedashgap = 4;
    config.linedashed = UNDEF;
    config.linealpha = _lib.HUNDREDSTRING;
    config.linethickness = 2;
    config.drawfullareaborder = 1;
    config.connectnulldata = 0;
  };

  return AreaBase;
}(_fusioncharts2['default']);

exports._setDefaultConfig = _setDefaultConfig = AreaBase.prototype.__setDefaultConfig;
exports['default'] = AreaBase;
exports._setDefaultConfig = _setDefaultConfig;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(303), __esModule: true };

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.configure = exports._createToolBox = exports._drawDataset = exports._allocateXAxisLabelSpace = undefined;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(361);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _constructor = __webpack_require__(79);

var _canvas = __webpack_require__(210);

var _canvas2 = _interopRequireDefault(_canvas);

var _redraphael = __webpack_require__(17);

var _redraphael2 = _interopRequireDefault(_redraphael);

var _vcanvas = __webpack_require__(144);

var _vcanvas2 = _interopRequireDefault(_vcanvas);

var _gradientLegend = __webpack_require__(405);

var _gradientLegend2 = _interopRequireDefault(_gradientLegend);

var _eventApi = __webpack_require__(7);

var _caption = __webpack_require__(212);

var _caption2 = _interopRequireDefault(_caption);

var _subCaption = __webpack_require__(406);

var _subCaption2 = _interopRequireDefault(_subCaption);

var _background = __webpack_require__(407);

var _background2 = _interopRequireDefault(_background);

var _colormanager = __webpack_require__(408);

var _colormanager2 = _interopRequireDefault(_colormanager);

var _quadrant = __webpack_require__(409);

var _quadrant2 = _interopRequireDefault(_quadrant);

var _numberformatter = __webpack_require__(410);

var _numberformatter2 = _interopRequireDefault(_numberformatter);

var _animationManager = __webpack_require__(411);

var _animationManager2 = _interopRequireDefault(_animationManager);

var _alertmanager = __webpack_require__(412);

var _alertmanager2 = _interopRequireDefault(_alertmanager);

var _legend = __webpack_require__(413);

var _legend2 = _interopRequireDefault(_legend);

var _mouseTracker = __webpack_require__(414);

var _mouseTracker2 = _interopRequireDefault(_mouseTracker);

var _lib = __webpack_require__(5);

var _libAttr = __webpack_require__(184);

var _cartesian = __webpack_require__(22);

var _cartesian2 = _interopRequireDefault(_cartesian);

var _domEvent = __webpack_require__(34);

var _domEvent2 = _interopRequireDefault(_domEvent);

var _toolbox = __webpack_require__(67);

var _toolbox2 = _interopRequireDefault(_toolbox);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */


var isVML = !!(window.SVGAngle || document.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1')),
    isIOS = navigator.userAgent.match(/ (iPad|iPhone|iPod)/g),
    DEFAULT_EXPORT_URL = location.protocol === 'https:' ? 'https://export.api3.fusioncharts.com/' : 'http://export.api3.fusioncharts.com/',
    TRACKER_FILL = 'rgba(255,0,0,' + (_lib.isIE ? 0.002 : 0.000001) + ')',
    // invisible but clickable
mathMax = Math.max,
    mathMin = Math.min,
    mathRound = Math.round,
    NONE = _lib.preDefStr.noneStr,
    LOGOROLLOUT = 'LogoRollout',
    LOGOROLLOVER = 'LogoRollover',
    LOGOCLICK = 'LogoClick',
    LOGOLOADED = 'LogoLoaded',
    LOGOLOADERROR = 'LogoLoadError',
    SEVENTYSTRING = _lib.preDefStr.SEVENTYSTRING,
    AUTO = _lib.preDefStr.AUTOSTRING,
    TL = 'tl',
    BOLD = 'bold',
    NORMAL = 'normal',
    getDataset = function getDataset(component) {
  var datasets = [];
  component.iterateComponents(function (child) {
    if (child.getType() === 'dataset') {
      datasets.push(child);
    }
  });
  return datasets;
},
    onContainerClick = function onContainerClick(e) {
  var tgt = e.target || e.originalTarget || e.srcElement || e.relatedTarget || e.fromElement,
      parentElem = tgt && tgt.parentElement,
      tgtNodeName = tgt && tgt.nodeName.toLowerCase(),
      chart = e.data,
      fusionCharts = chart.chartInstance,
      oriEvent = e.originalEvent,
      coordinate = (0, _lib.getMouseCoordinate)(chart.getFromEnv('chart-container'), oriEvent, chart),
      args;

  if (!fusionCharts.ref) {
    return;
  }

  args = (0, _lib.extend2)({
    height: fusionCharts.args.height,
    width: fusionCharts.args.width,
    pixelHeight: fusionCharts.ref.offsetHeight,
    pixelWidth: fusionCharts.ref.offsetWidth,
    id: fusionCharts.args.id,
    renderer: fusionCharts.args.renderer,
    container: fusionCharts.options.containerElement
  }, coordinate);

  /**
   * This event is fired when the chart is clicked. For touch devices, this event is fired when user
   * taps on the chart.
   *
   * This event provides useful information on the position of mouse relative to the chart and the page.
   * This can be used to position things like annotations based on where the chart is clicked.
   *
   * @see FusionCharts#event:chartRollOver
   * @see FusionCharts#event:chartRollOut
   * @see FusionCharts#event:chartMouseMove
   *
   * @event FusionCharts#chartClick
   * @since 3.4.0
   * @group chart
   *
   * @param {string} container - The DOM element within which the chart has been rendered.
   * @param {string} id - The `id` of the chart that has triggered this event.
   *
   * @param {string} height - The height of the chart specified at the time of rendering the chart in
   * pixels or percent.
   * @param {string} width - The width of the chart specified at the time of rendering the chart in pixels
   * or percent.
   *
   * @param {number} chartX - The x-coordinate of the mouse relative to the position of the chart.
   * @param {number} chartY - The y-coordinate of the mouse relative to the position of the chart.
   *
   * @param {number} pageX - The x-coordinate of the mouse relative to the document.
   * @param {number} pageY - The y-coordinate of the mouse relative to the document.
   *
   * @param {number} pixelHeight - The height of the chart in pixels. This is equivalent to the
   * `offsetHeight` of the chart container.
   * @param {number} pixelWidth - The width of the chart in pixels. This is equivalent to the
   * `offsetWidth` of the chart container.
   *
   * @example
   * FusionCharts.ready(function () {
   *     var chart = new FusionCharts({
   *         type: 'column2d',
   *         dataFormat: 'jsonurl',
   *         dataSource: 'chart-data.json',
   *         renderAt: 'chart-container-div',
   *
   *         events: {
   *             chartClick: function (eventObj, argsObj) {
   *                 console.log('Chart clicked at ' + argsObj.chartX + ',' + argsObj.chartY);
   *             }
   *         }
   *     });
   *
   *     chart.render();
   * });
   */
  (0, _eventApi.triggerEvent)('chartclick', chart.chartInstance, args);

  // do not receive event if the clicked target element is marked as
  // hot
  if (tgt && tgt.ishot && chart) {
    return;
  } else if (tgtNodeName === 'tspan' && parentElem && parentElem.ishot && chart) {
    /* The above check identifies text element and its related `ishot` proprty to
      * igonre the container click method.
      * This is a text element and Raphel creates text inside tspan element inside
      * text element. If we declare `ishot` attribute on the text element the target
      * may or may not derive it based on the way how text was declared in Raphael
      */
    return;
  }

  chart.config.link && chart.linkedItems.linkClickFN.call(chart, chart);
},
    chartHoverManager = function chartHoverManager(e) {
  var type = e.type,
      chart = e.data,
      linkedItems = chart.linkedItems || {},
      listeners = linkedItems.eventListeners || (linkedItems.eventListeners = []);

  // rollover
  if ((type === 'mouseover' || type === 'touchstart') && chart.mouseStateIn === false) {
    chart.mouseStateIn = true;
    MSCartesian.onContainerRollOver(e);
    // On mouse rollover on the chart, attach window mouseover event
    listeners.push(_domEvent2['default'].listen(isVML ? document : window, 'mouseover', MSCartesian.winMouseHover, chart));
  }
};
/**
 * function to allocate space x axis label
 * It restricts xAxis to take maximum space for for label
 * @param {Component}  axis xAxis instance of CartesianAxis
 */
function _allocateXAxisLabelSpace(axis) {
  var iapi = this,
      config = iapi.config,
      dimensions = axis.getAxisEndLabelDisplaySpace(),
      left = dimensions.left,
      right = dimensions.right,
      top = dimensions.top,
      sum,
      bottom = dimensions.bottom,
      availableWidth = config.availableWidth,
      availableHeight = config.availableHeight,
      canvasLeft = config.canvasLeft,
      canvasRight = config.canvasRight,
      canvasTop = config.canvasTop,
      canvasBottom = config.canvasBottom,
      width = config.width,
      height = config.height,
      setDimension = function setDimension(dimension1, dimension2) {
    if (dimension1 < dimension2 && dimension2 > 0) {
      return dimension2 - dimension1;
    } else {
      return 0;
    }
  };

  // Restricting space allocation to the maximum available space
  if (top + bottom > availableHeight) {
    sum = top + bottom;
    top = availableHeight * top / sum;
    bottom = availableHeight * bottom / sum;
  }

  if (left + right > availableWidth) {
    sum = left + right;
    left = availableWidth * left / sum;
    right = availableWidth * right / sum;
  }

  // Checking for existing canvas to chart space and recalculationg space allocation.
  left = setDimension(canvasLeft, left);
  right = setDimension(width - canvasRight, right);
  top = setDimension(canvasTop, top);
  bottom = setDimension(height - canvasBottom, bottom);

  iapi._allocateSpace({
    left: left,
    right: right,
    top: top,
    bottom: bottom
  });
}
/**
 * Create a toolbox with a context menu.
 * Add context menus for export and print options if enabled.
 * Create the chart Menu bar as a chart component.
 */
function _createToolBox2() {
  var tb,
      sCon,
      conf,
      list,
      group,
      toolBoxAPI,
      SymbolStore,
      ComponentGroup,
      SymbolWithContext,
      HorizontalToolbar,
      pId,

  // isbtoaSupported = !!window.btoa,
  iapi = this,

  // jsonData = iapi.jsonData.chart,
  // exportShowMenuItem = pluckNumber(jsonData.exportshowmenuitem),
  // exportFormats = jsonData.exportformats,
  chartMenuTools = iapi.getFromEnv('chartMenuTools'),
      getChartTools = chartMenuTools.get,
      setChartTools = chartMenuTools.set,
      iapiComponents = this.components,
      iapiConfig = iapi.config,

  // exportEnabled = iapiConfig.exportOption.enabled,
  chartMenuBar = iapi.getChildren('chartMenuBar'),
      actionBar = iapi.getChildren('actionBar'),
      printEnabled = iapiConfig.printOption.enabled;
  // exportString = 'Export As ',
  // fn,
  // exportMap = {
  //   PNG: exportString + 'PNG',
  //   JPG: exportString + 'JPG',
  //   PDF: exportString + 'PDF',
  //   SVG: exportString + 'SVG',
  //   XLS: exportString + 'XLS'
  // },
  // usrExportType,
  // tbParam = {},
  // tbConfigArr = [],
  // exportType,
  // exportParam,
  // length,
  // type,
  // i;

  /* Do not reconfigure the toolbox if its already drawn. This flag is set falsy on each time configurations
  are updated. */
  if (chartMenuBar && chartMenuBar.drawn || actionBar && actionBar.drawn) {
    return;
  }

  // create a new instance of the toolbar component.
  // tb = iapiComponents.tb || (iapiComponents.tb = new Toolbox());
  // if (!(tb = iapi.getChildren('tb'))) {
  //   tb = iapi.attachChild(new Toolbox(), 'tb', false);
  // }

  // tb.configure({
  //   graphics: iapi.graphics || (iapi.graphics = {}),
  //   chart: iapi,
  //   components: iapiComponents
  // });
  (0, _lib.componentFactory)(iapi, _toolbox2['default'], 'tb', 1, [{
    graphics: iapi.graphics || (iapi.graphics = {}),
    chart: iapi,
    components: iapiComponents
  }]);
  tb = iapi.getChildren('tb')[0];
  pId = tb.getICount();
  iapi.addToEnv('toolbox', tb);

  // get the instance APIs.
  // iapiComponents.toolBoxAPI = toolBoxAPI = iapiComponents.toolBoxAPI || (iapiComponents.toolBoxAPI =
  //           tb.getAPIInstances(tb.ALIGNMENT_HORIZONTAL));
  !iapi.getFromEnv('toolBoxAPI') && iapi.addToEnv('toolBoxAPI', tb.getAPIInstances(tb.ALIGNMENT_HORIZONTAL));
  toolBoxAPI = iapi.getFromEnv('toolBoxAPI');
  SymbolWithContext = toolBoxAPI.SymbolWithContext;
  SymbolStore = toolBoxAPI.SymbolStore;
  ComponentGroup = toolBoxAPI.ComponentGroup;
  HorizontalToolbar = toolBoxAPI.Toolbar;

  tb.idCount = tb.idCount || 0;
  tb.pId = pId;

  conf = tb.getDefaultConfiguration();

  SymbolStore.register('ContextIcon', function (posx, posy, rad) {
    var x = posx,
        y = posy,
        r = rad * 2,
        space = mathRound(r / 4),
        halfWidth = mathRound(r / 2) * 0.7,
        startX = x - halfWidth,
        endX = x + halfWidth,
        startY = y + space,
        endY = y - space;
    return ['M', startX, y, 'L', endX, y, 'M', startX, startY, 'L', endX, startY, 'M', startX, endY, 'L', endX, endY];
  });

  sCon = new SymbolWithContext('ContextIcon', tb.idCount++, pId);
  list = sCon.getListRefernce();
  iapi.addToEnv('chartMenuList', list);

  // if (exportEnabled && exportShowMenuItem !== 0) {
  //   if (exportFormats) {
  //     exportType = exportFormats.split('|');
  //     for (i = 0, length = exportType.length; i < length; i++) {
  //       exportParam = exportType[i].split('=');
  //       type = exportParam[0].toUpperCase();
  //       exportMap[type] && (exportMap[type] = exportParam[1] || exportMap[type]);
  //       exportMap[type] && (usrExportType || (usrExportType = {})) && (usrExportType[type] = true);
  //     }
  //   }

  //   fn = function (typeObj) {
  //     return function () {
  //       // lib.exportChart.call(iapi, typeObj);
  //     };
  //   };

  //           // **** temp code STARTs. Modules will add them.
  //           // add the export context in the context menu.
  //   for (type in exportMap) {
  //     if ((type === 'XLS' && !isbtoaSupported) || (usrExportType && !usrExportType[type])) {
  //       continue;
  //     }
  //     tbParam = {};
  //     tbParam[exportMap[type]] = {
  //       handler: fn({exportformat: type}),
  //       action: 'click'
  //     };
  //     tbConfigArr.push(tbParam);
  //   }
  //   setChartTools(tbConfigArr);
  // }

  // add the print context in the context menu.
  printEnabled && setChartTools([{
    'Print': {
      handler: function handler(options) {
        iapi.chartInstance.print(options);
      },
      action: 'click'
    }
  }]);
  // list.dispose();
  // append the list finally.
  list.appendAsList(getChartTools());

  // create a new group.
  group = new ComponentGroup(tb.idCount++, pId);
  // sets the default configuration for a button element
  group.setConfiguaration({
    buttons: conf,
    group: {
      fill: TRACKER_FILL,
      borderColor: TRACKER_FILL
    }
  });

  group.addSymbol(sCon);

  // delete iapiComponents.chartMenuBar;
  // delete iapiComponents.actionBar;
  // iapi.getChildren('chartMenuBar') && iapi.getChildren('chartMenuBar').dispose();
  // iapi.getChildren('actionBar') && iapi.getChildren('actionBar').dispose();

  if (group.btnConfig.vAlign === 't') {
    // create a new Horizontal toolbar
    // chartMenuBar = iapiComponents.chartMenuBar = new HorizontalToolbar(tb.idCount++, tb.pId);
    chartMenuBar = iapi.attachChild(new HorizontalToolbar(tb.idCount++, tb.pId), 'chartMenuBar', false);
    chartMenuBar.addComponent(group);
  } else {
    // create a new Horizontal toolbar
    // chartMenuBar = iapiComponents.actionBar = new HorizontalToolbar(tb.idCount++, tb.pId);
    chartMenuBar = iapi.attachChild(new HorizontalToolbar(tb.idCount++, tb.pId), 'actionBar', false);
    chartMenuBar.addComponent(group);
  }
}
/**
 * *@TODO this function should be removed after validating the realtime charts
 */
function _drawDataset() {
  var iapi = this,
      canvas = iapi.getChildren('canvas')[0];

  canvas._mapChildren(function (child) {
    child.syncDraw();
  });

  // Realtime helper function
  iapi._setRTdata && iapi._setRTdata();
}
/**
 * helper function to create component and configure and also configure the chart
 * It creates components which are depend on data and configure them and also configure chart
 * @param  {Object} dataObj contains json data of the chart
 */
// function configure (dataObj) {
//   dataObj.chart = (dataObj.chart || dataObj.graph || dataObj.map || { });
//   let i,
//     j,
//     k,
//     bPosition,
//     bHAlign,
//     bVAlign,
//     xAxis = [],
//     yAxis = [],
//     axes,
//     vCanvas,
//     canvas,
//     iapi = this,
//     jsonData = iapi.jsonData = dataObj || iapi.jsonData,
//     chartAttrs,
//     chartInstance = iapi.chartInstance,
//     is3D = iapi.is3D,
//     palleteString = is3D ? chartPaletteStr.chart3D : chartPaletteStr.chart2D,
//     config,
//     isBar = iapi.isBar,
//     inCanfontFamily,
//     inCanfontSize,
//     inCancolor,
//     fontSize,
//     // outCanfontFamily,
//     // outCancolor,
//     colorM = iapi.getFromEnv('color-manager'),
//     annotation = iapi.getChildren().annotation,
//     style,
//     zeroPlaneColor,
//     zeroPlaneAlpha,
//     inCanvasStyle,
//     inCanLineHeight,
//     dataLabelStyle,
//     fontBdrColor,
//     showCanvasBase,
//     realtimeEnabled,
//     enableAnimation,
//     transposeAnimation,
//     animation,
//     updateDuration = false,
//     initAnimDuration,
//     transposeAnimDuration,
//     key,
//     skipConfigureIteration = {},
//     animTypeObj = {
//       linear: 'linear',
//       easein: 'easeIn',
//       easeout: 'easeOut',
//       easeinout: 'easeInOut',
//       backin: 'backIn',
//       backout: 'backOut',
//       elastic: 'elastic',
//       bounce: 'bounce'
//     },
//     animConfig = {
//       'bubble': {
//         plotTranslate: {
//           duration: 1000,
//           effect: 'elasticOnce'
//         },
//         plotAppear: {
//           duration: 1000,
//           effect: 'bounce'
//         },
//         plotDisappear: {
//           duration: 1000,
//           effect: 'bounce'
//         },
//         categoryLine: {
//           duration: 1000,
//           effect: 'linear'
//         },
//         colorChange: {
//           duration: 1000,
//           effect: 'linear'
//         }
//       },
//       general: {
//         getDurationByPercent: function (i, len, percentDuration) {
//           var start = (i / len) * (1 - percentDuration);
//           return {
//             start: start,
//             end: start + percentDuration
//           };
//         },
//         getDurationByIndex: function (i, len, startIn, endInc) {
//           return {
//             start: (i + startIn) / len,
//             end: (i + endInc) / len
//           };
//         }
//       },
//       'funnelPyramid': {
//         sliceAnimType: 'bounce'
//       },
//       'angulargauge': {
//         initialDialAnimType: 'bounce'
//       },
//       'column': {
//         initialRender: {
//           effect: 'easeInOutQuint'
//         },
//         update: {
//           effect: 'linear'
//         },
//         legendInteraction: {
//           effect: 'easeInOutQuint'
//         }
//       }
//     };

//   // Add chartAttrs in the env
//   iapi.addToEnv('chart-attrib', jsonData.chart);

//   if (!colorM) {
//     colorM = new ColorManager(iapi);
//     iapi.addToEnv('color-manager', colorM);
//   }
//   // Create the legend object
//   iapi._createLegend();
//   componentFactory(iapi, Caption, 'caption');
//   componentFactory(iapi, SubCaption, 'subCaption');
//   componentFactory(iapi, Canvas, 'canvas');
//   canvas = iapi.getChildren('canvas')[0];
//   iapi.isXY && componentFactory(canvas, Quadrant, 'quadrant');
//   // Create Axis components.
//   iapi._createAxes();

//   iapi._feedAxesRawData();
//   skipConfigureIteration.axis = true;
//   componentFactory(iapi, Background, 'background');

//   axes = iapi.getChildren('xAxis');
//   for (k = 0; k < (axes && axes.length); k++) {
//     if (!axes[k].getState('removed')) {
//       xAxis.push(axes[k]);
//     }
//   }
//   axes = iapi.getChildren('yAxis');
//   for (k = 0; k < (axes && axes.length); k++) {
//     if (!axes[k].getState('removed')) {
//       yAxis.push(axes[k]);
//     }
//   }

//   if (xAxis && yAxis) {
//     componentFactory(canvas, VirtualCanvas, 'vCanvas',
//       xAxis.length * yAxis.length);
//     vCanvas = canvas.getChildren('vCanvas');
//     for (i = 0, k = 0; i < (xAxis && xAxis.length); i++) {
//       for (j = 0; j < (yAxis && yAxis.length); j++, k++) {
//         vCanvas[k]
//           .init(iapi)
//           .xAxis(xAxis[i])
//           .yAxis(yAxis[j])
//           .canvas(canvas);
//         vCanvas[k].addToEnv('vCanvas', vCanvas[k]);
//       }
//     }
//   }
//   jsonData.chart = (jsonData.chart || jsonData.graph ||
//                 jsonData.map || { });
//   delete jsonData.map;
//   delete jsonData.graph;
//   chartAttrs = jsonData.chart;
//   !chartAttrs && (chartAttrs = jsonData.chart = {});
//   config = iapi.config || (iapi.config = { });

//   // set and parse the default configuration
//   if (iapi.__setDefaultConfig) {
//     iapi.__setDefaultConfig();
//   }

//   parseConfiguration(chartAttrs, config);

//         // set the balnk snapLiterals object for annotation
//   config.snapLiterals = { };

//         // set the configuration for zooming
//   config.viewPortConfig = {
//     'scaleY': 1,
//     'scaleX': 1,
//     'x': 0,
//     'y': 0
//   };

//   config.dataCount = 0;
//   config.drawLabelInitially = pluckNumber(chartAttrs.drawlabelinitially);

//         // parse all 3d canvas attributes
//   if (is3D) {
//     if (isBar) {
//       config.xDepth = 5;
//       config.yDepth = 5;
//     } else {
//       config.xDepth = 10;
//       config.yDepth = 10;
//     }
//     config.showCanvasBase = showCanvasBase = Boolean(pluckNumber(chartAttrs.showcanvasbase, 1));
//     config.canvasBasePadding = pluckNumber(chartAttrs.canvasbasepadding, 2);
//     config.canvasBaseDepth = showCanvasBase ? pluckNumber(chartAttrs.canvasbasedepth, 10) : 0;
//     config.canvasBgDepth = pluckNumber(chartAttrs.canvasbgdepth, 3);
//   }

//         // Assigning anim config to iapi config
//   config.animConfig = config.animConfig || animConfig;

//   colorM && colorM.configure();

//   config.placeAxisLabelsOnTop = pluckNumber(chartAttrs.placexaxislabelsontop, 0);

//   config.enableAnimation = enableAnimation = pluckNumber(chartAttrs.animation,
//                 chartAttrs.defaultanimation, 1);

//   transposeAnimation = pluckNumber(chartAttrs.transposeanimation, 0);

//   initAnimDuration = enableAnimation ? pluckNumber(chartAttrs.animationduration, 1) * 1000 : 0;
//   transposeAnimDuration = transposeAnimation ?
//                                     pluckNumber(chartAttrs.transposeanimduration, 0.2) * 1000 : 0;

//   config.animationObj && (updateDuration = true);

//   config.animationObj = animation = {
//     initAnimDuration: initAnimDuration,
//     transposeAnimDuration: transposeAnimDuration
//   };

//   if (!updateDuration && (animation.duration === UNDEF)) {
//     animation.duration = animation.initAnimDuration;
//   } else {
//     animation.duration = animation.transposeAnimDuration;
//   }

//   for (key in animTypeObj) {
//     if (key === pluck(chartAttrs.animationeffect)) {
//       config.animationeffect = animTypeObj[key];
//     }
//   }

//   config.showToolTip = pluckNumber(chartAttrs.showtooltip, 1);

//         // Parse configurations
//   config.exportOption = {
//     enabled: pluckNumber(chartAttrs.exportenabled, 0),
//     bgcolor: (chartInstance.jsVars.transparent ||
//                 (pluckNumber(chartInstance.options.containerBackgroundOpacity, 1) === 0)) ? BLANKSTRING :
//                 (chartInstance.options.containerBackgroundColor || '#ffffff'),
//     bgalpha: (chartInstance.jsVars.transparent ? 0 :
//                 pluckNumber(chartInstance.options.containerBackgroundOpacity, 1)) + BLANKSTRING,

//     exporttargetwindow: pluck(chartAttrs.exporttargetwindow, (isIOS ? '_blank' : '_self')),
//     exportaction: (chartAttrs.exportaction &&
//                 (chartAttrs.exportaction.toString().toLowerCase() === 'save') && 'save') || 'download',
//     exportfilename: pluck(chartAttrs.exportfilename, 'FusionCharts'),
//     exporthandler: pluck(chartAttrs.html5exporthandler, chartAttrs.exporthandler, DEFAULT_EXPORT_URL),
//     exportparameters: pluck(chartAttrs.exportparameters, BLANKSTRING),
//     exportformat: pluck(chartAttrs.exportformat, 'PNG'),
//     exportcallback: pluck(chartAttrs.exportcallback, BLANKSTRING),

//     exportwithimages: pluckNumber(chartAttrs.exportwithimages, 1),

//     exportatclientside: pluckNumber(chartAttrs.exportatclientside, 0)
//   };

//   config.printOption = {
//     enabled: pluckNumber(chartAttrs.printshowbutton, chartAttrs.showprintmenuitem, 0)
//   };
//   config.chartMenuOptions = {
//     position: (bPosition = pluck(chartAttrs.toolbarposition, 'tr').toLowerCase()),
//     hAlign: (bHAlign = (BLANKSTRING + chartAttrs.toolbarhalign).toLowerCase() === POSITION_LEFT ?
//             'l' : bPosition.charAt(1)),
//     vAlign: (bVAlign = (BLANKSTRING + chartAttrs.toolbarvalign).toLowerCase() === POSITION_BOTTOM ?
//             'b' : bPosition.charAt(0)),
//     hDirection: pluckNumber(chartAttrs.toolbarhdirection, (bHAlign === 'r' ? -1 : 1)),
//     vDirection: pluckNumber(chartAttrs.toolbarvdirection, (bVAlign === 'b' ? -1 : 1)),
//     vMargin: pluckNumber(chartAttrs.toolbarvmargin, 6),
//     hMargin: pluckNumber(chartAttrs.toolbarhmargin, 10),
//     x: pluckNumber(chartAttrs.toolbarx, bHAlign === 'l' ? 0 : config.width),
//     y: pluckNumber(chartAttrs.toolbary, bVAlign === 't' ? 0 : config.height)
//   };

//   style = config.style = { };
//   // expose to environment
//   // TODO: needs to be mo re clear. So that only one set of style is available in each level
//   iapi.addToEnv('style', style);
//   config.textDirection = chartAttrs.hasrtltext === '1' ? 'rtl' : BLANKSTRING;

//   // ////////Chart font style////////////////////

//   // todo: init incanstyle, outcanstyle, captionStyle, subcaption style

//   style.inCanfontFamily = inCanfontFamily = pluck(chartAttrs.basefont, 'Verdana,sans');
//   style.inCanfontSize = inCanfontSize = pluckFontSize(chartAttrs.basefontsize, 10);
//   style.inCancolor = inCancolor = pluck(chartAttrs.basefontcolor,
//             colorM.getColor(palleteString.baseFontColor));
//   style.outCanfontFamily = pluck(chartAttrs.outcnvbasefont, inCanfontFamily);
//   style.fontSize = fontSize = pluckFontSize(chartAttrs.outcnvbasefontsize, inCanfontSize);
//   style.outCanfontSize = fontSize + PXSTRING;
//   style.outCancolor = pluck(chartAttrs.outcnvbasefontcolor, inCancolor)
//             .replace(/^#? ([a-f0-9]+)/ig, '#$1');
//   style.baseFontSize = inCanfontSize;
//   style.inCanfontSize = inCanfontSize + PXSTRING;
//   style.inCancolor = inCancolor.replace(/^#? ([a-f0-9]+)/ig, '#$1');

//   style.inCanvasStyle = inCanvasStyle = {
//     fontFamily: inCanfontFamily,
//     fontSize: inCanfontSize,
//     color: inCancolor
//   };

//   style.inCanLineHeight = inCanLineHeight = setLineHeight(inCanvasStyle);
//   fontBdrColor = getFirstValue(chartAttrs.valuebordercolor,
//             BLANKSTRING);
//   fontBdrColor = fontBdrColor ? convertColor(
//             fontBdrColor, pluckNumber(chartAttrs.valueborderalpha,
//             chartAttrs.valuealpha, 100)) : BLANKSTRING;

//   config.reverseXAxis = iapi.config.allowreversexaxis && pluckNumber(chartAttrs.reversexaxis, 0);
//   config.showBorder = pluckNumber(chartAttrs.showborder, is3D ? 0 : 1);
//   config.borderWidth = mathMax(config.showBorder ? pluckNumber(chartAttrs.borderthickness, 1) : 0, 0);
//   config.useplotgradientcolor = (chartAttrs.plotgradientcolor === '') ? 0 : config.useplotgradientcolor;
//   config.valuefontbold = pluckNumber(chartAttrs.valuefontbold, config.valuefontbold);

//   config.dataLabelStyle = dataLabelStyle = {
//     fontFamily: pluck(chartAttrs.valuefont, inCanfontFamily),
//     fontSize: pluck(chartAttrs.valuefontsize, pInt(inCanfontSize, 10)) + PXSTRING,
//     lineHeight: inCanLineHeight,
//     color: convertColor(pluck(chartAttrs.valuefontcolor, inCancolor),
//                 pluckNumber(chartAttrs.valuefontalpha,
//                 chartAttrs.valuealpha, 100)),
//     fontWeight: config.valuefontbold ? BOLD : NORMAL,
//     fontStyle: pluckNumber(chartAttrs.valuefontitalic) ? 'italic' :
//                 NORMAL,
//             // Set border as empty string when not required,
//             // since IE will stop js execution if it is UNDEF or null.
//     border: fontBdrColor || chartAttrs.valuebgcolor ?
//                 (pluckNumber(chartAttrs.valueborderthickness, 1) + 'px solid') : BLANKSTRING,
//     borderColor: fontBdrColor,
//     borderThickness: pluckNumber(chartAttrs.valueborderthickness, 1),
//     borderPadding: pluckNumber(chartAttrs.valueborderpadding, 2),
//     borderRadius: pluckNumber(chartAttrs.valueborderradius, 0),
//     backgroundColor: chartAttrs.valuebgcolor ?
//                 convertColor(chartAttrs.valuebgcolor,
//                 pluckNumber(chartAttrs.valuebgalpha, chartAttrs.valuealpha,
//                 100)) : BLANKSTRING,
//     borderDash: pluckNumber(chartAttrs.valueborderdashed, 0) ?
//                 getDashStyle(pluckNumber(chartAttrs.valueborderdashlen, 4),
//                 pluckNumber(chartAttrs.valueborderdashgap, 2),
//                 pluckNumber(chartAttrs.valueborderthickness, 1)) : DASH_DEF
//   };

//   setLineHeight(dataLabelStyle);

//         // @todo: fix the order of inheratance
//   config.orphanStyles = {
//     defaultStyle: {
//       style: extend2({ }, style.inCanvasStyle)
//     },
//     connectorlabels: {
//       style: extend2({ }, config.dataLabelStyle)
//     },
//     vyaxisname: { // for candle stick chart's volume axis
//                 // style: extend2 ( { }, hc.yAxis[0].title.style)
//       style: extend2({ }, style.inCanvasStyle)
//     }
//   };

//   config.legendPosition = pluck(chartAttrs.legendposition, POSITION_BOTTOM);

//         // LOGO URL (foreground) logo parameters
//   config.logoURL = getValidValue(chartAttrs.logourl);
//   config.logoPosition = pluck(chartAttrs.logoposition, 'tl').toLowerCase();
//   config.logoAlpha = pluckNumber(chartAttrs.logoalpha, 100);
//   config.logoLink = getValidValue(chartAttrs.logolink);
//   config.logoScale = pluckNumber(chartAttrs.logoscale, 100);
//   config.logoLeftMargin = pluckNumber(chartAttrs.logoleftmargin, 0);
//   config.logoTopMargin = pluckNumber(chartAttrs.logotopmargin, 0);

//         // Parsing space management attributes
//   config.minChartWidthPercent = pluckNumber(chartAttrs.minchartwidth, iapi.minChartWidth, 50) / 100;
//   config.minChartHeightPercent = pluckNumber(chartAttrs.minchartheight, iapi.minChartHeight, 50) / 100;
//   config.minCanvasWidthPercent = pluckNumber(chartAttrs.mincanvaswidth, iapi.minCanvasWidth, 60) / 100;
//   config.minCanvasHeightPercent = pluckNumber(chartAttrs.mincanvasheight, iapi.minCanvasHeight, 30) / 100;

//   iapi._parseBackgroundCosmetics();

//   // iapi._parseCaptionAttributes();
//   // iapi.getChildren('caption')[0].configure();

//   // Parse canvas drawing options
//   iapi._parseCanvasCosmetics();

//   // borderThickness = pluckNumber(chartAttrs.showborder, 1) ? pluckNumber(chartAttrs.borderthickness, 1) : 0;
//   // chart margins
//   config.origMarginTop = pluckNumber(chartAttrs.charttopmargin, iapi.chartTopMargin, 15);
//   config.origMarginLeft = pluckNumber(chartAttrs.chartleftmargin, iapi.chartLeftMargin, 15);
//   config.origMarginBottom = pluckNumber(chartAttrs.chartbottommargin, iapi.chartBottomMargin, 15);
//   config.origMarginRight = pluckNumber(chartAttrs.chartrightmargin, iapi.chartRightMargin, 15);

//   zeroPlaneColor = pluck(chartAttrs.zeroplanecolor, chartAttrs.divlinecolor,
//                 colorM.getColor(palleteString.divLineColor));
//   zeroPlaneAlpha = pluck(chartAttrs.zeroplanealpha, chartAttrs.divlinealpha,
//             colorM.getColor('divLineAlpha'));
//   config.zeroPlaneColor = convertColor(zeroPlaneColor, zeroPlaneAlpha);
//   config.zeroPlaneBorderColor = convertColor(pluck(chartAttrs.zeroplanebordercolor,
//             zeroPlaneColor), pluckNumber(chartAttrs.zeroplaneshowborder, 1) ? zeroPlaneAlpha : 0);
//   config.zeroPlaneShowBorder = pluckNumber(chartAttrs.zeroplaneshowborder, 1);

//   config.dataStreamURL = parseUnsafeString(chartAttrs.datastreamurl);
//   config.realtimeEnabled = realtimeEnabled = pluckNumber(chartAttrs.realtimeenabled, iapi.isRealTime);

//   config.showLegend = pluckNumber(chartAttrs.showlegend, iapi.showLegend, 1);
//   config.link = chartAttrs.clickurl;

//   config.annRenderDelay = pluckNumber(chartAttrs.annrenderdelay, 0) * 1000;

//   config.transposeAxis = pluckNumber(iapi.transposeAxis, chartAttrs.transposeaxis, 0);
//   config.useEllipsesWhenOverflow = pluckNumber(chartAttrs.useellipseswhenoverflow,
//             chartAttrs.useellipsewhenoverflow, 1);

//   config.gLegendPadding = pluckNumber(chartAttrs.legendpadding, 10);
//   config.skipZeroPlots = pluckNumber(chartAttrs.skipzeroplots, 1);

//   config.drawTrendRegion = pluckNumber(chartAttrs.drawcrossline, 0);
//   config.rolloverbandanimation = pluckNumber(chartAttrs.crosslineanimation, 0);
//   config.rolloverbandanimationduration = pluckNumber(chartAttrs.crosslineanimationduration, 0.09) * 1000;
//   config.plotcolorintooltip = pluckNumber(chartAttrs.plotcolorintooltip, (iapi.singleseries ? 0 : 1));
//   config.trendRegionColor = config.trendRegionStroke = convertColor(
//             pluck(chartAttrs.crosslinecolor, colorM.getColor(preDefStr.altHGridColorStr)),
//             pluck(chartAttrs.crosslinealpha, colorM.getColor(preDefStr.altHGridAlphaStr)));

//         // binSize for large data
//   config.binSize = mathMin(pluckNumber(chartAttrs.plotbinsize, iapi.binSize, 0.5), 1);
//   config.labelBinSize = mathMin(pluckNumber(chartAttrs.labelbinsize, 1), 1);
//   config.enableMouseOutEvent = pluckNumber(chartAttrs.enablemouseoutevent, iapi.enableMouseOutEvent, 0);
//         // config.trendRegionStroke = convertColor(
//         //     pluck(chartAttrs.rolloverbandcolor, colorM.getColor(palleteString.divLineColor)),
//         //     pluck(chartAttrs.rolloverbandalpha, colorM.getColor('divLineAlpha')));

//   config.tooltipgrayoutcolor = pluck(chartAttrs.tooltipgrayoutcolor, preDefStr.colors.AAAAAA);

//   realtimeEnabled && iapi._realTimeConfigure();

//   iapi.addToEnv('chartConfig', config);
//         // Setting tootip style
//   // iapi._setToolTipOptions();

//   // Parse legend optoins
//   // legend && legend.configure();

//   // linking the click function of rapheal objects
//   iapi.addToEnv('linkClickFN', getLinkAction(iapi.jsonData, iapi.chartInstance));

//   // Create dynamic components like message logger
//   iapi._createConfigurableComponents && iapi._createConfigurableComponents();

//   // if (iapi.getChildren('annotation')[0] && jsonData.annotations) {
//   //   iapi.getChildren('annotation')[0].configure(jsonData.annotations);
//   // }

//   // Update alert manager
//   if (iapi.config.realtimeEnabled) {
//     if (AlertManagerClass) {
//       componentFactory(iapi, AlertManagerClass, 'alertManager');
//     }
//   }
//   // Create Dataset components
//   iapi._createDatasets();
//   skipConfigureIteration.dataset = true;
//   skipConfigureIteration.crossline = true;
//   skipConfigureIteration.annotation = true;

//   iapi._mapChildren((child) => {
//     // components that already configure (listed in skipConfigureIteration) or removed
//     // must not be configured
//     if (!(child.getState('removed') || skipConfigureIteration[child.getType()])) {
//       child.configure && child.configure();
//     }
//   });

//   iapi.addToEnv('dataLabelStyle', dataLabelStyle);

//   annotation && annotation.configure(jsonData.annotations);

//   // after configure chart calls its async draw
//   iapi.asyncDraw();
// }

/**
 * Configures the chart component
 * @param {Object} dataObj User input json
 */
function configure(dataObj) {
  var iapi = this;
  iapi.parseChartAttr(dataObj);
  iapi.createComponent(dataObj);
  // Create Axis components.
  iapi._createAxes();

  iapi._feedAxesRawData();
  iapi.config.skipConfigureIteration.axis = true;

  iapi._createVcanvas();

  iapi._createDatasets();
  iapi.configureChildren();
  // after configure chart calls its async draw
  iapi.asyncDraw();
}
/**
 * Base class for all cartesian charts and who depend on this class
 * Its not an standalone chart
 * @type {class}
 */

var MSCartesian = function (_BaseChart) {
  _inherits(MSCartesian, _BaseChart);

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  MSCartesian.getName = function getName() {
    return 'MSCartesian';
  };

  /**
   * constructor function of this class
   */


  function MSCartesian() {
    _classCallCheck(this, MSCartesian);

    var _this = _possibleConstructorReturn(this, _BaseChart.call(this));

    _this.standaloneInit = false;
    _this.tooltipConstraint = 'chart';
    _this.annotationInteractionEvents = true;
    _this.useScaleRecursively = true;
    _this.stringConstants = {
      COMPONENT: 'component',
      CANVAS: 'canvas',
      CAPTION: 'caption'
    };
    _this._scrollBar = function () {
      var scrollItems = [];
      return {
        get: function get() {
          return scrollItems;
        },

        clear: function clear() {
          scrollItems.length = 0;
        },

        add: function add(options, callback) {
          scrollItems.push({
            conf: options,
            handler: callback
          });
        }
      };
    }();
    _this.addToEnv('chartMenuTools', MSCartesian.chartMenuTools());
    _this._allocateXAxisLabelSpace = _allocateXAxisLabelSpace;
    _this._drawDataset = _drawDataset;
    _this.mouseStateIn = false;
    return _this;
  }

  /**
   * Returns the type of the component
   *
   * @return {string} The type of the component
   */


  MSCartesian.prototype.getType = function getType() {
    return 'chartAPI';
  };
  /**
   * Parse the chart attributes and store in chart's config
   * @param {Object} dataObj User input json
   */


  MSCartesian.prototype.parseChartAttr = function parseChartAttr(dataObj) {
    var bPosition = void 0,
        bHAlign = void 0,
        bVAlign = void 0,
        iapi = this,
        jsonData = iapi.jsonData = dataObj || iapi.jsonData,
        chartAttrs = void 0,
        chartInstance = iapi.chartInstance,
        is3D = iapi.is3D,
        palleteString = is3D ? _lib.chartPaletteStr.chart3D : _lib.chartPaletteStr.chart2D,
        config = void 0,
        isBar = iapi.isBar,
        inCanfontFamily = void 0,
        inCanfontSize = void 0,
        inCancolor = void 0,
        fontSize = void 0,
        colorM = iapi.getFromEnv('color-manager'),
        style = void 0,
        zeroPlaneColor = void 0,
        zeroPlaneAlpha = void 0,
        inCanvasStyle = void 0,
        inCanLineHeight = void 0,
        dataLabelStyle = void 0,
        fontBdrColor = void 0,
        showCanvasBase = void 0,
        enableAnimation = void 0,
        transposeAnimation = void 0,
        animation = void 0,
        updateDuration = false,
        initAnimDuration = void 0,
        transposeAnimDuration = void 0,
        key = void 0,
        animTypeObj = {
      linear: 'linear',
      easein: 'easeIn',
      easeout: 'easeOut',
      easeinout: 'easeInOut',
      backin: 'backIn',
      backout: 'backOut',
      elastic: 'elastic',
      bounce: 'bounce'
    },
        animConfig = {
      'bubble': {
        plotTranslate: {
          duration: 1000,
          effect: 'elasticOnce'
        },
        plotAppear: {
          duration: 1000,
          effect: 'bounce'
        },
        plotDisappear: {
          duration: 1000,
          effect: 'bounce'
        },
        categoryLine: {
          duration: 1000,
          effect: 'linear'
        },
        colorChange: {
          duration: 1000,
          effect: 'linear'
        }
      },
      general: {
        getDurationByPercent: function getDurationByPercent(i, len, percentDuration) {
          var start = i / len * (1 - percentDuration);
          return {
            start: start,
            end: start + percentDuration
          };
        },
        getDurationByIndex: function getDurationByIndex(i, len, startIn, endInc) {
          return {
            start: (i + startIn) / len,
            end: (i + endInc) / len
          };
        }
      },
      'funnelPyramid': {
        sliceAnimType: 'bounce'
      },
      'angulargauge': {
        initialDialAnimType: 'bounce'
      },
      'column': {
        initialRender: {
          effect: 'easeInOutQuint'
        },
        update: {
          effect: 'linear'
        },
        legendInteraction: {
          effect: 'easeInOutQuint'
        }
      }
    };

    // Add chartAttrs in the env
    iapi.addToEnv('chart-attrib', jsonData.chart);

    if (!colorM) {
      colorM = new _colormanager2['default'](iapi);
      iapi.addToEnv('color-manager', colorM);
    }
    jsonData.chart = jsonData.chart || jsonData.graph || jsonData.map || {};
    delete jsonData.map;
    delete jsonData.graph;
    chartAttrs = jsonData.chart;
    !chartAttrs && (chartAttrs = jsonData.chart = {});
    config = iapi.config || (iapi.config = {});

    // set and parse the default configuration
    if (iapi.__setDefaultConfig) {
      iapi.__setDefaultConfig();
    }

    (0, _libAttr.parseConfiguration)(chartAttrs, config);

    // set the balnk snapLiterals object for annotation
    config.snapLiterals = {};

    // set the configuration for zooming
    config.viewPortConfig = {
      'scaleY': 1,
      'scaleX': 1,
      'x': 0,
      'y': 0
    };

    config.dataCount = 0;
    config.drawLabelInitially = (0, _lib.pluckNumber)(chartAttrs.drawlabelinitially);

    // parse all 3d canvas attributes
    if (is3D) {
      if (isBar) {
        config.xDepth = 5;
        config.yDepth = 5;
      } else {
        config.xDepth = 10;
        config.yDepth = 10;
      }
      config.showCanvasBase = showCanvasBase = Boolean((0, _lib.pluckNumber)(chartAttrs.showcanvasbase, 1));
      config.canvasBasePadding = (0, _lib.pluckNumber)(chartAttrs.canvasbasepadding, 2);
      config.canvasBaseDepth = showCanvasBase ? (0, _lib.pluckNumber)(chartAttrs.canvasbasedepth, 10) : 0;
      config.canvasBgDepth = (0, _lib.pluckNumber)(chartAttrs.canvasbgdepth, 3);
    }

    // Assigning anim config to iapi config
    config.animConfig = config.animConfig || animConfig;

    colorM && colorM.configure();

    config.placeAxisLabelsOnTop = (0, _lib.pluckNumber)(chartAttrs.placexaxislabelsontop, 0);

    config.enableAnimation = enableAnimation = (0, _lib.pluckNumber)(chartAttrs.animation, chartAttrs.defaultanimation, 1);

    transposeAnimation = (0, _lib.pluckNumber)(chartAttrs.transposeanimation, 0);

    initAnimDuration = enableAnimation ? (0, _lib.pluckNumber)(chartAttrs.animationduration, 1) * 1000 : 0;
    transposeAnimDuration = transposeAnimation ? (0, _lib.pluckNumber)(chartAttrs.transposeanimduration, 0.2) * 1000 : 0;

    config.animationObj && (updateDuration = true);

    config.animationObj = animation = {
      initAnimDuration: initAnimDuration,
      transposeAnimDuration: transposeAnimDuration
    };

    if (!updateDuration && animation.duration === _lib.UNDEF) {
      animation.duration = animation.initAnimDuration;
    } else {
      animation.duration = animation.transposeAnimDuration;
    }

    for (key in animTypeObj) {
      if (key === (0, _lib.pluck)(chartAttrs.animationeffect)) {
        config.animationeffect = animTypeObj[key];
      }
    }

    config.showToolTip = (0, _lib.pluckNumber)(chartAttrs.showtooltip, 1);

    // Parse configurations
    config.exportOption = {
      enabled: (0, _lib.pluckNumber)(chartAttrs.exportenabled, 0),
      bgcolor: chartInstance.jsVars.transparent || (0, _lib.pluckNumber)(chartInstance.options.containerBackgroundOpacity, 1) === 0 ? _lib.BLANKSTRING : chartInstance.options.containerBackgroundColor || '#ffffff',
      bgalpha: (chartInstance.jsVars.transparent ? 0 : (0, _lib.pluckNumber)(chartInstance.options.containerBackgroundOpacity, 1)) + _lib.BLANKSTRING,

      exporttargetwindow: (0, _lib.pluck)(chartAttrs.exporttargetwindow, isIOS ? '_blank' : '_self'),
      exportaction: chartAttrs.exportaction && chartAttrs.exportaction.toString().toLowerCase() === 'save' && 'save' || 'download',
      exportfilename: (0, _lib.pluck)(chartAttrs.exportfilename, 'FusionCharts'),
      exporthandler: (0, _lib.pluck)(chartAttrs.html5exporthandler, chartAttrs.exporthandler, DEFAULT_EXPORT_URL),
      exportparameters: (0, _lib.pluck)(chartAttrs.exportparameters, _lib.BLANKSTRING),
      exportformat: (0, _lib.pluck)(chartAttrs.exportformat, 'PNG'),
      exportcallback: (0, _lib.pluck)(chartAttrs.exportcallback, _lib.BLANKSTRING),

      exportwithimages: (0, _lib.pluckNumber)(chartAttrs.exportwithimages, 1),

      exportatclientside: (0, _lib.pluckNumber)(chartAttrs.exportatclientside, 0)
    };

    config.printOption = {
      enabled: (0, _lib.pluckNumber)(chartAttrs.printshowbutton, chartAttrs.showprintmenuitem, 0)
    };
    config.chartMenuOptions = {
      position: bPosition = (0, _lib.pluck)(chartAttrs.toolbarposition, 'tr').toLowerCase(),
      hAlign: bHAlign = (_lib.BLANKSTRING + chartAttrs.toolbarhalign).toLowerCase() === _lib.POSITION_LEFT ? 'l' : bPosition.charAt(1),
      vAlign: bVAlign = (_lib.BLANKSTRING + chartAttrs.toolbarvalign).toLowerCase() === _lib.POSITION_BOTTOM ? 'b' : bPosition.charAt(0),
      hDirection: (0, _lib.pluckNumber)(chartAttrs.toolbarhdirection, bHAlign === 'r' ? -1 : 1),
      vDirection: (0, _lib.pluckNumber)(chartAttrs.toolbarvdirection, bVAlign === 'b' ? -1 : 1),
      vMargin: (0, _lib.pluckNumber)(chartAttrs.toolbarvmargin, 6),
      hMargin: (0, _lib.pluckNumber)(chartAttrs.toolbarhmargin, 10),
      x: (0, _lib.pluckNumber)(chartAttrs.toolbarx, bHAlign === 'l' ? 0 : config.width),
      y: (0, _lib.pluckNumber)(chartAttrs.toolbary, bVAlign === 't' ? 0 : config.height)
    };

    style = config.style = {};
    // expose to environment
    // TODO: needs to be mo re clear. So that only one set of style is available in each level
    iapi.addToEnv('style', style);
    config.textDirection = chartAttrs.hasrtltext === '1' ? 'rtl' : _lib.BLANKSTRING;

    // ////////Chart font style////////////////////

    // todo: init incanstyle, outcanstyle, captionStyle, subcaption style

    style.inCanfontFamily = inCanfontFamily = (0, _lib.pluck)(chartAttrs.basefont, 'Verdana,sans');
    style.inCanfontSize = inCanfontSize = (0, _lib.pluckFontSize)(chartAttrs.basefontsize, 10);
    style.inCancolor = inCancolor = (0, _lib.pluck)(chartAttrs.basefontcolor, colorM.getColor(palleteString.baseFontColor));
    style.outCanfontFamily = (0, _lib.pluck)(chartAttrs.outcnvbasefont, inCanfontFamily);
    style.fontSize = fontSize = (0, _lib.pluckFontSize)(chartAttrs.outcnvbasefontsize, inCanfontSize);
    style.outCanfontSize = fontSize + _lib.PXSTRING;
    style.outCancolor = (0, _lib.pluck)(chartAttrs.outcnvbasefontcolor, inCancolor).replace(/^#? ([a-f0-9]+)/ig, '#$1');
    style.baseFontSize = inCanfontSize;
    style.inCanfontSize = inCanfontSize + _lib.PXSTRING;
    style.inCancolor = inCancolor.replace(/^#? ([a-f0-9]+)/ig, '#$1');

    style.inCanvasStyle = inCanvasStyle = {
      fontFamily: inCanfontFamily,
      fontSize: inCanfontSize,
      color: inCancolor
    };

    style.inCanLineHeight = inCanLineHeight = (0, _lib.setLineHeight)(inCanvasStyle);
    fontBdrColor = (0, _lib.getFirstValue)(chartAttrs.valuebordercolor, _lib.BLANKSTRING);
    fontBdrColor = fontBdrColor ? (0, _lib.convertColor)(fontBdrColor, (0, _lib.pluckNumber)(chartAttrs.valueborderalpha, chartAttrs.valuealpha, 100)) : _lib.BLANKSTRING;

    config.reverseXAxis = iapi.config.allowreversexaxis && (0, _lib.pluckNumber)(chartAttrs.reversexaxis, 0);
    config.showBorder = (0, _lib.pluckNumber)(chartAttrs.showborder, is3D ? 0 : 1);
    config.borderWidth = mathMax(config.showBorder ? (0, _lib.pluckNumber)(chartAttrs.borderthickness, 1) : 0, 0);
    config.useplotgradientcolor = chartAttrs.plotgradientcolor === '' ? 0 : config.useplotgradientcolor;
    config.valuefontbold = (0, _lib.pluckNumber)(chartAttrs.valuefontbold, config.valuefontbold);

    config.dataLabelStyle = dataLabelStyle = {
      fontFamily: (0, _lib.pluck)(chartAttrs.valuefont, inCanfontFamily),
      fontSize: (0, _lib.pluck)(chartAttrs.valuefontsize, (0, _lib.pInt)(inCanfontSize, 10)) + _lib.PXSTRING,
      lineHeight: inCanLineHeight,
      color: (0, _lib.convertColor)((0, _lib.pluck)(chartAttrs.valuefontcolor, inCancolor), (0, _lib.pluckNumber)(chartAttrs.valuefontalpha, chartAttrs.valuealpha, 100)),
      fontWeight: config.valuefontbold ? BOLD : NORMAL,
      fontStyle: (0, _lib.pluckNumber)(chartAttrs.valuefontitalic) ? 'italic' : NORMAL,
      // Set border as empty string when not required,
      // since IE will stop js execution if it is UNDEF or null.
      border: fontBdrColor || chartAttrs.valuebgcolor ? (0, _lib.pluckNumber)(chartAttrs.valueborderthickness, 1) + 'px solid' : _lib.BLANKSTRING,
      borderColor: fontBdrColor,
      borderThickness: (0, _lib.pluckNumber)(chartAttrs.valueborderthickness, 1),
      borderPadding: (0, _lib.pluckNumber)(chartAttrs.valueborderpadding, 2),
      borderRadius: (0, _lib.pluckNumber)(chartAttrs.valueborderradius, 0),
      backgroundColor: chartAttrs.valuebgcolor ? (0, _lib.convertColor)(chartAttrs.valuebgcolor, (0, _lib.pluckNumber)(chartAttrs.valuebgalpha, chartAttrs.valuealpha, 100)) : _lib.BLANKSTRING,
      borderDash: (0, _lib.pluckNumber)(chartAttrs.valueborderdashed, 0) ? (0, _lib.getDashStyle)((0, _lib.pluckNumber)(chartAttrs.valueborderdashlen, 4), (0, _lib.pluckNumber)(chartAttrs.valueborderdashgap, 2)) : _lib.DASH_DEF
    };

    (0, _lib.setLineHeight)(dataLabelStyle);

    // @todo: fix the order of inheratance
    config.orphanStyles = {
      defaultStyle: {
        style: (0, _lib.extend2)({}, style.inCanvasStyle)
      },
      connectorlabels: {
        style: (0, _lib.extend2)({}, config.dataLabelStyle)
      },
      vyaxisname: { // for candle stick chart's volume axis
        // style: extend2 ( { }, hc.yAxis[0].title.style)
        style: (0, _lib.extend2)({}, style.inCanvasStyle)
      }
    };

    config.legendPosition = (0, _lib.pluck)(chartAttrs.legendposition, _lib.POSITION_BOTTOM);

    // LOGO URL (foreground) logo parameters
    config.logoURL = (0, _lib.getValidValue)(chartAttrs.logourl);
    config.logoPosition = (0, _lib.pluck)(chartAttrs.logoposition, 'tl').toLowerCase();
    config.logoAlpha = (0, _lib.pluckNumber)(chartAttrs.logoalpha, 100);
    config.logoLink = (0, _lib.getValidValue)(chartAttrs.logolink);
    config.logoScale = (0, _lib.pluckNumber)(chartAttrs.logoscale, 100);
    config.logoLeftMargin = (0, _lib.pluckNumber)(chartAttrs.logoleftmargin, 0);
    config.logoTopMargin = (0, _lib.pluckNumber)(chartAttrs.logotopmargin, 0);

    // Parsing space management attributes
    config.minChartWidthPercent = (0, _lib.pluckNumber)(chartAttrs.minchartwidth, iapi.minChartWidth, 50) / 100;
    config.minChartHeightPercent = (0, _lib.pluckNumber)(chartAttrs.minchartheight, iapi.minChartHeight, 50) / 100;
    config.minCanvasWidthPercent = (0, _lib.pluckNumber)(chartAttrs.mincanvaswidth, iapi.minCanvasWidth, 60) / 100;
    config.minCanvasHeightPercent = (0, _lib.pluckNumber)(chartAttrs.mincanvasheight, iapi.minCanvasHeight, 30) / 100;

    // borderThickness = pluckNumber(chartAttrs.showborder, 1) ? pluckNumber(chartAttrs.borderthickness, 1) : 0;
    // chart margins
    config.origMarginTop = (0, _lib.pluckNumber)(chartAttrs.charttopmargin, iapi.chartTopMargin, 15);
    config.origMarginLeft = (0, _lib.pluckNumber)(chartAttrs.chartleftmargin, iapi.chartLeftMargin, 15);
    config.origMarginBottom = (0, _lib.pluckNumber)(chartAttrs.chartbottommargin, iapi.chartBottomMargin, 15);
    config.origMarginRight = (0, _lib.pluckNumber)(chartAttrs.chartrightmargin, iapi.chartRightMargin, 15);

    config.showXAxisPercentValues = (0, _lib.pluckNumber)(chartAttrs.showxaxispercentvalues, 1);

    zeroPlaneColor = (0, _lib.pluck)(chartAttrs.zeroplanecolor, chartAttrs.divlinecolor, colorM.getColor(palleteString.divLineColor));
    zeroPlaneAlpha = (0, _lib.pluck)(chartAttrs.zeroplanealpha, chartAttrs.divlinealpha, colorM.getColor('divLineAlpha'));
    config.zeroPlaneColor = (0, _lib.convertColor)(zeroPlaneColor, zeroPlaneAlpha);
    config.zeroPlaneBorderColor = (0, _lib.convertColor)((0, _lib.pluck)(chartAttrs.zeroplanebordercolor, zeroPlaneColor), (0, _lib.pluckNumber)(chartAttrs.zeroplaneshowborder, 1) ? zeroPlaneAlpha : 0);
    config.zeroPlaneShowBorder = (0, _lib.pluckNumber)(chartAttrs.zeroplaneshowborder, 1);

    // config.dataStreamURL = parseUnsafeString(chartAttrs.datastreamurl);
    config.realtimeEnabled = (0, _lib.pluckNumber)(chartAttrs.realtimeenabled, iapi.isRealTime);

    config.showLegend = (0, _lib.pluckNumber)(chartAttrs.showlegend, iapi.showLegend, 1);
    config.link = chartAttrs.clickurl;

    config.annRenderDelay = (0, _lib.pluckNumber)(chartAttrs.annrenderdelay, 0) * 1000;

    config.transposeAxis = (0, _lib.pluckNumber)(iapi.transposeAxis, chartAttrs.transposeaxis, 0);
    config.useEllipsesWhenOverflow = (0, _lib.pluckNumber)(chartAttrs.useellipseswhenoverflow, chartAttrs.useellipsewhenoverflow, 1);

    config.gLegendPadding = (0, _lib.pluckNumber)(chartAttrs.legendpadding, 10);
    config.skipZeroPlots = (0, _lib.pluckNumber)(chartAttrs.skipzeroplots, 1);

    config.drawTrendRegion = (0, _lib.pluckNumber)(chartAttrs.drawcrossline, 0);
    config.rolloverbandanimation = (0, _lib.pluckNumber)(chartAttrs.crosslineanimation, 0);
    config.rolloverbandanimationduration = (0, _lib.pluckNumber)(chartAttrs.crosslineanimationduration, 0.09) * 1000;
    config.plotcolorintooltip = (0, _lib.pluckNumber)(chartAttrs.plotcolorintooltip, iapi.singleseries ? 0 : 1);
    config.trendRegionColor = config.trendRegionStroke = (0, _lib.convertColor)((0, _lib.pluck)(chartAttrs.crosslinecolor, colorM.getColor(_lib.preDefStr.altHGridColorStr)), (0, _lib.pluck)(chartAttrs.crosslinealpha, colorM.getColor(_lib.preDefStr.altHGridAlphaStr)));

    // binSize for large data
    config.binSize = mathMin((0, _lib.pluckNumber)(chartAttrs.plotbinsize, iapi.binSize, 0.5), 1);
    config.labelBinSize = mathMin((0, _lib.pluckNumber)(chartAttrs.labelbinsize, 1), 1);
    config.enableMouseOutEvent = (0, _lib.pluckNumber)(chartAttrs.enablemouseoutevent, iapi.enableMouseOutEvent, 0);
    // config.trendRegionStroke = convertColor(
    //     pluck(chartAttrs.rolloverbandcolor, colorM.getColor(palleteString.divLineColor)),
    //     pluck(chartAttrs.rolloverbandalpha, colorM.getColor('divLineAlpha')));

    config.plotSpacePercent = Math.max((0, _lib.pluckNumber)(chartAttrs.plotspacepercent, iapi.plotSpacePercent), 0);
    config.maxColWidth = Math.abs((0, _lib.pluckNumber)(chartAttrs.maxcolwidth, chartAttrs.maxbarheight, 50));
    config.overlapColumns = (0, _lib.pluckNumber)(chartAttrs.overlapcolumns, chartAttrs.overlapbars, 1);
    config.plotPaddingPercent = chartAttrs.plotpaddingpercent;
    config.tooltipgrayoutcolor = (0, _lib.pluck)(chartAttrs.tooltipgrayoutcolor, _lib.preDefStr.colors.AAAAAA);
    iapi.addToEnv('chartConfig', config);

    // linking the click function of rapheal objects
    iapi.addToEnv('linkClickFN', (0, _lib.getLinkAction)(iapi.jsonData, iapi.chartInstance));

    iapi.addToEnv('dataLabelStyle', dataLabelStyle);
  };

  /**
   * Create child components of chart
   * @param {Object} dataObj User input json
   */


  MSCartesian.prototype.createComponent = function createComponent() {
    var canvas = void 0,
        iapi = this,
        skipConfigureIteration = void 0;

    skipConfigureIteration = iapi.config.skipConfigureIteration = {};
    (0, _lib.componentFactory)(iapi, _animationManager2['default'], 'animationManager', _lib.UNDEF, [iapi.jsonData.animationConfig]);
    // Create the legend object
    iapi._createLegend();
    (0, _lib.componentFactory)(iapi, _caption2['default'], 'caption');
    (0, _lib.componentFactory)(iapi, _subCaption2['default'], 'subCaption');
    (0, _lib.componentFactory)(iapi, _background2['default'], 'background');
    iapi._parseBackgroundCosmetics();
    iapi._createCanvas();
    iapi._parseCanvasCosmetics();
    canvas = iapi.getChildren('canvas')[0];
    iapi.isXY && (0, _lib.componentFactory)(canvas, _quadrant2['default'], 'quadrant');

    iapi._createGradientLegend();

    // Create dynamic components like message logger
    iapi._createConfigurableComponents && iapi._createConfigurableComponents();

    // Update alert manager
    if (iapi.config.realtimeEnabled) {
      iapi._realTimeConfigure && iapi._realTimeConfigure();
      if (_alertmanager2['default']) {
        (0, _lib.componentFactory)(iapi, _alertmanager2['default'], 'alertManager');
      }
    }
    skipConfigureIteration.dataset = true;
    skipConfigureIteration.crossline = true;
    skipConfigureIteration.annotation = true;

    iapi.addToEnv('animationManager', iapi.getChildren('animationManager')[0]);
    skipConfigureIteration.animationManager = true;
  };
  /**
   * Function to create vCanvas for each combination of axis
   */


  MSCartesian.prototype._createVcanvas = function _createVcanvas() {
    var iapi = this,
        canvas = iapi.getChildren('canvas')[0],
        vCanvas,
        xAxis = [],
        yAxis = [],
        axes,
        i,
        k,
        j;

    axes = iapi.getChildren('xAxis');
    for (k = 0; k < (axes && axes.length); k++) {
      if (!axes[k].getState('removed')) {
        xAxis.push(axes[k]);
      }
    }
    axes = iapi.getChildren('yAxis');
    for (k = 0; k < (axes && axes.length); k++) {
      if (!axes[k].getState('removed')) {
        yAxis.push(axes[k]);
      }
    }

    (0, _lib.componentFactory)(canvas, _vcanvas2['default'], 'vCanvas', xAxis.length * yAxis.length);
    vCanvas = canvas.getChildren('vCanvas');
    for (i = 0, k = 0; i < (xAxis && xAxis.length); i++) {
      for (j = 0; j < (yAxis && yAxis.length); j++, k++) {
        vCanvas[k].xAxis(xAxis[i]).yAxis(yAxis[j]).canvas(canvas);
        vCanvas[k].addToEnv('vCanvas', vCanvas[k]);
      }
    }
  };
  /**
   * Function to create Canvas for each combination of axis
   */


  MSCartesian.prototype._createCanvas = function _createCanvas() {
    (0, _lib.componentFactory)(this, _canvas2['default'], 'canvas', 1);
  };
  /**
   * Configure the child components
   */


  MSCartesian.prototype.configureChildren = function configureChildren() {
    var iapi = this;
    iapi._mapChildren(function (child) {
      // components that already configure (listed in skipConfigureIteration) or removed
      // must not be configured
      if (!(child.getState('removed') || iapi.config.skipConfigureIteration[child.getType()])) {
        child.configure && child.configure();
      }
    });
  };

  /**
   * Function for creating the toolbox
   */


  MSCartesian.prototype._createToolBox = function _createToolBox() {
    _createToolBox2.call(this);
  };

  /**
   * function to create component and configure and also configure the chart
   * It creates components which are depend on data and configure them and also configure chart
   * It calls helper function namely, configure
   * @param  {Object} dataObj contains json data of the chart
   */


  MSCartesian.prototype.configureAttributes = function configureAttributes(dataObj) {
    configure.call(this, dataObj);
  };
  /**
   * parse defualt configuration of the chart
   */


  MSCartesian.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _BaseChart.prototype.__setDefaultConfig && _BaseChart.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }

    config.valuefontbold = 0;
    config.stickytracking = 1;
    // realtime related attributes
    // @todo ideally this should be moved to a realtime base chart
    config.usemessagelog = 0;
    config.zeroplanethickness = _lib.UNDEF;
    config.animationeffect = 'linear';
    config.showshadow = 1;
    config.showhovereffect = _lib.UNDEF;
    config.plothovereffect = _lib.UNDEF;
    config.anchorhovereffect = _lib.UNDEF;
    config.plotborderdashed = _lib.UNDEF;
    config.stack100percent = _lib.UNDEF;
    config.showpercentvalues = _lib.UNDEF;
    config.showpercentintooltip = _lib.UNDEF;
    config.plotbordercolor = _lib.UNDEF;
    config.showtooltip = 1;
    config.seriesnameintooltip = 1;
    config.rotatevalues = 0;
    config.minimizetendency = 0;
    config.plotfillangle = 270;
    config.valuepadding = 2;
    config.useplotgradientcolor = 1;
    config.plotborderthickness = 1;
    config.plotfillalpha = SEVENTYSTRING;
    config.showvalues = 1;
    config.valueposition = AUTO;
    config.tooltipsepchar = ', ';
    config.usedataplotcolorforlabels = 0;
    config.placevaluesinside = 0;
    config.showplotborder = 1;
    config.use3dlighting = 1;
    config.useroundedges = 0;
    config.plotspacepercent = 20;
    config.plotpaddingpercent = _lib.UNDEF;
    config.plotfillratio = _lib.UNDEF;
    config.maxcolwidth = 50;
    config.plotborderdashlen = 5;
    config.plotborderdashgap = 4;
  };

  /**
   * this execute for onc time when the chart is rendered
   * @param  {Object} container DOM element of chart container
   * @param  {Object} dataObj   chart JSON object
   * @param  {Object} chartobj  chart object
   * @param  {Function} callBack  callBack function executes after draw complete
   */


  MSCartesian.prototype.init = function init(container, dataObj, chartobj, callBack) {
    var iapi = this,
        chartObj = iapi.chartInstance || chartobj,
        // legacy
    vars = chartObj.jsVars,
        animationManager,
        mouseTracker,
        ToolTipController = (0, _constructor.getDep)('ToolTipController'),
        toolTipController = new ToolTipController(container),
        postConfigure = function postConfigure() {
      iapi.setChartEvents();
      callBack({
        hasRendered: true,
        container: container
      });
    };

    // TODO: remove this from env, rathaer make required parts only available
    iapi.addToEnv('chart', iapi);

    iapi.jsonData = dataObj;

    iapi.addToEnv('chart-container', container);
    iapi.addToEnv('smartLabel', vars.smartLabel);

    iapi.addToEnv('number-formatter', new _numberformatter2['default'](iapi));

    animationManager = new _animationManager2['default']();
    iapi.attachChild(animationManager, 'animationManager');
    // animationManager.setLinkedItem('chart', iapi);
    iapi.addToEnv('animationManager', animationManager);
    // a copy of colorrange object is sent to avoid the issue.

    iapi.addToEnv('toolTipController', toolTipController);

    // Checking if the chart has proper data
    if (iapi._checkInvalidData()) {
      (0, _eventApi.triggerEvent)('nodatatodisplay', {}, chartObj, [chartObj.id]);
      callBack({
        hasRendered: true,
        container: container
      });
      return;
    }

    // Configure the inputs given by the user.
    iapi.configure(dataObj);

    iapi.disposeChartStyleSheet();

    // if non-tracker--mouse-tracking module need to be enabled
    if (iapi.config.enablemousetracking) {
      mouseTracker = new _mouseTracker2['default'](iapi);
      mouseTracker.addEvents();
    }

    iapi.addEventListener('drawn', postConfigure);
    iapi.inited = true;
    iapi.chartInstance.__state.dataReady = true;
  };
  /**
   * function to check if the chart has the proper data or not
   * @return {boolean} if JSON data is valid or not
   */


  MSCartesian.prototype._checkInvalidData = function _checkInvalidData() {
    var iapi = this,
        dataObj = iapi.jsonData,
        chartInstance = iapi.chartInstance;
    // Checking if the chart has proper data
    if (!iapi.isWidget && !iapi.isMap && !(dataObj.data && dataObj.data.length !== 0) && !dataObj.dataset && !dataObj.value && !dataObj.lineset && !dataObj.annotations && !dataObj.category && !(dataObj.tasks || dataObj.process) && !dataObj.axis) {
      iapi.setChartMessage();
      iapi.drawChartMessage();
      chartInstance.__state.dataReady = false;
      chartInstance.jsVars.hasNativeMessage = true;
      chartInstance.jsVars.drawCount += 1;
      return true;
    }
  };
  /**
   * function to instatiate legned class and add to env
   */


  MSCartesian.prototype._createLegend = function _createLegend() {
    if (_legend2['default']) {
      (0, _lib.componentFactory)(this, _legend2['default'], 'legend');
      this.addToEnv('legend', this.getChildren('legend')[0]);
    }
  };

  /**
   * Calculates the dimension required by gradient legend
   * @param {Object} allottedSpace Allowed space for Gradient legend component
   * @return {Object} Dimension of space taken (width, height)
   */


  MSCartesian.prototype.manageGradientLegendSpace = function manageGradientLegendSpace(allottedSpace) {
    var iapi = this,
        config = iapi.config,
        components = iapi.components,
        gradientLegend = components.gradientLegend,
        conf = gradientLegend && gradientLegend.conf,
        legendPosition,
        returnDimension,
        gLegendPadding = mathMin(config.gLegendPadding, 0.5 * allottedSpace),
        spaceUsed;
    if (conf) {
      legendPosition = conf.legendPosition;
      spaceUsed = gradientLegend.getLogicalSpace(allottedSpace);
      if (legendPosition === _lib.POSITION_BOTTOM) {
        returnDimension = {
          bottom: (spaceUsed.height || 0) + gLegendPadding
        };
      } else {
        returnDimension = {
          right: (spaceUsed.width || 0) + gLegendPadding
        };
      }
    } else {
      returnDimension = {
        bottom: 0,
        right: 0
      };
    }
    return returnDimension;
  };

  /**
   * Create Gradient legend component
   */


  MSCartesian.prototype._createGradientLegend = function _createGradientLegend() {
    var iapi = this,
        components = iapi.components || (iapi.components = {}),
        gLegend;
    if (iapi.hasGradientLegend) {
      gLegend = components.gradientLegend = components.gradientLegend || new _gradientLegend2['default']();
      iapi.addToEnv('gradientLegend', gLegend);
      components.postLegendInitFn = gLegend.init({
        chart: iapi
      });
      iapi.addToEnv('postLegendInitFn', components.postLegendInitFn);
    }
  };
  /**
   * function to instatiate axis and get attached to canvas
   */


  MSCartesian.prototype._createAxes = function _createAxes() {
    var iapi = this,
        canvas = iapi.getChildren('canvas')[0],
        zoomObj = {
      zoomable: true,
      pannable: true
    },
        yAxis,
        xAxis;

    (0, _lib.componentFactory)(iapi, _cartesian2['default'], 'yAxis');
    (0, _lib.componentFactory)(iapi, _cartesian2['default'], 'xAxis');

    yAxis = iapi.getChildren('yAxis')[0];
    xAxis = iapi.getChildren('xAxis')[0];

    canvas.attachAxis(xAxis, false, iapi.zoomX ? zoomObj : {});
    canvas.attachAxis(yAxis, true, iapi.zoomY ? zoomObj : {});

    iapi._setCategories();
  };
  /**
   * function to set category to xAxis
   */


  MSCartesian.prototype._setCategories = function _setCategories() {
    var iapi = this,
        dataObj = iapi.jsonData,
        xAxis = iapi.getChildren('xAxis'),
        categories = dataObj.categories && dataObj.categories[0].category;
    xAxis && xAxis[0].setCategory(categories);
  };
  /**
   * function to parse JSON data for configurations of axis
   */


  MSCartesian.prototype._feedAxesRawData = function _feedAxesRawData() {
    var iapi = this,
        chartConfig = iapi.config,
        colorM = iapi.getFromEnv('color-manager'),
        dataObj = iapi.jsonData,
        chartAttrs = dataObj.chart,
        isReverse = chartConfig.isInverse,
        xAxisConf,
        yAxisConf,
        is3d = iapi.is3d,
        palleteString = is3d ? _lib.chartPaletteStr.chart3D : _lib.chartPaletteStr.chart2D,
        yAxis,
        xAxis;

    xAxisConf = {
      isVertical: false,
      isReverse: chartConfig.reverseXAxis,
      isOpposit: false,
      outCanfontFamily: (0, _lib.pluck)(chartAttrs.outcnvbasefont, chartAttrs.basefont, 'Verdana,sans'),
      outCanfontSize: (0, _lib.pluckFontSize)(chartAttrs.outcnvbasefontsize, chartAttrs.basefontsize, 10),
      outCancolor: (0, _lib.pluck)(chartAttrs.outcnvbasefontcolor, chartAttrs.basefontcolor, colorM.getColor(palleteString.baseFontColor)).replace(/^#? ([a-f0-9]+)/ig, '#$1'),
      axisNamePadding: chartAttrs.xaxisnamepadding,
      axisValuePadding: chartAttrs.labelpadding,
      axisNameFont: chartAttrs.xaxisnamefont,
      axisNameFontSize: chartAttrs.xaxisnamefontsize,
      axisNameFontColor: chartAttrs.xaxisnamefontcolor,
      axisNameFontBold: chartAttrs.xaxisnamefontbold,
      axisNameFontItalic: chartAttrs.xaxisnamefontitalic,
      axisNameBgColor: chartAttrs.xaxisnamebgcolor,
      axisNameBorderColor: chartAttrs.xaxisnamebordercolor,
      axisNameAlpha: chartAttrs.xaxisnamealpha,
      axisNameFontAlpha: chartAttrs.xaxisnamefontalpha,
      axisNameBgAlpha: chartAttrs.xaxisnamebgalpha,
      axisNameBorderAlpha: chartAttrs.xaxisnameborderalpha,
      axisNameBorderPadding: chartAttrs.xaxisnameborderpadding,
      axisNameBorderRadius: chartAttrs.xaxisnameborderradius,
      axisNameBorderThickness: chartAttrs.xaxisnameborderthickness,
      axisNameBorderDashed: chartAttrs.xaxisnameborderdashed,
      axisNameBorderDashLen: chartAttrs.xaxisnameborderdashlen,
      axisNameBorderDashGap: chartAttrs.xaxisnameborderdashgap,
      useEllipsesWhenOverflow: chartAttrs.useellipseswhenoverflow,
      divLineColor: (0, _lib.pluck)(chartAttrs.vdivlinecolor, chartAttrs.divlinecolor, colorM.getColor(palleteString.divLineColor)),
      divLineAlpha: (0, _lib.pluck)(chartAttrs.vdivlinealpha, chartAttrs.divlinealpha, is3d ? colorM.getColor('divLineAlpha3D') : colorM.getColor('divLineAlpha')),
      divLineThickness: (0, _lib.pluckNumber)(chartAttrs.vdivlinethickness, chartAttrs.divlinethickness, 1),
      divLineIsDashed: Boolean((0, _lib.pluckNumber)(chartAttrs.vdivlinedashed, chartAttrs.vdivlineisdashed, chartAttrs.divlinedashed, chartAttrs.divlineisdashed, 0)),
      divLineDashLen: (0, _lib.pluckNumber)(chartAttrs.vdivlinedashlen, chartAttrs.divlinedashlen, 4),
      divLineDashGap: (0, _lib.pluckNumber)(chartAttrs.vdivlinedashgap, chartAttrs.divlinedashgap, 2),
      showAlternateGridColor: (0, _lib.pluckNumber)(chartAttrs.showalternatevgridcolor, 0),
      alternateGridColor: (0, _lib.pluck)(chartAttrs.alternatevgridcolor, colorM.getColor('altVGridColor')),
      alternateGridAlpha: (0, _lib.pluck)(chartAttrs.alternatevgridalpha, colorM.getColor('altVGridAlpha')),
      numDivLines: (0, _lib.pluckNumber)(chartAttrs.numvdivlines, iapi.numVDivLines),
      labelFont: chartAttrs.labelfont,
      labelFontSize: chartAttrs.labelfontsize,
      labelFontColor: chartAttrs.labelfontcolor,
      labelFontAlpha: chartAttrs.labelalpha,
      labelFontBold: chartAttrs.labelfontbold,
      labelFontItalic: chartAttrs.labelfontitalic,
      maxLabelHeight: chartAttrs.maxlabelheight,
      axisName: chartAttrs.xaxisname,
      axisMinValue: chartAttrs.xaxisminvalue,
      axisMaxValue: chartAttrs.xaxismaxvalue,
      setAdaptiveMin: (0, _lib.pluckNumber)(chartAttrs.setadaptivexmin, iapi.setadaptivexmin, chartConfig.setadaptivexmin),
      adjustDiv: chartAttrs.adjustvdiv,
      labelDisplay: chartAttrs.labeldisplay,
      showLabels: chartAttrs.showlabels,
      rotateLabels: chartAttrs.rotatelabels,
      slantLabel: (0, _lib.pluckNumber)(chartAttrs.slantlabels, chartAttrs.slantlabel),
      labelStep: (0, _lib.pluckNumber)(chartAttrs.labelstep, chartAttrs.xaxisvaluesstep),
      showAxisValues: (0, _lib.pluckNumber)(chartAttrs.showxaxisvalues, chartAttrs.showxaxisvalue),
      showLimits: (0, _lib.pluckNumber)(chartAttrs.showvlimits, iapi.showvlimits),
      showDivLineValues: (0, _lib.pluckNumber)(chartAttrs.showvdivlinevalues, chartAttrs.showvdivlinevalues, iapi.showvdivlinevalues),
      showZeroPlane: (0, _lib.pluckNumber)(chartAttrs.showvzeroplane, iapi.showzeroplane),
      zeroPlaneColor: chartAttrs.vzeroplanecolor,
      zeroPlaneThickness: (0, _lib.pluckNumber)(chartAttrs.vzeroplanethickness, chartAttrs.vdivlinethickness, chartConfig.zeroplanethickness, 2),
      zeroPlaneAlpha: (0, _lib.pluckNumber)(chartAttrs.vzeroplanealpha, chartAttrs.vdivlinealpha, chartConfig.zeroplanealpha),
      showZeroPlaneValue: (0, _lib.pluckNumber)(chartAttrs.showvzeroplanevalue, iapi.showzeroplanevalue),
      trendlineColor: chartAttrs.trendlinecolor,
      trendlineToolText: chartAttrs.trendlinetooltext,
      trendlineThickness: chartAttrs.trendlinethickness,
      trendlineAlpha: chartAttrs.trendlinealpha,
      showTrendlinesOnTop: chartAttrs.showtrendlinesontop,
      showAxisLine: is3d ? 0 : (0, _lib.pluckNumber)(chartAttrs.showxaxisline, chartAttrs.showaxislines, chartAttrs.drawAxisLines, iapi.showxaxisline, 0),
      axisLineThickness: (0, _lib.pluckNumber)(chartAttrs.xaxislinethickness, chartAttrs.axislinethickness, 1),
      axisLineAlpha: (0, _lib.pluckNumber)(chartAttrs.xaxislinealpha, chartAttrs.axislinealpha, 100),
      axisLineColor: (0, _lib.pluck)(chartAttrs.xaxislinecolor, chartAttrs.axislinecolor, '#000000')
    };
    yAxisConf = {
      isVertical: true,
      isReverse: !isReverse,
      isOpposit: false,
      outCanfontFamily: (0, _lib.pluck)(chartAttrs.outcnvbasefont, chartAttrs.basefont, 'Verdana,sans'),
      outCanfontSize: (0, _lib.pluckFontSize)(chartAttrs.outcnvbasefontsize, chartAttrs.basefontsize, 10),
      outCancolor: (0, _lib.pluck)(chartAttrs.outcnvbasefontcolor, chartAttrs.basefontcolor, colorM.getColor(palleteString.baseFontColor)).replace(/^#? ([a-f0-9]+)/ig, '#$1'),
      axisBreaks: chartAttrs.yaxisbreaks,
      axisNamePadding: chartAttrs.yaxisnamepadding,
      axisValuePadding: chartAttrs.yaxisvaluespadding,
      axisNameFont: chartAttrs.yaxisnamefont,
      axisNameFontSize: chartAttrs.yaxisnamefontsize,
      axisNameFontColor: chartAttrs.yaxisnamefontcolor,
      axisNameFontBold: chartAttrs.yaxisnamefontbold,
      axisNameFontItalic: chartAttrs.yaxisnamefontitalic,
      axisNameBgColor: chartAttrs.yaxisnamebgcolor,
      axisNameBorderColor: chartAttrs.yaxisnamebordercolor,
      axisNameAlpha: chartAttrs.yaxisnamealpha,
      axisNameFontAlpha: chartAttrs.yaxisnamefontalpha,
      axisNameBgAlpha: chartAttrs.yaxisnamebgalpha,
      axisNameBorderAlpha: chartAttrs.yaxisnameborderalpha,
      axisNameBorderPadding: chartAttrs.yaxisnameborderpadding,
      axisNameBorderRadius: chartAttrs.yaxisnameborderradius,
      axisNameBorderThickness: chartAttrs.yaxisnameborderthickness,
      axisNameBorderDashed: chartAttrs.yaxisnameborderdashed,
      axisNameBorderDashLen: chartAttrs.yaxisnameborderdashlen,
      axisNameBorderDashGap: chartAttrs.yaxisnameborderdashgap,
      axisNameWidth: chartAttrs.yaxisnamewidth,
      useEllipsesWhenOverflow: chartAttrs.useellipseswhenoverflow,
      rotateAxisName: (0, _lib.pluckNumber)(chartAttrs.rotateyaxisname, 1),
      axisName: chartAttrs.yaxisname,
      divLineColor: (0, _lib.pluck)(chartAttrs.divlinecolor, colorM.getColor(palleteString.divLineColor)),
      divLineAlpha: (0, _lib.pluck)(chartAttrs.divlinealpha, is3d ? colorM.getColor('divLineAlpha3D') : colorM.getColor('divLineAlpha')),
      divLineThickness: (0, _lib.pluckNumber)(chartAttrs.divlinethickness, 1),
      divLineIsDashed: Boolean((0, _lib.pluckNumber)(chartAttrs.divlinedashed, chartAttrs.divlineisdashed, 0)),
      divLineDashLen: (0, _lib.pluckNumber)(chartAttrs.divlinedashlen, 4),
      divLineDashGap: (0, _lib.pluckNumber)(chartAttrs.divlinedashgap, 2),
      showAlternateGridColor: (0, _lib.pluckNumber)(chartAttrs.showalternatehgridcolor, 1),
      alternateGridColor: (0, _lib.pluck)(chartAttrs.alternatehgridcolor, colorM.getColor('altHGridColor')),
      alternateGridAlpha: (0, _lib.pluck)(chartAttrs.alternatehgridalpha, colorM.getColor('altHGridAlpha')),
      numDivLines: (0, _lib.pluckNumber)(chartAttrs.numdivlines, iapi.numDivLines),
      axisMinValue: chartConfig.yRangeMin || chartAttrs.yaxisminvalue,
      axisMaxValue: chartConfig.yRangeMax || chartAttrs.yaxismaxvalue,
      setAdaptiveMin: (0, _lib.pluckNumber)(chartAttrs.setadaptivesymin, chartAttrs.setadaptiveymin, chartConfig.setAdaptiveMin),
      adjustDiv: chartAttrs.adjustdiv,
      labelStep: chartAttrs.yaxisvaluesstep,
      showAxisValues: (0, _lib.pluckNumber)(chartAttrs.showyaxisvalues, chartAttrs.showyaxisvalue, iapi.showyaxisvalues),
      showLimits: (0, _lib.pluckNumber)(chartAttrs.showyaxislimits, chartAttrs.showlimits, iapi.showLimits),
      showDivLineValues: (0, _lib.pluckNumber)(chartAttrs.showdivlinevalues, chartAttrs.showdivlinevalue, iapi.showdivlinevalues),
      showZeroPlane: (0, _lib.pluckNumber)(chartAttrs.showzeroplane, iapi.showzeroplane),
      zeroPlaneColor: chartAttrs.zeroplanecolor,
      zeroPlaneThickness: (0, _lib.pluckNumber)(chartAttrs.zeroplanethickness, chartAttrs.divlinethickness, chartConfig.zeroplanethickness, 2),
      zeroPlaneAlpha: (0, _lib.pluckNumber)(chartAttrs.zeroplanealpha, chartAttrs.divlinealpha, chartConfig.zeroplanealpha),
      showZeroPlaneValue: (0, _lib.pluckNumber)(chartAttrs.showzeroplanevalue, iapi.showzeroplanevalue),
      showZeroPlaneOnTop: chartConfig.showzeroplaneontop,
      trendlineColor: chartAttrs.trendlinecolor,
      trendlineToolText: chartAttrs.trendlinetooltext,
      trendlineThickness: chartAttrs.trendlinethickness,
      trendlineAlpha: chartAttrs.trendlinealpha,
      showTrendlinesOnTop: chartAttrs.showtrendlinesontop,
      showAxisLine: is3d ? 0 : (0, _lib.pluckNumber)(chartAttrs.showyaxisline, chartAttrs.showaxislines, chartAttrs.drawAxisLines, iapi.showyaxisline, 0),
      axisLineThickness: (0, _lib.pluckNumber)(chartAttrs.yaxislinethickness, chartAttrs.axislinethickness, 1),
      axisLineAlpha: (0, _lib.pluckNumber)(chartAttrs.yaxislinealpha, chartAttrs.axislinealpha, 100),
      limitUpdaterEnabled: iapi.config.limitUpdaterEnabled,
      axisLineColor: (0, _lib.pluck)(chartAttrs.yaxislinecolor, chartAttrs.axislinecolor, '#000000')
    };
    xAxisConf.vtrendlines = dataObj.vtrendlines;
    yAxisConf.trendlines = dataObj.trendlines;
    if (chartConfig.isstacked) {
      yAxisConf.isPercent = (0, _lib.pluckNumber)(chartConfig.stack100percent, 0);
    }
    yAxis = iapi.getChildren('yAxis') && iapi.getChildren('yAxis')[0];
    xAxis = iapi.getChildren('xAxis') && iapi.getChildren('xAxis')[0];
    if (yAxis) {
      yAxis.configure(yAxisConf);
    }
    if (xAxis) {
      xAxis.configure(xAxisConf);
    }
  };
  /**
   * function to  create dataset, groupmaneger.
   * assign dataset to group manager.
   **/


  MSCartesian.prototype._createDatasets = function _createDatasets() {
    var iapi = this,
        jsonData = iapi.jsonData,
        datasetsJSON = jsonData.dataset,
        children = iapi.getChildren(),
        canvas = children.canvas[0],
        vCanvas = void 0,
        datasetParent = vCanvas = canvas.getChildren('vCanvas')[0],
        DsGroupClass = void 0,
        DSClass = void 0,
        dsType = iapi.defaultDatasetType || '',
        groupManager = void 0;

    if (!(datasetsJSON && datasetsJSON.length !== 0)) {
      iapi.setChartMessage();
    }

    DsGroupClass = iapi.getDSGroupdef();
    (0, _lib.componentFactory)(vCanvas, DsGroupClass, 'datasetGroup_' + dsType);
    groupManager = vCanvas.getChildren('datasetGroup_' + dsType);
    groupManager && (datasetParent = groupManager[0]);
    DSClass = iapi.getDSdef();

    (0, _lib.datasetFactory)(datasetParent, DSClass, 'dataset', datasetsJSON.length, datasetsJSON);
  };
  /**
   * Function to set or reset event listeners on container and canvas DOM.
   * If there are any previous event listeners attach to the chart container or canvas
   * then previous events listeners will be detached and new required event listeners
   * will be attached.
   */


  MSCartesian.prototype.setChartEvents = function setChartEvents() {
    var chart = this,
        linkedItems = chart.linkedItems || {},
        listeners = linkedItems.eventListeners || (linkedItems.eventListeners = []),
        chartAttrs = chart.jsonData.chart,
        canvas = chart.getFromEnv('paper').canvas,
        container = chart.getFromEnv('chart-container'),

    // EnableChartMouseMoveEvent attribute to enable chartMouseMove event
    enableMouseMove = (0, _lib.pluckNumber)(chartAttrs.enablechartmousemoveevent, 0);

    // In case link is not defined, but chart has a previously attached
    // link, then we remove the same from container and from chart.
    _domEvent2['default'].unlisten(container, 'click', onContainerClick);

    // Check if link has been defined or not. If defined, then append
    // the click event to the chart container and pass on the relevant
    // information as event data
    listeners.push(_domEvent2['default'].listen(container, 'click', onContainerClick, chart));

    // Remove mouseover, touchstart, mouseout or touchend events if attached previously
    _domEvent2['default'].unlisten(canvas, 'mouseover', chartHoverManager, chart);
    _domEvent2['default'].unlisten(canvas, 'touchstart', chartHoverManager, chart);
    _domEvent2['default'].unlisten(canvas, 'mouseout', chartHoverManager, chart);
    _domEvent2['default'].unlisten(canvas, 'touchend', chartHoverManager, chart);

    // Attach mouseover, touchstart, mouseout or touchend events.
    listeners.push(_domEvent2['default'].listen(canvas, 'mouseover touchstart mouseout touchend', chartHoverManager, chart));

    // Remove mousemove and touchmove events if previously attached.
    _domEvent2['default'].unlisten(container, 'mousemove', MSCartesian.onContainerMouseMove, chart);
    _domEvent2['default'].unlisten(container, 'touchmove', MSCartesian.onContainerMouseMove, chart);

    if (enableMouseMove) {
      // Attach mousemove and touchmove events.
      listeners.push(_domEvent2['default'].listen(container, 'mousemove touchmove', MSCartesian.onContainerMouseMove, chart));
    }
  };
  /**
   * Adds buttons to the chart menu bar
   * @return {Object} Object containing APIs for the chart menu
   */


  MSCartesian.chartMenuTools = function chartMenuTools() {
    // contains the toolset for the chartMenuTools
    var toolSet = [];
    return {
      get: function get() {
        return toolSet;
      },

      set: function set(buttonArgsArr) {
        var i,
            len = buttonArgsArr.length || 0;

        for (i = 0; i < len; i += 1) {
          toolSet.push(buttonArgsArr[i]);
        }
      },
      reset: function reset(tb, iapi) {
        var actionBar = iapi.getChildren('actionBar'),
            chartMenuBar = iapi.getChildren('chartMenuBar');
        chartMenuBar && (chartMenuBar.drawn = false);
        actionBar && (actionBar.drawn = false);
        toolSet.length = 0;

        if (!tb) {
          return;
        }

        tb.idCount = 0;
        tb.clean();
      },
      // Vulnerable method. Bruteforece check to replace the text of the context menu.
      update: function update(id, newId, iapi) {
        var chartMenuBar = iapi.getChildren('chartMenuBar') || iapi.getChildren('actionBar'),
            SymbolWithContext = iapi.components.toolBoxAPI.SymbolWithContext,
            componentGroups = chartMenuBar.componentGroups,
            lists,
            list,
            contextMenu,
            symbolList,
            index,
            length,
            i,
            l,
            group;

        for (index = 0, length = componentGroups.length; index < length; index++) {
          group = componentGroups[index];

          symbolList = group.symbolList || [];
          for (i = 0, l = symbolList.length; i < l; i++) {
            if (!(symbolList[i] instanceof SymbolWithContext)) {
              continue;
            }

            contextMenu = symbolList[i];
            lists = contextMenu.getListRefernce().getFirstContainer().atomicLists;
          }
        }

        lists = lists || [];
        for (index = 0, length = lists.length; index < length; index++) {
          list = lists[index];
          if (list.name === id) {
            list.updateName(newId);
            break;
          }
        }
      }
    };
  };

  /**
   * This function return the configuration value
   * @param {string} confName configuration name
   * @return {Array} return configuration value corresponding to the confName
   */


  MSCartesian.prototype.getConfig = function getConfig(confName) {
    return confName ? this.config[confName] : this.config;
  };

  /**
   * Generalised getter function got chart API
   * @param {string} where plcae from where the object will be found
   * @param {string} what name of the object
   * @return {Object} return specific object from specific place
   */


  MSCartesian.prototype.get = function get(where, what) {
    var place = this[where];
    return what ? place && place[what] : place;
  };

  /**
   * function to clear applied css property
   */


  MSCartesian.prototype.disposeChartStyleSheet = function disposeChartStyleSheet() {
    var chart = this,
        paper = chart.getFromEnv('paper');

    paper && paper.cssClear();
  };
  /**
   * function to render css style applied on paper
   */


  MSCartesian.prototype.createChartStyleSheet = function createChartStyleSheet() {
    var chart = this,
        paper = chart.getFromEnv('paper');

    paper.cssRender();
  };
  /**
   * allocate space for canvas
   * @param  {Object} dimensions contains left, right, top, bottom co-ordinate (relative)
   */


  MSCartesian.prototype._allocateSpace = function _allocateSpace(dimensions) {
    var iapi = this,
        canvasConfig = iapi.getChildren('canvas')[0].config,
        config = iapi.config,
        canvasHeight = config.canvasHeight,
        canvasWidth = config.canvasWidth,
        availableHeight = config.availableHeight,
        availableWidth = config.availableWidth;

    config.canvasLeft += dimensions.left || 0;
    config.canvasTop += dimensions.top || 0;
    canvasWidth = config.canvasWidth = mathMax(canvasWidth - ((dimensions.left || 0) + (dimensions.right || 0)), 0);
    canvasHeight = config.canvasHeight = mathMax(canvasHeight - ((dimensions.top || 0) + (dimensions.bottom || 0)), 0);

    config.availableHeight = mathMax(availableHeight - ((dimensions.top || 0) + (dimensions.bottom || 0)), 0);
    config.availableWidth = mathMax(availableWidth - ((dimensions.left || 0) + (dimensions.right || 0)), 0);
    config.canvasRight = config.canvasLeft + canvasWidth;
    config.canvasBottom = config.canvasTop + canvasHeight;

    canvasConfig.canvasPaddingLeft = mathMax(canvasConfig.canvasPaddingLeft, dimensions.paddingLeft || 0);
    canvasConfig.canvasPaddingRight = mathMax(canvasConfig.canvasPaddingRight, dimensions.paddingRight || 0);
    canvasConfig.canvasPaddingTop = mathMax(canvasConfig.canvasPaddingTop, dimensions.paddingTop || 0);
    canvasConfig.canvasPaddingBottom = mathMax(canvasConfig.canvasPaddingBottom, dimensions.paddingBottom || 0);
  };
  /**
   * function to calculate and allote space for legend
   */


  MSCartesian.prototype._manageLegendSpace = function _manageLegendSpace() {
    var iapi = this,
        config = iapi.config,
        legend = iapi.getChildren('legend') && iapi.getChildren('legend')[0],
        gradientLegend = iapi.components.gradientLegend,
        conf,
        colorRangeObj = iapi.jsonData.colorrange,
        hasLegend = iapi.hasLegend,
        spaceTakenByLegend = {},
        hasGradientLegend = iapi.hasGradientLegend,
        legendPosition,
        allottedSpace,
        factor,
        chartAttr = iapi.jsonData.chart,
        mapByCategory = (0, _lib.pluckNumber)(chartAttr.mapbycategory, 0),
        isGradient = hasGradientLegend && colorRangeObj && (0, _lib.pluckNumber)(colorRangeObj.gradient);

    // Check if jsonData has colorrange
    if (isGradient && !mapByCategory) {
      conf = gradientLegend.conf;
      hasGradientLegend = true;
      config.gLegendEnabled = true;
      factor = 0.5;
      legendPosition = conf.legendPosition;
    } else {
      conf = legend.config;
      hasGradientLegend = false;
      config.gLegendEnabled = false;
      legendPosition = conf.legendPos;
      factor = legendPosition === _lib.POSITION_RIGHT ? 0.8 : 0.4;
    }

    if (legendPosition === _lib.POSITION_RIGHT) {
      allottedSpace = config.availableWidth * factor;
    } else {
      allottedSpace = config.availableHeight * factor;
    }

    if (hasGradientLegend) {
      spaceTakenByLegend = iapi.manageGradientLegendSpace(allottedSpace);
    } else {
      if (hasLegend !== false) {
        spaceTakenByLegend = legend._manageLegendPosition(allottedSpace);
      }
    }

    iapi._allocateSpace({
      bottom: spaceTakenByLegend.bottom || 0,
      right: spaceTakenByLegend.right || 0
    });
  };
  /**
   * function to get calculate width or hieght for stacked charts
   * @param  {number} maxAvailableSpace available space for height or width
   * @return {Object}                   contains top and right value
   */


  MSCartesian.prototype._getSumValueSpace = function _getSumValueSpace(maxAvailableSpace) {
    var iapi = this,
        dim = {},
        isBar = iapi.isBar,
        chartAttr = iapi.jsonData.chart,
        showSum = iapi.showsum !== 0 ? (0, _lib.pluckNumber)(chartAttr.showsum, iapi.showsum, 0) : 0,
        stack100Percent = (0, _lib.pluckNumber)(iapi.config.stack100percent),
        isStacked = iapi.config.isstacked,
        width = 0,
        i,
        stackManagers = [],
        height = 0;

    iapi.iterateComponents(function (child) {
      if (child.getName() === 'cartesianStackManager') {
        stackManagers.push(child);
      }
    });

    if (showSum && stack100Percent && isStacked && stackManagers.length) {
      for (i = stackManagers.length - 1; i >= 0; i--) {
        dim = stackManagers[i].getMaxSumValueSpace();
        if (!isBar) {
          height = Math.max(height, dim.maxHeight);
        } else {
          width = Math.max(width, dim.maxWidth);
        }
      }
      if (height > maxAvailableSpace) {
        height = maxAvailableSpace;
      }
      if (width > maxAvailableSpace) {
        width = maxAvailableSpace;
      }
    }

    return {
      top: height,
      right: width
    };
  };
  /**
   * Returns the postion for the caption placement
   * @param  {number} centerX center position of charts
   * @return {number}         extra spaces
   */


  MSCartesian.prototype._fetchCaptionPos = function _fetchCaptionPos(centerX) {
    var extraSpace,
        iapi = this,
        iapiConfig = iapi.config,
        totalWidth = iapiConfig.width,
        chartMenuBar = iapi.getChildren('chartMenuBar'),
        btnConfig = chartMenuBar.componentGroups[0].btnConfig,
        chartMenuLogicalSpace = chartMenuBar.getLogicalSpace(),
        toolBoxWidth = chartMenuLogicalSpace.width,
        caption = iapi.getChildren('caption') && iapi.getChildren('caption')[0],
        captionConfig = caption.config,
        captionWidth = captionConfig.width,
        isHalign = btnConfig.hAlign === 'l',
        rightWidth = iapiConfig.width - centerX,
        availableWidth = isHalign ? centerX : rightWidth,
        origMarginRight = iapiConfig.origMarginRight,
        origMarginLeft = iapiConfig.origMarginLeft,
        offsetX = isHalign ? origMarginLeft : origMarginRight;

    // check if even after placing the caption
    // space available on right.
    if (captionConfig.align === _lib.POSITION_MIDDLE) {
      extraSpace = availableWidth - captionWidth / 2 - offsetX - toolBoxWidth;
    } else if (captionConfig.align === 'start') {
      // left aligned
      extraSpace = isHalign ? -1 : totalWidth - iapiConfig.canvasLeft - offsetX - captionWidth - toolBoxWidth + captionConfig.horizontalPadding;
    } else {
      // right-aligned.
      extraSpace = isHalign ? totalWidth - (origMarginRight + origMarginLeft + toolBoxWidth + captionWidth) : -1;
    }
    return extraSpace;
  };
  /**
   * function to
   * @param  {number} availableHeight available hieght to alocate
   * @param  {number} availableWidth  available width to alocate
   * @return {Object}                 dimension is needed
   */


  MSCartesian.prototype._manageCaptionSpacing = function _manageCaptionSpacing(availableHeight, availableWidth) {
    var iapi = this,
        caption = iapi.getChildren('caption')[0],
        dimension;

    dimension = caption.manageSpace(availableHeight, availableWidth);
    return dimension;
  };
  /**
   * function calculate toolbar hieght and allocate required space for toolbar
   * @param  {number} availableHeight available height basically here the value is approx. chart height
   * @return {Object}                 details of region space taken by toolbar and caption
   */


  MSCartesian.prototype._manageChartMenuBar = function _manageChartMenuBar(availableHeight) {
    var captionDimensions,
        iapi = this,
        iapiConfig = iapi.config,
        chartMenuBar = iapi.getChildren('chartMenuBar'),
        chartMenuLogicalSpace = chartMenuBar && chartMenuBar.getLogicalSpace(),
        caption = iapi.getChildren('caption') && iapi.getChildren('caption')[0],
        captionConfig = caption.config,
        isCaptionOnTop = captionConfig.isOnTop,
        chartCenterX = iapiConfig.width / 2,
        canvasRight = iapiConfig.canvasRight,

    // For Non-cartesian charts(e.g. Pie series) canvasCenter coincides with chartCenterX
    canvasCenterX = canvasRight ? (iapiConfig.canvasLeft + canvasRight) / 2 : chartCenterX,
        extraSpace = 0,
        centerX = captionConfig.alignWithCanvas ? canvasCenterX : chartCenterX,
        btnConfig = chartMenuBar && chartMenuBar.componentGroups[0].btnConfig,
        manageToolBox = chartMenuLogicalSpace && btnConfig.spaceNotHardCoded;
    if (btnConfig && btnConfig.spaceNotHardCoded) {
      btnConfig.x = (0, _lib.pluckNumber)(btnConfig.hAlign === 'l' ? 0 : iapiConfig.width);
      btnConfig.y = (0, _lib.pluckNumber)(btnConfig.vAlign === 't' ? 0 : iapiConfig.height);
    }
    delete captionConfig._offsetHeight;
    if (isCaptionOnTop) {
      // place caption with a constrain on both height and width.
      // manage the space requirements for the caption.
      captionDimensions = iapi._manageCaptionSpacing(availableHeight);
      // If the toolbox isOnTop
      if (manageToolBox) {
        extraSpace = iapi._fetchCaptionPos(centerX);
        // not enough space on right is available. Place the caption and toolbox in two-tiers.
        captionConfig._offsetHeight = extraSpace < 0 ? chartMenuLogicalSpace.height : 0;
        captionDimensions.top = extraSpace < 0 ? (0, _lib.pluckNumber)(captionDimensions.top, 0) + chartMenuLogicalSpace.height : mathMax(captionDimensions.top, chartMenuLogicalSpace.height);
      }
      iapi._allocateSpace(captionDimensions);
    } else {
      // reduce the canvas height by the toolbox required height.
      iapi._allocateSpace({
        top: manageToolBox ? chartMenuLogicalSpace.height : 0
      });
      captionDimensions = iapi._manageCaptionSpacing(availableHeight);
      // allocate the space for caption.
      iapi._allocateSpace(captionDimensions);
    }
    return {
      top: chartMenuLogicalSpace ? mathMax(chartMenuLogicalSpace.height, captionDimensions.top) : captionDimensions.top,
      bottom: captionDimensions.bottom
    };
  };
  /**
   * calculate and allote space for various components
   * every components are get notified with maximum space and then components return
   * the available space.
   */


  MSCartesian.prototype._spaceManager = function _spaceManager() {
    // todo marge _allocateSpace and _spacemanager
    var availableWidth,
        availableHeight,
        iapi = this,
        config = iapi.config,
        xAxis = iapi.getChildren('xAxis') && iapi.getChildren('xAxis')[0],
        yAxisArr = iapi.getChildren('yAxis') && iapi.getChildren('yAxis') || [],
        yAxis,
        len,
        legend = iapi.getChildren('legend') && iapi.getChildren('legend')[0],
        legendPosition = legend.config.legendPos,
        xDepth = config.xDepth,
        yDepth = config.yDepth,
        canvasBgDepth = config.canvasBgDepth,
        allottedSpace,
        canvasBaseDepth = config.canvasBaseDepth,
        canvasBasePadding = config.canvasBasePadding,
        canvas = iapi.getChildren('canvas')[0],
        canvasBorderWidth = canvas.config.canvasBorderWidth,
        showRTValue = config.realTimeConfig && config.realTimeConfig.showRTValue,
        chartBorderWidth = config.borderWidth,
        canvasMarginTop = config.canvasMarginTop,
        canvasMarginBottom = config.canvasMarginBottom,
        canvasMarginLeft = config.canvasMarginLeft,
        canvasMarginRight = config.canvasMarginRight,
        minCanvasHeight = config.minCanvasHeight,
        minCanvasWidth = config.minCanvasWidth,
        minChartWidth = config.minChartWidth,
        minChartHeight = config.minChartHeight,
        height = config.height,
        width = config.width,
        diff,
        heightAdjust = false,
        widthAdjust = false,
        top,
        bottom,
        left,
        right,
        i,
        currentCanvasHeight,
        currentCanvasWidth,
        origCanvasTopMargin = config.origCanvasTopMargin,
        origCanvasBottomMargin = config.origCanvasBottomMargin,
        origCanvasLeftMargin = config.origCanvasLeftMargin,
        origCanvasRightMargin = config.origCanvasRightMargin,
        chartBorderHorizontal,
        chartBorderVertical,
        canvasBorderHorizontal,
        canvasBorderVertical,
        yAxisSpaceAllocation = [],
        xAxisSpaceAllocation,
        spaceTakenByAxis,
        sum;

    if (config.canvasWidth - 2 * chartBorderWidth < minChartWidth) {
      chartBorderVertical = (config.canvasWidth - minChartWidth) / 2;
    }

    if (config.canvasHeight - 2 * chartBorderWidth < minChartHeight) {
      chartBorderHorizontal = (config.canvasHeight - minChartHeight) / 2;
    }

    iapi._allocateSpace({
      top: chartBorderHorizontal || chartBorderWidth,
      bottom: chartBorderHorizontal || chartBorderWidth,
      left: chartBorderVertical || chartBorderWidth,
      right: chartBorderVertical || chartBorderWidth
    });

    for (i = 0, len = yAxisArr.length; i < len; i++) {
      yAxis = yAxisArr[i];
      //* ***** Manage space
      availableWidth = config.availableWidth * 0.7;
      spaceTakenByAxis = yAxis && yAxis.placeAxis(availableWidth) || {};

      yAxisSpaceAllocation.push({
        axisIndex: i,
        spaceTaken: spaceTakenByAxis
      });

      yAxis && iapi._allocateSpace(spaceTakenByAxis);
    }

    config.yAxisSpaceAllocation = yAxisSpaceAllocation;
    iapi._allocateSpace(iapi._manageActionBarSpace && iapi._manageActionBarSpace(config.availableHeight * 0.225) || {});

    // No space is allocated for legend drawing in single series charts
    iapi._manageLegendSpace(allottedSpace);

    availableHeight = legendPosition === _lib.POSITION_BOTTOM ? config.availableHeight * 0.6 : config.availableWidth * 0.6;

    // space management for 3d canvas
    if (yDepth) {
      iapi._allocateSpace({
        bottom: yDepth
      });
      config.shift = xDepth + canvasBasePadding + canvasBaseDepth;
    }
    if (canvasBgDepth) {
      iapi._allocateSpace({
        right: canvasBgDepth
      });
    }

    if (config.canvasWidth - 2 * canvasBorderWidth < minCanvasWidth) {
      canvasBorderVertical = (config.canvasWidth - minCanvasWidth) / 2;
    }

    iapi._allocateSpace({
      left: canvasBorderVertical || canvasBorderWidth,
      right: canvasBorderVertical || canvasBorderWidth
    });

    // Check for minimun canvas width for applying canvas left and right margin.
    if (minCanvasWidth > width - canvasMarginLeft - canvasMarginRight) {
      widthAdjust = true;
      diff = config.canvasWidth - minCanvasWidth;
      sum = canvasMarginLeft + canvasMarginRight;
      canvasMarginLeft = config.canvasMarginLeft = diff * canvasMarginLeft / sum;
      canvasMarginRight = config.canvasMarginRight = diff * canvasMarginRight / sum;
    }

    // Calculating the left and right canvas margin.
    left = canvasMarginLeft > config.canvasLeft ? canvasMarginLeft - config.canvasLeft : 0;
    right = canvasMarginRight > width - config.canvasRight ? canvasMarginRight + config.canvasRight - width : 0;

    iapi._allocateSpace({
      left: left,
      right: right
    });

    // Forcing canvas width to its minimum
    if (widthAdjust) {
      sum = origCanvasLeftMargin + origCanvasRightMargin;
      currentCanvasWidth = config.canvasWidth;
      if (currentCanvasWidth > minCanvasWidth) {
        diff = currentCanvasWidth - minCanvasWidth;
        left = diff * origCanvasLeftMargin / sum;
        right = diff * origCanvasRightMargin / sum;
      }
      iapi._allocateSpace({
        left: left,
        right: right
      });
    }

    config.actualCanvasMarginRight = right;
    config.actualCanvasMarginBottom = bottom;

    // a space manager that manages the space for the tools as well as the captions.
    iapi._manageChartMenuBar(availableHeight);

    availableHeight = config.availableHeight * 0.2;

    iapi._allocateSpace(iapi._getSumValueSpace(availableHeight));

    availableHeight = config.availableHeight * 0.3;
    if (config.realtimeEnabled) {
      if (showRTValue) {
        iapi._allocateSpace(iapi._realTimeValuePositioning(availableHeight));
      } else {
        iapi._hideRealTimeValue();
      }
    }

    iapi._resetViewPortConfig && iapi._resetViewPortConfig();
    iapi._setAxisScale && iapi._setAxisScale();

    availableHeight = config.availableHeight * 0.6;
    config.xAxisSpaceAllocation = xAxisSpaceAllocation = xAxis && xAxis.placeAxis(availableHeight);
    xAxis && iapi._allocateSpace(xAxisSpaceAllocation);

    // alocate the space for scroll.
    availableHeight = config.availableHeight * 0.3;
    iapi._manageScrollerPosition && iapi._manageScrollerPosition(availableHeight);

    if (config.canvasHeight - 2 * canvasBorderWidth < minCanvasHeight) {
      canvasBorderHorizontal = (config.canvasHeight - minCanvasHeight) / 2;
    }

    iapi._allocateSpace({
      top: canvasBorderHorizontal || canvasBorderWidth,
      bottom: canvasBorderHorizontal || canvasBorderWidth
    });

    iapi._allocateSpace({
      bottom: canvasBaseDepth
    });

    // Check for minimum canvas height for applying top and bottom margin.
    if (minCanvasHeight > height - canvasMarginTop - canvasMarginBottom) {
      heightAdjust = true;
      diff = config.canvasHeight - minCanvasHeight;
      sum = canvasMarginTop + canvasMarginBottom;
      canvasMarginTop = config.canvasMarginTop = diff * canvasMarginTop / sum;
      canvasMarginBottom = config.canvasMarginBottom = diff * canvasMarginBottom / sum;
    }

    // Allocate space for canvas margin only if the margin is less than the margin entered by the user.
    top = canvasMarginTop > config.canvasTop ? canvasMarginTop - config.canvasTop : 0;
    bottom = canvasMarginBottom > height - config.canvasBottom ? canvasMarginBottom + config.canvasBottom - height : 0;

    iapi._allocateSpace({
      top: top,
      bottom: bottom
    });

    // Forcing canvas height to its minimum
    if (heightAdjust) {
      sum = origCanvasTopMargin + origCanvasBottomMargin;
      currentCanvasHeight = config.canvasHeight;
      if (currentCanvasHeight > minCanvasHeight) {
        diff = currentCanvasHeight - minCanvasHeight;
        top = diff * origCanvasTopMargin / sum;
        bottom = diff * origCanvasBottomMargin / sum;
      }
      iapi._allocateSpace({
        top: top,
        bottom: bottom
      });
    }

    config.actualCanvasMarginTop = top;
    config.actualCanvasMarginLeft = left;
    canvas.setDimension({
      top: config.canvasTop,
      left: config.canvasLeft,
      width: config.canvasWidth,
      height: config.canvasHeight
    });
  };
  /**
   * calculate margins and space for and mange space for components
   */


  MSCartesian.prototype._manageSpace = function _manageSpace() {
    var iapi = this,
        canvas = iapi.getChildren('canvas')[0],
        canvasConfig = canvas.config,
        config = iapi.config,
        width = iapi.getFromEnv('chartWidth'),
        height = iapi.getFromEnv('chartHeight'),
        minCanvasWidth,
        minCanvasHeight,
        marginTop,
        marginLeft,
        marginBottom,
        marginRight,
        canvasHeight,
        canvasWidth,
        minChartHeight,
        minChartWidth,
        diff,
        sum;

    // Setting the initial chart dimensions.
    config.width = width;
    config.height = height;
    config.minChartHeight = minChartHeight = config.minChartHeightPercent * height;
    config.minChartWidth = minChartWidth = config.minChartWidthPercent * width;
    config.minCanvasWidth = minCanvasWidth = config.minCanvasWidthPercent * minChartWidth;
    config.minCanvasHeight = minCanvasHeight = config.minCanvasHeightPercent * minChartHeight;

    config.marginTop = marginTop = config.origMarginTop;
    config.marginLeft = marginLeft = config.origMarginLeft;
    config.marginBottom = marginBottom = config.origMarginBottom;
    config.marginRight = marginRight = config.origMarginRight;

    config.canvasMarginTop = config.origCanvasTopMargin;
    config.canvasMarginLeft = config.origCanvasLeftMargin;
    config.canvasMarginBottom = config.origCanvasBottomMargin;
    config.canvasMarginRight = config.origCanvasRightMargin;

    config.canvasHeight = canvasHeight = config.height - config.marginTop - config.marginBottom;
    config.canvasWidth = canvasWidth = config.width - config.marginLeft - config.marginRight;
    config.availableHeight = canvasHeight - minCanvasHeight;
    config.availableWidth = canvasWidth - minCanvasWidth;

    // Check for minimum chart height
    if (canvasHeight < minChartHeight) {
      diff = height - minChartHeight;
      config.canvasHeight = minChartHeight;
      sum = marginTop + marginBottom;
      config.marginTop = diff * marginTop / sum;
      config.marginBottom = diff * marginBottom / sum;
      config.availableHeight = minChartHeight - minCanvasHeight;
    }

    // Check for minimum chart width
    if (canvasWidth < minChartWidth) {
      diff = width - minChartWidth;
      sum = marginRight + marginLeft;
      config.canvasWidth = minChartWidth;
      config.marginLeft = diff * marginLeft / sum;
      config.marginRight = diff * marginRight / sum;
      config.availableWidth = minChartWidth - minCanvasWidth;
    }

    config.canvasLeft = config.marginLeft;
    config.canvasTop = config.marginTop;

    canvasConfig.canvasPaddingLeft = mathMin(canvasConfig.origCanvasLeftPad, mathRound(0.1 * config.height));
    canvasConfig.canvasPaddingRight = mathMin(canvasConfig.origCanvasRightPad, mathRound(0.1 * config.height));
    canvasConfig.canvasPaddingTop = mathMin(canvasConfig.origCanvasTopPad, mathRound(0.1 * config.height));
    canvasConfig.canvasPaddingBottom = mathMin(canvasConfig.origCanvasBottomPad, mathRound(0.1 * config.height));

    // manage space
    iapi._spaceManager();
  };
  /**
   * function to calculate post space management calculations
   * calculations like axis dimenetion set, allocate space for xaxis labels,
   * canvas padding etc.
   */


  MSCartesian.prototype._postSpaceManagement = function _postSpaceManagement() {
    var iapi = this,
        config = iapi.config,
        xAxis = iapi.getChildren('xAxis') && iapi.getChildren('xAxis')[0],
        legend = iapi.getChildren('legend')[0],
        xDepth = config.xDepth,
        i,
        canvas,
        canvasArr = iapi.getChildren('canvas');

    iapi.setAxisDimention();
    xAxis && iapi._allocateXAxisLabelSpace(xAxis);
    xAxis && xAxis.shiftLabels(-xDepth, 0);
    legend.postSpaceManager();

    for (i = 0; i < canvasArr.lentgh; i++) {
      canvas = canvasArr[i];
      // function for adjusting value padding depending upon data and axis labels.
      canvas.setCanvasPadding();
    }
    // Re-set the dimension after setting the canvas padding
    iapi.setAxisDimention();
  };

  /**
   * Sets dimension of Axis components
   */


  MSCartesian.prototype.setAxisDimention = function setAxisDimention() {
    var iapi = this,
        xAxis = iapi.getChildren('xAxis') && iapi.getChildren('xAxis')[0],
        yAxis = iapi.getChildren('yAxis') && iapi.getChildren('yAxis')[0],
        chartConfig = iapi.getFromEnv('chartConfig'),
        xDepth = chartConfig.xDepth,
        canvasConfig = iapi.getChildren('canvas')[0].config,
        canvasBorderWidth = canvasConfig.canvasBorderWidth,
        canvasPadding = canvasConfig.canvasPadding,
        canvasLeft = chartConfig.canvasLeft,
        canvasPaddingLeft = canvasConfig.canvasPaddingLeft,
        canvasTop = chartConfig.canvasTop,
        canvasPaddingTop = canvasConfig.canvasPaddingTop;

    xAxis && xAxis.setAxisDimention({
      x: canvasLeft + (xDepth || 0) + Math.max(canvasPaddingLeft, canvasPadding),
      y: chartConfig.canvasBottom + (chartConfig.shift || 0) + canvasBorderWidth,
      opposite: canvasTop - canvasBorderWidth,
      axisLength: chartConfig.canvasWidth - (xDepth || 0) - Math.max(canvasPaddingLeft, canvasPadding) - Math.max(canvasConfig.canvasPaddingRight, canvasPadding)
    });

    yAxis && yAxis.setAxisDimention({
      x: canvasLeft - canvasBorderWidth,
      y: canvasTop + canvasPaddingTop,
      opposite: chartConfig.canvasRight + canvasBorderWidth,
      axisLength: chartConfig.canvasHeight - canvasPaddingTop - canvasConfig.canvasPaddingBottom
    });
  };

  /**
   * *@TODO needs to be validate where to place this fn
   * function to calculate max, min value of trendlines
   * @param  {string} type     trendline type vertical or horizontal
   * @param  {string} axisType  axis type primary or secondary
   * @return {Object}           contains value of min and max
   */


  MSCartesian.prototype._getTrendLineMinMax = function _getTrendLineMinMax(type, axisType) {
    var iapi = this,
        trendLines = type === 'v' ? iapi.jsonData.vtrendlines : iapi.jsonData.trendlines,
        retObj = {
      max: -Infinity,
      min: Infinity
    },
        trendLineObj,
        i,
        ii,
        ln,
        lnn;

    axisType = axisType || 'p';
    if (trendLines) {
      for (i = 0, ln = trendLines.length; i < ln; i += 1) {
        for (ii = 0, lnn = trendLines[i].line ? trendLines[i].line.length : 0; ii < lnn; ii += 1) {
          trendLineObj = trendLines[i].line[ii];
          if (axisType === 's' && trendLineObj.parentyaxis !== 's' || axisType !== 's' && trendLineObj.parentyaxis === 's') {
            continue;
          }
          retObj.max = mathMax(trendLineObj.startvalue || -Infinity, trendLineObj.endvalue || -Infinity, retObj.max);
          retObj.min = mathMin(trendLineObj.startvalue || Infinity, trendLineObj.endvalue || Infinity, retObj.min);
        }
      }
    }
    return retObj;
  };

  /**
   * All numeric calculations to be done here
   */


  MSCartesian.prototype._preDraw = function _preDraw() {
    var iapi = this;
    iapi.config.realtimeEnabled && iapi._setRealTimeCategories && iapi._setRealTimeCategories();
    iapi.getFromEnv('animationManager').setIsSingleStep();
    iapi._mapChildren(function (child) {
      child.preDraw && child.preDraw();
    });
    // set axis limit call from those charts of which datasets are directly child of the chart components
    iapi._setAxisLimits && iapi._setAxisLimits();
    iapi.getFromEnv('chartMenuTools').reset(iapi.getFromEnv('tb'), iapi);
    iapi.config.useShowLogMenu && iapi._setUseLog();
  };

  /**
   * Parse server input text and converts to input data object for chart
   * @param {string} responseText User input text as from server
   * @return {Object} parsed data from response text
   */


  MSCartesian.prototype._linearDataParser = function _linearDataParser(responseText) {
    /* Commands to handle:
     * label, value, toolText, showLabel, link, color, vLine and related params (?),
     * clear, stopUpdate, pointerId related updates,
     */
    var iapi = this,
        AMPERSAND = '&',
        EQUALS = '=',
        PIPE = '|',
        COMMA = ',',
        commands,
        command,
        params,
        valueVisibility,
        toolTexts,
        toolTextsTarget,
        colors,
        links,
        vlineLabels,
        vlineColors,
        vlineThickness,
        vlineDashed,
        showLabels,
        i,
        l,
        labels,
        vlines,
        values,
        target,
        dataStamp,
        pause,
        clear,
        len,
        data,
        j,
        existingDatasets = getDataset(iapi),
        existingDatasetsLen = existingDatasets && existingDatasets.length,
        valuesLen,
        realTimeConfig = iapi.config.realTimeConfig,
        prevData = realTimeConfig.prevData = [],
        legacyUpdateObj = realTimeConfig.legacyUpdateObj = {},
        dataObjValues = legacyUpdateObj.values = [],
        dataObjTarget = legacyUpdateObj.target = [],
        dataObjShowValues = legacyUpdateObj.valueVisibility = [],
        dataObjToolTexts = legacyUpdateObj.toolTexts = [],
        dataObjToolTextsTarget = legacyUpdateObj.toolTextsTarget = [],
        dataObjColors = legacyUpdateObj.colors = [],
        dataObjLinks = legacyUpdateObj.links = [],
        maxValueLen = 0,
        dataObj,
        updateObj = {
      categories: { category: [] },
      dataset: []
    },
        labelsLen,
        category = updateObj.categories.category,
        dataset = updateObj.dataset,
        prevDataObj,
        lowerCaseCommand,
        tempToolText = responseText,
        toolText;

    // clean value
    responseText = responseText && responseText.toString && responseText.toString() || '';
    // replacing all the | with , for hlinear gauge and angular gauge.
    if (iapi.rtParserModify) {
      tempToolText = tempToolText.replace(/([^\\])(\|)/g, '$1,');
      responseText = responseText.replace(/\|/g, ',');
    }
    // split the commands.
    commands = responseText.split(AMPERSAND);

    for (i = 0, l = commands.length; i < l; i += 1) {
      // for every command, separate the command name and its values.
      command = commands[i].split(EQUALS);
      params = command[1];
      command = command[0];

      // no need to process improper data strings as of now.
      if (command === _lib.BLANKSTRING || command === _lib.UNDEF || params === _lib.UNDEF || params === _lib.BLANKSTRING) {
        continue;
      }

      // desensitize case.
      lowerCaseCommand = command.toLowerCase();

      switch (lowerCaseCommand) {
        case 'label':
          legacyUpdateObj.labels = labels = params.split(COMMA);
          break;

        case 'vline':
          legacyUpdateObj.vlines = vlines = params.split(COMMA);
          break;
        case 'vlinelabel':
          legacyUpdateObj.vlineLabels = vlineLabels = params.split(COMMA);
          break;
        case 'vlinecolor':
          legacyUpdateObj.vlineColors = vlineColors = params.split(COMMA);
          break;
        case 'vlinethickness':
          legacyUpdateObj.vlineThickness = vlineThickness = params.split(COMMA);
          break;
        case 'vlinedashed':
          legacyUpdateObj.vlineDashed = vlineDashed = params.split(COMMA);
          break;

        case 'value':
          values = params.split(PIPE);
          break;

        case 'target':
          target = params.split(PIPE);
          break;

        case 'showlabel':
          legacyUpdateObj.showLabels = showLabels = params.split(COMMA);
          break;

        case 'showvalue':
          valueVisibility = params.split(PIPE);
          break;

        case 'tooltext':
          toolTexts = tempToolText.match(/tooltext=(.*?\\&)*.*?[^\\]&/i);
          toolTexts =
          // When tooltext is succeeded by other parameters like &value, &color, etc.
          // Eliminating 'tooltext=' text from tooltext.
          toolTexts ? toolTexts[0].substr(9, toolTexts[0].length - 10) :
          // When tooltext is the last argument in the feedData string.
          tempToolText.match(/(tooltext=)(.*)/i)[2];
          // Replacing all '|' characters except '\|' characters.
          toolTexts = toolTexts && toolTexts.replace(/([^\\])(\|)/g, '$1_FC@@**');
          toolTexts = toolTexts.split('_FC@@**');

          // @todo - The string has to split with '|' and not '\|' directly without using replace.
          // // When tooltext is succeeded by other parameters like &value, &color, etc.
          // if (toolTexts[1] && toolTexts[2]) {
          //     toolTexts = toolTexts[1] + toolTexts[2];
          //     toolTexts = toolTexts.split(/\|(?=\\)/);
          // }
          // // When tooltext is the last argument in the feedData string.
          // else {
          //     toolTexts = tempToolText.match(/(tooltext=)(.*)/i)[2];
          //     toolTexts = toolTexts && toolTexts.split(/\|(?=\|)/);
          // }
          break;

        case 'targettooltext':
          toolTextsTarget = params.split(PIPE);
          break;

        case 'link':
          links = params.split(PIPE);
          break;

        case 'color':
          colors = params.split(PIPE);
          break;

        case 'datastamp':
          legacyUpdateObj.dataStamp = dataStamp = params;
          break;

        case 'stopupdate':
          legacyUpdateObj.pause = pause = params == '1';
          break;

        case 'clear':
          legacyUpdateObj.clear = clear = params == '1';
          break;

        default:
          // directly add the information in the update object
          legacyUpdateObj[command] = updateObj[command] = params;
      }
    }

    valuesLen = values && values.length;
    for (i = 0; i < valuesLen; i++) {
      dataObjValues[i] = values[i].split(COMMA);
      dataObjTarget[i] = target && target[i] && target[i].split(COMMA);
      dataObjShowValues[i] = valueVisibility && valueVisibility[i] && valueVisibility[i].split(COMMA);
      dataObjToolTextsTarget[i] = toolTextsTarget && toolTextsTarget[i] && toolTextsTarget[i].split(COMMA);
      dataObjColors[i] = colors && colors[i] && colors[i].split(COMMA);
      dataObjLinks[i] = links && links[i] && links[i].split(COMMA);
      if (toolTexts) {
        toolText = toolTexts[i];
        if (toolText) {
          toolText = toolText.replace(/([^\\])(\,)/g, '$1_FC@@**');
          dataObjToolTexts[i] = toolText.split('_FC@@**');
        }
      }

      // Finding the dataset that has the maximum data entered through feedData.
      maxValueLen = mathMax(maxValueLen, dataObjValues[i].length);
    }
    labelsLen = labels && labels.length;

    // No of data that is to be added is the maximum of number of categories or the num of data entered.
    len = mathMax(labelsLen || 0, maxValueLen || 0);

    for (i = 0; i < len; i++) {
      category.push({
        label: labels && labels[i],
        color: vlineColors && vlineColors[i],
        showlabel: showLabels && showLabels[i]
      });
    }

    if (vlines) {
      category.push({
        label: vlineLabels && vlineLabels[0],
        vline: vlines && vlines[0],
        color: vlineColors && vlineColors[0],
        thickness: vlineThickness && vlineThickness[0],
        dashed: vlineDashed && vlineDashed[0],
        showlabel: showLabels && showLabels[0]
      });
    }

    for (i = 0; i < existingDatasetsLen; i++) {
      dataObj = {};
      data = dataObj.data = [];
      prevDataObj = prevData[i] = [];
      for (j = 0; j < len; j++) {
        data.push({
          value: dataObjValues[i] && dataObjValues[i][j],
          target: dataObjTarget[i] && dataObjTarget[i][j],
          showvalue: dataObjShowValues[i] && dataObjShowValues[i][j],
          tooltext: dataObjToolTexts[i] && dataObjToolTexts[i][j] && dataObjToolTexts[i][j].replace(/\\/g, ''),
          tooltexttarget: dataObjToolTextsTarget[i] && dataObjToolTextsTarget[i][j],
          color: dataObjColors[i] && dataObjColors[i][j],
          link: dataObjLinks[i] && dataObjLinks[i][j]

        });
        prevDataObj.push(dataObjValues[i] && dataObjValues[i][j]);
      }
      dataset.push(dataObj);
    }

    if (pause) {
      iapi._stopUpdate();
    }

    if (clear) {
      iapi._clearChart();
    }

    if (dataStamp) {
      iapi.config.dataStamp = dataStamp;
    }

    return updateObj;
  };

  /**
   * Function to clear the realTime timers
   */


  MSCartesian.prototype._clearTimers = function _clearTimers() {
    var iapi = this,
        realTimeConfig = iapi.config && iapi.config.realTimeConfig,
        timers = iapi.config.timers,
        setTimeout = timers && timers.setTimeout,
        setInterval = timers && timers.setInterval,
        timer;
    realTimeConfig && (realTimeConfig.refreshIntervalFlag = false);
    for (timer in setTimeout) {
      clearTimeout(setTimeout[timer]);
    }

    for (timer in setInterval) {
      clearInterval(setInterval[timer]);
    }
  };
  /**
   * Legacy function for real time update via feedData
   * @param  {string}  stream raw data that has to be fed to the chart
   * @return {boolean} whether data are fed or not
   */


  MSCartesian.prototype.feedData = function feedData(stream) {
    var iapi = this,
        isRealTime = iapi.config.realtimeEnabled,
        realTimeConfig = iapi.config.realTimeConfig || (iapi.config.realTimeConfig = {}),
        dataObj,
        chartChildren = iapi.getChildren(),
        dataset = getDataset(iapi),
        i,
        len = dataset.length;
    dataObj = iapi._linearDataParser(stream);
    if (isRealTime && iapi.chartInstance.isActive()) {
      if (realTimeConfig.clear) {
        for (i = 0; i < len; i++) {
          dataset[i]._realTimeConfigure(true);
        }
        realTimeConfig.clear = false;
      }

      // if message logger, then update the logger as well
      if (chartChildren.messageLogger) {
        chartChildren.messageLogger.addLog(dataObj);
      }

      // if message logger, then update the logger as well
      if (chartChildren.alertManager) {
        chartChildren.alertManager[0].processRTData(dataObj);
      }

      iapi.realTimeUpdate(dataObj);
      iapi.realTimeDraw({
        source: 'feedData'
      });
      // Code for changing chart visuals at regular intervals.
      return true;
    } else {
      return false;
    }
  };
  /**
   * Only updates the internal data-structure without updating visuals.
   * @param  {Object} dataObj new data object to be added in dataset
   */


  MSCartesian.prototype.realTimeUpdate = function realTimeUpdate(dataObj) {
    var iapi = this,
        datasets = getDataset(iapi),
        i,
        cachedArrivedJSON = iapi.config.cachedArrivedJSON,
        currJSONDataset,
        cachedCategories = cachedArrivedJSON && cachedArrivedJSON.categories,
        newDataset = dataObj.dataset,
        newCategory = dataObj.categories && dataObj.categories.category || [];

    if (!iapi.config.cachedArrivedJSON) {
      cachedArrivedJSON = iapi.config.cachedArrivedJSON = {};
      cachedArrivedJSON.dataset = [];
      cachedCategories = cachedArrivedJSON.categories = {};
      cachedCategories.category = [];
    }
    for (i = 0; i < datasets.length; i++) {
      currJSONDataset = cachedArrivedJSON.dataset[i] || (cachedArrivedJSON.dataset[i] = {});
      currJSONDataset.data || (currJSONDataset.data = []);
      currJSONDataset.data.push.apply(currJSONDataset.data, newDataset[i].data);
    }

    cachedCategories.category.push.apply(cachedCategories.category, newCategory);
  };

  /**
   * Calculates space for components during realtime update
   */


  MSCartesian.prototype._RTmanageSpace = function _RTmanageSpace() {
    var iapi = this,
        config = iapi.config,
        chartChildren = iapi.getChildren(),
        xAxis = chartChildren.xAxis[0],
        yAxis = chartChildren.yAxis[0],
        sYAxis = chartChildren.yAxis[1],
        bottom,
        canvas = chartChildren.canvas && chartChildren.canvas[0],
        canvasConfig = canvas.config,
        canvasBorderWidth = canvasConfig.canvasBorderWidth,
        canvasPaddingTop = canvasConfig.canvasPaddingTop,
        canvasPaddingBottom = canvasConfig.canvasPaddingBottom,
        canvasPadding = canvasConfig.canvasPadding || 0,
        canvasPaddingLeft = canvasConfig.canvasPaddingLeft,
        canvasPaddingRight = canvasConfig.canvasPaddingRight,
        xAxisSpaceAllocation,
        yAxisSpaceAllocation,
        sYAxisSpaceAllocation,
        availableHeight,
        availableWidth,
        prevXAxisSpaceAllocation = config.xAxisSpaceAllocation,
        spaceTakenByYAxis = config.yAxisSpaceAllocation || [],
        prevYAxisSpaceAllocation = spaceTakenByYAxis[0] && spaceTakenByYAxis[0].spaceTaken || {},
        prevSYAxisSpaceAllocation = spaceTakenByYAxis[1] && spaceTakenByYAxis[1].spaceTaken || {},
        primaryAxisOnleft = config.primaryAxisOnleft,
        pYAxisStartXPos,
        sYAxisStartXPos,
        pYAxisOppLength,
        sYAxisOppLength,
        tempVar;

    availableHeight = config.availableHeight;
    xAxisSpaceAllocation = config.xAxisSpaceAllocation = xAxis.placeAxis(availableHeight + prevXAxisSpaceAllocation.bottom);

    bottom = xAxisSpaceAllocation.bottom - prevXAxisSpaceAllocation.bottom;
    // when xAxis not at previous position
    if (bottom !== 0) {
      iapi._allocateSpace({
        bottom: bottom
      });

      availableWidth = config.availableWidth;
      spaceTakenByYAxis[0].spaceTaken = yAxisSpaceAllocation = yAxis.placeAxis(availableWidth + prevYAxisSpaceAllocation.left);

      iapi._allocateSpace({
        left: yAxisSpaceAllocation.left - prevYAxisSpaceAllocation.left
      });

      availableWidth = config.availableWidth;

      pYAxisStartXPos = config.canvasLeft - canvasBorderWidth;
      pYAxisOppLength = config.canvasRight + canvasBorderWidth;

      if (sYAxis) {
        sYAxisStartXPos = pYAxisOppLength;
        sYAxisOppLength = pYAxisStartXPos;
        // when primary axis is on right change the positions
        if (primaryAxisOnleft === 0) {
          tempVar = pYAxisStartXPos;
          pYAxisStartXPos = sYAxisStartXPos;
          sYAxisStartXPos = tempVar;
          tempVar = pYAxisOppLength;
          pYAxisOppLength = sYAxisOppLength;
          sYAxisOppLength = tempVar;
        }

        spaceTakenByYAxis[1].spaceTaken = sYAxisSpaceAllocation = sYAxis.placeAxis(availableWidth + (prevSYAxisSpaceAllocation.right || 0));

        iapi._allocateSpace({
          right: (sYAxisSpaceAllocation.right || 0) - (prevSYAxisSpaceAllocation.right || 0)
        });

        sYAxis.setAxisDimention({
          x: sYAxisStartXPos,
          y: config.canvasTop + canvasPaddingTop,
          opposite: sYAxisOppLength,
          axisLength: config.canvasHeight - canvasPaddingTop - canvasPaddingBottom
        });
      }

      xAxis && xAxis.setAxisDimention({
        x: config.canvasLeft + mathMax(canvasPaddingLeft, canvasPadding),
        y: config.canvasBottom + (config.shift || 0) + canvasBorderWidth,
        opposite: config.canvasTop - canvasBorderWidth,
        axisLength: config.canvasWidth - mathMax(canvasPaddingLeft, canvasPadding) - mathMax(canvasPaddingRight, canvasPadding)
      });
      yAxis && yAxis.setAxisDimention({
        x: pYAxisStartXPos,
        y: config.canvasTop + canvasPaddingTop,
        opposite: pYAxisOppLength,
        axisLength: config.canvasHeight - canvasPaddingTop - canvasPaddingBottom
      });
      iapi.canvasPadding && canvas.setCanvasPadding();
    }
  };

  /**
   * Update visuals during real time draw.
   * @param  {Object} eventArgs Conatins the key value for the event Args of realTimeUpdate event.
   */


  MSCartesian.prototype.realTimeDraw = function realTimeDraw() {
    var eventArgs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var iapi = this,
        chartChildren = iapi.getChildren(),
        canvas = chartChildren.canvas && chartChildren.canvas[0],
        vCanvas = canvas.getChildren('vCanvas'),
        xAxis = chartChildren.xAxis && chartChildren.xAxis[0],
        yAxis = chartChildren.yAxis && chartChildren.yAxis[0],
        yAxis1 = chartChildren.yAxis && chartChildren.yAxis[1],
        scale = chartChildren.scale,
        dataset = getDataset(iapi),
        dslen = dataset.length,
        len,
        dataObj = iapi.config.cachedArrivedJSON,
        newDataset = dataObj && dataObj.dataset,
        newCategory = dataObj && dataObj.categories && dataObj.categories.category || [],
        catLen = xAxis && xAxis.getCategoryLen(),
        realTimeConfig = iapi.config.realTimeConfig = iapi.config.realTimeConfig || (iapi.config.realTimeConfig = {}),
        newCatLength = 0,
        curDataset,
        datasetParent,
        showRTValue = realTimeConfig.showRTValue,
        maxminFlag = realTimeConfig.maxminFlag,
        i,
        drawLatency,
        isClear = realTimeConfig.clear,
        dataStreamer = iapi.getChildren('dataStreamer')[0],
        drawStart = new Date();

    // set the state that the realtime update is going to happen
    iapi.state = 'realTimeUpdate';
    // Querying if animation is single step
    iapi.getFromEnv('animationManager').setIsSingleStep();
    if (dataset) {
      if (dataObj) {
        if (xAxis) {
          xAxis.categoryInsert(catLen, newCategory, true);
          for (i = 0, len = newCategory.length; i < len; i++) {
            if (!newCategory[i].vline) {
              newCatLength += 1;
            }
          }
          xAxis.categoryDelete(0, newCatLength, true);
          xAxis.categoryTranslate(newCatLength);
        }
        iapi.config._sumValuesUpdated = false;

        if (isClear) {
          for (i = 0; i < dslen; i++) {
            dataset[i]._realTimeConfigure(true);
          }
          realTimeConfig.clear = false;
        }

        for (i = 0; i < dslen; i++) {
          curDataset = newDataset[i];
          dataset[i].addData(curDataset);
          dataset[i].removeData(0, curDataset.data.length);
          dataset[i].maxminFlag && (realTimeConfig.maxminFlag = dataset[i].maxminFlag);
          datasetParent = dataset[i].getLinkedParent();
          datasetParent.childChanged();
        }
        iapi.config.cachedArrivedJSON = _lib.UNDEF;
      }

      // Set RT update info in v-canvas so that it animates the canvas properly
      if (vCanvas) {
        for (i = 0, len = vCanvas.length; i < len; i++) {
          vCanvas[i].rtShiftAnim && vCanvas[i].rtShiftAnim(newCatLength);
        }
      }
      // Function to manage space during realTime
      iapi.rtManageSpace && iapi._RTmanageSpace();
      iapi._preDraw();
      xAxis && xAxis.syncDraw();
      maxminFlag && yAxis && yAxis.syncDraw();
      yAxis1 && yAxis1.syncDraw();
      maxminFlag && scale && scale.syncDraw();
      canvas.syncDraw();

      showRTValue && iapi._drawRealTimeValue && iapi._drawRealTimeValue();
    }

    iapi._setRTdata && iapi._setRTdata();

    drawLatency = new Date() - drawStart;

    if (!isClear) {
      eventArgs.prevData = realTimeConfig.prevData;
      eventArgs.latency = drawLatency;
      eventArgs.updateObject = realTimeConfig.legacyUpdateObj;
    }

    dataStreamer.addToEnv('realtimeDrawingLatency', drawLatency);
    (0, _eventApi.triggerEvent)('realTimeUpdateComplete', iapi.chartInstance, eventArgs);
  };

  /**
   * Clears the entire chart plots
   * @param {string} _source The source of feeding data into chart for realtime
   */


  MSCartesian.prototype._clearChart = function _clearChart(_source) {
    var iapi = this,
        chartChildren = iapi.getChildren(),
        xAxis = chartChildren.xAxis && chartChildren.xAxis[0],
        dataset = getDataset(iapi),
        catLen = xAxis.getCategoryLen(),
        realTimeConfig = iapi.config.realTimeConfig || (iapi.config.realTimeConfig = {}),
        curDataset,
        i,
        len = dataset.length;

    realTimeConfig.clear = true;

    if (dataset) {
      if (xAxis) {
        xAxis.categoryDelete(0, catLen, true);
      }
      iapi.config._sumValuesUpdated = false;
      for (i = 0; i < len; i++) {
        curDataset = dataset[i];
        dataset[i].removeData(0, curDataset.components.data.length);
        dataset[i].maxminFlag && (realTimeConfig.maxminFlag = dataset[i].maxminFlag);
      }
      iapi._setRealTimeCategories();
    }

    (0, _eventApi.triggerEvent)('ChartCleared', this.chartInstance, {
      source: _source
    }, [this.id, _source]);
  };

  /**
   * Function to set cursor for the chart in case chart link is present.
   */


  MSCartesian.prototype.setChartCursor = function setChartCursor() {
    var chart = this,
        link = chart.config.link,
        style = chart.getFromEnv('paper').canvas.style;
    // Set the cursor based on the presense of link. Note that IE and
    // other browsers have separate css value.
    if (_redraphael2['default'].svg) {
      style.cursor = link ? _lib.POINTER : 'default';
    } else {
      chart.getFromEnv('paper').canvas.style.cursor = link ? _lib.HAND : 'default';
    }
  };
  /**
   * function to create chart level containers
   */


  MSCartesian.prototype._createLayers = function _createLayers() {
    var iapi = this,
        parentGroup,
        paper = iapi.getFromEnv('paper');
    //* **** Create elements or components required for drawing

    // create elements if they are not available
    parentGroup = iapi.getContainer('parentgroup') || iapi.addContainer('parentgroup', paper.group('parentgroup'));
    !iapi.getContainer('backgroundGroup') && iapi.addContainer('backgroundGroup', paper.group('background', parentGroup));

    !iapi.getChildContainer('axisBottomGroup') && iapi.addChildContainer('axisBottomGroup', paper.group('axisbottom', parentGroup));

    !iapi.getChildContainer('belowPlotGroup') && iapi.addChildContainer('belowPlotGroup', paper.group('belowplot', parentGroup));

    !iapi.getChildContainer('lowerAnnotationGroup') && iapi.addChildContainer('lowerAnnotationGroup', paper.group('lowerannotations', iapi.getChildContainer('belowPlotGroup')));

    !iapi.getChildContainer('plotGroup') && iapi.addChildContainer('plotGroup', paper.group('plots', parentGroup));

    !iapi.getChildContainer('abovePlotGroup') && iapi.addChildContainer('abovePlotGroup', paper.group('aboveplot', parentGroup));

    !iapi.getChildContainer('upperAnnotationGroup') && iapi.addChildContainer('upperAnnotationGroup', paper.group('upperannotations', iapi.getChildContainer('abovePlotGroup')));

    !iapi.getChildContainer('axisTopGroup') && iapi.addChildContainer('axisTopGroup', paper.group('axistop', parentGroup));

    !iapi.getChildContainer('sumLabelsLayer') && iapi.addChildContainer('sumLabelsLayer', paper.group('sumlabels', parentGroup).attr('class', 'fusioncharts-datalabels'));

    !iapi.getChildContainer('datalabelsGroup') && iapi.addChildContainer('datalabelsGroup', paper.group('datalabel', parentGroup));

    !iapi.getChildContainer('legendGroup') && iapi.addChildContainer('legendGroup', paper.group('legend', parentGroup));

    !iapi.getChildContainer('captionGroup') && iapi.addChildContainer('captionGroup', paper.group('caption', parentGroup)) /* .trackTooltip(true) */;

    !iapi.getChildContainer('defaultGroup') && iapi.addChildContainer('defaultGroup', paper.group('chartdefault', parentGroup));

    !iapi.getChildContainer('defaultShadowGroup') && iapi.addChildContainer('defaultShadowGroup', paper.group('chartdefault-shadow', parentGroup));

    !iapi.getChildContainer('trackerGroup') && iapi.addChildContainer('trackerGroup', paper.group('tracker', parentGroup)) /* .trackTooltip(true) */;

    !iapi.getChildContainer('buttonGroup') && iapi.addChildContainer('buttonGroup', paper.group('buttons'));
  };
  /**
   * function to parse label css and apply
   */


  MSCartesian.prototype._setDataLabelStyle = function _setDataLabelStyle() {
    var iapi = this,
        style = iapi.config.dataLabelStyle,
        labelCSS = {
      fontFamily: style.fontFamily,
      fontSize: style.fontSize,
      fontWeight: style.fontWeight,
      fontStyle: style.fontStyle
    },
        datalabelsGroup = iapi.getChildContainer('datalabelsGroup');
    datalabelsGroup.css(labelCSS);
  };
  /**
   * function to calculate caption width and hieght
   */


  MSCartesian.prototype._manageCaptionPosition = function _manageCaptionPosition() {
    var iapi = this,
        caption = iapi.getChildren('caption')[0];

    caption.managePosition();
  };
  /**
   * *@TODO have to reallocate this code for a specific chart type where legend is needed
   * function to draw and hide legend as per need
   */


  MSCartesian.prototype.drawLegend = function drawLegend() {
    var iapi = this,
        legend = iapi.getFromEnv('legend'),
        gLegend = iapi.components.gradientLegend,
        hasLegend = iapi.hasLegend,
        drawGradientLegend = iapi.config.gLegendEnabled;

    if (drawGradientLegend) {
      if (legend) {
        legend.hide();
      }
      iapi.drawGradientLegend && iapi.drawGradientLegend();
    } else {
      if (gLegend) {
        gLegend.elem && gLegend.elem.gl.carpet && gLegend.elem.gl.carpet.node && gLegend.elem.gl.carpet.group.hide();
      }
      hasLegend !== false && legend.drawLegend();
    }
  };
  /**
   * Draws the gradient legend component
   */


  MSCartesian.prototype.drawGradientLegend = function drawGradientLegend() {
    var iapi = this,
        components = iapi.components,
        config = iapi.config,
        colorRangeObj = iapi.jsonData.colorrange,
        gradientLegend = components.gradientLegend || {},
        conf = gradientLegend.conf || {},
        legendPosition = conf.legendPosition,
        canvasLeft = config.canvasLeft,
        canvasTop = config.canvasTop,
        canvasWidth = config.canvasWidth,
        canvasHeight = config.canvasHeight,
        marginBottom = config.marginBottom,
        marginRight = config.marginRight,
        hasGradientLegend = iapi.hasGradientLegend,
        spaceTakenByGradientLegend,
        spaceLeft,
        width,
        height,
        xPos,
        yPos;

    spaceTakenByGradientLegend = gradientLegend.getLogicalSpace();
    width = spaceTakenByGradientLegend.width;
    height = spaceTakenByGradientLegend.height;
    if (legendPosition === _lib.POSITION_BOTTOM) {
      spaceLeft = canvasWidth - width;
      xPos = canvasLeft + (spaceLeft < 0 ? 0 : spaceLeft / 2);
      yPos = config.height - spaceTakenByGradientLegend.height - marginBottom - (config.actionBarHeight || 0);
    } else {
      spaceLeft = canvasHeight - height;
      yPos = canvasTop + (spaceLeft < 0 ? 0 : spaceLeft / 2);
      xPos = config.width - spaceTakenByGradientLegend.width - marginRight;
    }
    colorRangeObj && hasGradientLegend && gradientLegend.draw(xPos, yPos, {
      paper: iapi.getFromEnv('paper'),
      parentGroup: iapi.getContainer('parentgroup')
    });
  };
  /**
   * draw logoImage logo url is given and fire various events
   */


  MSCartesian.prototype._drawLogo = function _drawLogo() {
    var iapi = this,
        paper = iapi.getFromEnv('paper'),
        config = iapi.config,
        chartBorderWidth = config.borderWidth || 0,
        chartHeight = config.height,
        chartWidth = config.width,
        logoImages = iapi.getGraphicalElement('logoImage'),
        chartLogoImage = logoImages && logoImages[0],
        logoURL = config.logoURL,
        logoAlpha = config.logoAlpha / 100,
        logoPositionSTR = config.logoPosition,
        logoLink = config.logoLink,
        logoScale = config.logoScale,

    // logoLeftMargin = config.logoLeftMargin,
    // logoTopMargin = config.logoTopMargin,
    eventLen,
        eventI,


    // animationObj = iapi.get(configStr, animationObjStr),
    // animType = animationObj.animType,
    // animObj = animationObj.animObj,
    // dummyObj = animationObj.dummyObj,
    // animationDuration = animationObj.duration,

    position = {
      tr: {
        vAlign: _lib.POSITION_TOP,
        hAlign: _lib.POSITION_RIGHT
      },
      bl: {
        vAlign: _lib.POSITION_BOTTOM,
        hAlign: _lib.POSITION_LEFT
      },
      br: {
        vAlign: _lib.POSITION_BOTTOM,
        hAlign: _lib.POSITION_RIGHT
      },
      cc: {
        vAlign: _lib.POSITION_MIDDLE,
        hAlign: _lib.POSITION_MIDDLE
      }
    },
        dataArr = [],
        logoImageAttr,
        logoPosition;

    if (logoURL) {
      logoPosition = position[logoPositionSTR];
      if (!logoPosition) {
        logoPosition = {
          vAlign: _lib.POSITION_TOP,
          hAlign: _lib.POSITION_LEFT
        };
      }

      if (!chartLogoImage) {
        chartLogoImage = paper.image();
        iapi.addGraphicalElement('logoImage', chartLogoImage);
      }

      // chartLogoImage.animateWith(dummyObj, animObj, {
      //   opacity: 0
      // }, animationDuration, animType, function () {
      //   chartLogoImage.attr('src', logoURL);
      //   chartLogoImage.translate(logoLeftMargin, logoTopMargin);
      // }, {
      //   start: 0,
      //   end: 0.5
      // });

      chartLogoImage.on('load', function () {
        chartLogoImage.show();

        logoImageAttr = (0, _lib.setImageDisplayMode)(NONE, logoPosition.vAlign, logoPosition.hAlign, logoScale, chartBorderWidth, chartWidth, chartHeight, chartLogoImage._.RefImg);

        /*
         * In VML, RedRphael looks for attribute 'w' & 'h' instead of width and height. As
         * same type of rendering is also used for background image but the issue could not be
         * replicated for bgImage, it is best to keep this small change tied to logo image only.
         */
        if (isVML) {
          logoImageAttr.w = logoImageAttr.width || 0;
          logoImageAttr.h = logoImageAttr.height || 0;
        }

        iapi.getFromEnv('animationManager').registerAnimation([{
          animType: 'easeOut',
          data: dataArr
        }], 'final');

        // chartLogoImage.animateWith(dummyObj, animObj, logoImageAttr,
        // animationDuration, animType, null, {
        //   start: 0.51,
        //   end: 0.52
        // });

        // chartLogoImage.animateWith(dummyObj, animObj, {
        //   opacity: logoAlpha
        // }, animationDuration, animType, null, {
        //   start: 0.52,
        //   end: 1
        // });

        // raise event of logo load
        /**
         * This event is fired when external logo added to the chart using `logoURL` attribute has
         * finished loading.
         *
         * To know more about external logos, see
         * {@tutorial configuring-your-chart-loading-external-logos}
         *
         * @see FusionCharts#event:logoRollover
         * @see FusionCharts#event:logoRollout
         * @see FusionCharts#event:logoClick
         * @see FusionCharts#event:logoLoadError
         *
         * @event FusionCharts#logoLoaded
         * @group chart:logo
         * @tutorial configuring-your-chart-loading-external-logos
         *
         * @param {string} logoURL - is the URL of the logo image.
         * @param {number} logoAlpha - is the value of the alpha
         *                 of the logo image.
         * @param {string} logoPosition - is the position of the chart
         *                  logo.
         * @param {number} logoScale - is the value of scaling for
         *                 logo image.
         * @param {string} logoLink - is the URL linked to the logo
         *                 which on clicking will be taken to the
         *                 URL link.
         */
        (0, _eventApi.triggerEvent)(LOGOLOADED, iapi.chartInstance, {
          logoURL: logoURL,
          logoAlpha: logoAlpha * 100,
          logoPosition: logoPositionSTR || TL,
          logoScale: logoScale,
          logoLink: logoLink
        });
      });

      chartLogoImage.on('error', function (e) {
        /**
         * This event is fired when there was an error in loading external logo added to the chart
         * using `logoURL` attribute.
         *
         * To know more about external logos, see
         * {@tutorial configuring-your-chart-loading-external-logos}
         *
         * @see FusionCharts#event:logoRollover
         * @see FusionCharts#event:logoRollout
         * @see FusionCharts#event:logoClick
         * @see FusionCharts#event:logoLoaded
         *
         * @event FusionCharts#logoLoadError
         * @group chart:logo
         * @tutorial configuring-your-chart-loading-external-logos
         *
         * @param {string} logoURL - is the URL of the logo image.
         * @param {number} logoAlpha - is the value of the alpha of the logo image.
         * @param {string} logoPosition - is the position of the chart logo.
         * @param {number} logoScale - is the value of scaling for logo image.
         * @param {string} logoLink - is the URL linked to the logo which on clicking will be taken to
         * the URL link.
         * @param {string} error - is the error message.
         */
        (0, _eventApi.triggerEvent)(LOGOLOADERROR, iapi.chartInstance, {
          logoURL: logoURL,
          logoAlpha: logoAlpha * 100,
          logoPosition: logoPositionSTR || TL,
          logoScale: logoScale,
          logoLink: logoLink,
          error: e
        });
      });

      if (logoLink) {
        chartLogoImage.css({
          cursor: _lib.POINTER,
          '_cursor': _lib.HAND
        });
      } else {
        chartLogoImage.css({
          cursor: 'default',
          '_cursor': NORMAL
        });
      }

      // unbind events during update
      if (chartLogoImage.events && chartLogoImage.events.length) {
        for (eventI = 0, eventLen = chartLogoImage.events.length; eventI < eventLen; eventI++) {
          chartLogoImage.events[eventI].unbind();
          chartLogoImage.events.splice(eventI, 1);
          eventLen -= 1;
          eventI -= 1;
        }
      }

      // create event for LogoClick, LogoRollover & LogoRollout
      chartLogoImage.mouseover(function (e) {
        var cord = (0, _lib.getMouseCoordinate)(iapi.chartInstance.ref, e);

        /**
         * This event is fired when the mouse is hovered over external logo added to the chart using
         * `logoURL` attribute.
         *
         * To know more about external logos, see
         * {@tutorial configuring-your-chart-loading-external-logos}
         *
         * @see FusionCharts#event:logoRollout
         * @see FusionCharts#event:logoClick
         * @see FusionCharts#event:logoLoaded
         * @see FusionCharts#event:logoLoadError
         *
         * @event FusionCharts#logoRollover
         * @group chart:logo
         * @tutorial configuring-your-chart-loading-external-logos
         *
         * @param {string} logoURL - The URL of the logo image.
         * @param {number} logoAlpha - The value of the alpha
         *                 of the logo image.
         * @param {string} logoPosition - The position of the
         *                 logo.
         * @param {number} logoScale - The value of scaling of
         *                  the logo image.
         * @param {string} logoLink - The URL linked to the logo
         *               which on clicking will be taken to the
         *               URL link.
         * @param {number} chartX - The relative X-Cordinate
         *                 to screen where the mouse was
         *                 hovered over the logo.
         * @param {number} chartY - The relative Y-Cordinate
         *                 to screen where the mouse was
         *                 hovered over the logo.
         * @param {number} pageX - The relative Y-Cordinate
         *                 to screen where the mouse was
         *                 hovered over the logo.
         * @param {number} pageY - The relative Y-Cordinate
         *                 to screen where the mouse was
         *                 hovered over the logo.
         */
        (0, _eventApi.triggerEvent)(LOGOROLLOVER, iapi.chartInstance, {
          logoURL: logoURL,
          logoAlpha: logoAlpha * 100,
          logoPosition: logoPositionSTR || TL,
          logoScale: logoScale,
          logoLink: logoLink,
          chartX: cord.chartX,
          chartY: cord.chartY,
          pageX: cord.pageX,
          pageY: cord.pageY
        });
      });
      chartLogoImage.mouseout(function (e) {
        var cord = (0, _lib.getMouseCoordinate)(iapi.chartInstance.ref, e);
        // raise event of logo load
        /**
         * This event is fired when the mouse is moved outside external logo added to the chart
         * using `logoURL` attribute.
         *
         * To know more about external logos, see
         * {@tutorial configuring-your-chart-loading-external-logos}
         *
         * @see FusionCharts#event:logoRollover
         * @see FusionCharts#event:logoClick
         * @see FusionCharts#event:logoLoaded
         * @see FusionCharts#event:logoLoadError
         *
         * @event FusionCharts#logoRollout
         * @group chart:logo
         * @tutorial configuring-your-chart-loading-external-logos
         *
         * @param {string} logoURL - The URL of the logo image.
         * @param {number} logoAlpha - The value of the alpha
         *                 of the logo image.
         * @param {string} logoPosition - The position of the
         *                 logo.
         * @param {string} logoScale - The value of scaling for
         *                  logo image.
         * @param {string} logoLink - The URL linked to the
         *                 logo which on clicking will be taken
         *                 to the URL link.
         * @param {number} chartX - The relative X-Cordinate
         *                 to screen where the mouse was
         *                 hovered out of logo image.
         * @param {number} chartY - The relative Y-Cordinate
         *                 to screen where the mouse was
         *                 hovered out of the logo image.
         * @param {number} pageX - The relative Y-Cordinate
         *                 to screen where the mouse was
         *                 hovered out of the logo image.
         * @param {number} pageY - The relative Y-Cordinate
         *                 to screen where the mouse was
         *                 hovered out of the logo image.
         */
        (0, _eventApi.triggerEvent)(LOGOROLLOUT, iapi.chartInstance, {
          logoURL: logoURL,
          logoAlpha: logoAlpha * 100,
          logoPosition: logoPositionSTR || TL,
          logoScale: logoScale,
          logoLink: logoLink,
          chartX: cord.chartX,
          chartY: cord.chartY,
          pageX: cord.pageX,
          pageY: cord.pageY
        });
      });
      chartLogoImage.click(function (e) {
        var cord = (0, _lib.getMouseCoordinate)(iapi.chartInstance.ref, e);

        /**
         * This event is fired when the mouse is clicked on external logo added to the chart using
         * `logoURL` attribute. For touch devices, this event is fired when user taps on the logo.
         *
         * To know more about external logos, see
         * {@tutorial configuring-your-chart-loading-external-logos}
         *
         * @see FusionCharts#event:logoRollover
         * @see FusionCharts#event:logoRollout
         * @see FusionCharts#event:logoLoaded
         * @see FusionCharts#event:logoLoadError
         *
         * @event FusionCharts#logoClick
         * @group chart:logo
         * @tutorial configuring-your-chart-loading-external-logos
         *
         * @param {string} logoURL - The URL of the logo image.
         * @param {number} logoAlpha - The value of the alpha of the logo image.
         * @param {string} logoPosition - The position of the position of the logo.
         * @param {number} logoScale - The value of scaling for logo image.
         * @param {string} logoLink - The URL linked to the logo which on clicking will be taken to
         * the URL link.
         * @param {number} chartX - The relative X-Cordinate to screen where the mouse was hovered
         * out of the chart logo.
         * @param {number} chartY - The relative Y-Cordinate to screen where the mouse was hovered
         * out of the chart logo.
         * @param {number} pageX - The relative Y-Cordinate to screen where the mouse was hovered
         * out of the chart logo.
         * @param {number} pageY - is the relative Y-Cordinate to screen where the mouse was hovered
         * out of the chart logo.
         */
        (0, _eventApi.triggerEvent)(LOGOCLICK, iapi.chartInstance, {
          logoURL: logoURL,
          logoAlpha: logoAlpha * 100,
          logoPosition: logoPositionSTR || TL,
          logoScale: logoScale,
          logoLink: logoLink,
          chartX: cord.chartX,
          chartY: cord.chartY,
          pageX: cord.pageX,
          pageY: cord.pageY
        }, _lib.UNDEF, function () {
          logoLink && iapi.getFromEnv('linkClickFN').call({
            link: logoLink
          }, iapi);
        });
      });
    } else {
      if (chartLogoImage) {
        dataArr.push({
          callback: function callback() {
            chartLogoImage.hide();
          },
          el: chartLogoImage,
          attrs: {
            opacity: 0
          },
          animConfig: [{
            syncWith: 'initial'
          }]
        });
      }
    }
    iapi.getFromEnv('animationManager').registerAnimation([{
      animType: 'easeOut',
      data: dataArr
    }], 'final');
  };
  /**
   * Dispose function of the chart API
   */


  MSCartesian.prototype._dispose = function _dispose() {
    this._clearTimers && this._clearTimers();
    _BaseChart.prototype._dispose.call(this);
  };
  /**
   * function to handle draw related job of various components
   * this function call draw of all the components which are child of the chart components
   */


  MSCartesian.prototype._updateVisuals = function _updateVisuals() {
    var iapi = this,
        container = iapi.getFromEnv('chart-container'),
        coreOptions = iapi.getFromEnv('core-options'),
        annotation = iapi.getChildren('annotation'),
        paper = iapi.getFromEnv('paper'),

    // tooltip = components.tooltip,
    // animationObj = iapi.get(configStr, animationObjStr),
    animType = 'linear',
        canvas,
        config = iapi.config,

    // animationStarted,
    prevWidth = config.prevWidth,
        prevHeight = config.prevHeight,

    // fireCallBack = iapi.fireCallBack,
    dataSets,
        i,
        length,
        attr;

    config.animationStarted = true;

    // In FC user can set the global core option SVGDefinitionURL as 'absolute' to make all definations in absolute URL.
    // This fix some issues in some browsers.
    // As FusionCharts.js is independent of Redraphael and this is the forst place where RedRaphael is getting used, we are configuring this attribute here.
    if (coreOptions && !coreOptions._SVGDefinitionURLUpdated) {
      if (/^\s*absolute\s*$/i.test(coreOptions.SVGDefinitionURL)) {
        // Assign the URL in R._url so that it uses that url only for the SVG definition.
        _redraphael2['default']._url = (_redraphael2['default']._g && _redraphael2['default']._g.win || window).location.href.replace(/#.*?$/, _lib.BLANKSTRING);
      }
      // Mart a flag so that we only execute this for the first time.
      coreOptions._SVGDefinitionURLUpdated = true;
    }
    if (!paper) {
      paper = new _redraphael2['default'](container, container.offsetWidth, container.offsetHeight);
      iapi.addToEnv('paper', paper);
      paper.setConfig('stroke-linecap', _lib.ROUND);
    } else {
      // Fix for IE8 paper animation.
      if (prevWidth || prevHeight) {
        paper.setSize(prevWidth, prevHeight);
      }
      attr = {
        width: container.offsetWidth,
        height: container.offsetHeight
      };
      // animationStarted = true;
      // iapi._chartAnimation(true, fireCallBack);
      // paper.animateWith(dummyObj, animObj, attr, animationDuration, animType);
      iapi.getFromEnv('animationManager').registerAnimation([{
        animType: animType,
        data: [{
          el: paper,
          attrs: attr
        }]
      }], 'default');
    }

    config.prevWidth = container.offsetWidth;
    config.prevHeight = container.offsetHeight;

    // Setting tooltip style
    // paper.tooltip(tooltip.style, tooltip.config.shadow, tooltip.config.constrain);
    // Setting the cursor in case of chart link
    iapi.setChartCursor();
    // create drawing layers
    iapi._createLayers();
    // Set style for dataLabels
    iapi._setDataLabelStyle();
    // Start the chart animation
    // !animationStarted && iapi._chartAnimation(true, fireCallBack);
    // draw components
    iapi._drawBackground();

    if (annotation) {
      annotation[0].addToEnv('paper', paper);
      annotation[0].addToEnv('smartLabel', iapi.getFromEnv('smartLabel'));
      annotation[0].addToEnv('lowerAnnotationGroup', iapi.getChildContainer('lowerAnnotationGroup'));
      annotation[0].addToEnv('upperAnnotationGroup', iapi.getChildContainer('upperAnnotationGroup'));
      annotation[0].draw();
    }

    // iapi._draw3Dcanvas && iapi._draw3Dcanvas ();
    // draw the chartMenu bar
    // @todo Remove this check once toolbox resize is fixed
    iapi.getChildren('chartMenuBar') && iapi._drawChartMenuBar();

    iapi._manageCaptionPosition();
    // iapi._drawCaption ();
    iapi.getChildren('caption') && iapi.getChildren('caption')[0].syncDraw();

    iapi.drawLegend();

    iapi.getChildren('actionBar') && iapi.drawActionBar();
    iapi._drawAxis && iapi._drawAxis();

    if (iapi.hasCanvas !== false) {
      canvas = iapi.getChildren('canvas');
      canvas[0].syncDraw();
      canvas[1] && canvas[1].syncDraw();
    }

    if (dataSets = iapi.getChildren('dataset')) {
      for (i = 0, length = dataSets.length; i < length; i++) {
        dataSets[i].syncDraw();
      }
    }
    iapi._drawCreditLabel();
    iapi._drawLogo();

    iapi.drawAxisUpdateUI && iapi.drawAxisUpdateUI();

    // re-draw the message logger, if that is already drawn
    if (iapi.getChildren('messageLogger') && iapi.getChildren('messageLogger')[0].isDrawn()) {
      iapi.getChildren('messageLogger')[0].draw();
    }

    iapi.drawScrollBar && iapi.drawScrollBar();
    if (iapi.showRTvalue && config.realTimeConfig.showRTValue) {
      iapi._drawRealTimeValue();
    }
  };
  /**
   * function to draw chart menu bar
   */


  MSCartesian.prototype._drawChartMenuBar = function _drawChartMenuBar() {
    var iapi = this,
        chartMenuBar = iapi.getChildren('chartMenuBar'),
        logicalSpace = chartMenuBar.getLogicalSpace(),
        toolbarConfig = chartMenuBar.toolbarConfig,
        btnConfig = chartMenuBar.componentGroups[0].btnConfig,
        vDirection = btnConfig.vDirection,
        hDirection = btnConfig.hDirection,
        y = btnConfig.y,
        x = btnConfig.x;
    toolbarConfig.fill = TRACKER_FILL;
    toolbarConfig.borderColor = TRACKER_FILL;
    if (btnConfig.spaceNotHardCoded) {
      y += btnConfig.vMargin * vDirection + mathMin(0, logicalSpace.height * vDirection);
      x += btnConfig.hMargin * hDirection - mathMax(0, logicalSpace.width * hDirection);
      chartMenuBar.draw(btnConfig.hAlign === 'l' ? x + logicalSpace.width : x - logicalSpace.width, y);
    } else {
      chartMenuBar.draw(x, y);
    }

    chartMenuBar.drawn = true;
  };
  /**
   * function to manage all draw draw related jobList
   * this function handle all the draw related jobs like space management,
   * post space management and draw
   */


  MSCartesian.prototype.draw = function draw() {
    var iapi = this,
        chartObj = iapi.chartInstance,
        container = iapi.getFromEnv('chart-container');

    // set the charts width and height in the env
    iapi.addToEnv('chartWidth', container.offsetWidth);
    iapi.addToEnv('chartHeight', container.offsetHeight);

    if (iapi.config.hasChartMessage) {
      iapi._hide();
      iapi.drawChartMessage();
      (0, _eventApi.triggerEvent)('nodatatodisplay', chartObj, {}, [chartObj.id]);
      iapi.chartInstance.jsVars.drawCount += 1;
      iapi.chartInstance.__state.dataReady = false;
      iapi.chartInstance.jsVars.hasNativeMessage = true;
    } else {
      iapi._hideChartMessage();
      iapi._clearTimers && iapi._clearTimers();

      iapi.config.plotOverFlow = false;
      // show the chart if hidden
      iapi._show();

      // do the final calculations before drawing
      iapi._preDraw();
      // create any scroll elements if any.
      iapi._createToolBox();
      // if api has function to add Toolbar; call it
      iapi.addToolbar && iapi.addToolbar();
      // allocate space to all components
      iapi._manageSpace();
      // after space allocation provide final positions to all components
      iapi._postSpaceManagement();
      // draw elements finally
      iapi._updateVisuals();
      iapi.inited = true;
      iapi.chartInstance.jsVars.drawCount += 1;
      iapi.chartInstance.jsVars.hasNativeMessage = false;
    }
  };
  /**
   * function to draw axis and scale based on the availablity
   */


  MSCartesian.prototype._drawAxis = function _drawAxis() {
    var iapi = this,
        yAxisArr = iapi.getChildren('yAxis') || [],
        xAxisArr = iapi.getChildren('xAxis') || [],
        scale = iapi.getChildren('scale') && iapi.getChildren('scale')[0],
        i,
        len;
    for (i = 0, len = xAxisArr.length; i < len; i++) {
      xAxisArr[i].syncDraw();
    }
    for (i = 0, len = yAxisArr.length; i < len; i++) {
      !yAxisArr[i].getState('removed') && yAxisArr[i].syncDraw();
    }
    scale && scale.syncDraw();
  };
  /**
   * function to set visiblity true for parentgroup container of chart
   */


  MSCartesian.prototype._show = function _show() {
    this.getContainer('parentgroup') && this.getContainer('parentgroup').show();
  };
  /**
   * *@TODO validate after tooltip module working state
   */
  // _setToolTipOptions () {
  // @TODO uncomment this code after validating
  // var iapi = this,
  //   colorM = iapi.getFromEnv('color-manager'),
  //   chartAttrs = iapi.getFromEnv('chart-attrib'),
  //   tooltip,
  //   config,
  //   chartStyle = iapi.getFromEnv('style'),
  //   inCanvasStyle = chartStyle.inCanvasStyle,
  //   style,
  //   backgroundColor,
  //   borderColor,
  //   borderWidth,
  //   padding;
  //
  // // tooltip = components.tooltip || (tooltip = components.tooltip = { });
  // config = tooltip.config || (config = tooltip.config = { });
  //
  // backgroundColor = convertColor(pluck(chartAttrs.tooltipbgcolor,
  //           colorM.getColor('toolTipBgColor')), pluck(chartAttrs.tooltipbgalpha, 100));
  // borderColor = convertColor(pluck(chartAttrs.tooltipbordercolor,
  //           colorM.getColor('toolTipBorderColor')), pluck(chartAttrs.tooltipborderalpha, 100));
  // borderWidth = pluckNumber(chartAttrs.tooltipborderthickness, 1) + 'px';
  //
  // padding = pluckNumber(chartAttrs.tooltippadding, 3) + 'px';
  //
  // style = tooltip.style = {
  //   fontFamily: chartStyle.inCanfontFamily,
  //   fontSize: chartStyle.inCanfontSize,
  //   lineHeight: inCanvasStyle.lineHeight,
  //   color: convertColor(chartStyle.inCancolor),
  //   backgroundColor: backgroundColor,
  //   borderColor: borderColor,
  //   borderWidth: borderWidth,
  //   padding: padding
  // };
  //
  // if (chartAttrs.tooltipcolor) {
  //   style.color = getFirstColor(chartAttrs.tooltipcolor);
  // }
  //
  // if (chartAttrs.tooltipborderradius || chartAttrs.useroundedges) {
  //   style.borderRadius = pluckNumber(chartAttrs.tooltipborderradius, 2) + 'px';
  // }
  //
  // config.shadow = pluckNumber(chartAttrs.showtooltipshadow, chartAttrs.showshadow, 1) ? {
  //   enabled: true,
  //   opacity: mathMax(pluckNumber(chartAttrs.tooltipbgalpha, 100),
  //               pluckNumber(chartAttrs.tooltipborderalpha, 100)) / 100
  // } : false;
  //
  // config.constrain = pluckNumber(chartAttrs.constraintooltip, 1);
  // }

  /**
   * function to parse canvas cosmetics.
   */


  MSCartesian.prototype._parseCanvasCosmetics = function _parseCanvasCosmetics() {
    var canvasBorderThickness,
        canBGAlpha,
        showCanvasBorder,
        shadow,
        iapi = this,
        config = iapi.config,
        canvasConfig = iapi.getChildren('canvas')[0].config,
        chartAttrs = iapi.jsonData.chart,
        colorM = iapi.getFromEnv('color-manager'),
        is3D = iapi.is3D,
        oriCanvasBorderThickness,
        palleteString = is3D ? _lib.chartPaletteStr.chart3D : _lib.chartPaletteStr.chart2D,
        isRoundEdges = canvasConfig.isRoundEdges = (0, _lib.pluckNumber)(chartAttrs.useroundedges, 0),
        showAxisLine = (0, _lib.pluckNumber)(chartAttrs.showxaxisline, chartAttrs.showyaxisline, chartAttrs.showaxislines, 0),
        hideAxisLine = showAxisLine ? 0 : 1;

    canvasConfig.canvasBorderRadius = (0, _lib.pluckNumber)(chartAttrs.plotborderradius, isRoundEdges ? 2 : 0);

    showCanvasBorder = canvasConfig.showCanvasBorder = Boolean((0, _lib.pluckNumber)(chartAttrs.showcanvasborder, hideAxisLine, canvasBorderThickness, isRoundEdges ? 0 : 1));

    // Storing original canvasBorderThickness for future reference
    oriCanvasBorderThickness = canvasConfig.oriCanvasBorderThickness = mathMax((0, _lib.pluckNumber)(chartAttrs.canvasborderthickness, isRoundEdges ? 0 : (0, _lib.pluckNumber)(iapi.canvasborderthickness, 2), 0));

    canvasBorderThickness = canvasConfig.canvasBorderWidth = iapi.is3D ? 0 : showCanvasBorder ? oriCanvasBorderThickness : 0;

    canvasConfig.canvasBorderColor = (0, _lib.convertColor)((0, _lib.pluck)(chartAttrs.canvasbordercolor, colorM.getColor(_lib.canvasBorderColorStr)), (0, _lib.pluck)(chartAttrs.canvasborderalpha, colorM.getColor('canvasBorderAlpha')));
    canBGAlpha = canvasConfig.canBGAlpha = (0, _lib.pluck)(chartAttrs.canvasbgalpha, colorM.getColor(_lib.canvasBGAlphaStr));

    canvasConfig.canBGColor = {
      FCcolor: {
        color: (0, _lib.pluck)(chartAttrs.canvasbgcolor, colorM.getColor(palleteString.canvasBgColor)),
        alpha: (0, _lib.pluck)(chartAttrs.canvasbgalpha, 100),
        angle: (0, _lib.pluck)(chartAttrs.canvasbgangle, 0),
        ratio: (0, _lib.pluck)(chartAttrs.canvasbgratio)
      }
    };

    shadow = canvasConfig.shadow = (0, _lib.pluckNumber)(chartAttrs.showshadow, isRoundEdges, 0) && isRoundEdges ? {
      enabled: true,
      opacity: canBGAlpha / 100
    } : 0;
    canvasConfig.shadowOnCanvasFill = shadow && shadow.enabled;

    // borderThickness = pluckNumber(chartAttrs.showborder, 1) ? pluckNumber(chartAttrs.borderthickness, 1) : 0;
    // chart margins
    config.origMarginTop = (0, _lib.pluckNumber)(chartAttrs.charttopmargin, 15);
    config.origMarginLeft = (0, _lib.pluckNumber)(chartAttrs.chartleftmargin, 15);
    config.origMarginBottom = (0, _lib.pluckNumber)(chartAttrs.chartbottommargin, 15);
    config.origMarginRight = (0, _lib.pluckNumber)(chartAttrs.chartrightmargin, 15);

    config.origCanvasLeftMargin = (0, _lib.pluckNumber)(chartAttrs.canvasleftmargin, 0);
    config.origCanvasRightMargin = (0, _lib.pluckNumber)(chartAttrs.canvasrightmargin, 0);
    config.origCanvasTopMargin = (0, _lib.pluckNumber)(chartAttrs.canvastopmargin, 0);
    config.origCanvasBottomMargin = (0, _lib.pluckNumber)(chartAttrs.canvasbottommargin, 0);

    // canvas padding
    canvasConfig.canvasPadding = (0, _lib.pluckNumber)(chartAttrs.canvaspadding, 0);

    canvasConfig.origCanvasTopPad = (0, _lib.pluckNumber)(chartAttrs.canvastoppadding, 0);
    canvasConfig.origCanvasBottomPad = (0, _lib.pluckNumber)(chartAttrs.canvasbottompadding, 0);
    canvasConfig.origCanvasLeftPad = (0, _lib.pluckNumber)(chartAttrs.canvasleftpadding, 0);
    canvasConfig.origCanvasRightPad = (0, _lib.pluckNumber)(chartAttrs.canvasrightpadding, 0);
  };
  /**
   * function to calculate actionBar height
   * @return {bottom} conyains bottom with actionBar height
   */


  MSCartesian.prototype._manageActionBarSpace = function _manageActionBarSpace() {
    var iapi = this,
        config = iapi.config,
        components = iapi.getChildren(),
        actionBar = components.actionBar,

    // chartMenuBar = components.chartMenuBar,
    // chartMenuLogicalSpace = chartMenuBar.getLogicalSpace() || {},
    actionBarSpace = actionBar && actionBar.getLogicalSpace() || {},
        actionBarHeight = actionBarSpace.height || 0;
    config.actionBarHeight = actionBarHeight;
    return {
      bottom: actionBarHeight
    };
  };
  /**
   * function to parse background cosmetics.
   */


  MSCartesian.prototype._parseBackgroundCosmetics = function _parseBackgroundCosmetics() {
    var iapi = this,
        is3D = iapi.is3D,
        background = iapi.getChildren('background')[0],
        config = background.config,
        colorM = iapi.getFromEnv('color-manager'),
        chartAttrs = iapi.jsonData.chart,
        showBorder;
    showBorder = config.showBorder = (0, _lib.pluckNumber)(chartAttrs.showborder, iapi.showBorder, is3D ? 0 : 1);
    config.borderWidth = mathMax(showBorder ? (0, _lib.pluckNumber)(chartAttrs.borderthickness, 1) : 0, 0);
    // chartBorderWidth = config.borderWidth = pluckNumber (chartAttrs.borderwidth, 1),
    config.borderRadius = config.borderRadius = (0, _lib.pluckNumber)(chartAttrs.borderradius, 0);
    config.borderDashStyle = config.borderDashStyle = (0, _lib.pluckNumber)(chartAttrs.borderdashed, 0) ? (0, _lib.getDashStyle)((0, _lib.pluckNumber)(chartAttrs.borderdashlen, 4), (0, _lib.pluckNumber)(chartAttrs.borderdashgap, 2)) : _lib.DASH_DEF;
    config.borderAlpha = (0, _lib.pluck)(chartAttrs.borderalpha, is3D ? '100' : colorM && colorM.getColor('borderAlpha'));
    config.borderColor = config.borderColor = (0, _lib.convertColor)((0, _lib.pluck)(chartAttrs.bordercolor, is3D ? '#666666' : colorM && colorM.getColor('borderColor')), config.borderAlpha);
  };
  /**
   * function to set visiblity false for parentgroup container of chart
   */


  MSCartesian.prototype._hide = function _hide() {
    this.getContainer('parentgroup') && this.getContainer('parentgroup').hide();
  };
  /**
   * callBack function for animation for fire animationComplete internal event
   */


  MSCartesian.prototype._animCallBack = function _animCallBack() {
    var iapi = this,
        config = iapi.config;

    if (config.animationStarted) {
      (0, _eventApi.triggerEvent)('internal.animationComplete', iapi.chartInstance, {});
      config.animationStarted = false;
    }
  };

  /**
   * function for resetting animation duration
   */


  MSCartesian.prototype._setAnimDuration = function _setAnimDuration() {
    var iapi = this,
        config = iapi.config,
        animation = config.animationObj;
    animation && (animation.duration = animation.transposeAnimDuration);
  };

  /**
   * Triggers the mouse move event on the chart
   * @param  {Event} e The event object associated with the mouse move
   */


  MSCartesian.onContainerMouseMove = function onContainerMouseMove(e) {
    var chart = e.data,
        fusionCharts = chart.chartInstance,
        oriEvent = e.originalEvent,
        coordinate = (0, _lib.getMouseCoordinate)(chart.getFromEnv('chart-container'), oriEvent, chart),
        args;

    if (!fusionCharts.ref) {
      return;
    }

    args = (0, _lib.extend2)({
      height: fusionCharts.args.height,
      width: fusionCharts.args.width,
      pixelHeight: fusionCharts.ref.offsetHeight,
      pixelWidth: fusionCharts.ref.offsetWidth,
      id: fusionCharts.args.id,
      renderer: fusionCharts.args.renderer,
      container: fusionCharts.options.containerElement
    }, coordinate);

    /**
     * This event is triggered whenever user moves the mouse pointer over a chart. The event
     * arguments pass useful information such as the pointer location relative to both chart and the page,
     * which can be utilised to perform various actions on the chart such as position an annotation or
     * integrate charts with custom tooltip libraries.
     *
     * > This event is not fired by default and needs to be enabled for individual charts by setting the
     * > value of chart attribute `enableChartMouseMoveEvent` to `1`.
     *
     * @see FusionCharts#event:chartRollOver
     * @see FusionCharts#event:chartRollOut
     * @see FusionCharts#event:chartClick
     * @event FusionCharts#chartMouseMove
     * @since  3.4.0
     * @group chart
     *
     * @param {string} container - The DOM element within which the chart has been rendered.
     * @param {string} id - The `id` of the chart that has triggered this event.
     *
     * @param {string} height - The height of the chart specified at the time of rendering the chart in
     * pixels or percent.
     * @param {string} width - The width of the chart specified at the time of rendering the chart in pixels
     * or percent.
     *
     * @param {number} chartX - The x-coordinate of the mouse relative to the position of the chart.
     * @param {number} chartY - The y-coordinate of the mouse relative to the position of the chart.
     *
     * @param {number} pageX - The x-coordinate of the mouse relative to the document.
     * @param {number} pageY - The y-coordinate of the mouse relative to the document.
     *
     * @param {number} pixelHeight - The height of the chart in pixels. This is equivalent to the
     * `offsetHeight` of the chart container
     * @param {number} pixelWidth - The width of the chart in pixels. This is equivalent to the
     * `offsetWidth` of the chart container
     */
    (0, _eventApi.triggerEvent)('chartMouseMove', chart.chartInstance, args);
  };

  /**
   * Triggers the mouse roll over event on the chart
   * @param  {Event} e The event object associated with the mouse roll over
   */


  MSCartesian.onContainerRollOver = function onContainerRollOver(e) {
    var chart = e.data,
        fusionCharts = chart.chartInstance,
        oriEvent = e.originalEvent,
        coordinate = (0, _lib.getMouseCoordinate)(chart.getFromEnv('chart-container'), oriEvent, chart),
        args;

    if (!fusionCharts.ref) {
      return;
    }

    args = (0, _lib.extend2)({
      height: fusionCharts.args.height,
      width: fusionCharts.args.width,
      pixelHeight: fusionCharts.ref.offsetHeight,
      pixelWidth: fusionCharts.ref.offsetWidth,
      id: fusionCharts.args.id,
      renderer: fusionCharts.args.renderer,
      container: fusionCharts.options.containerElement
    }, coordinate);

    /**
     * This event is fired when the mouse pointer moves over the chart. For touch devices,
     * this event is raised when user taps on to the chart after previously tapping onto anywhere outside
     * the chart.
     *
     * One can listen to this event and track when user is pointing to a chart and perform relevant actions
     * such as highlighting information anywhere else on the page that is relevant to the chart.
     * @see FusionCharts#event:chartRollOut
     * @see FusionCharts#event:chartClick
     * @see FusionCharts#event:chartMouseMove
     * @event FusionCharts#chartRollOver
     * @since 3.4.0
     * @group chart
     *
     * @param {string} container - The DOM element within which the chart has been rendered.
     * @param {string} id - The `id` of the chart that has triggered this event.
     *
     * @param {string} height - The height of the chart specified at the time of rendering the chart in
     * pixels or percent.
     * @param {string} width - The width of the chart specified at the time of rendering the chart in pixels
     * or percent.
     *
     * @param {number} chartX - The x-coordinate of the mouse relative to the position of the chart.
     * @param {number} chartY - The y-coordinate of the mouse relative to the position of the chart.
     *
     * @param {number} pageX - The x-coordinate of the mouse relative to the document.
     * @param {number} pageY - The y-coordinate of the mouse relative to the document.
     *
     * @param {number} pixelHeight - The height of the chart in pixels. This is equivalent to the
     * `offsetHeight` of the chart container
     * @param {number} pixelWidth - The width of the chart in pixels. This is equivalent to the
     * `offsetWidth` of the chart container
     *
     * @example
     * // Create a chart and display the caption of the chart over which the mouse has been hovered. The
     * // event is attached to the FusionCharts global `addEventListener` function so that it is fired for
     * // all charts rendered on that page Once this event listener has been attached, any chart rendered on
     * // page will cause a console log when hovered or tapped.
     * FusionCharts.addEventListener('chartRollOver', function (event) {
     *     var chart = event.sender, // access the chart that raised this event
     *         caption = chart && chart.getChartAttribute(CAPTION); // get the chart caption
     *
     *     // Output the caption in JavaScript console
     *     console.log('Mouse entered on the chart with caption: ' + caption);
     * });
     */
    (0, _eventApi.triggerEvent)('chartRollOver', chart.chartInstance, args);
  };

  /**
   * Triggers the mouse roll out event on the chart
   * @param  {Event} e The event object associated with the mouse roll out
   */


  MSCartesian.onContainerRollOut = function onContainerRollOut(e) {
    var chart = e.chart,
        fusionCharts = chart.chartInstance,
        oriEvent = e.event,
        coordinate = (0, _lib.getMouseCoordinate)(chart.getFromEnv('chart-container'), oriEvent, chart),
        args;

    if (!fusionCharts.ref) {
      return;
    }

    args = (0, _lib.extend2)({
      height: fusionCharts.args.height,
      width: fusionCharts.args.width,
      pixelHeight: fusionCharts.ref.offsetHeight,
      pixelWidth: fusionCharts.ref.offsetWidth,
      id: fusionCharts.args.id,
      renderer: fusionCharts.args.renderer,
      container: fusionCharts.options.containerElement
    }, coordinate);

    /**
     * This event is fired when the mouse pointer moves out of the chart. For touch devices,
     * this event is raised when user taps on to anywhere outside the chart after previously tapping on the
     * chart.
     *
     * One can listen to this event and track when user is no longer pointing to a particular chart.
     * @see FusionCharts#event:chartRollOver
     * @see FusionCharts#event:chartClick
     * @see FusionCharts#event:chartMouseMove
     * @event FusionCharts#chartRollOut
     * @since 3.4.0
     * @group chart
     *
     * @param {string} container - The DOM element within which the chart has been rendered.
     * @param {string} id - The `id` of the chart that has triggered this event.
     *
     * @param {string} height - The height of the chart specified at the time of rendering the chart in
     * pixels or percent.
     * @param {string} width - The width of the chart specified at the time of rendering the chart in pixels
     * or percent.
     *
     * @param {number} chartX - The x-coordinate of the mouse relative to the position of the chart.
     * @param {number} chartY - The y-coordinate of the mouse relative to the position of the chart.
     *
     * @param {number} pageX - The x-coordinate of the mouse relative to the document.
     * @param {number} pageY - The y-coordinate of the mouse relative to the document.
     *
     * @param {number} pixelHeight - The height of the chart in pixels. This is equivalent to the
     * `offsetHeight` of the chart container
     * @param {number} pixelWidth - The width of the chart in pixels. This is equivalent to the
     * `offsetWidth` of the chart container
     *
     * @example
     * // Create a chart and display the caption of the chart over which the mouse has been hovered. The
     * // event is attached to the FusionCharts global `addEventListener` function so that it is fired for
     * // all charts rendered on that page Once this event listener has been attached, any chart rendered on
     * // page will cause a console log when hovered out or tapped away.
     * FusionCharts.addEventListener('chartRollOut', function (event) {
     *     var chart = event.sender, // access the chart that raised this event
     *         caption = chart && chart.getChartAttribute(CAPTION); // get the chart caption
     *
     *     // Output the caption in JavaScript console
     *     console.log('Mouse left the chart with caption: ' + caption);
     * });
     */
    (0, _eventApi.triggerEvent)('chartRollOut', chart.chartInstance, args);
  };

  /**
   * Detaches the mouseover handler from the chart
   * @param  {Event} e  The event object associated with the rollout
   */


  MSCartesian.winMouseHover = function winMouseHover(e) {
    var event = e.originalEvent,
        tgt = event.target || event.originalTarget || event.srcElement || event.relatedTarget || event.fromElement,
        chart = e.data,
        paper = chart.getFromEnv('paper'),
        eve = {
      chart: chart,
      event: e.originalEvent
    };

    // On mouse rollout of the chart, detach window mouseover event
    if (isVML) {
      if (!paper.getById(tgt.parentNode.raphaelid)) {
        MSCartesian.onContainerRollOut(eve);
        chart.mouseStateIn = false;
        _domEvent2['default'].unlisten(document, 'mouseover', MSCartesian.winMouseHover);
      }
    } else {
      if (!tgt.viewportElement) {
        chart.mouseStateIn = false;
        MSCartesian.onContainerRollOut(eve);
        _domEvent2['default'].unlisten(window, 'mouseover', MSCartesian.winMouseHover);
      }
    }
  };

  return MSCartesian;
}(_fusioncharts2['default']);

exports['default'] = MSCartesian;
exports._allocateXAxisLabelSpace = _allocateXAxisLabelSpace;
exports._drawDataset = _drawDataset;
exports._createToolBox = _createToolBox2;
exports.configure = configure;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _componentInterface = __webpack_require__(6);

var _componentInterface2 = _interopRequireDefault(_componentInterface);

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */


var math = Math,
    mathMin = math.min,
    mathMax = math.max,
    mathAbs = math.abs,
    UNDEF;

/**
 * ColumnMultiSeriesgroup basically manages all the position of multiseries columns side by side.
 * suppose multiseries column chart contains 2 dataset now what will be the column width and
 * position to accomodate all the columns. This manager conveys the column width and position
 * for every column plots to its children
 */

var ColumnMultiSeriesgroup = function (_ComponentInterface) {
  _inherits(ColumnMultiSeriesgroup, _ComponentInterface);

  /**
   * constructor function this class
   */
  function ColumnMultiSeriesgroup() {
    _classCallCheck(this, ColumnMultiSeriesgroup);

    var _this = _possibleConstructorReturn(this, _ComponentInterface.call(this));

    _this.setState('visible', true);
    return _this;
  }
  /**
   * function to configure this manager
   */


  ColumnMultiSeriesgroup.prototype.configure = function configure() {
    var manager = this,
        numVisibleDataset = 0;
    manager._mapChildren(function (child) {
      child.configure && child.configure();
    });
    manager._mapChildren(function (child) {
      child.getState('visible') && numVisibleDataset++;
    });
    manager.setState('visible', !!numVisibleDataset);
  };
  /**
   * Create child containers
   */


  ColumnMultiSeriesgroup.prototype.createContainer = function createContainer() {
    var manager = this,
        paper = manager.getFromEnv('paper'),
        key = void 0,
        parent = manager.getLinkedParent(),
        pContainer = void 0,
        parentChildContainers = parent.getChildContainer();

    for (key in parentChildContainers) {
      pContainer = parentChildContainers[key];

      !manager.getChildContainer(key) && manager.addChildContainer(key, paper.group('manager-' + key, pContainer));
    }
  };
  /**
   * function call sync draw of its children
   */


  ColumnMultiSeriesgroup.prototype.draw = function draw() {
    this.setColumnPosition();
    this.createContainer();
    this.childrenSyncDraw();
  };
  /**
   * function to calculate maximum canvas padding is required by the children of this manager
   * @return {Object} contains dimension required
   */


  ColumnMultiSeriesgroup.prototype.getCanvasPadding = function getCanvasPadding() {
    var manager = this,
        dim,
        key,
        returnDimension = {
      paddingLeft: 0,
      paddingRight: 0,
      paddingTop: 0,
      paddingBottom: 0
    };
    manager.setColumnPosition();
    manager._mapChildren(function (child) {
      dim = child.getCanvasPadding && child.getCanvasPadding() || {};
      for (key in dim) {
        if (dim.hasOwnProperty(key)) {
          returnDimension[key] = Math.max(dim[key], returnDimension[key]);
        }
      }
    });
    return returnDimension;
  };
  /**
   * function to calculate column position and width
   */


  ColumnMultiSeriesgroup.prototype.setColumnPosition = function setColumnPosition() {
    var manager = this,
        chartConfig = manager.getFromEnv('chartConfig'),

    // chartAttr = manager.getFromEnv('chart-attrib'),
    xAxis = manager.getFromEnv('xAxis'),
        oldNumOfColumns = manager.getFromEnv('numOfColumns'),
        definedGroupPadding = chartConfig.plotSpacePercent,
        plotSpacePercent = mathMax((0, _lib.pluckNumber)(definedGroupPadding, 20) % 100, 0),
        groupPadding = plotSpacePercent / 200,
        xAxisZeroPos = xAxis.getAxisPosition(0),
        xAxisFirstPos = xAxis.getAxisPosition(1),
        maxColWidth = chartConfig.maxColWidth,
        groupMaxWidth = mathAbs(xAxisFirstPos - xAxisZeroPos),
        groupNetWidth = void 0,
        columnWidth = void 0,
        commonXShift = void 0,
        plotEffectivePadding = void 0,
        plotPaddingPercent = chartConfig.plotPaddingPercent,
        plotPadding = void 0,
        xPosFirst = void 0,
        xPosNext = void 0,
        isCrisp = true,
        groupNetHalfWidth = void 0,
        groupNetGapWidth = 4,
        overlapColumns = chartConfig.overlapColumns,
        count = 0,
        numOfColumns = 0;

    manager.addToEnv('groupMaxWidth', groupMaxWidth);
    manager._mapChildren(function (child) {
      if (!child.getState('removed') && child.getState('visible') !== false) {
        numOfColumns++;
      }
    });

    manager.addToEnv('numOfColumns', numOfColumns);
    manager.addToEnv('numColDiff', (0, _lib.pluckNumber)(oldNumOfColumns - numOfColumns, 0));
    groupNetWidth = (1 - definedGroupPadding * 0.01) * groupMaxWidth || mathMin(groupMaxWidth * (1 - groupPadding * 2), maxColWidth * (numOfColumns || 1));
    columnWidth = numOfColumns === 0 ? groupNetWidth : groupNetWidth / numOfColumns;

    plotPadding = numOfColumns > 1 ? !overlapColumns && plotPaddingPercent === UNDEF ? 4 : plotPaddingPercent > 0 ? columnWidth * plotPaddingPercent / 100 : 0 : 0;

    plotEffectivePadding = mathMin(columnWidth - 1, plotPadding);

    manager.addToEnv('plotWidth', columnWidth);
    commonXShift = -(numOfColumns / 2 * columnWidth - columnWidth / 2);

    manager._mapChildren(function (child) {
      if (!child.getState('removed') && child.getState('visible')) {
        child.addToEnv('shift', commonXShift + count * columnWidth + plotEffectivePadding / 2);
        count++;
      }
    });
    groupNetHalfWidth = groupNetWidth / 2;
    xPosFirst = xAxisZeroPos - groupNetHalfWidth;
    xPosNext = xAxisFirstPos - groupNetHalfWidth;
    if (xPosNext - (xPosFirst + groupNetWidth) < groupNetGapWidth) {
      isCrisp = false;
    }

    if (plotSpacePercent === 0) {
      isCrisp = true;
    }

    manager.addToEnv('isCrisp', isCrisp);
  };
  /**
   * function to accomodate the changes of its child and notify its parent for further action if its needed
   * @param  {Object} updateInfo is an object with the informations about the changes in its child
   */


  ColumnMultiSeriesgroup.prototype.childChanged = function childChanged() {
    var updateInfo = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var manager = this,
        config = manager.config,
        parent = manager.getLinkedParent(),
        range = void 0,
        count = 0,
        prevVisiblity = manager.getState('visible'),
        changeInfo = {},
        informParent = void 0;
    // get the number of visible children
    manager._mapChildren(function (child) {
      if (child.getState('visible')) {
        count++;
      }
    });
    // set the manager visiblity according to number of children visible
    manager.setState('visible', !!count);
    // if the visiblity state changed then parent inform flag set to true
    prevVisiblity !== !!count && (informParent = true);
    // if the managers data limit get changed then also inform the parent
    if (updateInfo.dataLimitChanged !== false) {
      range = manager.getDataLimits();
      if (range.min !== config.range.min || range.max !== config.range.max) {
        config.range.min = range.min;
        config.range.max = range.max;
        changeInfo.dataLimitChanged = true;
        informParent = true;
      }
    }
    // if the axis value got changed then inform parent
    // right now we do not change value padding on any type of update
    // if (updateInfo.paddingChanged !== false) {
    //   padding = manager.getAxisValuePadding();
    //   if (padding.left !== config.padding.left || padding.right !== config.padding.right) {
    //     config.padding.left = padding.left;
    //     config.padding.right = padding.right;
    //     changeInfo.paddingChanged = true;
    //     informParent = true;
    //   }
    // }
    if (informParent) {
      parent.childChanged && parent.childChanged(changeInfo);
    } else {
      manager.asyncDraw();
    }
  };
  /**
   * function to get value for axis padding from is children
   * @return {Object} with left and right member
   */


  ColumnMultiSeriesgroup.prototype.getAxisValuePadding = function getAxisValuePadding() {
    var paddingObj = {},
        axisPaddingLeft = -Infinity,
        axisPaddingRight = -Infinity;
    this._mapChildren(function (child) {
      if (child.getState('removed')) {
        return;
      }
      paddingObj = child.getAxisValuePadding && child.getAxisValuePadding() || {};
      axisPaddingLeft = Math.max(axisPaddingLeft, paddingObj.left || -Infinity);
      axisPaddingRight = Math.max(axisPaddingRight, paddingObj.right || -Infinity);
    });

    if (axisPaddingLeft === -Infinity) {
      axisPaddingLeft = 0;
    }
    if (axisPaddingRight === -Infinity) {
      axisPaddingRight = 0;
    }
    if (!this.config.padding) {
      this.config.padding = {};
      this.config.padding.left = axisPaddingLeft;
      this.config.padding.right = axisPaddingRight;
    }
    return {
      left: axisPaddingLeft,
      right: axisPaddingRight
    };
  };
  /**
   * function to get data limits from its child datasets
   * return minimun and maximum value among the datasets limit
   * @param {boolean} allVisible  whether consider all the datasets are visible or not
   * @return {Object}             [min, max]
   */


  ColumnMultiSeriesgroup.prototype.getDataLimits = function getDataLimits(allVisible) {
    var manager = this,
        min = +Infinity,
        max = -Infinity,
        maxminObj = void 0,
        numOfColumns = 0,
        getMaxMin = function getMaxMin(_maxminObj) {
      max = Math.max(max, _maxminObj.max);
      min = Math.min(min, _maxminObj.min);
    };

    manager._mapChildren(function (child) {
      if (child.getState('removed') || child.getState('visible') === false) {
        if (allVisible) {
          maxminObj = child.getDataLimits(allVisible);
          getMaxMin(maxminObj);
        }
        return;
      }
      numOfColumns++;
      maxminObj = child.getDataLimits(allVisible);
      getMaxMin(maxminObj);
    });
    if (!numOfColumns) {
      manager.setState('visible', false);
    } else {
      manager.setState('visible', true);
    }
    if (!this.config.range) {
      this.config.range = {};
      this.config.range.min = this.config.dataMin;
      this.config.range.max = this.config.dataMax;
    }
    return { max: max, min: min };
  };
  /**
   * it return the status of dataset visiblity
   * @return {boolean} returns the visiblity status of dataset
   */


  ColumnMultiSeriesgroup.prototype.isVisible = function isVisible() {
    return !this.isNotVisible;
  };
  /**
   * function to return type of this component
   * @return {string} type
   */


  ColumnMultiSeriesgroup.prototype.getType = function getType() {
    return 'manager';
  };
  /**
   * function to return name of this component
   * @return {string} name
   */


  ColumnMultiSeriesgroup.prototype.getName = function getName() {
    return 'multiseriesColumnManager';
  };

  return ColumnMultiSeriesgroup;
}(_componentInterface2['default']);

exports['default'] = ColumnMultiSeriesgroup;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.version = undefined;

var _constructor = __webpack_require__(79);

var _constructor2 = _interopRequireDefault(_constructor);

var _xmlTranscoder = __webpack_require__(322);

var _xmlTranscoder2 = _interopRequireDefault(_xmlTranscoder);

var _jsonTranscoder = __webpack_require__(323);

var _jsonTranscoder2 = _interopRequireDefault(_jsonTranscoder);

var _jsonUrlTranscoder = __webpack_require__(324);

var _jsonUrlTranscoder2 = _interopRequireDefault(_jsonUrlTranscoder);

var _xmlUrlTranscoder = __webpack_require__(325);

var _xmlUrlTranscoder2 = _interopRequireDefault(_xmlUrlTranscoder);

var _ignore_case_ext = __webpack_require__(326);

var _ignore_case_ext2 = _interopRequireDefault(_ignore_case_ext);

var _themes = __webpack_require__(328);

var _themes2 = _interopRequireDefault(_themes);

var _themes3 = __webpack_require__(355);

var _themes4 = _interopRequireDefault(_themes3);

var _tooltipController = __webpack_require__(356);

var _tooltipController2 = _interopRequireDefault(_tooltipController);

var _tooltipAdapter = __webpack_require__(358);

var _tooltipAdapter2 = _interopRequireDefault(_tooltipAdapter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

// import modifyEnv from './core/dependency-manager';
// import addEventAPI from './core/events/events';
// import enableDebugging from './core/debugger/debugger';
// import rendererLib from './mantle/renderer/renderer-lib';
// import renderer from './mantle/renderer/renderer';
// import rendererInterface from './mantle/renderer-javascript/renderer-javascript-interface';
// import runtime from './core/constructor/../runtime/runtime';
// import updater from './mantle/updater/updater';
// import addChartAttrApis from './crust/api-chartattributes/api-chartattributes';
// import { addNumberFormatter } from './mantle/renderer-javascript/components/numberformatter';
// import { dataStreamerListener } from './mantle/renderer-javascript/components/datastreamer';

// export * from './core/debugger/debugger';
// export * from './core/events/events';
// export * from './core/ajax/ajax';
// export * from './core/runtime/runtime';
// export * from './crust/managedprint/managedprint-deprecated.js';
// export * from './mantle/renderer/renderer';
// export * from './mantle/transcoder/transcoder';
// export * from './mantle/transcoder-json/transcoder-json';
// export * from './mantle/transcoder-xml/transcoder-xml';
// export * from './mantle/transcoder-csv/transcoder-csv';
// export * from './mantle/renderer-javascript/renderer-javascript';
// export * from './mantle/renderer-javascript/components/polyfill';
// export * from './mantle/renderer-javascript/components/svgdecanvo';
// export * from './mantle/renderer-javascript/components/lib-attr`';
// export * from './mantle/renderer-javascript/components/lib';
// export * from './mantle/renderer-javascript/components/component-interface.js';
// export * from './mantle/renderer-javascript/components/chart-api.js';
// export * from './mantle/renderer-javascript/components/schedular';
// export * from './mantle/renderer-javascript/components/mouse-tracker';
// export * from './mantle/renderer-javascript/redraphael/redraphael';
// export * from './mantle/renderer-javascript/redraphael/redraphael.css';
// export * from './mantle/renderer-javascript/redraphael/redraphael.export';
// export * from './mantle/renderer-javascript/redraphael/redraphael.shadow';
// export * from './mantle/renderer-javascript/redraphael/redraphael.shapes';
// export * from './mantle/renderer-javascript/redraphael/redraphael.html';
// export * from './mantle/renderer-javascript/redraphael/redraphael.tooltip';
// export * from './mantle/renderer-javascript/components/vcanvas.js';
// export * from './mantle/renderer-javascript/components/legend.js';
// export * from './mantle/renderer-javascript/components/smartlabel';
// export * from './mantle/renderer-javascript/components/numberformatter';
// export * from './mantle/renderer-javascript/components/dom';
// export * from './mantle/renderer-javascript/components/colormanager';
// export * from './mantle/renderer-javascript/components/annotations';
// export * from './mantle/renderer-javascript/components/jpeg-to-pdf';
// export * from './mantle/renderer-javascript/export/batch-export';
// export * from './mantle/renderer-javascript/export/export';
// export * from './mantle/renderer-javascript/toolbox';
// export * from './mantle/renderer-javascript/components/animation-manager.js';
// export * from './mantle/renderer-javascript/input/input-base.js';
// export * from './mantle/renderer-javascript/input/zoom-in.js';
// export * from './mantle/renderer-javascript/input/zoom-out.js';
// export * from './mantle/renderer-javascript/input/zoom-reset.js';
// export * from './mantle/renderer-javascript/input/input-pan.js';
// export * from './mantle/renderer-javascript/input/input-dbtap-zoom.js';
// export * from './mantle/renderer-javascript/input/input-drag-zoom.js';
// export * from './mantle/renderer-javascript/input/input-pinch-zoom.js';
// export * from './mantle/renderer-javascript/components/axis-ref-visuals.js';
// export * from './mantle/renderer-javascript/components/canvas.js';
// export * from './mantle/renderer-javascript/logic';
// export * from './mantle/renderer-javascript/visualizer';
// export * from './mantle/renderer-javascript/renderer-javascript-interface';
// export * from './crust/api-chartattributes/api-chartattributes';
// export * from './crust/api-linkedcharts/api-linkedcharts';
// export * from './crust/themes/themes';
// export * from './crust/themes/themes.default';
// export * from './mantle/renderer-javascript/kdtree';
// export * from './crust/highlightmanager/highlighter';
/* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */
/**
 * @private
 * @module fusioncharts
 *
 * @requires fusioncharts.constructor
 *
 * @requires fusioncharts.transcoder
 * @requires fusioncharts.transcoder.json
 * @requires fusioncharts.transcoder.xml
 * @requires fusioncharts.transcoder.csv
 *
 * @requires fusioncharts.renderer
 * @requires fusioncharts.renderer.javascript
 * @requires fusioncharts.renderer.javascript.interface
 *
 * @requires fusioncharts.api.chartattributes
 * @requires fusioncharts.api.linkedcharts
 * @requires fusioncharts.api.themes
 * @requires fusioncharts.api.themes.default
 * @requires fusioncharts.api.highlightmanager
 * @export fusioncharts.js
 */

var version = '3.13.0';

_constructor2['default'].addDep(_xmlTranscoder2['default']);
_constructor2['default'].addDep(_jsonTranscoder2['default']);
_constructor2['default'].addDep(_jsonUrlTranscoder2['default']);
_constructor2['default'].addDep(_xmlUrlTranscoder2['default']);
_constructor2['default'].addDep(_themes2['default']);
_constructor2['default'].addDep(_themes4['default']);
_constructor2['default'].addDep(_ignore_case_ext2['default']);
_constructor2['default'].addDep(_tooltipAdapter2['default']);
_constructor2['default'].addDep(_tooltipController2['default']);

exports.version = version;
exports['default'] = _constructor2['default'];

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _index = __webpack_require__(362);

var _index2 = _interopRequireDefault(_index);

var _lib = __webpack_require__(5);

var _schedular = __webpack_require__(41);

var _schedular2 = _interopRequireDefault(_schedular);

var _redraphael = __webpack_require__(396);

var _redraphael2 = _interopRequireDefault(_redraphael);

var _redraphael3 = __webpack_require__(397);

var _redraphael4 = _interopRequireDefault(_redraphael3);

var _redraphael5 = __webpack_require__(398);

var _redraphael6 = _interopRequireDefault(_redraphael5);

var _redraphael7 = __webpack_require__(399);

var _redraphael8 = _interopRequireDefault(_redraphael7);

var _redraphael9 = __webpack_require__(400);

var _redraphael10 = _interopRequireDefault(_redraphael9);

var _redraphaelHtml = __webpack_require__(401);

var _redraphaelHtml2 = _interopRequireDefault(_redraphaelHtml);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var blankObject = {}; /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */

/**
 * @private
 * @module fusioncharts.redraphael
 * @requires fusioncharts.renderer.javascript.lib
 * @requires fusioncharts.renderer.javascript.schedular
 * @requires ../../../../vendors/redraphael/package/raphael-fusioncharts.js
 */


_index2['default'].fn._elementFromEvent = function (event) {
  if (!event || this.removed) {
    return null;
  }

  var element = event.srcElement || event.target || (event = event.originalEvent) && (event.srcElement || event.target) || blankObject;

  element.nodeName === 'tspan' && (element = element.parentNode);
  return this.getById(element.raphaelid);
};
_index2['default'].requestAnimFrame = _schedular2['default'].addJob && function (callback) {
  _schedular2['default'].addJob(callback, _lib.priorityList.animation, true);
};

_index2['default'].instantRequestAnimFrame = _schedular2['default'].addJob && function (callback) {
  _schedular2['default'].addJob(callback, _lib.priorityList.instant);
};

(0, _redraphael2['default'])(_index2['default']);
(0, _redraphael4['default'])(_index2['default']);
(0, _redraphael6['default'])(_index2['default']);
(0, _redraphael8['default'])(_index2['default']);
(0, _redraphael10['default'])(_index2['default']);
(0, _redraphaelHtml2['default'])(_index2['default']);

exports['default'] = _index2['default'];

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _componentInterface = __webpack_require__(6);

var _componentInterface2 = _interopRequireDefault(_componentInterface);

var _lib = __webpack_require__(5);

var _isArray = __webpack_require__(435);

var _isArray2 = _interopRequireDefault(_isArray);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */


var visibleStr = _lib.preDefStr.visibleStr,
    UNDEF = void 0,
    math = Math,
    mathMin = math.min,
    mathMax = math.max;

/**
 * CartesianStackgroup basically manages all plots position of stack charts (column and area) in stacking
 * Suppose there are 2 column plot in a stack chart then what will be the base and y position would be
 * calculated in this manager. This manager calculated sum for all the stacks. It calculats and sets base
 * position and y position for every single plot.
 */

var CartesianStackgroup = function (_ComponentInterface) {
  _inherits(CartesianStackgroup, _ComponentInterface);

  /**
   * constructor function this class
   */
  function CartesianStackgroup() {
    _classCallCheck(this, CartesianStackgroup);

    var _this = _possibleConstructorReturn(this, _ComponentInterface.call(this));

    _this.setState('visible', true);
    return _this;
  }
  /**
   * function to configure this manager
   */


  CartesianStackgroup.prototype.configure = function configure() {
    var numVisibleDataset = 0;
    this._mapChildren(function (child) {
      child.getState('visible') && numVisibleDataset++;
    });
    this.setState('visible', !!numVisibleDataset);
  };
  /**
   * Create child containers
   */


  CartesianStackgroup.prototype.createContainer = function createContainer() {
    var manager = this,
        paper = manager.getFromEnv('paper'),
        key = void 0,
        parent = manager.getLinkedParent(),
        pContainer = void 0,
        parentChildContainers = parent.getChildContainer();

    // create all types child container to reside graphics elements for the children of this manager.
    // because this stack manager is common for the all types of stacked dataset
    for (key in parentChildContainers) {
      pContainer = parentChildContainers[key];
      !manager.getChildContainer(key) && manager.addChildContainer(key, paper.group('manager-' + key, pContainer));
    }
    // create the container for the sum labels to reside the graphic element of sum label
    // so that the transformation to can be applied on scrolling
    !manager.getContainer('sumLabelsLayer') && manager.addContainer('sumLabelsLayer', paper.group('manager-sumLabelsLayer', parent.getChildContainer('sumLabelsLayer')).attr('class', 'fusioncharts-datalabels'));
  };
  /**
   * function call sync draw of its children
   */


  CartesianStackgroup.prototype.draw = function draw() {
    this.createContainer();
    this.childrenSyncDraw();
    this.drawSumValue();
  };
  /**
   * function to calculate plot position, max and min of manager in case a of stacked dataset
   */


  CartesianStackgroup.prototype._setStackPosition = function _setStackPosition() {
    var manager = this,
        dataMin = +Infinity,
        dataMax = -Infinity,
        oldNumOfColumns = manager.getFromEnv('numOfColumns'),

    // transposeAxis = manager.getFromEnv('chartConfig').transposeAxis,
    numOfColumns = 0,
        stackValueArr = [];

    manager._mapChildren(function (child) {
      if (child.getState('removed') || child.getState('visible') === false) {
        return;
      }
      numOfColumns++;
      var datum = void 0,
          data = child.getData(),
          i = void 0,
          setValue = void 0,
          stackedValue = 0,
          len = data && data.length,
          base = 0;

      for (i = 0; i < len; i++) {
        datum = data[i];
        if (datum && datum.config && datum.config.setValue !== UNDEF && datum.config.setValue !== null) {
          if (!stackValueArr[i]) {
            stackValueArr[i] = {};
          }
          setValue = datum.config.setValue;

          stackValueArr[i].positive || (stackValueArr[i].positive = 0);
          stackValueArr[i].negative || (stackValueArr[i].negative = 0);
          if (setValue >= 0) {
            base = stackValueArr[i].positive;
            stackedValue = setValue + base;
            stackValueArr[i].positive = stackedValue;
          } else if (setValue < 0) {
            base = stackValueArr[i].negative;
            stackedValue = setValue + base;
            stackValueArr[i].negative = stackedValue;
          }
          if (setValue !== null) {
            stackValueArr[i].isNotNull = true;
          }
          dataMax = mathMax(stackedValue, dataMax);
          dataMin = mathMin(stackedValue, dataMin);
          datum.config._y = stackedValue;
          datum.config._b = base;
        }
      }
    });
    manager.config.stackValues = stackValueArr;
    manager.config.dataMin = dataMin;
    manager.config.dataMax = dataMax;

    if (!numOfColumns) {
      manager.setState('visible', false);
    } else {
      manager.setState('visible', true);
    }
    manager.addToEnv('stackValues', stackValueArr);
    manager.addToEnv('numOfColumns', numOfColumns);
    manager.addToEnv('numColDiff', (0, _lib.pluckNumber)(oldNumOfColumns - numOfColumns, 0));
  };

  /**
   * Helper function for determining the xPos of sumLabel
   * @param {number} index The index of the sumLabel
   * @return {number} x-position
   */


  CartesianStackgroup.prototype._getXpos = function _getXpos(index) {
    var manager = this,
        shift = manager.getFromEnv('shift') || 0,
        xAxis = manager.getFromEnv('xAxis');
    return xAxis.getAxisPosition(index) + shift;
  };

  /**
   * function to draw sum value of the stack
   * It renders the sum value of the stacked plots
   * @param  {number} [start=0] start index of sumValue label draw
   * @param  {number} end       end index of sumValue label draw
   */


  CartesianStackgroup.prototype.drawSumValue = function drawSumValue() {
    var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var end = arguments[1];

    var manager = this,
        config = manager.config,

    // shift = manager.getFromEnv('shift') || 0,
    // xAxis = manager.getFromEnv('xAxis'),
    yAxis = manager.getFromEnv('yAxis'),
        paper = manager.getFromEnv('paper'),
        chart = manager.getFromEnv('chart'),
        animationObj = chart.get('config', 'animationObj'),
        animType = animationObj.animType,
        SmartLabel = manager.getFromEnv('smartLabel'),
        chartConfig = chart.config,
        chartAttrs = manager.getFromEnv('chart-attrib'),
        stack100percent = (0, _lib.pluckNumber)(chartConfig.stack100percent),
        rotateValues = chartConfig.rotatevalues ? 270 : 0,
        stackValues = config.stackValues,
        range = end || stackValues && stackValues.length,
        style = chartConfig.dataLabelStyle,
        i = void 0,
        xPos = void 0,
        yPos = void 0,
        bgColor = void 0,
        bdColor = void 0,
        labelDim = void 0,
        dataArr = [],
        resize = chart.state === 'resize',
        noAnim = chart.state === 'noAnim',
        realTimeUpdate = chart.state === 'realTimeUpdate',
        sumLabelsLayer = manager.getContainer('sumLabelsLayer'),
        sumLabels = manager.getGraphicalElement('sumLabels'),
        sumLabel = void 0,
        attrs = void 0,
        positive = void 0,
        negative = void 0,
        offsetY = void 0,
        displayValue = void 0,
        sumValue = void 0,
        prevLen = void 0,
        currLen = void 0,
        label = void 0,
        animObj = manager.getFromEnv('chartConfig').animationObj,
        transposeAnimDuration = animObj.transposeAnimDuration,
        showsum = (0, _lib.pluckNumber)(chartAttrs.showsum, chart.showsum, 0),
        callback = function callback(isVisible) {
      if (!isVisible) {
        this.hide();
      }
    },
        setAttrFn = function setAttrFn(attr) {
      var elem = this;
      elem.attr(attr);
    };

    // @TODO sumValue layers and sumvalue containers needs to be validated.
    if (showsum) {
      // @TODO layer gets hide; have to fix
      sumLabelsLayer.css(style);
      SmartLabel.setStyle(style);
      sumLabelsLayer.show();
      if (!resize && !noAnim && !realTimeUpdate) {
        dataArr.push({
          el: sumLabelsLayer,
          attrs: {
            opacity: 0
          },
          callback: callback.bind(sumLabelsLayer, manager.getState('visible')),
          animConfig: [{
            syncWith: 'initial'
          }]
        });
        dataArr.push({
          el: sumLabelsLayer,
          attrs: {
            opacity: manager.getState('visible') ? 1 : 0
          },
          animConfig: [{
            syncWith: 'final'
          }]
        });
      }
      prevLen = sumLabels && sumLabels.length;
      currLen = stackValues.length;

      // Remove extra sum labels if the previous sumlabels count is greater than new sumvalue count
      if (prevLen > currLen) {
        for (i = currLen; i < prevLen; i++) {
          label = sumLabels[i];
          if (label) {
            if (transposeAnimDuration) {
              dataArr.push({
                el: label,
                attrs: {
                  opacity: 0
                },
                callback: callback.bind(label),
                animConfig: [{
                  syncWith: 'initial'
                }]
              });
            } else {
              // Stopping any previous animation.
              label.stop();
              label.hide();
            }
            manager.removeGraphicalElement(label);
          }
        }
      }

      for (i = start; i < range; i++) {
        sumLabel = (0, _isArray2['default'])(sumLabels) && sumLabels[i];
        if (!stackValues[i] || !stackValues[i].isNotNull) {
          sumLabel && sumLabel.hide();
          continue;
        }
        positive = stackValues[i].positive;
        negative = stackValues[i].negative;
        sumValue = positive + negative;
        /*
          Getting the y shift which decides how much to shift the y position
          of the sum label
        */
        offsetY = sumValue < 0 ? negative : positive;
        displayValue = yAxis.dataLabels(sumValue);

        if (displayValue) {
          bgColor = style.backgroundColor;
          bdColor = style.borderColor;

          labelDim = SmartLabel.getOriSize(displayValue);
          xPos = manager._getXpos(i);
          yPos = yAxis.getAxisPosition(stack100percent ? 100 : offsetY);
          attrs = manager.getSumValuePosition(labelDim, {
            stack100percent: stack100percent,
            rotateValues: rotateValues,
            xPos: xPos,
            yPos: yPos,
            offsetY: offsetY
          });
          attrs.opacity = 0;
          attrs.text = displayValue;
          attrs.fill = style.color;
          attrs['text-bound'] = [bgColor, bdColor, style.borderThickness, style.borderPadding, style.borderRadius, style.borderDash];
          attrs['line-height'] = style.lineHeight;
          attrs.visibility = visibleStr;
          attrs.transform = paper.getSuggestiveRotation(rotateValues, attrs.x, attrs.y);
          //  @TODO needs to validate 'text-anchor'
          if (attrs['text-anchor']) {
            delete attrs['text-bound'];
          }
          if (!sumLabel) {
            sumLabel = paper.text(attrs, sumLabelsLayer);
            manager.addGraphicalElement('sumLabels', sumLabel, true);
            dataArr.push({
              el: sumLabel,
              attrs: {
                opacity: 1
              },
              animConfig: [{
                syncWith: 'final',
                hookFn: setAttrFn.bind(sumLabel, attrs)
              }]
            });
          } else if (sumLabel && !resize) {
            sumLabel.show();
            dataArr.push({
              el: sumLabel,
              attrs: {
                opacity: 0
              },
              animConfig: [{
                syncWith: 'initial'
              }]
            });

            dataArr.push({
              el: sumLabel,
              attrs: {
                opacity: 1
              },
              animConfig: [{
                syncWith: 'final',
                hookFn: setAttrFn.bind(sumLabel, attrs)
              }]
            });
          } else {
            delete attrs.opacity;
            dataArr.push({
              el: sumLabel,
              attrs: attrs,
              animConfig: [{
                syncWith: 'default'
              }]
            });
          }
        }
      }
      manager.getFromEnv('animationManager').registerAnimation([{
        animType: animType,
        data: dataArr
      }], 'final');
    } else {
      sumLabelsLayer.hide();
    }
  };
  /**
   * function calculate the coordinates for the sum value label
   * it returns the calculated x, y coordinate to render the label
   * @param  {Object} labelDim    display value dimention
   * @param  {Object} labelConfig display value configuration
   * @return {Object}             contains x, y positions of the label
   */


  CartesianStackgroup.prototype.getSumValuePosition = function getSumValuePosition(labelDim, labelConfig) {
    var manager = this,
        chart = manager.getFromEnv('chart'),
        config = chart.config,
        canvasBottom = config.canvasBottom,
        canvasTop = config.canvasTop,
        is3D = chart.is3D,
        stack100percent = labelConfig.stack100percent,
        gutter = 2,
        yDepth = config.yDepth,
        xDepth = config.xDepth,
        origTextHeight,
        outsideColSpace,
        yPos = labelConfig.yPos,
        textHeight,
        xPos = labelConfig.xPos,
        labelHeight,
        canvasBorderThickness = manager.getFromEnv('canvasConfig').canvasBorderWidth,
        offsetY = labelConfig.offsetY,
        rotateValues = labelConfig.rotateValues;

    // Storing the width and height in state if state not created
    if (rotateValues) {
      // If rotated values we use the width of
      // the text as height
      labelHeight = labelDim.width;
    } else {
      labelHeight = labelDim.height;
    }

    textHeight = origTextHeight = labelHeight;
    textHeight = textHeight / 2 + gutter;
    // If not stack 100 percent
    if (!stack100percent) {
      // For positive values
      if (offsetY >= 0) {
        outsideColSpace = yPos - canvasTop;
        // If text does not fit outside column shift the label inside the column
        if (outsideColSpace < origTextHeight) {
          yPos = yPos + textHeight - outsideColSpace;
        } else {
          // If text fits in the space between column and canvas
          yPos = yPos - textHeight;
        }
      }
      // For positive values
      if (offsetY < 0) {
        outsideColSpace = canvasBottom - yPos;
        if (outsideColSpace < origTextHeight) {
          yPos = yPos - textHeight;
        } else {
          yPos = yPos + textHeight;
        }
        if (is3D) {
          xPos -= xDepth;
          yPos += yDepth;
        }
      }
    } else {
      // Label management when stack100percent
      // If space not available outside canvas
      if (canvasTop <= origTextHeight) {
        yPos = textHeight;
      } else {
        // If space available outside canvas
        yPos = canvasTop - textHeight - canvasBorderThickness;
      }
    }

    return {
      x: xPos,
      y: yPos
    };
  };
  /**
   * function to accomodate the changes of its child and notify its parent for further action if its needed
   * @param  {Object} updateInfo is an object with the informations about the changes in its child
   */


  CartesianStackgroup.prototype.childChanged = function childChanged() {
    var updateInfo = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var manager = this,
        config = manager.config,
        parent = manager.getLinkedParent(),
        range = void 0,
        prevVisiblity = manager.getState('visible'),
        count = 0,
        changeInfo = {},
        informParent = void 0;
    // get the number of visible children
    manager._mapChildren(function (child) {
      if (child.getState('visible')) {
        count++;
      }
    });
    // set the manager visiblity according to number of children visible
    manager.setState('visible', !!count);
    // if the visiblity state changed then parent inform flag set to true
    prevVisiblity !== !!count && (informParent = true);
    // if the managers data limit get changed then also inform the parent
    if (updateInfo.dataLimitChanged !== false) {
      range = manager.getDataLimits();
      if (range.min !== config.range.min || range.max !== config.range.max) {
        config.range.min = range.min;
        config.range.max = range.max;
        changeInfo.dataLimitChanged = true;
        informParent = true;
      }
    }
    // if the axis value got changed then inform parent
    // right now we do not change value padding on any type of update
    // if (updateInfo.paddingChanged !== false) {
    //   padding = manager.getAxisValuePadding();
    //   if (padding.left !== config.padding.left || padding.right !== config.padding.right) {
    //     config.padding.left = padding.left;
    //     config.padding.right = padding.right;
    //     changeInfo.paddingChanged = true;
    //     informParent = true;
    //   }
    // }
    if (informParent) {
      parent.childChanged && parent.childChanged(changeInfo);
    } else {
      manager.asyncDraw();
    }
  };
  /**
   * function to get value for axis padding from is children
   * @return {Object} with left and right member
   */


  CartesianStackgroup.prototype.getAxisValuePadding = function getAxisValuePadding() {
    var paddingObj = {},
        axisPaddingLeft = -Infinity,
        axisPaddingRight = -Infinity;
    this._mapChildren(function (child) {
      if (child.getState('removed')) {
        return;
      }
      paddingObj = child.getAxisValuePadding && child.getAxisValuePadding() || {};
      axisPaddingLeft = Math.max(axisPaddingLeft, paddingObj.left || -Infinity);
      axisPaddingRight = Math.max(axisPaddingRight, paddingObj.right || -Infinity);
    });
    if (axisPaddingLeft === -Infinity) {
      axisPaddingLeft = 0;
    }
    if (axisPaddingRight === -Infinity) {
      axisPaddingRight = 0;
    }
    if (!this.config.padding) {
      this.config.padding = {};
      this.config.padding.left = axisPaddingLeft;
      this.config.padding.right = axisPaddingRight;
    }
    return {
      left: axisPaddingLeft,
      right: axisPaddingRight
    };
  };
  /**
   * function to get data limits from its child datasets
   * return minimun and maximum value among the datasets range
   * @param {boolean} allVisible  whether consider all the datasets are visible or not
   * @return {Object}             [min, max]
   */


  CartesianStackgroup.prototype.getDataLimits = function getDataLimits(allVisible) {
    this._setStackPosition();

    if (!this.config.range) {
      this.config.range || (this.config.range = {});
      this.config.range.min = this.config.dataMin;
      this.config.range.max = this.config.dataMax;
    }

    return allVisible ? this._getStackLimit() : { max: this.config.dataMax,
      min: this.config.dataMin
    };
  };
  /**
   * functio to return limit of the manager by considering all the datasets are visble
   * @return {Object} contains data limit
   */


  CartesianStackgroup.prototype._getStackLimit = function _getStackLimit() {
    var manager = this,
        dataMin = +Infinity,
        dataMax = -Infinity,
        stackValueArr = [];

    manager._mapChildren(function (child) {
      if (child.getState('removed')) {
        return;
      }
      var datum = void 0,
          data = child.getData(),
          i = void 0,
          setValue = void 0,
          stackedValue = 0,
          len = data && data.length,
          base = 0;

      for (i = 0; i < len; i++) {
        datum = data[i];
        if (datum && datum.config && datum.config.setValue !== UNDEF && datum.config.setValue !== null) {
          if (!stackValueArr[i]) {
            stackValueArr[i] = {};
          }
          setValue = datum.config.setValue;

          stackValueArr[i].positive || (stackValueArr[i].positive = 0);
          stackValueArr[i].negative || (stackValueArr[i].negative = 0);
          if (setValue > 0) {
            base = stackValueArr[i].positive;
            stackedValue = setValue + base;
            stackValueArr[i].positive = stackedValue;
          } else if (setValue < 0) {
            base = stackValueArr[i].negative;
            stackedValue = setValue + base;
            stackValueArr[i].negative = stackedValue;
          }
          dataMax = mathMax(stackedValue, dataMax);
          dataMin = mathMin(stackedValue, dataMin);
        }
      }
    });
    return { max: dataMax,
      min: dataMin
    };
  };

  /**
   * it return the status of dataset visiblity
   * @return {boolean} returns the visiblity status of dataset
   */


  CartesianStackgroup.prototype.isVisible = function isVisible() {
    return !this.isNotVisible;
  };
  /**
   * function to get calculate width or hieght for stacked charts' sumvalue label
   * @param  {number} maxAvailableSpace available space for height or width
   * @return {Object}                   contains top and right value
   */


  CartesianStackgroup.prototype.getMaxSumValueSpace = function getMaxSumValueSpace() {
    var manager = this,
        stackSumValues = manager.config.stackValues,
        chart = manager.getFromEnv('chart'),
        i,
        dim = {},
        len = stackSumValues && stackSumValues.length,
        numberFormatter = manager.getFromEnv('number-formatter'),
        formattedValue,
        width,
        height,
        maxHeight = 0,
        maxWidth = 0,
        sumValue,
        SmartLabel = manager.getFromEnv('smartLabel'),
        dataLabelStyle = chart.config.dataLabelStyle;
    SmartLabel.useEllipsesOnOverflow(chart.config.useEllipsesWhenOverflow);
    SmartLabel.setStyle(dataLabelStyle);

    for (i = 0; i < len; i++) {
      if (stackSumValues[i]) {
        sumValue = stackSumValues[i].positive + stackSumValues[i].negative;
        formattedValue = numberFormatter.dataLabels(sumValue);
        dim = SmartLabel.getOriSize(formattedValue);
        width = dim.width;
        height = dim.height;
        maxWidth = mathMax(maxWidth, width);
        maxHeight = mathMax(maxHeight, height);
      }
    }
    return {
      maxWidth: maxWidth,
      maxHeight: maxHeight
    };
  };
  /**
   * function to calculate maximum canvas padding is required by the children of this manager
   * @return {Object} contains dimension required
   */


  CartesianStackgroup.prototype.getCanvasPadding = function getCanvasPadding() {
    var manager = this,
        dim,
        key,
        returnDimension = {
      paddingLeft: 0,
      paddingRight: 0,
      paddingTop: 0,
      paddingBottom: 0
    };
    manager._setStackPosition();
    manager._mapChildren(function (child) {
      dim = child.getCanvasPadding && child.getCanvasPadding() || {};
      for (key in dim) {
        if (dim.hasOwnProperty(key)) {
          returnDimension[key] = Math.max(dim[key], returnDimension[key]);
        }
      }
    });
    return returnDimension;
  };
  /**
   * function to return type of this component
   * @return {string} type
   */


  CartesianStackgroup.prototype.getType = function getType() {
    return 'manager';
  };
  /**
   * function to return name of this component
   * @return {string} name
   */


  CartesianStackgroup.prototype.getName = function getName() {
    return 'cartesianStackManager';
  };

  return CartesianStackgroup;
}(_componentInterface2['default']);

exports['default'] = CartesianStackgroup;

/***/ }),
/* 19 */
/***/ (function(module, exports) {

var core = module.exports = {version: '2.4.0'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _column = __webpack_require__(8);

var _column2 = _interopRequireDefault(_column);

var _lib = __webpack_require__(5);

var _schedular = __webpack_require__(41);

var _schedular2 = _interopRequireDefault(_schedular);

var _kdtree = __webpack_require__(93);

var _kdtree2 = _interopRequireDefault(_kdtree);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var UNDEF,
    win = window,
    Image = win.Image,
    isVML = !_lib.hasSVG,
    NONE = 'none',
    ROLLOVER = 'DataPlotRollOver',
    ROLLOUT = 'DataPlotRollOut',

// hot/tracker threshold in pixels
HTP = _lib.hasTouch ? _lib.TOUCH_THRESHOLD_PIXELS : _lib.CLICK_THRESHOLD_PIXELS,

// add the tools thats are requared

PLOTBORDERCOLOR = 'plotBorderColor',
    PLOTGRADIENTCOLOR = 'plotGradientColor',
    SHOWSHADOW = 'showShadow',
    POINTER = 'pointer',
    EVENTARGS = 'eventArgs',
    DATAPLOTCLICK = 'dataplotclick',
    DEFAULT_CURSOR = _lib.preDefStr.DEFAULT,
    visibleStr = _lib.preDefStr.visibleStr,
    hiddenStr = _lib.preDefStr.hiddenStr,
    SETROLLOVERATTR = _lib.preDefStr.setRolloverAttrStr,
    SETROLLOUTATTR = _lib.preDefStr.setRolloutAttrStr,
    defined = function defined(obj) {
  return obj !== UNDEF && obj !== null;
},
    M = 'M',
    L = 'L',
    Z = 'Z',
    math = Math,
    mathMin = math.min,
    mathMax = math.max,
    mathCeil = math.ceil,
    mathRound = math.round,
    MAX_MITER_LINEJOIN = 2;
/**
 * Creates the Area Dataset
 * @class
 */

var AreaDataset = function (_ColumnDataset) {
  _inherits(AreaDataset, _ColumnDataset);

  /**
   * Constructor function for instantiation
   */
  function AreaDataset() {
    _classCallCheck(this, AreaDataset);

    var _this = _possibleConstructorReturn(this, _ColumnDataset.call(this));

    _this.type = 'area';
    return _this;
  }

  /**
   * Sets the default value of attributes
   */


  AreaDataset.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _ColumnDataset.prototype.__setDefaultConfig && _ColumnDataset.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    config.valueposition = UNDEF;
    config.plotborderdashlen = UNDEF;
    config.plotborderdashgap = UNDEF;
    config.plotborderdashstyle = UNDEF;
    config.plotborderthickness = UNDEF;
    config.linethickness = UNDEF;
    config.linedashlen = UNDEF;
    config.linedashgap = UNDEF;
    config.dashed = UNDEF;
    config.linedashstyle = UNDEF;
    config.linecolor = UNDEF;
    config.linealpha = UNDEF;
    config.anchorbgcolor = UNDEF;
    config.anchorbordercolor = UNDEF;
    config.anchorradius = UNDEF;
    config.anchoralpha = UNDEF;
    config.anchorimageurl = UNDEF;
    config.anchorsides = UNDEF;
    config.anchorbgalpha = UNDEF;
    config.anchorborderthickness = UNDEF;
    config.anchorshadow = UNDEF;
    config.anchorstartangle = UNDEF;
    config.anchorimagealpha = UNDEF;
    config.anchorimagescale = UNDEF;
    config.anchorimagepadding = UNDEF;
    config.alpha = UNDEF;
    config.parentyaxis = UNDEF;
  };

  /**
   * Function that return the nearest plot details
   * @param   {number} chartX x-axis position of the mouse cordinate
   * @param   {number} chartY y-axis position of the mouse cordinate
   * @return {Object} return an object with details of nearest plot and whether it is
   *                   hovered or not
   */


  AreaDataset.prototype._getHoveredPlot = function _getHoveredPlot(chartX, chartY) {
    var dataset = this,
        xAxis = dataset.getFromEnv('xAxis'),
        components = dataset.components,
        dataStore = components.dataRT || components.data,
        pointObj,
        xMin,
        xMax,
        len = dataStore.length,
        returnValue,
        plotsPerBin = dataset.config.plotsPerBin || 1,
        numBinMin,
        numBinMax,
        binStrtIndex,
        binStopIndex = binStrtIndex + plotsPerBin - 1,
        conf = dataset.config,
        i,
        maxRadius = conf && conf.radius || 0;

    // getting new chart XY accordint to Translation of axis
    chartX += xAxis.getTranslation();

    xMin = Math.floor(Math.max(xAxis.getValue(chartX - maxRadius), 0));

    xMax = Math.ceil(Math.min(xAxis.getValue(chartX + maxRadius), len - 1));

    if (plotsPerBin > 1) {
      numBinMin = mathCeil(xMin / plotsPerBin);
      numBinMax = mathCeil(xMax / plotsPerBin);
      binStrtIndex = (numBinMin - 1) * plotsPerBin + 1;
      binStopIndex = numBinMax * plotsPerBin;
      xMin = binStrtIndex;
      xMax = binStopIndex;
    }

    for (i = xMax; i >= xMin; i--) {
      pointObj = dataStore[i];
      if (pointObj) {
        returnValue = dataset.isWithinShape(pointObj, i, chartX, chartY);
        if (returnValue) {
          break;
        }
      }
    }

    return returnValue;
  };
  /**
   * Determines the clip path needs to be applied on basis of argument type
   * @param  {string} type   type of clip applied
   * @return {Array}         ClipPath array for clipping
   */


  AreaDataset.prototype.getClip = function getClip(type) {
    var dataset = this,
        xAxis = dataset.getFromEnv('xAxis'),
        yAxis = dataset.getFromEnv('yAxis'),
        yAxisLimits = yAxis.getLimit(),
        xAxisLimits = xAxis.getLimit(),
        xMinPixel = xAxis.getPixel(xAxisLimits.min),
        yMinPixel = yAxis.getPixel(yAxisLimits.min),
        yMaxPixel = yAxis.getPixel(yAxisLimits.max),
        width = Math.abs(xAxis.getPixel(xAxisLimits.max) - xMinPixel),
        height = yMinPixel - yMaxPixel,
        resArr = [];

    resArr.push(xMinPixel);
    resArr.push(height < 0 ? yMinPixel : yMaxPixel);
    if (type === 'init') {
      resArr.push(0);
    } else if (type === 'canvas') {
      resArr.push(width);
    }
    resArr.push(Math.abs(height));
    return resArr;
  };

  AreaDataset.prototype.isWithinShape = function isWithinShape(pointObj, pX, x, y, setVal) {
    var anchorProps, config, radius, borderThickness, dataset, viewPortConfig, components, dataStore, dragTolerance, xPos, yPos, dx, dy, diff, hoverEffects, xShift;

    if (!pointObj || !(setVal = pointObj.config.setValue) && setVal !== 0) {
      return;
    }

    anchorProps = pointObj.config.anchorProps;
    config = pointObj.config;
    borderThickness = anchorProps && anchorProps.borderThickness;
    dataset = this;
    viewPortConfig = dataset.getFromEnv('chart').config.viewPortConfig;
    components = dataset.components;
    dataStore = components.dataRT || components.data;
    dragTolerance = (0, _lib.pluckNumber)(config.dragTolerance, 0);
    xShift = viewPortConfig ? viewPortConfig.x * viewPortConfig.scaleX : 0;

    xPos = pointObj._xPos - xShift;
    yPos = pointObj._yPos;

    if (yPos !== null) {
      hoverEffects = pointObj.config.hoverEffects;
      radius = Math.max(anchorProps && anchorProps.radius, hoverEffects && hoverEffects.anchorRadius || 0, HTP) + borderThickness / 2;

      if (!radius) {
        radius = 0;
      }
      dx = x - xPos;
      dy = y - yPos;
      diff = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));

      if (diff <= radius || diff <= dragTolerance) {
        return {
          pointIndex: pX,
          hovered: true,
          pointObj: dataStore[pX]
        };
      } else {
        return false;
      }
    }
  };

  /**
   * Determines the opacity of shadow
   * @return {Object} Opacity value of shadow
   */


  AreaDataset.prototype._parseShadowOptions = function _parseShadowOptions() {
    var dataSet = this,
        chart = dataSet.getFromEnv('chart'),
        conf = dataSet.config,
        chartAttr = chart.jsonData.chart,
        colorM = dataSet.getFromEnv('color-manager'),
        defaultShadow = (0, _lib.pluckNumber)(chart.defaultPlotShadow, colorM.getColor(SHOWSHADOW));
    return {
      opacity: (0, _lib.pluckNumber)(chartAttr.showshadow, defaultShadow) ? conf.alpha / 100 : 0
    };
  };
  /**
   * This method handles all mouse events of an dataset.
   * @param {string} eventType name of the event
   * @param {number} plotIndex index of the plot where this event has been occured
   * @param {Event} e reference of the original mouse event
   * @param {number} datasetIndex index of the dataSet on which the mouse is hovered
   */


  AreaDataset.prototype._firePlotEvent = function _firePlotEvent(eventType, plotIndex, e) {
    var dataset = this,
        chart = dataset.getFromEnv('chart'),
        components = dataset.components,
        toolTipController = dataset.getFromEnv('toolTipController'),
        dataStore = components.dataRT || components.data,
        data = dataStore[plotIndex],
        sharedAnchor = dataset.graphics.sharedAnchor,
        setElement = data.graphics.element || data.config.setValue !== UNDEF && sharedAnchor && sharedAnchor.element,
        toolTip = this.config.currentToolTip,
        originalEvent = e.originalEvent,
        style = dataset.getFromEnv('paper').canvas.style,
        config,
        eventArgs,
        setLink;

    if (setElement) {
      config = data.config;
      setLink = config.setLink;
      eventArgs = config.eventArgs;
      switch (eventType) {
        case 'mouseover':
          dataset._decideTooltipType(plotIndex, e);
          dataset._rolloverResponseSetter(chart, data, originalEvent);
          setLink && (style.cursor = POINTER);
          break;
        case 'mouseout':
          toolTipController.hide(toolTip);
          dataset._rolloutResponseSetter(chart, data, originalEvent);
          setLink && (style.cursor = DEFAULT_CURSOR);
          break;
        case 'click':
          _lib.plotEventHandler.call(setElement, chart, originalEvent, DATAPLOTCLICK, eventArgs);
          break;
        case 'mousemove':
          dataset._decideTooltipType(plotIndex, e);
      }
    }
  };

  AreaDataset.prototype._rolloverResponseSetter = function _rolloverResponseSetter(chart, data, event, onlyHoverEffect) {
    var dataset = this,
        dataGraphics = data.graphics,
        elem = dataGraphics && (dataGraphics.element || dataset.getAnchor(chart, data)),
        elData = elem && elem.getData(),
        hoverEnabled = elData.hoverEnabled;

    if (elData.draged !== true) {
      dataset._hoverFunc(data, ROLLOVER, hoverEnabled, chart.jsonData.chart);
      !onlyHoverEffect && elem && _lib.plotEventHandler.call(elem, chart, event, ROLLOVER);
    }
  };

  AreaDataset.prototype._rolloutResponseSetter = function _rolloutResponseSetter(chart, data, event, onlyHoverEffect) {
    var dataset = this,
        dataGraphics = data.graphics,
        elem = dataGraphics && (dataGraphics.element || dataset.getAnchor(chart, data, true)),
        elData = elem && elem.getData(),
        hoverEnabled = elData.hoverEnabled,
        plotType = dataset.type,
        dataConf = data.config,
        anchorProps = dataConf.anchorProps,
        isVisibleAnchor = anchorProps.radius && anchorProps.anchorAlpha;

    if (elData.draged !== true) {
      dataset._hoverFunc(data, ROLLOUT, hoverEnabled, chart.jsonData.chart);
      !onlyHoverEffect && elem && _lib.plotEventHandler.call(elem, chart, event, ROLLOUT);
    }
    // for area hide anchors if anchors radius and alpha disabled
    dataConf.isAnchorsDrawn && !isVisibleAnchor && plotType === 'area' && elem && elem.hide();
  };
  // create one anchor per dataset and move the anchor when


  AreaDataset.prototype.getAnchor = function getAnchor(chart, data, hideAnchor) {
    var dataset = this,
        chartGraphics = dataset.graphics,
        sharedAnchor = chartGraphics.sharedAnchor || (chartGraphics.sharedAnchor = {}),
        singleAnchor = sharedAnchor.element,

    // container = dataset.graphics.containers,
    paper = dataset.getFromEnv('paper'),
        config = data && data.config,
        anchorProps = config && config.anchorProps,
        eventArgs,
        setRolloutAttr,
        setRolloverAttr,
        hoverEffects,
        radius,
        anchorShadow,
        prevAnchorHovered,
        showHoverEffect;
    // If there in data value there will be no anchor properties hence return
    if (!anchorProps) {
      return;
    }
    eventArgs = config && config.eventArgs;
    setRolloutAttr = config && config.setRolloutAttr;
    setRolloverAttr = config && config.setRolloverAttr;
    hoverEffects = config && config.hoverEffects;
    radius = anchorProps && anchorProps.radius;
    anchorShadow = anchorProps && anchorProps.shadow;
    prevAnchorHovered = chart.config.prevAnchorHovered;
    showHoverEffect = anchorProps && anchorProps.anchorAlpha;
    // PREVENT default animation for shared anchors
    hoverEffects.anchorAnimation = 0;
    // if shared anchor is not created
    if (!singleAnchor) {
      singleAnchor = sharedAnchor.element = paper.polypath(dataset.getContainer('plotGroup'));
    }
    // add properties to the shared anchor
    if (data._index !== prevAnchorHovered) {
      singleAnchor.shadow(anchorShadow, dataset.getContainer('shadowGroup')).data('anchorRadius', radius).data('anchorHoverRadius', hoverEffects.anchorRadius).data('hoverEnabled', hoverEffects.enabled).data(EVENTARGS, eventArgs);

      // Storing necessary attributes in the element for future reference
      if (hoverEffects.enabled) {
        singleAnchor && singleAnchor.data(SETROLLOVERATTR, setRolloverAttr).data(SETROLLOUTATTR, setRolloutAttr);
      }
    }
    // on rollout hide anchor
    hideAnchor ? singleAnchor.hide() : showHoverEffect && singleAnchor.show();
    // save last hovered index
    prevAnchorHovered = config.prevAnchorHovered = data._index;
    return singleAnchor;
  };
  /**
   * Parses all the attributes for dataset level and set level
   * Called from init function of area class and line class
   * Both line and area attributes configuration is done here
   * @param {Object} datasetJSON the data provided by user
   * @return {boolean} false if datasetJSON is undefined
   */


  AreaDataset.prototype.configureAttributes = function configureAttributes(datasetJSON) {
    if (!datasetJSON) {
      return false;
    }
    this.trimData(datasetJSON);
    this.JSONData = datasetJSON;
    var dataSet = this,
        chart = dataSet.getFromEnv('chart'),
        chartConfig = chart.config,
        conf = dataSet.config,
        JSONData = dataSet.JSONData,
        chartAttr = chart.jsonData.chart,
        singleSeries = chart.singleseries,
        colorM = dataSet.getFromEnv('color-manager'),
        index = dataSet.getJSONIndex(),
        showplotborder = (0, _lib.pluckNumber)(JSONData.showplotborder, chartAttr.showplotborder || 1),
        plotFillColor = !singleSeries || (0, _lib.getValidValue)(chartAttr.palettecolors) ? colorM.getPlotColor(index) : colorM.getColor('plotFillColor').split(/\s*\,\s*/)[0],
        usePlotGradientColor = void 0,
        COMMASTRING = ',',
        BLANKSTRING = '',
        lineDashStyle = void 0,
        isDual = chartConfig.isdual,
        hasLineSet = chartConfig.haslineset;

    dataSet.__setDefaultConfig();
    (0, _lib.parseConfiguration)(JSONData, conf, chart.config, { data: true });

    conf.plotColor = plotFillColor;

    // Functional attributes configuration
    if (isDual) {
      // ParentYAxis is always 1 for lineset
      if (hasLineSet) {
        conf.parentYAxis = 1;
      } else {
        conf.parentYAxis = (0, _lib.pluck)(JSONData.parentyaxis && JSONData.parentyaxis.toLowerCase(), 'p') === 's' ? 1 : 0;
      }
    } else {
      conf.parentYAxis = 0;
    }

    // dataSet.yAxis = chartComponents.yAxis[parentYAxis];
    conf.valueposition = conf.valueposition.toLowerCase();

    // Data Plot cosmetics attributes configuration parsing
    conf.plotfillcolor = (0, _lib.pluck)(JSONData.color, chartAttr.plotfillcolor, plotFillColor);
    usePlotGradientColor = chartConfig.useplotgradientcolor;
    conf.plotgradientcolor = usePlotGradientColor !== 0 ? (0, _lib.getDefinedColor)(chartAttr.plotgradientcolor, colorM.getColor(PLOTGRADIENTCOLOR)) : '';

    conf.plotfillalpha = (0, _lib.pluck)(JSONData.alpha, chartConfig.plotfillalpha);
    conf.fillColor = {
      color: conf.plotfillcolor + (conf.plotgradientcolor ? COMMASTRING + conf.plotgradientcolor : BLANKSTRING),
      alpha: conf.plotfillalpha,
      angle: conf.plotfillangle
    };
    conf.plotborderalpha = showplotborder ? (0, _lib.pluck)(JSONData.plotborderalpha, chartAttr.plotborderalpha, JSONData.alpha, chartAttr.plotfillalpha, '95') : 0;
    conf.plotbordercolor = (0, _lib.pluck)(JSONData.plotbordercolor, chartAttr.plotbordercolor, chartAttr.areabordercolor, singleSeries ? (0, _lib.getValidValue)(chartAttr.palettecolors) ? colorM.getPlotColor(0) : colorM.getColor(PLOTBORDERCOLOR).split(/\s*\,\s*/)[0] : '666666');

    // Line configuration attributes parsing
    conf.drawLine = (0, _lib.pluckNumber)(JSONData.drawline, chartAttr.drawlines, 1);
    conf.plotborderdashstyle = conf.dashed ? (0, _lib.getDashStyle)(conf.plotborderdashlen, conf.plotborderdashgap) : NONE;
    conf.linecolor = (0, _lib.pluck)(JSONData.color, chartAttr.linecolor, conf.plotColor);

    conf.legendSymbolColor = dataSet.type === 'line' ? conf.linecolor : conf.plotfillcolor;

    lineDashStyle = (0, _lib.getDashStyle)(conf.linedashlen, conf.linedashgap);
    conf.lineDashStyle = conf.dashed ? lineDashStyle : NONE;

    conf.defaultPadding = {
      left: 0.5,
      right: 0.5
    };

    // conf.showShadow = pluckNumber(chartAttr.showshadow, 1);
    conf.shadow = dataSet._parseShadowOptions();
    // // Anchor cosmetics attributes in dataset level
    conf.drawanchors = (0, _lib.pluckNumber)(JSONData.drawanchors, JSONData.showanchors, chartAttr.showanchors, chartAttr.drawanchors);
    conf.anchorbgcolor = (0, _lib.pluck)(JSONData.anchorbgcolor, chartConfig.anchorbgcolor, colorM.getColor('anchorBgColor'));
    conf.anchorbordercolor = (0, _lib.pluck)(JSONData.anchorbordercolor, chartConfig.anchorbordercolor, conf.linecolor, conf.plotColor);
    // dataStore = dataSet.components.data = dataSet.components.data || (dataSet.components.data = []);
    dataSet.setState('visible', (0, _lib.pluckNumber)(JSONData.visible, !Number(JSONData.initiallyhidden), 1) === 1);
    this._setConfigure();
    dataSet._realTimeConfigure && dataSet._realTimeConfigure();
    chart.hasLegend !== false && dataSet._addLegend();
    dataSet.setState('dirty', true);
  };

  /**
   * Configure data level
   * @param {Object} newDataset new dataset added
   * @param {Object} newIndex new added dataset index
   */


  AreaDataset.prototype._setConfigure = function _setConfigure(newDataset, newIndex) {
    var dataSet = this,
        chart = dataSet.getFromEnv('chart'),
        conf = dataSet.config,
        chartConfig = chart.config,
        JSONData = dataSet.JSONData,
        chartAttr = chart.jsonData.chart,
        setDataArr = newDataset || JSONData.data || [],
        setData,
        dataObj,
        xAxis = dataSet.getFromEnv('xAxis'),
        yAxis = dataSet.getFromEnv('yAxis'),
        len = newDataset ? newDataset.data.length : xAxis.getCategoryLen(),
        dataStore,
        isDrag = chartConfig.isDrag,
        config,
        i,
        toolText,
        toolTipValue,
        setValue,
        setDisplayValue,
        macroIndices,
        parserConfig,
        formatedVal,
        seriesname,
        maxValue = -Infinity,
        minValue = +Infinity,
        catObj,
        yAxisName = (0, _lib.parseUnsafeString)(chartConfig.yaxisname),
        xAxisName = (0, _lib.parseUnsafeString)(chartConfig.xaxisname),
        tooltipSepChar = chartConfig.tooltipsepchar,

    // @todo please check this change done for multiaxisline also it may cause some problem there
    lineDashed = conf.dashed,
        // pluckNumber(JSONData.dashed, chartAttr.linedashed),
    tempIndex,
        setIndex,
        radius;

    conf.imageCount = 0;
    dataStore = dataSet.components.data;
    if (!dataStore) {
      dataStore = dataSet.components.data = [];
    }
    conf.maxRadius = -Infinity;
    chartConfig.dragTolerance = chartConfig.dragTolerance || -Infinity;

    for (i = 0; i < len; i++) {
      if (newDataset) {
        setData = newDataset && newDataset.data[i] || {};

        if (newIndex !== UNDEF) {
          tempIndex = newIndex + i;
          dataObj = dataStore[tempIndex];
        } else {
          tempIndex = dataStore.length - len + i;
          dataObj = dataStore[tempIndex];
        }
      } else {
        dataObj = dataStore[i];
        setData = setDataArr && setDataArr[i] || {};
      }

      config = dataObj && dataObj.config;

      if (!dataObj) {
        dataObj = dataStore[i] = {};
      }

      if (!dataObj.config) {
        config = dataStore[i].config = {};
      }

      if (!dataObj.graphics) {
        dataObj.graphics = {};
      }
      setIndex = (0, _lib.pluckNumber)(tempIndex - len, i);
      config.setValue = setValue = yAxis.getCleanValue(setData.value, conf.stack100percent);
      config.setLink = (0, _lib.pluck)(setData.link);
      // Parsing the anchor properties for set level
      config.anchorProps = this._parseAnchorProperties(setIndex);

      conf.maxRadius = mathMax(config.anchorProps.radius + config.anchorProps.borderThickness / 2, conf.maxRadius);

      radius = config.anchorProps.radius + config.anchorProps.borderThickness / 2;
      config.dragTolerance = isDrag ? (radius < 6 ? 5.5 : radius + 0.5) + HTP : 0;

      catObj = xAxis.getLabel(setIndex);
      config.label = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)(catObj.tooltext || catObj.label));
      config.showValue = (0, _lib.pluckNumber)(setData.showvalue, conf.showvalues);

      // Dashed, color and alpha configuration in set level is only for line chart
      config.dashed = (0, _lib.pluckNumber)(setData.dashed, lineDashed);
      config.dashStyle = config.dashed ? (0, _lib.getDashStyle)(conf.linedashlen, conf.linedashgap) : 'none';
      config.color = (0, _lib.pluck)(setData.color, conf.linecolor);
      config.setColor = setData.color;
      config.setAlpha = setData.alpha;
      config.setDashed = setData.dashed;
      config.alpha = (0, _lib.pluck)(setData.alpha, setData.linealpha, conf.linealpha);

      if (setValue !== null) {
        maxValue = mathMax(maxValue, setValue);
        minValue = mathMin(minValue, setValue);
      }
      config.setTooltext = (0, _lib.parseUnsafeString)(setData.toolText);
      config.toolTipValue = toolTipValue = yAxis.dataLabels(setValue);
      config.setDisplayValue = setDisplayValue = (0, _lib.parseUnsafeString)(setData.displayvalue);
      config.displayValue = (0, _lib.pluck)(setDisplayValue, toolTipValue);
      config.formatedVal = formatedVal = config.toolTipValue;
      config.setTooltext = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(setData.tooltext, JSONData.plottooltext, chartAttr.plottooltext)));
      config.valuePosition = (0, _lib.pluck)(setData.valueposition, conf.valueposition);
      if (config.valuePosition) {
        config.valuePosition = config.valuePosition.toLowerCase();
      }

      // Initial tooltext parsing
      if (!chartConfig.showtooltip) {
        toolText = false;
      } else {
        if (formatedVal === null) {
          toolText = false;
        } else if (config.setTooltext !== UNDEF) {
          macroIndices = [1, 2, 3, 4, 5, 6, 7];
          parserConfig = {
            yaxisName: yAxisName,
            xaxisName: xAxisName,
            formattedValue: formatedVal,
            label: config.label
          };
          toolText = (0, _lib.parseTooltext)(config.setTooltext, macroIndices, parserConfig, setData, chartAttr, JSONData);
        } else {
          if (chartConfig.seriesnameintooltip) {
            seriesname = (0, _lib.getFirstValue)(JSONData && JSONData.seriesname);
          }
          toolText = seriesname ? seriesname + tooltipSepChar : '';
          toolText += config.label ? config.label + tooltipSepChar : '';
        }
      }
      config.toolText = toolText;
      config.setLevelTooltext = config.setTooltext;
      // Storing x and y values for pixel calculations
      config._x = i;
      config._y = setValue;
      // Storing the initial parsed tooltext which will be later used in stack100percent calculations
      // on legend click
      config.setTooltext = toolText;
      config.hoverEffects = this._parseHoverEffectOptions(dataObj, setData);
      config.anchorProps.isAnchorHoverRadius = config.hoverEffects.anchorRadius;
      chartConfig.dragTolerance = mathMax(chartConfig.dragTolerance, conf.maxRadius, config.hoverEffects.anchorRadius);
    }
    chartConfig.dragTolerance = isDrag ? (chartConfig.dragTolerance > 5 ? chartConfig.dragTolerance : 5.5) + HTP : 0;
    conf.maxValue = maxValue;
    conf.minValue = minValue;
    dataSet.ErrorValueConfigure && dataSet.ErrorValueConfigure();
  };

  /**
   * Handle K-D Tree related tasks to ensure smooth hover experience.
   */


  AreaDataset.prototype.setupHoverTracker = function setupHoverTracker() {
    var dataset = this,

    // Search data to store data in separate array that will be used in KdTree search Algorithm
    searchDataArr = dataset.searchDataArr = [],
        dsComponents = dataset.components,
        dataStore = dsComponents.data,
        anchorProps = {},
        i,
        ii,
        xPos,
        yPos,
        dataObj,
        plotConfig;

    for (i = 0, ii = dataStore.length; i < ii; i++) {
      dataObj = dataStore[i];
      if (dataObj) {
        plotConfig = dataObj.config;
        xPos = plotConfig._Px;
        yPos = plotConfig._Py;
        anchorProps = plotConfig.anchorProps;
        // Pushing object to custom array that will be required for K-D Tree Search Algorithm
        // (in integer format)
        searchDataArr.push({
          x: xPos,
          y: yPos,
          index: i,
          data: dataObj,
          r: anchorProps.radius || 0
        });
      }
    }
    // Building KdTree with the x and y positions of all the plots.
    this.dataTree = new _kdtree2['default']().buildKdTree(searchDataArr);
  };

  /**
   * Function to draw line
   * @param {Object} anim The animation object which will be passed to animation manager. All
   *                      animation configuration should be pushed into this.
   * Line chart has a setLevel attribute 'color', thus line segments can have different colors,
   * but a line path can support only one color, so we are making multiple paths depending on the
   * color applied. lineOb is object having all line elements and key is the color and stroke combined,
   * thus all line segment having same color is grouped under one key. elements having different
   * line color is animated by fading in and out, on main color's line element transition is applied.
   */


  AreaDataset.prototype.drawCommonElements = function drawCommonElements(anim) {
    var dataset = this,
        dataStore = dataset.components.data,
        chart = dataset.getFromEnv('chart'),
        dsConfig = dataset.config,
        chartConfig = chart.config,
        paper = dataset.getFromEnv('paper'),
        containers = dataset.getContainer('plotGroup'),
        lineElement,
        prevProxyPathExpanded,
        finalPath,
        proxyPath,
        prevProxyPath,
        basePath,
        zeroPath,
        xAxis = dataset.getFromEnv('xAxis'),
        yAxis = dataset.getFromEnv('yAxis'),
        scrollMinVal = dsConfig.scrollMinVal,
        scrollMaxVal = dsConfig.scrollMaxVal,

    // Cosmetics
    isOnlyLineBorder = !chartConfig.drawfullareaborder,
        plotBorderColor = dsConfig.plotbordercolor,
        plotBorderAlpha = dsConfig.plotborderalpha,
        plotBorderDashStyle = dsConfig.plotborderdashstyle,
        plotBorderThickness = dsConfig.plotborderthickness,
        colorArr = dsConfig.fillColor,

    // shadow
    // shadow = dsConfig.shadow,
    firstDraw = !dataset.drawn,
        lineProps,
        connector,
        lim = {
      x: xAxis.getLimit(),
      y: yAxis.getLimit()
    },
        legendInteractivity = dsConfig.legendInteractivity,
        tempStore = [],
        i,
        shadow = dsConfig.shadow,
        shadowContainer = dataset.getContainer('shadowGroup'),
        isSingleStepAnim = chartConfig.isSingleStepAnim || chart.state === 'realTimeUpdate',
        positionObj,
        scrolling = xAxis.getState('scrolling'),
        firstRealTimeUpdate = chart.state === 'realTimeUpdate' && !dataset.realTimeUpdated;

    // Setting min and max pixels
    lim.x.minPixel = xAxis.getPixel(lim.x.min);
    lim.x.maxPixel = xAxis.getPixel(lim.x.max);
    lim.y.minPixel = yAxis.getPixel(lim.y.min);
    lim.y.maxPixel = yAxis.getPixel(lim.y.max);
    lim.y.base = yAxis.getPixel(0);
    lim.x.base = xAxis.getPixel(0);
    // Setting a tempdata store to save for next
    for (i = scrollMinVal; i < scrollMaxVal; i++) {
      if (!dataStore[i] || !dataStore[i].config) {
        continue;
      }
      tempStore[i] = {
        config: {
          _Px: dataStore[i].config._Px,
          _Pbx: dataStore[i].config._Pbx,
          _Py: dataStore[i].config._Py,
          _Pby: dataStore[i].config._Pby,
          setValue: dataStore[i].config.setValue
        }
      };
    }
    positionObj = {
      begin: scrollMinVal,
      end: scrollMaxVal
    };
    // Getting final path for area
    // If dataset is not visible area will morph to base
    finalPath = this.getLinePath(dataStore, {}, scrolling ? positionObj : null, !dataset.getState('visible') && 'base');

    // Getting path for area for animation
    basePath = this.getLinePath(dataStore, {}, null, 'base');
    if (!firstDraw) {
      // Get path to animate with axis
      prevProxyPath = this.getLinePathProxy(dsConfig.prevDataStore, {}, chartConfig.connectnulldataOld);
      prevProxyPathExpanded = this.getOldPath(prevProxyPath, lim);
      proxyPath = this.getLinePathProxy(dataStore, {}, chartConfig.connectnulldata);
    }
    // Creating Line Element
    lineElement = dataset.getGraphicalElement('lineElement');

    if (!scrolling) {
      // Creating line element if does not exist
      if (firstDraw || firstRealTimeUpdate) {
        zeroPath = this.getLinePath(dataStore, {}, null, 'zero');
        lineElement = dataset.addGraphicalElement('lineElement', paper.path(dataset.getContainer('commonElemsGroup')));
        // lineElement = dataset.graphics.lineElement = paper.path(dataset.getContainer('commonElemsGroup'));
        lineElement.attr({
          path: !isSingleStepAnim && zeroPath.getPathArr(),
          opacity: 0
        });
      }
      // Stop previous animation
      lineElement.stop();
      dataset.getState('visible') && lineElement.show();
      // Animate to original path
      if (firstDraw || legendInteractivity || !dataset.getState('visible') || isSingleStepAnim) {
        !isSingleStepAnim && legendInteractivity && dataset.getState('visible') && lineElement.attr({
          path: basePath.getPathArr()
        });
        if (chart.state === 'realTimeUpdate') {
          anim.plot.data.push({
            el: lineElement,
            attrs: {},
            preAnimFn: function preAnimFn() {
              this.attr({
                path: finalPath.getPathArr()
              }).attr({
                opacity: 1
              });
            },
            animType: firstDraw && 'easeOut' || 'easeIn'
          });
        } else if (!chartConfig.realTimeEnabled) {
          anim.plot.data.push({
            el: lineElement,
            attrs: {
              path: finalPath.getPathArr()
            },
            animConfig: [{
              hookFn: function hookFn() {
                this.attr({
                  opacity: 1
                });
              }
            }],
            animType: firstDraw && 'easeOut' || 'easeIn',
            callback: !dataset.getState('visible') && function () {
              this && this.hide();
            }
          });
        }
      } else {
        // Line animation in sync with axis
        anim.initial.data.push({
          el: lineElement,
          attrs: {
            path: prevProxyPathExpanded.getPathArr()
          },
          animConfig: [{
            syncWith: 'axis',
            hookFn: function hookFn() {
              lineElement.attr('path', prevProxyPath.getPathArr());
            }
          }]
        });
        // Animating to proxy path
        anim.plot.data.push({
          el: lineElement,
          attrs: {
            path: proxyPath.getPathArr()
          },
          animType: 'easeIn',
          animConfig: [{
            smartMorph: true,
            hookFn: function hookFn() {
              lineElement.attr({
                path: prevProxyPathExpanded.getPathArr()
              });
            }
          }],
          callback: function callback() {
            lineElement.attr({
              path: finalPath.getPathArr()
            });
          }
        });
      }

      // Fade in and out stroke
      if (!isSingleStepAnim) {
        // Fade out and in stroke
        anim.initial.data.push({
          el: lineElement,
          attrs: {
            'stroke-opacity': 0
          }
        });
        dataset.getState('visible') && anim['final'].data.push({
          el: lineElement,
          attrs: {
            'stroke-opacity': plotBorderAlpha / 100
          }
        });
      }
      // Getting line properties
      lineProps = {
        stroke: (0, _lib.toRaphaelColor)({
          color: plotBorderColor,
          alpha: plotBorderAlpha
        }),
        // Stroke width 0 when showing only upper line border
        'stroke-width': isOnlyLineBorder ? 0 : plotBorderThickness,
        'stroke-linecap': 'round',
        fill: (0, _lib.toRaphaelColor)(colorArr),
        'stroke-linejoin': plotBorderThickness > MAX_MITER_LINEJOIN ? 'round' : 'miter',
        'stroke-dasharray': plotBorderDashStyle
      };
      // Applying shadow
      lineElement.shadow(shadow, shadowContainer);
      // Applying Attribute on initial draw other wise animating
      if (firstDraw || firstRealTimeUpdate) {
        lineElement.attr(lineProps);
      } else {
        // animation code for cosmetics
        anim.plot.data.push({
          el: lineElement,
          attrs: lineProps
        });
      }
      // applying shadow on line
      // lineElement.shadow(shadow, containers.shadowContainer);
      // If drawfullareaborder is 0 only top border area is drawn
      if (isOnlyLineBorder) {
        connector = dataset.getGraphicalElement('connector');
        if (!connector) {
          connector = dataset.addGraphicalElement('connector', paper.path({
            path: finalPath.pathArr,
            stroke: (0, _lib.toRaphaelColor)({
              color: plotBorderColor,
              alpha: plotBorderAlpha
            }),
            'stroke-width': plotBorderThickness,
            'stroke-linecap': 'round',
            'stroke-linejoin': plotBorderThickness > MAX_MITER_LINEJOIN ? 'round' : 'miter',
            'stroke-dasharray': plotBorderDashStyle
          }, containers));
        }
        // Connector will fade out and then fade in
        connector.show();
        anim.initial.data.push({
          el: connector,
          attrs: {
            opacity: 0
          }
        });
        anim.plot.data.push({
          el: connector,
          attrs: {
            path: finalPath.pathArr
          }
        });
        anim['final'].data.push({
          el: connector,
          attrs: {
            opacity: 1
          }
        });
      } else {
        connector && anim.plot.data.push({
          el: connector,
          attrs: {
            opacity: 0
          }
        });
      }
    } else {
      anim.plot.data.push({
        el: lineElement,
        attrs: {
          path: finalPath.getPathArr()
        }
      });
    }
    // Saving limits
    dsConfig.prevLim = lim;
    // Saving data store
    dsConfig.prevDataStore = tempStore;
    if (chart.state === 'realTimeUpdate') {
      dataset.realTimeUpdated = true;
    }
    // Saving connectnulldata attribute
    chartConfig.connectnulldataOld = chartConfig.connectnulldata;
  };

  AreaDataset.prototype.doSkip = function doSkip(dataObj) {
    var dataSet = this,
        config = dataObj && dataObj.config,
        isSkipped = config && config.isSkipped,
        conf = dataSet.config,
        dataSkipped = conf.isSkippedData,
        legendInteractivity = conf.legendInteractivity,
        firstDraw = dataSet.drawn !== true,
        visible = dataSet.getState('visible'),
        setElement,
        imageElement,
        setValue;

    setElement = dataObj.graphics.element;
    imageElement = dataObj.graphics.image;
    setValue = config.setValue;

    if (setValue === undefined || isSkipped === true || dataSkipped !== false && !firstDraw && legendInteractivity && (!visible && !setElement || visible && setElement && !dataObj._xPos && !dataObj._yPos)) {
      setElement && setElement.hide();
      imageElement && imageElement.hide();

      config && (config.isSkipped = true);
      return true;
    }
    return false;
  };

  /**
    * drawPlots: Function to draw anchor elements or columns in case of column chart
    */


  AreaDataset.prototype.drawPlots = function drawPlots(anim) {
    var dataset = this,
        chart = dataset.getFromEnv('chart'),
        chartConfig = chart.config,
        datasetIndex = dataset.getJSONIndex(),
        visible = dataset.getState('visible'),
        containers = dataset.getContainer(),
        paper = dataset.getFromEnv('paper'),
        dsComponents = dataset.components,
        pool = dsComponents.pool || (dsComponents.pool = {
      element: [],
      hotElement: [],
      label: []
    }),
        dsConfig = dataset.config,
        dsGraphics = dataset.graphics,
        showTooltip = chartConfig.showToolTip,
        dataStore = dsComponents.data,
        connectNullData = dsConfig.connectNullData,
        chartAttr = chart.jsonData.chart,
        dsLen = dataStore.length,
        graphics,
        JSONData = dataset.JSONData,
        yAxis = dataset.getFromEnv('yAxis'),
        xAxis = dataset.getFromEnv('xAxis'),
        context = dataset.config.context = dataset.config.context || {},

    // getValidValue = lib.getValidValue,
    anchorGroup = dataset.getContainer('plotGroup'),
        setDataArr = JSONData.data || [],
        scrolling = xAxis.getState('scrolling'),
        i = 0,

    // noOfImages = 0,
    // isNewElem = false,
    // initialAnimation = false,
    lastYPos = null,
        animAttrObj = {},
        anchorProps = {},
        setRolloutAttr = {},
        setRolloverAttr = {},
        linePath = [],
        lastMoveCommand = [],
        setTooltext,
        xVal,
        yVal,
        setData,
        dataObj,
        setValue,
        setLink,
        symbol,
        toolText,

    // anchorRadius,
    eventArgs,
        lastXPos,
        setElement,
        imageElement,
        anchorBackground,
        hoverEffects,
        xPos,
        yPos,
        imgRef,
        anchorShadow,
        displayValue,
        plotConfig,

    // trackerConfig,
    animAttrs,
        animState,
        isAnchorVisible,
        anchorAlpha,
        radius,
        scrollMinVal,
        scrollMaxVal,
        _oldStartIndex = dsConfig._oldStartIndex,
        _oldEndIndex = dsConfig._oldEndIndex,
        visibleStart,
        visibleEnd,
        hasScroll = chart.hasScroll,
        sharedAnchor = dsGraphics.sharedAnchor,
        sharedElem = sharedAnchor && sharedAnchor.element,
        drwCnt = 0,
        step = chartConfig.viewPortConfig.step || 1;

    // Saving the anim attributes
    animAttrs = dsComponents.animAttrs = [];

    context.axisLimit = {
      yAxis: {
        limit: yAxis.getVisibleConfig()
      },
      xAxis: {
        limit: xAxis.getVisibleConfig()
      }
    };
    context.axisLimit.yAxis.limitPixel = {
      min: yAxis.getPixel(context.axisLimit.yAxis.limit.min),
      max: yAxis.getPixel(context.axisLimit.yAxis.limit.max)
    };

    context.axisLimit.xAxis.limitPixel = {
      min: xAxis.getPixel(context.axisLimit.xAxis.limit.min),
      max: xAxis.getPixel(context.axisLimit.xAxis.limit.max)
    };
    context.catLen = xAxis.getCategoryLen();
    // Sending anchor group to front
    _schedular2['default'].addJob(function () {
      anchorGroup.toFront();
    });

    dsConfig.scrollMinVal = scrollMinVal = hasScroll ? mathMax(mathRound(xAxis.getVisibleConfig().minValue) - 1, 0) : 0;
    dsConfig.scrollMaxVal = scrollMaxVal = hasScroll ? mathMin(mathRound(xAxis.getVisibleConfig().maxValue) + 2, dsLen) : dsLen;

    if (scrollMinVal > _oldStartIndex) {
      dataset.reuseFN(_oldStartIndex, scrollMinVal > _oldEndIndex ? _oldEndIndex : scrollMinVal);
    }
    if (scrollMaxVal < _oldEndIndex) {
      dataset.reuseFN(scrollMaxVal < _oldStartIndex ? _oldStartIndex : scrollMaxVal, _oldEndIndex);
    }

    visibleStart = scrollMinVal > _oldStartIndex ? scrollMinVal : _oldStartIndex;
    visibleEnd = scrollMaxVal < _oldEndIndex ? scrollMaxVal : _oldEndIndex;

    dsConfig._oldStartIndex = scrollMinVal;
    dsConfig._oldEndIndex = scrollMaxVal;
    chart.state === 'noAnim' && dataset.hideAllAnchors && dataset.hideAllAnchors();
    for (i = scrollMinVal; i < scrollMaxVal; i += step) {
      if (scrolling && hasScroll && !chartConfig.skipAttr && i > visibleStart && i < visibleEnd) {
        continue;
      }

      // Contains values given in the user's JSON
      setData = setDataArr[i];

      // Contains configurations specific to the 'i'th plot. Also contains an initially empty
      // graphics object which has the Raphael element associated with this plot
      dataObj = dataStore[i];

      if (!dataObj || !dataObj.config) {
        animAttrs.push(UNDEF);
        continue;
      }

      // Skip drawing unnecessary datasets
      if (dataset.doSkip(dataObj)) {
        continue;
      }

      if (setData) {
        setTooltext = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(setData.tooltext, JSONData.plottooltext, chartAttr.plottooltext)));
      }

      plotConfig = dataObj.config;
      graphics = dataObj.graphics;

      // xPos and yPos are the pixel conversions of the values provided.
      xPos = plotConfig._Px;
      yPos = plotConfig._Py;
      xVal = plotConfig._x;
      yVal = plotConfig._y;
      setLink = plotConfig.setLink;
      setValue = plotConfig.setValue;
      // showValue = plotConfig.showValue;
      anchorProps = plotConfig.anchorProps;
      displayValue = plotConfig.displayValue;
      // trackerConfig = plotConfig.trackerConfig = {};
      // Cache the hoverEffect configurations.
      hoverEffects = plotConfig.hoverEffects;
      // Get the tool text associated with the data plot
      toolText = plotConfig.toolText;
      // Storing the event arguments
      plotConfig.eventArgs = {
        index: i,
        link: setLink,
        value: setValue,
        displayValue: displayValue,
        toolText: toolText,
        id: dsConfig.userID,
        datasetIndex: datasetIndex || 0,
        datasetName: JSONData.seriesname,
        visible: visible
      };

      if (showTooltip) {
        toolText = toolText + (setTooltext ? '' : plotConfig.toolTipValue);
      } else {
        toolText = '';
      }

      plotConfig.finalTooltext = toolText;

      symbol = anchorProps.symbol;
      anchorShadow = anchorProps.shadow;
      anchorAlpha = anchorProps.anchorAlpha;
      radius = anchorProps.radius;
      isAnchorVisible = radius && anchorAlpha;

      /**
       * Storing the x position and y position in dataObject for future reference
       * For example - when drawing labels we need this xPos and yPos
       */
      dataObj._xPos = xPos;
      dataObj._yPos = yPos;
      dataObj._xVal = xVal;
      dataObj._yVal = yVal;
      dataObj._index = i;

      // State of the animation. Possible states are: default, initial, update, hide
      animState = 'default';

      if (yVal !== null && xVal !== null) {
        plotConfig.eventArgs.x = xVal;
        plotConfig.eventArgs.y = yVal;

        if (hoverEffects.enabled) {
          // Set the rollOver and rollOut attributes configurations only if hoverEffects are enabled.
          setRolloverAttr = {
            polypath: [hoverEffects.anchorSides || 2, xPos, yPos, hoverEffects.anchorRadius, hoverEffects.startAngle, hoverEffects.dip],
            fill: (0, _lib.toRaphaelColor)({
              color: hoverEffects.anchorColor,
              alpha: hoverEffects.anchorBgAlpha
            }),
            stroke: (0, _lib.toRaphaelColor)({
              color: hoverEffects.anchorBorderColor,
              alpha: hoverEffects.anchorBorderAlpha
            }),
            'stroke-width': hoverEffects.anchorBorderThickness
          };

          setRolloutAttr = {
            // XXX: Is this validated yet??!
            // TODO: in the new architechture, instead of symbol it was anchorsides. Please validate.
            polypath: [symbol[1] || 2, xPos, yPos, anchorProps.radius, anchorProps.startAngle, 0],
            fill: (0, _lib.toRaphaelColor)({
              color: anchorProps.bgColor,
              alpha: anchorProps.bgAlpha
            }),
            stroke: (0, _lib.toRaphaelColor)({
              color: anchorProps.borderColor,
              alpha: anchorProps.borderAlpha
            }),
            'stroke-width': anchorProps.borderThickness
          };

          hoverEffects.attrs = {
            'hoverEnabled': hoverEffects.enabled,
            'anchorRadius': anchorProps.radius,
            'anchorHoverRadius': hoverEffects.anchorRadius
          };

          hoverEffects.attrs[SETROLLOVERATTR] = setRolloverAttr;
          hoverEffects.attrs[SETROLLOUTATTR] = setRolloutAttr;

          anchorProps.isAnchorHoverRadius = hoverEffects.attrs.anchorRadius;
        }

        if (anchorProps.imageUrl) {
          // If imageurl is present, i.e., the data plot is an image
          imgRef = new Image();
          plotConfig.anchorImageLoaded = false;

          if (!visible) {
            // Hide the image if it should not be visible
            animAttrObj = {
              opacity: 0
            };
            animState = 'hide';
          }

          imageElement = graphics.image;
          if (!imageElement) {
            if (pool.image && pool.image.length) {
              imageElement = graphics.image = pool.image.shift();
              imageElement.show();
            } else {
              imageElement = graphics.image = imageElement = paper.image(anchorGroup);
            }
            animState = 'initial';
            imageElement.attr({
              opacity: 0
            });
          } else {
            animState = 'update';
          }

          imageElement.attr('src', anchorProps.imageUrl);

          anchorBackground = graphics.element;
          if (!anchorBackground) {
            if (pool.element && pool.element.length) {
              anchorBackground = graphics.element = pool.element.shift();
            } else {
              anchorBackground = graphics.element = paper.polypath(anchorGroup);
            }
          }

          imgRef.onload = this._onAnchorImageLoad(dataset, i, eventArgs, xPos, yPos);
          imgRef.onerror = this._onErrorSetter(dataset, i);
          imgRef.src = anchorProps.imageUrl;
        } else {
          // Else the data plot is not an image.
          /**
           * The Raphael Element referring to the current data plot.
           * @type {Element}
           */
          setElement = graphics.element;

          // Hide the image element (in case it was present and visible)
          imageElement = graphics.image;
          imageElement && imageElement.hide();

          if (!setElement) {
            // If there is no existing graphics element then create it.
            if (pool.element && pool.element.length) {
              // Reuse the cache element
              setElement = graphics.element = pool.element.pop();
            } else {
              // If there is no element in cache store then create it.
              setElement = graphics.element = paper.polypath(containers.plotGroup);
              // The element was clearly newly created.
              // isNewElem = true;
              // plotConfig.isAnchorsDrawn = true;
              // new anchor drawn
            }
            drwCnt++;

            // Then, animate it in sync with plot. Raise the plot to its actual y-position.
            // Change the plot's opacity to its actual opacity. Adjust other cosmetics as per
            // configuration.
            animAttrObj = {
              polypath: [symbol[1] || 2, xPos, yPos, anchorProps.radius, anchorProps.startAngle, 0],
              fill: (0, _lib.toRaphaelColor)({
                color: anchorProps.bgColor,
                alpha: anchorProps.bgAlpha
              }),
              stroke: (0, _lib.toRaphaelColor)({
                color: anchorProps.borderColor,
                alpha: anchorProps.borderAlpha
              }),
              'stroke-width': anchorProps.borderThickness,
              opacity: 1,
              'fill-opacity': anchorProps.bgAlpha,
              'stroke-opacity': 1
            };
            animState = 'initial';
          } else {
            // There was an existing graphics element. Adjust its attributes as necessary.
            if (visible && isAnchorVisible) {
              // If the element should continue to be visible, adjust its attributes as necessary.
              animAttrObj = {
                polypath: [symbol[1] || 2, xPos, yPos, anchorProps.radius, anchorProps.startAngle, 0],
                fill: (0, _lib.toRaphaelColor)({
                  color: anchorProps.bgColor,
                  alpha: anchorProps.bgAlpha
                }),
                stroke: (0, _lib.toRaphaelColor)({
                  color: anchorProps.borderColor,
                  alpha: anchorProps.borderAlpha
                }),
                'stroke-width': anchorProps.borderThickness,
                opacity: 1,
                'fill-opacity': anchorProps.bgAlpha,
                'stroke-opacity': 1
              };
              animState = 'update';
            } else {
              // The element should not continue to be visible.
              // Move the element to the bottom of the canvas. Fade out the element.
              animAttrObj = {
                polypath: [symbol[1] || 2, xPos, chartConfig.canvasBottom, anchorProps.radius, anchorProps.startAngle, 0],
                opacity: 0,
                'fill-opacity': 0,
                'stroke-opacity': 0
              };
              animState = 'hide';
            }
          }

          if (!(plotConfig.isAnchorsDrawn || dsConfig.drawanchors || isAnchorVisible)) {
            // If no anchor is required the hide anchor
            setElement && !isAnchorVisible && setElement.hide();
            continue;
          }

          // graphics.element && graphics.element.show();

          // Set all attributes that are not related to position.
          setElement.attr({
            'cursor': setLink ? POINTER : ''
            // visibility: !anchorProps.radius ? hiddenStr : visible
          });

          // Add the shadow of the eleemnt to the shadow container
          setElement.shadow(anchorShadow, containers.shadowGroup);

          // TODO: The condition was used in old architechture. Please validate.
          // Create the hot element only under the following conditions.
          // if (setLink || showTooltip || hoverEffects) {
          //   // Anchor radius of hot element is set to maximum of hover radius and anchor radius.
          //   anchorRadius = mathMax(anchorProps.radius, hoverEffects.anchorRadius || 0);
          //   trackerConfig.trackerRadius = anchorRadius;
          // }
        }

        // graphics.element && graphics.element.show();

        if (hoverEffects.enabled) {
          setElement && setElement.data('hoverEnabled', hoverEffects.attrs.hoverEnabled).data('anchorRadius', hoverEffects.attrs.anchorRadius).data('anchorHoverRadius', hoverEffects.attrs.anchorHoverRadius).data(SETROLLOVERATTR, hoverEffects.attrs[SETROLLOVERATTR])
          // .data('alwaysInvisible', hoverEffects.attrs.alwaysInvisible)
          // .data('setRolloverProperties', hoverEffects.attrs.setRolloverProperties)
          .data(SETROLLOUTATTR, hoverEffects.attrs[SETROLLOUTATTR]);
        }

        // If the y-position of the last value is not null.
        if (lastYPos !== null) {
          if (lastMoveCommand.length) {
            linePath = linePath.concat(lastMoveCommand);
            lastMoveCommand.length = 0;
          }
          // move to the starting position of the line segment
          if (!linePath.join('')) {
            linePath.push(M, lastXPos, lastYPos);
          }
          // Draw line to end position
          linePath.push(L, xPos, yPos);
        } else {
          // Pushing the x  y position of move command to lastMoveCommand array
          lastMoveCommand.push(M, xPos, yPos);
        }

        // Storing the xPos and yPos of this data for next iterations.
        lastXPos = xPos;
        lastYPos = yPos;

        // !anchorProps.imageUrl && this.drawLabel(i);
        setElement && setElement.data(EVENTARGS, plotConfig && plotConfig.eventArgs);
      } else {
        if (setValue) {
          setValue.isNull = true;
        }

        lastMoveCommand.length = 0;
        if (!connectNullData) {
          lastYPos = null;
        }

        animAttrObj = {
          polypath: [symbol[1] || 2, xPos, chartConfig.canvasBottom, anchorProps.radius, anchorProps.startAngle, 0],
          'opacity': 0,
          'stroke-opacity': 0,
          'fill-opacity': 0
        };
        animState = 'hide';
      }
      animAttrs.push({
        attrs: animAttrObj,
        state: animState,
        elem: graphics.element,
        image: graphics.image
      });
    }

    // In a case when all the anchors and shared anchor both are drawn then hide
    // shared anchor and if chart is rendered without any anchors draw a single anchor.
    if (i === drwCnt || dsConfig.drawanchors) {
      sharedElem && sharedElem.hide();
    } else {
      if (sharedAnchor && sharedElem) {
        sharedElem.hide();
      } else {
        dataset.getAnchor(chart, dataObj, true);
      }
    }

    // Animating plots
    dataset.animatePlots(anim);
  };

  /**
   * Animate the plot elements in steps
   * @param {Object} anim - Animation slots of different steps
   */


  AreaDataset.prototype.animatePlots = function animatePlots(anim) {
    var dataset = this,
        chart = dataset.getFromEnv('chart'),
        chartConfig = chart.config,
        isSingleStepAnim = chartConfig.isSingleStepAnim || chart.state === 'realTimeUpdate',
        dsComponents = dataset.components,
        dataStore = dsComponents.data,
        animStore = dsComponents.animAttrs,
        dsLen = dataStore.length,
        visible = dataset.getState('visible'),
        showAndSet = function showAndSet(attrs) {
      this.show().attr(attrs);
    },
        dataObj,
        animObj,
        animState,
        animAttrs,
        animElem,
        i,
        ii,
        imageAlpha,
        animImage,
        changeAttr = function changeAttr() {
      this.attr({
        opacity: 0
      });
    };

    for (i = 0, ii = dsLen; i < ii; i += 1) {
      dataObj = dataStore[i];
      animObj = animStore[i];

      if (!dataObj || !animObj || !animObj.elem) {
        continue;
      }

      imageAlpha = dataObj.config.anchorProps.imageAlpha * 0.01;

      animState = animObj.state;
      animAttrs = animObj.attrs;
      animElem = animObj.elem;
      animImage = animObj.image;
      !visible && (animAttrs.opacity = 0);
      animElem.show();
      if (isSingleStepAnim) {
        anim.plot.data.push({
          el: animElem,
          attrs: animAttrs
        });
      } else {
        if (animState === 'initial') {
          anim['final'].data.push({
            el: animElem,
            // type: visible ? 'fadeIn' : 'fadeOut',
            animConfig: [{
              hookFn: showAndSet.bind(animElem, animAttrs)
            }]
          });

          animImage && anim['final'].data.push({
            el: animImage,
            type: 'linear',
            attrs: {
              opacity: imageAlpha
            },
            animConfig: [{
              hookFn: changeAttr
            }]
          });
        } else if (animState === 'update') {
          anim.initial.data.push({
            el: animElem,
            type: 'fadeOut'
          });

          animImage && anim.initial.data.push({
            el: animImage,
            type: 'linear',
            attrs: {
              opacity: 0
            }
          });

          // Apearing anchors will fadeIn at last
          animElem.hide();
          animImage && animImage.hide();
          anim['final'].data.push({
            el: animElem,
            type: visible ? 'fadeIn' : 'fadeOut',
            animConfig: [{
              hookFn: showAndSet.bind(animElem, animAttrs)
            }]
          });

          animImage && anim['final'].data.push({
            el: animImage,
            type: 'linear',
            attrs: {
              opacity: imageAlpha
            }
          });
          // }
        } else if (animState === 'hide') {
          anim.initial.data.push({
            el: animElem,
            type: 'fadeOut'
          });

          animImage && anim['final'].data.push({
            el: animImage,
            type: 'linear',
            attrs: {
              opacity: 0
            }
          });
        } else {
          animElem.attr(animAttrs);
        }
      }
    }
  };

  /**
   * Remove the plot elements in step animation
   * @param {Object} anim - Animation slots of different steps
   */


  AreaDataset.prototype.removeElements = function removeElements(anim) {
    var dataSet = this,
        components = dataSet.components,
        removeDataArr = components.removeDataArr,
        pool = components.pool || (components.pool = {
      element: [],
      hotElement: [],
      label: []
    }),
        removeData,
        maxminFlag = dataSet.maxminFlag,
        ele,
        graphics,
        i,
        chart = dataSet.getFromEnv('chart'),
        xAxis = dataSet.getFromEnv('xAxis'),
        isRealtimeRemoved = function isRealtimeRemoved(el) {
      return el.attrs.x === xAxis.getPixel(0);
    },
        applyAttr = function applyAttr(el, attr) {
      return function () {
        el.attr(attr);
      };
    },
        animCallBack = function animCallBack() {
      this.hide();
    };

    for (i = removeDataArr.length - 1; i >= 0; i--) {
      removeData = removeDataArr[i];
      removeDataArr.splice(i, 1);
      // In case of non existing data plot continue;
      if (!removeData || !removeData.graphics) {
        continue;
      }

      graphics = removeData.graphics;
      for (ele in graphics) {
        if (ele === 'label' && dataSet.startPosition === UNDEF && dataSet.endPosition === UNDEF) {
          anim.initial.data.push({
            el: graphics[ele],
            type: 'fadeOut'
          });
        }

        if (ele === 'label' && chart.state === 'realTimeUpdate' && isRealtimeRemoved(graphics[ele])) {
          anim.initial.data.push({
            el: graphics[ele],
            preAnimFn: applyAttr(graphics[ele], {
              x: graphics[ele].attrs.x - (xAxis.getPixel(1) - xAxis.getPixel(0))
            }),
            type: 'fadeOut'
          });
        } else if (ele === 'label') {
          anim.initial.data.push({
            el: graphics[ele],
            type: 'fadeOut'
          });
        }

        anim.initial.data.push({
          el: graphics[ele],
          type: 'fadeOut'
        });

        anim.initial.data.push({
          el: graphics[ele],
          type: 'fadeOut',
          callback: animCallBack
        });
      }

      // Storing the graphic elements for reuse.
      removeData.graphics.element && (pool.element = pool.element.concat(removeData.graphics.element));
      removeData.graphics.hotElement && (pool.hotElement = pool.hotElement.concat(removeData.graphics.hotElement));
      removeData.graphics.label && (pool.label = pool.label.concat(removeData.graphics.label));
    }

    components.pool = pool;
    maxminFlag && dataSet.getDataLimits();
  };

  /**
   * Calculate current pos w.r.t prev for an array
   * @param   {Object}  path   current path
   * @param   {Object}  lim    x,y axis limits
   * @return {Array}          Old path
   */


  AreaDataset.prototype.getOldPath = function getOldPath(path, lim) {
    var dataSet = this,
        xLim = lim.x,
        yLim = lim.y,
        oldLim = dataSet.config && dataSet.config.prevLim,
        oldLimX = oldLim.x,
        oldLimY = oldLim.y,
        i = 0,
        ii = path.pathArr.length,
        item,
        arr = [],
        getOldValX = function getOldValX(val) {
      // getting ratio by pixels
      val = (val - oldLimX.minPixel) / (oldLimX.maxPixel - oldLimX.minPixel);
      // ratio to value
      val = val * (oldLimX.max - oldLimX.min) + oldLimX.min;
      // value in old ratio
      val = (val - xLim.min) / (xLim.max - xLim.min);
      // return position in previous
      return val * (xLim.maxPixel - xLim.minPixel) + xLim.minPixel + 1;
    },
        getOldValY = function getOldValY(val) {
      if (val < oldLimY.base && val > yLim.base || val > oldLimY.base && val < yLim.base) {
        val = yLim.base;
      }
      return val - 1;
    },
        getOldValYBase = function getOldValYBase(val) {
      if (val === oldLimY.base) {
        return yLim.base;
      }
      return getOldValY(val);
    };
    if (oldLimY.min === yLim.min && oldLimX.min === xLim.min && oldLimY.max === yLim.max && oldLimX.max === xLim.max) {
      return path;
    }
    path = (0, _lib.extend2)({}, path);
    if (!oldLim) {
      return arr;
    }
    // generating new copy of array
    path.pathArr = path.pathArr.slice(0);
    path.path2Arr = path.path2Arr.slice(0);
    for (i = ii; i--;) {
      item = path.pathArr[i].slice(0);
      // check if array
      if (!item[1] || !item.join) {
        continue;
      }
      item[1] = getOldValX(item[1]);
      item[2] = getOldValYBase(item[2]);
      path.pathArr[i] = item;
    }
    for (i = path.path2Arr.length; i--;) {
      item = path.path2Arr[i].slice(0);
      // check if array
      if (!item[1] || !item.join) {
        continue;
      }
      item[1] = getOldValX(item[1]);
      item[2] = getOldValYBase(item[2]);
      path.path2Arr[i] = item;
    }
    return path;
  };

  AreaDataset.prototype.getPathArr = function getPathArr() {
    var pathObj = this,
        pathArr = pathObj.pathArr,
        path2Arr = pathObj.path2Arr;

    if (pathArr.length || path2Arr.length) {
      return pathArr.concat(path2Arr);
    } else {
      return [];
    }
  };

  AreaDataset.prototype.getLinePath = function getLinePath(data, lastObj, positions, type) {
    var dataset = this,
        chart = dataset.getFromEnv('chart'),
        chartConfig = chart.config,
        connectNullData = chartConfig.connectnulldata,
        obj = lastObj || {},

    // Used for determining whether the last value was valid
    // Initially it is false
    lastValidValue = obj.lastValidValue || false,
        temp = obj.temp || [],
        temp2 = obj.temp2 || [],
        pathArr = obj.pathArr || [],
        path2Arr = obj.path2Arr || [],
        i,
        config,
        xPos,
        yPos,
        baseXPos,
        baseYPos,
        length = data.length,
        pointsJoined = obj.pointsJoined || 0,
        dataObj,
        setValue,
        startPos = positions && positions.begin || 0,
        endPos = positions && positions.end || length,
        step = chartConfig.viewPortConfig.step || 1,
        yAxis = dataset.getFromEnv('yAxis'),
        xAxis = dataset.getFromEnv('xAxis'),
        baseZero = yAxis.getPixel(0),
        removeDataLen = dataset.removeDataLen || 0,
        prevStore = dataset.config.prevDataStore,
        dataWithRemovedPaths = [],
        xDiff = (xAxis.getPixel(1) - xAxis.getPixel(0)) * removeDataLen,
        item;

    // Pushing removed data into array if in realtime
    if (chart.state === 'realTimeUpdate') {
      for (i = 0; i < removeDataLen; ++i) {
        if (!prevStore) {
          continue;
        }
        item = prevStore[i];
        item && (item = item.config);
        if (!item) {
          continue;
        }
        dataWithRemovedPaths.push({
          config: {
            _Px: item._Px - xDiff,
            _Py: item._Py,
            _Pby: item._Pby && baseZero,
            _Pbx: item._Pbx && item._Pbx - xDiff,
            setValue: item.setValue
          }
        });
      }
    } else {
      // No need to iterate more if not in
      // realTimeUpdated
      removeDataLen = 0;
    }
    // Added current dataStore to arr
    dataWithRemovedPaths = dataWithRemovedPaths.concat(data);

    for (i = startPos; i < endPos + removeDataLen; i += step) {
      dataObj = dataWithRemovedPaths[i];
      if (!dataObj) {
        continue;
      }

      config = dataObj.config;
      setValue = config.setValue;

      // skip the data plot if isSkipped flag is set to false
      if (setValue === UNDEF || config && config.isSkipped === true) {
        config && delete config.isSkipped;
        continue;
      }
      xPos = config._Px;
      yPos = config._Py;
      baseXPos = config._Pbx;
      baseYPos = config._Pby;

      // take base or zero y value for animation
      if (type === 'zero') {
        yPos = baseZero;
        baseYPos = baseZero;
      } else if (type === 'base') {
        yPos = config._Pby;
      }
      // create the path array
      // If the last value is valid
      if (setValue === null || setValue.isNull) {
        // If null data points are also to be connected
        if (!connectNullData) {
          // Checking if any points are joined then closing the path
          if (pointsJoined > 0) {
            // Check if the last command of the path is not Z
            if (path2Arr[path2Arr.length - 1] !== Z && baseYPos !== UNDEF) {
              path2Arr.push(Z);
            }
            pathArr = pathArr.concat(path2Arr);
            path2Arr = [];
          }
          temp = [];
          temp2 = [];
          lastValidValue = false;
        }
      } else {
        if (lastValidValue) {
          if (temp.length) {
            pathArr = pathArr.concat(temp);
            if (baseXPos !== UNDEF) {
              path2Arr = temp2;
              temp2 = [];
            }
            temp = [];
            pointsJoined++;
          }
          // Push the upper x and y position to pathArr
          pathArr.push([L, xPos, yPos]);
          if (baseYPos !== UNDEF) {
            // Push the lower x y positions to the front of the array for joining the last
            // upper point and first lower point of the area plot
            path2Arr.unshift([L, xPos, baseYPos]);
          }
        } else {
          // Push the upper x and y positions of area plot to temp
          temp.push([M, xPos, yPos]);
          if (baseYPos !== UNDEF) {
            // Push the lower x and y position of area plot to temp2
            temp2.push([L, baseXPos, baseYPos]);
          }
          // No points are joined when starting a new path
          pointsJoined = 0;
          lastValidValue = true;
        }
      }
    }
    // If path is not closed and any points are joined then close the path
    if (path2Arr[path2Arr.length - 1] !== Z && pointsJoined > 0 && baseYPos !== UNDEF) {
      path2Arr.push(Z);
    }
    return {
      pathArr: pathArr,
      path2Arr: this.getName() === 'line' ? [] : path2Arr,
      lastValidValue: lastValidValue,
      pointsJoined: pointsJoined,
      temp: temp,
      temp2: temp2,
      getPathArr: dataset.getPathArr
    };
  };

  AreaDataset.prototype.getLinePathProxy = function getLinePathProxy(data, lastObj, connectNullData) {
    var dataset = this,
        chart = dataset.getFromEnv('chart'),
        isStacked = chart.config.isstacked,
        chartConfig = chart.config,

    // connectNullData = chartConfig.connectnulldata,
    obj = lastObj || {},

    // Used for determining whether the last value was valid
    // Initially it is false
    lastValidValue = obj.lastValidValue || false,
        temp = obj.temp || [],
        temp2 = obj.temp2 || [],
        pathArr = obj.pathArr || [],
        path2Arr = obj.path2Arr || [],
        i,
        config,
        xPos,
        yPos,
        baseXPos,
        baseYPos,
        length = data.length,
        pointsJoined = obj.pointsJoined || 0,
        dataObj,
        setValue,
        startPos = 0,
        endPos = length,
        step = chartConfig.viewPortConfig.step || 1,
        prev = {},
        joinWithPrev = false,
        prevValue;

    for (i = startPos; i < endPos; i += step) {
      dataObj = data[i];
      if (!dataObj) {
        continue;
      }

      config = dataObj.config;
      setValue = config.setValue;
      xPos = config._Px;
      yPos = config._Py;
      // skip the data plot if isSkipped flag is set to false
      if (setValue === UNDEF || config && config.isSkipped === true) {
        config && delete config.isSkipped;
        continue;
      }
      baseXPos = config._Pbx;
      baseYPos = config._Pby;
      // create the path array
      if (setValue === null) {
        // connect previously left path
        if (!pathArr.length) {
          continue;
        }
        // Connect previous to its base
        if (prevValue !== null) {
          // Pushing multiple times to create different number of
          // points so that redraphael's differential algorithm
          // could work
          if (!connectNullData) {
            pathArr.push([L, prev.bX, prev.bY]);
            pathArr.push([L, prev.bX, prev.bY]);
            pathArr.push([L, prev.bX, prev.bY]);
            // Asking next line to join its base
            // to this point
            joinWithPrev = true;
          }
        }
        // Last value isnt valid
        lastValidValue = false;
      } else {
        // Starting the path
        if (!pathArr.length) {
          pathArr.push([M, baseXPos, baseYPos]);
        }
        // Joining base if necessary
        if (joinWithPrev) {
          joinWithPrev = false;
          pathArr.push([L, baseXPos, baseYPos]);
        }
        // Connecting line
        pathArr.push([L, xPos, yPos]);
        if (isStacked && dataset.getJSONIndex()) {
          path2Arr.unshift([L, baseXPos, baseYPos]);
        }
      }
      // Storing values
      prevValue = setValue;
      setValue !== null && (prev = {
        val: setValue,
        x: xPos,
        y: yPos,
        bX: baseXPos,
        bY: baseYPos
      });
    }

    pathArr.push([L, prev.bX, prev.bY]);
    return {
      pathArr: pathArr,
      path2Arr: path2Arr,
      lastValidValue: lastValidValue,
      pointsJoined: pointsJoined,
      temp: temp,
      temp2: temp2,
      getPathArr: dataset.getPathArr
    };
  };
  // Function to remove a data from a dataset during real time update.


  AreaDataset.prototype._removeDataVisuals = function _removeDataVisuals(dataObj) {
    var dataSet = this,
        pool = dataSet.components.pool || (dataSet.components.pool = {}),
        elementPool,
        ele,
        graphics,
        graphicsObj;
    if (!dataObj) {
      return;
    }
    graphics = dataObj.graphics;
    for (ele in graphics) {
      elementPool = pool[ele] || (pool[ele] = []);
      graphicsObj = graphics[ele];
      if (graphicsObj.hide && typeof graphicsObj.hide === 'function') {
        graphicsObj.attr({
          'text-bound': []
        });
        graphicsObj.hide();
        graphicsObj.shadow && graphicsObj.shadow(false);
      }
      elementPool.push(graphics[ele]);
    }
  };
  /**
    * parse the anchor properties at set level
    * @param {number} i - set index
    * Called from configure function of area class for each set data of dataset
    */


  AreaDataset.prototype._parseAnchorProperties = function _parseAnchorProperties(i, dataArr) {
    var dataSet = this,
        conf = dataSet.config,
        plotType = dataSet.type,
        chart = dataSet.getFromEnv('chart'),
        anchorAlpha = chart.config.anchoralpha,
        defaultAnchorVisibility = (!chart.config.anchoralpha && plotType) === 'area' ? 0 : 1,
        JSONData = dataSet.JSONData,
        chartAttr = chart.jsonData.chart,
        setDataArr = dataArr || JSONData.data || [],
        setData = setDataArr[i] || {},
        anchorProps = {},
        mapSymbolName = _lib.graphics.mapSymbolName,
        showAnchorShadow,
        anchorAttrsDefined,
        drawAnchors;
    // Check if anchor attributes are defined
    anchorAttrsDefined = (0, _lib.pluck)(setData.anchorstartangle, JSONData.anchorstartangle, chartAttr.anchorstartangle, setData.anchorimagealpha, JSONData.anchorimagealpha, chartAttr.anchorimagealpha, setData.anchorimagescale, JSONData.anchorimagescale, chartAttr.anchorimagescale, setData.anchorimagepadding, JSONData.anchorimagepadding, chartAttr.anchorimagepadding, setData.anchorimageurl, JSONData.anchorimageurl, chartAttr.anchorimageurl, setData.anchorradius, JSONData.anchorradius, chartAttr.anchorradius, setData.anchorbgcolor, JSONData.anchorbgcolor, chartAttr.anchorbgcolor, setData.anchorbordercolor, JSONData.anchorbordercolor, chartAttr.anchorbordercolor, setData.anchoralpha, JSONData.anchoralpha, chartAttr.anchoralpha, setData.anchorsides, JSONData.anchorsides, chartAttr.anchorsides, setData.anchorborderthickness, JSONData.anchorborderthickness, chartAttr.anchorborderthickness, UNDEF) !== UNDEF;
    drawAnchors = (0, _lib.pluckNumber)(setData.drawanchors, conf.drawanchors);
    /*
        If any anchor attribute is defined then we choose between draw anchors attribute
        and whether any anchor attributes are defined
        Otherwise we choose between default anchor visibility which is false for area
        and true for line and drawanchors attribute
    */
    if (anchorAttrsDefined) {
      anchorProps.enabled = (0, _lib.pluckNumber)(drawAnchors, anchorAttrsDefined);
    } else {
      anchorProps.enabled = (0, _lib.pluckNumber)(drawAnchors, defaultAnchorVisibility);
    }
    anchorProps.startAngle = (0, _lib.pluckNumber)(setData.anchorstartangle, conf.anchorstartangle);
    anchorProps.imageAlpha = (0, _lib.pluckNumber)(setData.anchorimagealpha, conf.anchorimagealpha);
    anchorProps.imageScale = (0, _lib.pluckNumber)(setData.anchorimagescale, conf.anchorimagescale);
    anchorProps.imagePadding = (0, _lib.pluckNumber)(setData.anchorimagepadding, conf.anchorimagepadding);
    if (anchorProps.imagePadding < 0) {
      anchorProps.imagePadding = 0;
    }
    anchorProps.imageUrl = (0, _lib.pluck)(setData.anchorimageurl, conf.anchorimageurl);
    if (anchorProps.imageUrl) {
      conf.imageCount++;
    }
    anchorProps.radius = (0, _lib.pluckNumber)(setData.anchorradius, conf.anchorradius);
    anchorProps.isAnchorRadius = (0, _lib.pluck)(setData.anchorradius, JSONData.anchorradius, chartAttr.anchorradius);
    anchorProps.bgColor = (0, _lib.pluck)(setData.anchorbgcolor, conf.anchorbgcolor);
    if (!anchorProps.enabled) {
      anchorAlpha = 0;
    } else {
      anchorAlpha = (0, _lib.getFirstAlpha)((0, _lib.pluck)(setData.anchoralpha, conf.anchoralpha, anchorProps.enabled ? _lib.HUNDREDSTRING : '0'));
    }
    anchorProps.anchorAlpha = anchorAlpha;
    anchorProps.bgAlpha = (0, _lib.getFirstAlpha)((0, _lib.pluck)(setData.anchorbgalpha, conf.anchorbgalpha, anchorAlpha)) * anchorAlpha / 100;
    anchorProps.imageAlpha = anchorProps.imageAlpha * anchorAlpha / 100;
    anchorProps.borderColor = (0, _lib.pluck)(setData.anchorbordercolor, conf.anchorbordercolor);
    anchorProps.borderAlpha = anchorAlpha;
    anchorProps.sides = (0, _lib.pluck)(setData.anchorsides, conf.anchorsides);
    anchorProps.borderThickness = (0, _lib.pluck)(setData.anchorborderthickness, conf.anchorborderthickness);
    anchorProps.symbol = mapSymbolName(anchorProps.sides).split('_');
    showAnchorShadow = (0, _lib.pluckNumber)(setData.anchorshadow, conf.anchorshadow) && anchorProps.radius >= 1;
    anchorProps.shadow = {
      opacity: showAnchorShadow ? anchorAlpha / 100 : 0
    };
    return anchorProps;
  };

  AreaDataset.prototype._hideGraphics = function _hideGraphics(graphics) {
    var dataset = this,
        graphicObj,
        prop;
    for (prop in graphics) {
      if (graphics.hasOwnProperty(prop)) {
        graphicObj = graphics[prop];
        if (!graphicObj) {
          continue;
        }
        if (graphicObj.hide) {
          graphicObj.hide();
        } else {
          dataset._hideGraphics(graphicObj);
        }
      }
    }
  };
  /*
   * Parses the hover effect attributes for set level
   * @param {Object} setData
   * Called from configure function of area class
   */


  AreaDataset.prototype._parseHoverEffectOptions = function _parseHoverEffectOptions(dataObj, setData) {
    var dataset = this,
        JSONData = dataset.JSONData,
        chart = dataset.getFromEnv('chart'),
        chartAttr = chart.jsonData.chart,
        chartConfig = chart.config,
        config = dataObj.config,
        conf = dataset.config,
        anchorProps = config.anchorProps || {},
        showHoverEffect = chartConfig.plothovereffect,
        drawAnchors = conf.drawanchors,
        hoverEffects = {
      enabled: false
    };
    setData = setData || {};
    if (showHoverEffect !== 0 && drawAnchors !== 0) {
      // Checking if any hover attributes are defined
      // If defined then set enabled true
      hoverEffects.enabled = (0, _lib.pluck)(setData.hovercolor, setData.anchorhovercolor, setData.hovercolor, JSONData.hovercolor, setData.anchorbghovercolor, JSONData.anchorbghovercolor, chartAttr.anchorbghovercolor, JSONData.anchorhovercolor, chartAttr.anchorhovercolor, setData.hoveralpha, setData.anchorhoveralpha, JSONData.anchorhoveralpha, chartAttr.anchorhoveralpha, setData.bghoveralpha, setData.anchorbghoveralpha, JSONData.anchorbghoveralpha, chartAttr.anchorbghoveralpha, setData.anchorborderhovercolor, setData.borderhovercolor, JSONData.anchorborderhovercolor, chartAttr.anchorborderhovercolor, setData.anchorborderhoverthickness, setData.borderhoverthickness, JSONData.anchorborderhoverthickness, chartAttr.anchorborderhoverthickness, setData.anchorborderhoveralpha, setData.borderhoveralpha, JSONData.anchorborderhoveralpha, chartAttr.anchorborderhoveralpha, setData.hoverdip, setData.anchorhoverdip, JSONData.anchorhoverdip, chartAttr.anchorhoverdip, setData.anchorhoverstartangle, JSONData.anchorhoverstartangle, chartAttr.anchorhoverstartangle, setData.hoversides, setData.anchorhoversides, JSONData.anchorhoversides, chartAttr.anchorhoversides, setData.hoverradius, setData.anchorhoverradius, JSONData.anchorhoverradius, chartAttr.anchorhoverradius, JSONData.plotfillhovercolor, chartAttr.plotfillhovercolor, chartConfig.plothovereffect, UNDEF) !== UNDEF;
      hoverEffects.startAngle = (0, _lib.pluckNumber)(setData.anchorhoverstartangle, JSONData.anchorhoverstartangle, chartAttr.anchorhoverstartangle, anchorProps.startAngle);

      hoverEffects.anchorSides = (0, _lib.pluckNumber)(setData.hoversides, setData.anchorhoversides, JSONData.anchorhoversides, chartAttr.anchorhoversides, anchorProps.sides);
      hoverEffects.anchorRadius = (0, _lib.pluckNumber)(setData.anchorhoverradius, JSONData.anchorhoverradius, chartAttr.anchorhoverradius);

      hoverEffects.isAnchorHoverRadius = hoverEffects.anchorRadius;
      hoverEffects.anchorRadius = (0, _lib.pluckNumber)(hoverEffects.anchorRadius, anchorProps.radius + (showHoverEffect ? 2 : 0));
      hoverEffects.anchorScale = (0, _lib.pluck)(setData.hoverscale, JSONData.anchorscale, chartAttr.anchorscale);
      hoverEffects.imageHoverScale = (0, _lib.pluckNumber)(setData.anchorimagehoverScale, JSONData.anchorimagehoverscale, chartAttr.anchorimagehoverscale, 110);
      hoverEffects.imageHoverAlpha = (0, _lib.pluckNumber)(setData.anchorimagehoveralpha, JSONData.anchorimaghoverealpha, chartAttr.anchorimagehoveralpha);
      hoverEffects.anchorAlpha = (0, _lib.pluck)(setData.anchorhoveralpha, setData.hoveralpha, JSONData.anchorhoveralpha, chartAttr.anchorhoveralpha, anchorProps.anchorAlpha);

      hoverEffects.anchorColor = (0, _lib.getFirstColor)((0, _lib.pluck)(setData.hovercolor, setData.anchorhovercolor, setData.hoverColor, setData.anchorbghovercolor, JSONData.anchorbghovercolor, JSONData.anchorhovercolor, JSONData.hovercolor, chartAttr.anchorbghovercolor, chartAttr.anchorhovercolor, chartAttr.plotfillhovercolor, anchorProps.bgColor));

      hoverEffects.anchorBgAlpha = (0, _lib.pluck)(setData.bghoveralpha, setData.anchorbghoveralpha, JSONData.anchorbghoveralpha, chartAttr.anchorbghoveralpha, chartAttr.plotfillhoveralpha, anchorProps.bgAlpha);

      hoverEffects.anchorBgAlpha = hoverEffects.anchorBgAlpha * hoverEffects.anchorAlpha / 100;

      hoverEffects.anchorBorderColor = (0, _lib.pluck)(setData.borderhovercolor, setData.anchorborderhovercolor, JSONData.anchorborderhovercolor, chartAttr.anchorborderhovercolor, anchorProps.borderColor);

      hoverEffects.anchorBorderAlpha = (0, _lib.pluck)(setData.borderhoveralpha, setData.anchorborderhoveralpha, JSONData.anchorborderhoveralpha, chartAttr.anchorborderhoveralpha, hoverEffects.anchorAlpha, anchorProps.borderAlpha);

      hoverEffects.anchorBorderThickness = (0, _lib.pluckNumber)(setData.borderhoverthickness, setData.anchorborderhoverthickness, JSONData.anchorborderhoverthickness, chartAttr.anchorborderhoverthickness, chartAttr.anchorBorderThickness, anchorProps.borderThickness);

      hoverEffects.dip = (0, _lib.pluck)(setData.hoverdip, setData.anchorhoverdip, JSONData.anchorhoverdip, chartAttr.anchorhoverdip, anchorProps.dip);

      hoverEffects.anchorAnimation = (0, _lib.pluckNumber)(setData.anchorhoveranimation, JSONData.anchorhoveranimation, chartAttr.anchorhoveranimation, 1);
    }
    return hoverEffects;
  };
  /**
    * Sets the attributes of the anchor elements when hovering over anchor
    * @param {Object} plotItem - object of plotItem
    * @param {Object} eventType - type of event
    * @param {Object} chartAttr - attributes of chart
    * Called from rollOverResponseSetter and rolloutresponsesetter function of line and area
    */


  AreaDataset.prototype._hoverPlotAnchor = function _hoverPlotAnchor(plotItem, eventType) {
    var dataset = this,
        sharedAnchor = dataset.graphics.sharedAnchor,
        plotElem = plotItem.graphics.element || sharedAnchor && sharedAnchor.element,
        valElem = plotItem.graphics.label,
        config = plotItem.config || {},
        anchorAlpha = config.anchorProps.anchorAlpha,
        anchorImageUrl = config && config.anchorProps.imageUrl,
        plotElemImage = isVML && anchorImageUrl ? plotItem.graphics.element : plotItem.graphics.image,
        isImg = plotElem.type === 'image',
        anchorRadius = plotElem.data('anchorRadius'),
        anchorHoverRadius = plotElem.data('anchorHoverRadius'),
        rolloverAnimationDuration = 50,
        hoverEffects = plotItem.config.hoverEffects,
        elemHoverAttr = hoverEffects.attrs[SETROLLOVERATTR],
        elemUnHoverAttr = hoverEffects.attrs[SETROLLOUTATTR],

    // Radius diff is how much we have to shift the position of the value element
    // when animating it. If the value is above the anchor then we are
    // shifting the value upwards otherwise downwards
    radiusDiff = valElem && (valElem.data('isBelow') ? 1 : -1) * (isImg ? (elemHoverAttr.height - elemUnHoverAttr.height) * 0.5 : anchorHoverRadius - anchorRadius),
        selectedAttr = eventType === ROLLOVER ? elemHoverAttr : elemUnHoverAttr,
        animationImageAttr,
        elemImageHoverAttr,
        elemImageUnHoverAttr,
        animationAttr = {
      polypath: selectedAttr.polypath
    },
        shiftValues = 1,
        staticAttr = {
      fill: selectedAttr.fill,
      'stroke-width': selectedAttr['stroke-width'],
      stroke: selectedAttr.stroke
    },
        rotation = valElem && valElem.data('rotation') || '',
        valAnimation = {
      transform: 'T0,' + (eventType === ROLLOVER ? radiusDiff : 0) + rotation
    },

    /* if hover alpha and anchor alpha is not 0 and anchorhoverradius and anchor
    radius is not same then only we are animating the anchors */
    animationDuration = !(/,0\)$/.test(elemHoverAttr.fill) && /,0\)$/.test(elemUnHoverAttr.fill)) && plotElem.data('anchorHoverRadius') - plotElem.data('anchorRadius') && hoverEffects.anchorAnimation && rolloverAnimationDuration;

    if (plotElemImage) {
      elemImageHoverAttr = plotElemImage.data(SETROLLOVERATTR);
      elemImageUnHoverAttr = plotElemImage.data(SETROLLOUTATTR);
      animationImageAttr = eventType == ROLLOVER ? elemImageHoverAttr : elemImageUnHoverAttr;
    }
    if (eventType == ROLLOVER && anchorHoverRadius !== 0 || eventType == ROLLOUT && anchorRadius !== 0) {
      plotElem.attr({
        visibility: visibleStr
      });
      if (plotElemImage) {
        plotElemImage.attr({
          visibility: visibleStr
        });
      }
    }
    if (plotElemImage) {
      plotElemImage.css({
        opacity: animationImageAttr.alpha * 0.01
      });
    }

    if (isImg) {
      plotElem.css({
        opacity: animationAttr.alpha * 0.01
      });
    } else {
      plotElem.attr(staticAttr);
    }
    // Stopping any previous animation of anchorElement
    plotElem.stop();

    plotElem.animate(animationAttr, animationDuration, 'easeOut', function () {
      if (eventType === ROLLOVER && !anchorHoverRadius || eventType === ROLLOUT && !anchorRadius) {
        plotElem.attr({
          'visibility': hiddenStr
        });
      }
    });
    // If image is present then animating the image too
    if (plotElemImage) {
      plotElemImage.animate(animationImageAttr, animationDuration, 'easeOut', function () {
        if (eventType === ROLLOVER && !anchorHoverRadius || eventType === ROLLOUT && !anchorRadius) {
          plotElemImage.attr({
            'visibility': hiddenStr
          });
        }
      });
    }
    valElem && valElem.stop();
    // Animating the values
    (animationDuration || sharedAnchor && sharedAnchor.element && anchorAlpha) && shiftValues && valElem && valElem.animate(valAnimation, rolloverAnimationDuration, 'easeOut');
  };
  /**
    * Draws a label
    * Called for each data value to be drawn from draw function of kagi
    * @param {number} i - index of data
    */


  AreaDataset.prototype.drawLabel = function drawLabel(start, end) {
    var dataSet = this,
        chart = dataSet.getFromEnv('chart'),
        chartConfig = chart.config,
        SmartLabel = dataSet.getFromEnv('smartLabel'),
        style = chart.config.dataLabelStyle,
        dataStore = dataSet.components.data,
        paper = dataSet.getFromEnv('paper'),
        stack100Percent = chartConfig.stack100percent,
        displayValue = '',
        rotateValues = chartConfig.rotatevalues ? 270 : 0,
        canvasTop = chartConfig.canvasTop,
        canvasHeight = chartConfig.canvasHeight,
        isStacked = chart.config.isstacked,
        GUTTER_4 = 4,
        GUTTER_2 = 2,
        valuePadding,
        dataLabelContainer = dataSet.getContainer('labelGroup'),
        pool = dataSet.components.pool || {},
        bBoxObj,
        graphic,
        textHeight,
        origTextHeight,
        textY,
        textX,
        yAdjust,
        anchorProps,
        valuePosition,
        placeValuesInside,
        topSpace,
        bottomSpace,
        config,
        xPos,
        yPos,
        prevConfig,

    // nextConfig,
    prevValue,

    // nextValue,
    value,
        showValue,
        labelElement,
        labelStyle,
        anchorRadius,
        dataObj,
        dLen,
        i,
        setValue,
        attr,
        tempGraphics,
        visible = dataSet.getState('visible'),
        anim = {
      plot: {
        data: [],
        animType: 'linear'
      },
      initial: {
        data: []
      },
      final: {
        data: []
      }
    },
        isSingleStep = chartConfig.isSingleStepAnim || chart.state === 'realTimeUpdate',
        key = '',
        firstDraw = !dataSet.graphics.dataLabelContainer,
        applyAttr = function applyAttr(el, attrs) {
      return function () {
        el.attr(attrs);
      };
    };

    if (firstDraw) {
      dataLabelContainer.attr({
        opacity: 0
      });
    }

    i = start || 0;
    dLen = end || dataStore.length;

    labelStyle = {
      'font-weight': style.fontWeight,
      'font-style': style.fontStyle,
      'font-family': style.fontFamily,
      'font-size': style.fontSize,
      'line-height': style.lineHeight
    };

    SmartLabel.setStyle(labelStyle);

    // Animation for label container and not for each label
    !isSingleStep && anim.initial.data.push({
      el: dataLabelContainer,
      attrs: {
        opacity: 0
      }
    });
    !isSingleStep && visible && this.config.showvalues && anim['final'].data.push({
      el: dataLabelContainer,
      attrs: {
        opacity: 1
      }
    });

    for (; i < dLen; i++) {
      dataObj = dataStore[i];
      config = dataObj && dataObj.config;
      setValue = config && config.setValue;

      if (dataObj === UNDEF || setValue === UNDEF || setValue === null || config.labelSkip === true) {
        config && delete config.labelSkip;
        tempGraphics = dataObj && dataObj.graphics;
        if (tempGraphics && tempGraphics.label) {
          anim.initial.data.push({
            el: tempGraphics.label,
            attrs: {
              opacity: 0
            }
          });
        }
        continue;
      }
      anchorProps = config.anchorProps;
      graphic = dataObj.graphics;
      yPos = dataObj._yPos || dataObj.config._Py;
      xPos = dataObj._xPos || dataObj.config._Px;
      anchorRadius = graphic.element ? graphic.image && graphic.element.attr('height') * 0.5 || anchorProps.radius - 3 : 0;

      valuePadding = chartConfig.valuepadding + GUTTER_2 + anchorRadius;

      valuePosition = config.valuePosition;

      // Deciding the value position
      switch (valuePosition) {
        case 'above':
          placeValuesInside = 0;
          break;

        case 'below':
          placeValuesInside = 1;
          break;
        // Calculating the value position
        default:
          prevConfig = dataStore[i - 1] && dataStore[i - 1].config || {};
          // nextConfig = (dataStore[i + 1] && dataStore[i + 1].config) || {};
          if (isStacked && stack100Percent) {
            prevValue = prevConfig.value;
            // nextValue = nextConfig.value;
            value = config.value;
          } else {
            prevValue = prevConfig.setValue;
            // nextValue = nextConfig.setValue;
            value = config.setValue;
          }
          // For first data the value is placed always above
          // For other data checking if
          placeValuesInside = !i ? 0 : prevValue > value ? 1 : 0;
      }

      displayValue = config.displayValue;
      showValue = config.showValue;
      labelElement = graphic.label;

      // Drawing label only if displayvalue is defined and not blank and setValue is not null
      if (defined(displayValue) && displayValue !== '' && value !== null && showValue) {
        attr = {
          text: displayValue,
          fill: style.color,
          'text-bound': [style.backgroundColor, style.borderColor, style.borderThickness, style.borderPadding, style.borderRadius, style.borderDash]
        };

        bBoxObj = SmartLabel.getOriSize(displayValue);

        if (rotateValues) {
          // If rotated values we use the width of
          // the text as height

          config._state = {
            // If label is already rotated then we take the width as labelWidth
            labelWidth: bBoxObj.height,
            labelHeight: bBoxObj.width
          };
          config._rotated = true;
        } else {
          config._state = {
            // If label is already rotated then we take the height as labelWidth
            labelWidth: bBoxObj.width,
            labelHeight: bBoxObj.height
          };
          config._rotated = false;
        }

        // Calculating the total text height
        textHeight = origTextHeight = config._state.labelHeight;
        textHeight += valuePadding;
        yAdjust = origTextHeight * 0.5 + valuePadding;
        topSpace = yPos - canvasTop;
        bottomSpace = canvasTop + canvasHeight - yPos;
        textY = yPos;
        textX = xPos;
        textHeight = textHeight + GUTTER_4;
        // Calculating the y position of text when drawing it below anchors
        if (placeValuesInside) {
          // If space is available below anchor
          if (bottomSpace > textHeight) {
            textY += yAdjust;
            config._valueBelowPoint = 1;
          } else if (topSpace > textHeight) {
            // If space available above anchor
            textY -= yAdjust;
            config._valueBelowPoint = 0;
          }
        } else {
          // Calculating the y position of text when drawing it above anchors
          // if space available for text above anchors
          if (topSpace > textHeight) {
            textY -= yAdjust;
            config._valueBelowPoint = 0;
          } else if (bottomSpace > textHeight) {
            // if space available below anchors
            textY += yAdjust;
            config._valueBelowPoint = 1;
          }
        }

        if (!labelElement) {
          if (pool.label && pool.label.length) {
            graphic.label = labelElement = pool.label.shift();
            graphic.label.show();
          } else {
            attr.x = textX;
            attr.y = textY;
            attr.transform = paper.getSuggestiveRotation(rotateValues, textX, textY);
            graphic.label = labelElement = paper.text(attr, dataLabelContainer);
          }
          labelElement.attr({
            opacity: 0
          });
        }
        attr.opacity = 1;
        attr.transform = paper.getSuggestiveRotation(rotateValues, textX, textY);
        labelElement.show();
        attr.x = textX;
        attr.y = textY;
        // label position will animate only in single step
        if (chart.state === 'realTimeUpdate') {
          anim.plot.data.push({
            el: labelElement,
            attrs: {},
            preAnimFn: applyAttr(labelElement, attr)
          });
        } else if (chart.state !== 'realTimeUpdate' && isSingleStep && !firstDraw) {
          anim.plot.data.push({
            el: labelElement,
            attrs: attr
          });
        } else {
          anim['final'].data.push({
            el: labelElement,
            attrs: {},
            animConfig: [{
              hookFn: applyAttr(labelElement, attr)
            }]
          });
        }
        labelElement.data('isBelow', config._valueBelowPoint);
        labelElement.data('rotation', paper.getSuggestiveRotation(rotateValues, textX, textY));
      } else {
        labelElement && anim.initial.data.push({
          el: labelElement,
          type: 'fadeOut'
        });
      }
    }

    // Registering the animations only when something is happening
    for (key in anim) {
      chart.getFromEnv('animationManager').registerAnimation([anim[key]], key);
    }
  };
  /**
   * function to return defalut value padding
   * @return {Object} default padding value for axis
   */


  AreaDataset.prototype.getAxisValuePadding = function getAxisValuePadding() {
    return this.config.defaultPadding;
  };

  AreaDataset.prototype._hoverFunc = function _hoverFunc(dataObj, state, hoverEnabled, chartAttr) {
    if (hoverEnabled) {
      return this._hoverPlotAnchor(dataObj, state, chartAttr);
    }
  };

  /**
   * Returns the name of the component
   * @return {string} The name of the component, in this case 'area'.
   */


  AreaDataset.prototype.getName = function getName() {
    return 'area';
  };

  return AreaDataset;
}(_column2['default']);

exports['default'] = AreaDataset;

/***/ }),
/* 21 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports._drawScrollBar = undefined;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _iterator = __webpack_require__(9);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(10);

var _symbol2 = _interopRequireDefault(_symbol);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _assign = __webpack_require__(13);

var _assign2 = _interopRequireDefault(_assign);

var _typeof = typeof _symbol2['default'] === "function" && typeof _iterator2['default'] === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2['default'] === "function" && obj.constructor === _symbol2['default'] && obj !== _symbol2['default'].prototype ? "symbol" : typeof obj; };

var _componentInterface = __webpack_require__(6);

var _componentInterface2 = _interopRequireDefault(_componentInterface);

var _elementRecycler = __webpack_require__(214);

var _elementRecycler2 = _interopRequireDefault(_elementRecycler);

var _lib = __webpack_require__(5);

var _eventApi = __webpack_require__(7);

var _limitUpdater = __webpack_require__(415);

var _limitUpdater2 = _interopRequireDefault(_limitUpdater);

var _redraphael = __webpack_require__(17);

var _redraphael2 = _interopRequireDefault(_redraphael);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var UNDEF,
    PXSTRING = 'px',
    DASH_DEF = 'none',
    convertColor = _lib.graphics.convertColor,
    TRUE_STRING = 'true',
    ONE_STRING = '1',
    POINTER = 'pointer',
    NORMALSTRING = 'normal',
    EVENTARGS = 'eventArgs',
    CRISP = 'crisp',
    BUTT = 'butt',
    visibleStr = _lib.preDefStr.visibleStr,
    hiddenStr = _lib.preDefStr.hiddenStr,
    POSITION_MIDDLE = _lib.preDefStr.POSITION_MIDDLE,
    POSITION_START = _lib.preDefStr.POSITION_START,
    POSITION_TOP = _lib.preDefStr.POSITION_TOP,
    POSITION_BOTTOM = _lib.preDefStr.POSITION_BOTTOM,
    POSITION_END = _lib.preDefStr.POSITION_END,
    pInt = function pInt(s, mag) {
  return parseInt(s, mag || 10);
},

// M = 'M',
// L = 'L',
mathRound = Math.round,
    mathMin = Math.min,
    mathMax = Math.max,
    mathAbs = Math.abs,
    mathCeil = Math.ceil,
    mathFloor = Math.floor,
    getCrispPath = function getCrispPath(path, width) {
  var isCrisped = false,
      oddWidth = width % 2,
      value,
      roundValue;

  if (path[1] === path[4]) {
    value = path[1];
    roundValue = mathRound(value);
    path[1] = path[4] = oddWidth ? roundValue > value ? roundValue - 0.5 : roundValue + 0.5 : roundValue;
    isCrisped = true;
  }
  if (path[2] === path[5]) {
    value = path[2];
    roundValue = mathRound(value);
    path[2] = path[5] = oddWidth ? roundValue > value ? roundValue - 0.5 : roundValue + 0.5 : roundValue;
    isCrisped = true;
  }
  return {
    path: path,
    isCrisped: isCrisped
  };
},

/**
 * Forces a given value to a given limit
 * @param  {number} value The value to be limited
 * @param  {number} limit The number to which the given value must be limited
 * @return {number}       The limited value
 */
_forceValidLowerLimit = function _forceValidLowerLimit(value, limit) {
  return value < limit ? limit : value;
},


// /**
//  * Returns the pixel value of the scroll position when provided the percentage value of the scroll position
//  * @param  {number} apparentScrollPos The percentage value of the scroll position. Lies between 0 and 1.
//  * @param  {number} axisZoom          The zoom level of the axis
//  * @param  {number} axisLength        The length of the axis
//  * @return {number}                   The pixel value corresponding to the scrolled percentage
//  */
// _calculateScrollPosition (apparentScrollPos, axisZoom, axisLength) {
//   return ((axisLength * ((1 * axisZoom) - 1)) * apparentScrollPos);
// },

/**
 * Function return all the attribute as object
 * @param {Object} obj The object for which the attribute list is to be extracted
 * @return {Object} The return object that contain all the atribute list
 */
_getAttribAsObj = function _getAttribAsObj(obj) {
  var ind,
      ret = {};
  for (ind in obj) {
    if (obj.hasOwnProperty(ind) && typeof obj[ind] === 'string' && !!obj[ind]) {
      ret[ind] = obj[ind];
    }
  }
  return ret;
},


/**
 * Rounds a decimal number to its precision-th decimal place
 * @param  {number} num       A decimal number
 * @param  {number} precision The precision to which the number will be rounded. This must be
 *                            greater than zero
 * @return {number}           A decimal number rounded to the precision-th decimal place
 */
getRoundedDecimal = function getRoundedDecimal(num, precision) {
  var base = 10,
      limit = Math.pow(base, precision);

  return precision > 0 ? Math.round(num * limit) / limit : num;
};

/**
 * Given a name of an axis component, checks it for plurality and normalises it to a name that
 * axis can understand
 * @param  {string} name The component name
 * @return {string}      The normalized name
 */
function sanitiseComponentName(name) {
  var sanitisedName = '';

  if (name === 'trend' || name === 'trends') {
    sanitisedName = 'trend';
  }
  if (name === 'catVLine' || name === 'catVLines') {
    sanitisedName = 'catVLine';
  }
  if (name === 'label' || name === 'labels') {
    sanitisedName = 'labels';
  }
  if (name === 'line' || name === 'lines') {
    sanitisedName = 'lines';
  }
  if (name === 'band' || name === 'bands') {
    sanitisedName = 'bands';
  }
  if (name === 'catBand' || name === 'catBands') {
    sanitisedName = 'catBand';
  }

  return sanitisedName;
}

/**
 * Draws the scrollbar associated with the axis
 */
function _drawScrollBar() {
  var axis = this,
      chart = axis.getFromEnv('chart'),
      axisComponents = axis._components,
      chartConfig = chart.config,
      graphics = chart.graphics,
      paper = axis.getFromEnv('paper'),
      axisConfig = axis.config,
      axisRange = axisConfig.axisRange,
      scrollOptions = chartConfig.scrollOptions || (chartConfig.scrollOptions = {}),
      max = axisRange.max,
      min = axisRange.min,
      vxLength = scrollOptions.vxLength,
      scrollBar = axisComponents.scrollBar,
      scrollNode = scrollBar && scrollBar.node,

  // scrollToEnd = chartConfig.scrollToEnd,
  // lastScrollPosition = chartConfig.lastScrollPosition,
  // axisZoom = axis.getZoomScale(),
  canvasLeft,
      canvasTop,
      canvasHeight,
      canvasWidth,
      canvasConfig,
      canvasBorderWidth,
      axisLineWidth,
      axisLineStartExtension,
      axisLineEndExtension,
      scrollRatio,
      windowedCanvasWidth,
      fullCanvasWidth,
      scrollBarParentGroup,
      visibleConfig,
      visibleMax,
      visibleMin,
      visibleRange,
      totalRange,
      scrollPosition;

  if (!scrollBar) {
    return;
  }

  // if (lastScrollPosition !== UNDEF) {
  //   startPercent = lastScrollPosition;
  // } else {
  //   startPercent = scrollToEnd ? 1 : 0;
  // }
  canvasLeft = chartConfig.canvasLeft;
  canvasTop = chartConfig.canvasTop;
  canvasHeight = chartConfig.canvasHeight;
  canvasWidth = chartConfig.canvasWidth;
  canvasConfig = chart.getChildren('canvas')[0].config;
  canvasBorderWidth = canvasConfig.canvasBorderWidth;
  axisLineWidth = axisConfig.showAxisLine ? axisConfig.axisLineThickness || 0 : 0;
  axisLineStartExtension = (0, _lib.pluckNumber)(canvasBorderWidth, axisConfig.lineStartExtension);
  axisLineEndExtension = (0, _lib.pluckNumber)(canvasBorderWidth, axisConfig.lineEndExtension);
  scrollOptions.viewPortMin = min;
  scrollOptions.viewPortMax = max;
  // scrollRatio = ((scrollOptions.scrollRatio = 1) / axisZoom);

  visibleConfig = axis.getVisibleConfig();
  visibleMax = visibleConfig.maxValue;
  visibleMin = visibleConfig.minValue;
  visibleRange = visibleMax - visibleMin;

  totalRange = axisRange.max - axisRange.min;
  scrollRatio = visibleRange / totalRange;

  scrollPosition = (visibleMin - axisRange.min) / (totalRange - visibleRange);

  windowedCanvasWidth = scrollOptions.windowedCanvasWidth = axis.getAxisPosition(vxLength);
  fullCanvasWidth = scrollOptions.fullCanvasWidth = axis.getAxisPosition(max - min) - windowedCanvasWidth;

  scrollBarParentGroup = graphics.scrollBarParentGroup;
  if (!scrollBarParentGroup) {
    scrollBarParentGroup = graphics.scrollBarParentGroup = paper.group('scrollBarParentGroup', graphics.parentGroup).insertBefore(chart.getChildContainer().datalabelsGroup);
  }
  // draw the scroller element
  // todo padding needs to be included.
  if (axisConfig.scrollEnabled !== false) {
    if (axisConfig.isVertical) {
      scrollBar.draw(canvasLeft, canvasTop, {
        height: canvasHeight,
        scrollRatio: scrollRatio,
        roundEdges: canvasConfig.isRoundEdges,
        fullCanvasWidth: fullCanvasWidth,
        windowedCanvasWidth: windowedCanvasWidth,
        scrollPosition: scrollPosition,
        parentLayer: scrollBarParentGroup
      });
    } else {
      scrollBar.draw(canvasLeft - axisLineStartExtension, canvasTop + canvasHeight + canvasBorderWidth + axisLineWidth - 2, {
        width: canvasWidth + axisLineStartExtension + axisLineEndExtension,
        scrollRatio: scrollRatio,
        roundEdges: canvasConfig.isRoundEdges,
        fullCanvasWidth: fullCanvasWidth,
        windowedCanvasWidth: windowedCanvasWidth,
        scrollPosition: scrollPosition,
        parentLayer: scrollBarParentGroup
      });
    }

    // attach the callback for raising event only for it is a new scroll node.
    !scrollNode && function () {
      var prevPos;
      _redraphael2['default'].eve.on('raphael.scroll.start.' + scrollBar.node.id, function (pos) {
        axis.setState('scrolling', true);
        prevPos = pos;
        (0, _eventApi.triggerEvent)('scrollstart', chart.chartInstance, {
          scrollPosition: pos
        });
      });

      _redraphael2['default'].eve.on('raphael.scroll.end.' + scrollBar.node.id, function (pos) {
        axis.setState('scrolling', false);
        (0, _eventApi.triggerEvent)('scrollend', chart.chartInstance, {
          prevScrollPosition: prevPos,
          scrollPosition: pos
        });
      });
    }();
  } else {
    scrollBar && scrollBar.node && scrollBar.node.hide();
  }

  axisConfig.scrollBarDrawn = true;
}

/**
 * The Cartesian Axis is a special kind of axis which is used to uniquely identify points in a plane
 * using two numbers.
 *
 * This class takes care of all cosmetics and calculations related to rendering a cartesian axis on
 * a chart. In addition it also takes care of drawing the ticks, the labels and the scroll bars of
 * the axis.
 * @class
 */

var CartesianAxis = function (_ComponentInterface) {
  _inherits(CartesianAxis, _ComponentInterface);

  /**
   * Instantiates the axis with some instance members
   */
  function CartesianAxis() {
    _classCallCheck(this, CartesianAxis);

    var _this = _possibleConstructorReturn(this, _ComponentInterface.call(this));

    _this._drawScrollBar = _drawScrollBar;
    return _this;
  }

  /**
   * Sets the default configuration of the axis
   */


  CartesianAxis.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _ComponentInterface.prototype.__setDefaultConfig && _ComponentInterface.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }

    config.setAdaptiveMin = 0;
    config.adjustDiv = 1;
    config.axisNameWidth = UNDEF;
    config.rotateAxisName = 0;
    config.useEllipsesWhenOverflow = 1;
    config.divLineColor = UNDEF;
    config.divLineAlpha = UNDEF;
    config.divLineThickness = UNDEF;
    config.divLineIsDashed = UNDEF;
    config.divLineDashLen = UNDEF;
    config.divLineDashGap = UNDEF;
    config.showAlternateGridColor = UNDEF;
    config.alternateGridColor = UNDEF;
    config.alternateGridAlpha = UNDEF;
    config.showZeroPlane = 1;
    config.zeroPlaneAlpha = 80;
    config.showZeroPlaneValue = 1;
    config.showZeroPlaneOnTop = 1;
    config.showAxisLine = UNDEF;
    config.axisLineThickness = UNDEF;
    config.axisLineAlpha = UNDEF;
    config.tickLength = UNDEF;
    config.trendlineToolText = UNDEF;
    config.trendlineColor = '333333';
    config.trendlineThickness = 1;
    config.trendlineAlpha = UNDEF;
    config.showTrendlinesOnTop = 0;
    config.trendlinesAreDashed = 0;
    config.trendlinesDashLen = 5;
    config.trendlinesDashGap = 2;
    config.isTrendZone = UNDEF;
    config.showTrendlines = 1;
    config.showTrendlineLabels = 1;
    config.showLabels = 1;
    config.maxLabelHeight = UNDEF;
    config.rotateLabels = UNDEF;
    config.slantLabel = 0;
    config.showAxisValues = 1;
    config.showTooltip = 1;
    config.isActive = true; // this attribute control the drawing of divline and trendline
    config.drawLabels = true;
    config.drawOnlyCategoryLine = false; // true only for candlestick volume canvas
    config.drawLabelsOpposit = false;
    config.drawPlotlines = true;
    config.drawAxisLine = true;
    config.drawPlotBands = true;
    config.drawAxisName = true;
    config.drawAxisNameOpposit = false;
    config.axisNameAlignCanvas = false;
    config.drawAxisNameFromBottom = false;
    config.drawTrendLines = true;
    config.drawTrendLabels = true;
    config.drawTick = true;
    config.drawTickMinor = true;
    config.animateAxis = true;
    config.drawAxisLineWRTCanvas = true;
    config.isRelativeAxisInverse = false;
    config.axisIndex = 0;
    config.uniqueClassName = 0;
    config.viewPortRatio = {};
    config.canvas = {};
    config.axisRange = {};
    config.isConfigured = true;
    config.axisDimention = {};
    // configuration required for drag chart to edit the extreme labels
    config.extremeLabels = {
      firstLabel: {},
      lastLabel: {}
    };
    // these are configuration for internal use don't use it from outside
    config._setRangeAgain = false;
    config._defaultForceDecimal = UNDEF;
    config._defaultDecimalPrecision = UNDEF;
    config.rangeChanged = false;
    config.dimensionChanged = false;

    config.apparentScrollPos = 0;
    // axis.configure();
    this.addToEnv('componentInfo', {
      catVLine: [],
      trend: [],
      labels: [],
      lines: [],
      bands: [],
      catBand: []
    });
  };

  /**
   * Prepare the axis attributes for use by the chart drawing. It applies default values to the
   * options that are undefined.
   * @param  {Object}  rawAttr The raw attributes to be set
   */


  CartesianAxis.prototype.configure = function configure(rawAttr) {
    var axis = this,
        axisConfig = axis.config,
        chart = axis.getFromEnv('chart'),
        jsonData = chart.jsonData,
        is3d = axis.getFromEnv('chart').is3D,
        FCChartObj = jsonData.chart,
        numberFormatter = axis.getFromEnv('number-formatter'),
        tempAxis = axis.getFromEnv('tempAxis'),
        axisAttr,
        limitUpdater,
        fontBdrColor,
        trendFontBdrColor,
        labelFontBdrColor;

    axisAttr = axisConfig.rawAttr = (0, _lib.extend2)(axisConfig.rawAttr || {}, rawAttr);

    // store the trendlines to the axis object
    axisConfig.trendLines = axisAttr.trendlines;
    axisConfig.vTrendLines = axisAttr.vtrendlines;

    axis.__setDefaultConfig();
    (0, _lib.parseConfiguration)(axisAttr, axisConfig);

    // TODO : validation of the attributes is required
    axisConfig.axisName = (0, _lib.parseUnsafeString)(axisAttr.axisName);
    // Store the attribute value in the axisConfig object
    axisConfig.axisValuePadding = axisConfig.axisNamePadding || (0, _lib.pluckNumber)(axisAttr.axisValuePadding, 4); // if change also in placeAxis
    axisConfig.axisNamePadding = axisConfig.axisNamePadding || (0, _lib.pluckNumber)(axisAttr.axisNamePadding, 5); // if change also in placeAxis
    axisConfig.maxLabelWidthPercent = (0, _lib.pluckNumber)(axisAttr.maxLabelWidthPercent);
    axisConfig.maxLabelWidthPercent = mathAbs(axisConfig.maxLabelWidthPercent);
    axisConfig.numDivLines = (0, _lib.pluckNumber)(axisAttr.numDivLines, 4);

    axisConfig.numDivLines = _forceValidLowerLimit(axisConfig.numDivLines, 0);

    axisConfig.categoryNumDivLines = (0, _lib.pluckNumber)(axisAttr.numDivLines, 0);

    axisConfig.axisValuePadding = _forceValidLowerLimit(axisConfig.axisValuePadding, 0);

    axisConfig.isReverse = Number(axisAttr.isReverse, 0);
    axisConfig.isOpposit = Number(axisAttr.isOpposit, 0);
    axisConfig.isVertical = Number(axisAttr.isVertical, 0);

    axisConfig.categoryDivLinesFromZero = 1; // can be overwritten programetically
    axisConfig.axisMinValue = numberFormatter.getCleanValue(axisAttr.axisMinValue);
    axisConfig.axisMaxValue = numberFormatter.getCleanValue(axisAttr.axisMaxValue);
    axisConfig.zeroPlaneColor = (0, _lib.pluck)(axisAttr.zeroPlaneColor, axisAttr.divLineColor);
    axisConfig.zeroPlaneThickness = (0, _lib.pluck)(axisAttr.zeroPlaneThickness, axisAttr.divLineThickness);
    axisConfig.axisLineColor = convertColor(axisAttr.axisLineColor, axisAttr.axisLineAlpha);
    axisConfig.tickAlpha = (0, _lib.pluckNumber)(axisAttr.tickAlpha, axisConfig.axisLineAlpha);
    axisConfig.tickColor = convertColor((0, _lib.pluck)(axisAttr.tickColor, axisAttr.axisLineColor), axisConfig.tickAlpha);
    axisConfig.tickWidth = (0, _lib.pluckNumber)(axisAttr.tickWidth, axisConfig.axisLineThickness);

    axisConfig.maxZoomLimit = (0, _lib.pluckNumber)(FCChartObj.maxzoomlimit, chart.maxzoomlimit, 1000);
    axisConfig.showVLines = (0, _lib.pluckNumber)(FCChartObj.showvlines, 1);
    axisConfig.showVLinesOnTop = (0, _lib.pluckNumber)(FCChartObj.showvlinesontop, 0);
    axisConfig.showVLineLabels = (0, _lib.pluckNumber)(FCChartObj.showvlinelabels, this.showVLineLabels, 1);
    axisConfig.showVLineLabelBorder = (0, _lib.pluckNumber)(FCChartObj.showvlinelabelborder, 1);
    axisConfig.rotateVLineLabels = (0, _lib.pluckNumber)(FCChartObj.rotatevlinelabels, 0);
    axisConfig.vLineColor = (0, _lib.pluck)(FCChartObj.vlinecolor, '333333');
    axisConfig.vLineLabelColor = (0, _lib.pluck)(FCChartObj.vlinelabelcolor);
    axisConfig.vLineThickness = (0, _lib.pluck)(FCChartObj.vlinethickness, 1);
    axisConfig.vLineAlpha = (0, _lib.pluckNumber)(FCChartObj.vlinealpha, 80);
    axisConfig.vLineLabelBgColor = (0, _lib.pluck)(FCChartObj.vlinelabelbgcolor, 'ffffff');
    axisConfig.vLineLabelBgAlpha = (0, _lib.pluckNumber)(FCChartObj.vlinelabelbgalpha, is3d ? 50 : 100);
    axisConfig.staggerLines = Math.max((0, _lib.pluckNumber)(FCChartObj.staggerlines, 2), 2);

    axisConfig.staggerLines = _forceValidLowerLimit(axisConfig.staggerLines, 1);

    axisConfig.trendlineValuesOnOpp = (0, _lib.pluck)(axisAttr.trendlineValuesOnOpp, axisAttr.trendlineValuesOnOpp, 0);
    axisConfig.labelDisplay = (0, _lib.pluck)(axisAttr.labelDisplay, 'auto').toLowerCase();
    axisConfig.labelStep = (0, _lib.pluckNumber)(axisAttr.labelStep, 0);
    axisConfig.labelStep = mathRound(axisConfig.labelStep);

    axisConfig.labelStep = _forceValidLowerLimit(axisConfig.labelStep, 0);

    axisConfig._oriLabelStep = axisConfig.labelStep;
    axisConfig.showLimits = (0, _lib.pluckNumber)(axisAttr.showLimits, axisConfig.showAxisValues);
    axisConfig.showUpperLimit = axisAttr.showLimits;
    axisConfig.showDivLineValues = (0, _lib.pluckNumber)(axisAttr.showDivLineValues, axisConfig.showAxisValues);

    axisConfig.showCanvasBorder = chart.getChildren('canvas')[0].config.showCanvasBorder ? 1 : 0;

    axisConfig.axisBreak = axisAttr.axisBreaks;
    axisConfig.isBreak = !!axisConfig.axisBreak;
    if (axisConfig.isBreak) {
      axis._processAxisBreak();
    }

    if (axisAttr.limitUpdaterEnabled) {
      limitUpdater = new _limitUpdater2['default']();
      axis.attachChild(limitUpdater, 'limitUpdater', true);
      limitUpdater.addToEnv('chartContainer', chart.getLinkedItem('container'));
      limitUpdater.configure();
    }

    // Store the axis name style attributesa
    fontBdrColor = (0, _lib.getFirstValue)(axisAttr.axisNameBorderColor, _lib.BLANKSTRING);
    fontBdrColor = fontBdrColor ? convertColor(fontBdrColor, (0, _lib.pluckNumber)(axisAttr.axisNameBorderAlpha, axisAttr.axisNameAlpha, 100)) : _lib.BLANKSTRING;
    axisConfig.name = axisConfig.name || {};
    axisConfig.name.style = {
      fontFamily: (0, _lib.pluck)(axisAttr.axisNameFont, axisAttr.outCanfontFamily),
      fontSize: (0, _lib.pluck)(axisAttr.axisNameFontSize, pInt(axisAttr.outCanfontSize)) + PXSTRING,
      color: convertColor((0, _lib.pluck)(axisAttr.axisNameFontColor, axisAttr.outCancolor), (0, _lib.pluckNumber)(axisAttr.axisNameFontAlpha, axisAttr.axisNameAlpha, 100)),
      fontWeight: (0, _lib.pluckNumber)(axisAttr.axisNameFontBold, 1) ? 'bold' : NORMALSTRING,
      fontStyle: (0, _lib.pluckNumber)(axisAttr.axisNameFontItalic) ? 'italic' : NORMALSTRING,
      border: fontBdrColor || axisAttr.axisNameBgColor ? (0, _lib.pluckNumber)(axisAttr.axisNameBorderThickness, 1) + 'px solid' : UNDEF,
      borderColor: fontBdrColor,
      borderThickness: (0, _lib.pluckNumber)(axisAttr.axisNameBorderThickness, 1),
      borderPadding: (0, _lib.pluckNumber)(axisAttr.axisNameBorderPadding, 2),
      borderRadius: (0, _lib.pluckNumber)(axisAttr.axisNameBorderRadius, 0),
      backgroundColor: axisAttr.axisNameBgColor ? convertColor(axisAttr.axisNameBgColor, (0, _lib.pluckNumber)(axisAttr.axisNameBgAlpha, axisAttr.axisNameAlpha, 100)) : _lib.BLANKSTRING,
      borderDash: (0, _lib.pluckNumber)(axisAttr.axisNameBorderDashed, 0) ? (0, _lib.getDashStyle)((0, _lib.pluckNumber)(axisAttr.axisNameBorderDashLen, 4), (0, _lib.pluckNumber)(axisAttr.axisNameBorderDashGap, 2)) : DASH_DEF
    };
    // Calculate the line height of the axis name
    axisConfig.name.style.lineHeight = (0, _lib.setLineHeight)(axisConfig.name.style);

    // Trend line label font style
    trendFontBdrColor = (0, _lib.getFirstValue)(FCChartObj.trendvaluebordercolor, _lib.BLANKSTRING);
    trendFontBdrColor = trendFontBdrColor ? convertColor(trendFontBdrColor, (0, _lib.pluckNumber)(FCChartObj.trendvalueborderalpha, FCChartObj.trendvaluealpha, 100)) : _lib.BLANKSTRING;
    axisConfig.trend = axisConfig.trend || {};
    axisConfig.trend.trendStyle = {
      fontFamily: (0, _lib.pluck)(FCChartObj.trendvaluefont, axisAttr.outCanfontFamily),
      color: (0, _lib.pluck)(FCChartObj.trendvaluefontcolor, axisAttr.trendlineColor, axisAttr.outCancolor, '333333'),
      fontSize: (0, _lib.pluckFontSize)(FCChartObj.trendvaluefontsize, pInt(axisAttr.outCanfontSize)) + PXSTRING,
      fontWeight: (0, _lib.pluckNumber)(FCChartObj.trendvaluefontbold) ? 'bold' : NORMALSTRING,
      fontStyle: (0, _lib.pluckNumber)(FCChartObj.trendvaluefontitalic) ? 'italic' : NORMALSTRING,
      // Set border as empty string when not required,
      // since IE will stop js execution if it is undefined or null.
      border: trendFontBdrColor || FCChartObj.trendvaluebgcolor ? (0, _lib.pluckNumber)(FCChartObj.trendvalueborderthickness, 1) + 'px solid' : '',
      borderColor: trendFontBdrColor,
      borderThickness: (0, _lib.pluckNumber)(FCChartObj.trendvalueborderthickness, 1),
      borderPadding: (0, _lib.pluckNumber)(FCChartObj.trendvalueborderpadding, 2),
      borderRadius: (0, _lib.pluckNumber)(FCChartObj.trendvalueborderradius, 0),
      backgroundColor: FCChartObj.trendvaluebgcolor ? convertColor(FCChartObj.trendvaluebgcolor, (0, _lib.pluckNumber)(FCChartObj.trendvaluebgalpha, FCChartObj.trendvaluealpha, 100)) : _lib.BLANKSTRING,
      borderDash: (0, _lib.pluckNumber)(FCChartObj.trendvalueborderdashed, 0) ? (0, _lib.getDashStyle)((0, _lib.pluckNumber)(FCChartObj.trendvalueborderdashlen, 4), (0, _lib.pluckNumber)(FCChartObj.trendvalueborderdashgap, 2)) : DASH_DEF
    };
    // Trend line label line height
    axisConfig.trend.trendStyle.lineHeight = (0, _lib.setLineHeight)(axisConfig.trend.trendStyle);
    axisConfig.labels = axisConfig.labels || {};
    axisConfig.lines = axisConfig.lines || {};
    axisConfig.band = axisConfig.band || {};

    // Axis label style
    labelFontBdrColor = (0, _lib.getFirstValue)(FCChartObj.labelbordercolor, _lib.BLANKSTRING);
    labelFontBdrColor = labelFontBdrColor ? convertColor(labelFontBdrColor, (0, _lib.pluckNumber)(FCChartObj.labelborderalpha, FCChartObj.labelalpha, 100)) : _lib.BLANKSTRING;
    axisConfig.labels.style = {
      fontFamily: (0, _lib.pluck)(axisAttr.labelFont, axisAttr.outCanfontFamily),
      fontSize: (0, _lib.pluckNumber)(axisAttr.labelFontSize, pInt(axisAttr.outCanfontSize)) + PXSTRING,
      fontWeight: (0, _lib.pluckNumber)(axisAttr.labelFontBold) ? 'bold' : NORMALSTRING,
      fontStyle: (0, _lib.pluckNumber)(axisAttr.labelFontItalic) ? 'italic' : NORMALSTRING,
      color: convertColor((0, _lib.pluck)(axisAttr.labelFontColor, axisAttr.outCancolor), (0, _lib.pluckNumber)(axisAttr.labelFontAlpha, 100)),
      labelLink: FCChartObj.labellink,
      border: labelFontBdrColor || FCChartObj.labelbgcolor ? (0, _lib.pluckNumber)(FCChartObj.labelborderthickness, 1) + 'px solid' : '',
      borderColor: labelFontBdrColor,
      borderThickness: (0, _lib.pluckNumber)(FCChartObj.labelborderthickness, 1),
      borderPadding: (0, _lib.pluckNumber)(FCChartObj.labelborderpadding, 2),
      borderRadius: (0, _lib.pluckNumber)(FCChartObj.labelborderradius, 0),
      backgroundColor: FCChartObj.labelbgcolor ? convertColor(FCChartObj.labelbgcolor, (0, _lib.pluckNumber)(FCChartObj.labelbgalpha, FCChartObj.labelalpha, 100)) : _lib.BLANKSTRING,
      borderDash: (0, _lib.pluckNumber)(FCChartObj.labelborderdashed, 0) ? (0, _lib.getDashStyle)((0, _lib.pluckNumber)(FCChartObj.labelborderdashlen, 4), (0, _lib.pluckNumber)(FCChartObj.labelborderdashgap, 2)) : DASH_DEF
    };
    // Axis label line height
    axisConfig.labels.style.lineHeight = (0, _lib.setLineHeight)(axisConfig.labels.style);
    axisConfig.numberFormatterFn = (0, _lib.pluck)(axisAttr.numberFormatterFn);

    // Setting zoom and scroll if present
    axisConfig.apparentScrollPos = axisAttr.apparentScrollPos || axisConfig.apparentScrollPos;
    // axis.setZoomScale(axisAttr.zoomScale || axisConfig.zoomScale);

    axisConfig.axisEndLabelDisplaySpace = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    axisConfig.isConfigured = true;
    axisConfig._defaultForceDecimal = UNDEF;
    axisConfig._defaultDecimalPrecision = UNDEF;

    axis.setScrollType('smart');

    axis.addToEnv('savedAxis', tempAxis && (0, _lib.extend2)({}, tempAxis));
  };

  /**
   * Register vertical axis animations with the animation manager.
   * @param {Array}  animData An array of objects containing information about the elements to
   *                          be animated
   * @param {Object} opt      Whether to force the animation to be in sync with a specific time slot
   *                          (initial, axis, plot or final)
   */


  CartesianAxis.prototype._registerVerticalAxisAnims = function _registerVerticalAxisAnims(animData, opt) {
    var axis = this,
        axisConfig = axis.config,
        rangeChanged = axisConfig.rangeChanged,
        dimensionChanged = axisConfig.dimensionChanged,
        forceType = opt && opt.force,
        registrationTag = '';

    if (!axis.getFromEnv('tempAxis')) {
      registrationTag = 'initial';
    } else {
      registrationTag = rangeChanged || dimensionChanged ? 'axis' : 'plot';
    }

    axis.getFromEnv('animationManager').registerAnimation([{
      data: animData,
      animType: 'linear',
      animConfig: [{
        start: 0,
        end: 1
      }]
    }], forceType || registrationTag);
  };
  /**
   * Register horizontal axis animations with the animation manager.
   * @param  {Array} animData An array of objects containing information about the elements to
   *                          be animated
   */


  CartesianAxis.prototype._registerHorizontalAxisAnims = function _registerHorizontalAxisAnims(animData) {
    var axis = this,
        axisConfig = axis.config,
        chart = axis.getFromEnv('chart'),
        animationManager = chart.getFromEnv('animationManager'),
        rangeChanged = axisConfig.rangeChanged,
        dimensionChanged = axisConfig.dimensionChanged,
        registrationTag = '';

    if (!axis.getFromEnv('tempAxis')) {
      registrationTag = 'initial';
    } else {
      registrationTag = rangeChanged || dimensionChanged ? 'axis' : 'plot';
    }

    animationManager.registerAnimation([{
      data: animData,
      animType: 'linear',
      animConfig: [{
        start: 0,
        end: 1
      }]
    }], registrationTag);
  };

  /**
   * Sets the scrolling behavior of the axis.
   * **'none'** indicates that the scroll bar wil never be shown
   * **'smart'** indicates that the scroll bar will be shown only when the axis limits are beyond
   * the visible limits of the chart
   * **'always'** indicates that the scroll bar will always be visible
   * @param {string} type The type of scroll behavior.
   */


  CartesianAxis.prototype.setScrollType = function setScrollType(type) {
    var visibleConfig = this.getVisibleConfig();
    if (type === 'none' || type === 'smart' || type === 'always') {
      this.config.scrollType = type;
    }
    this.setVisibleConfig(visibleConfig.min, visibleConfig.max);
  };

  /**
   * Returns the currently active scrolling behavior of the axis.
   * @return {string} The axis' scrolling behavior
   */


  CartesianAxis.prototype.getScrollType = function getScrollType() {
    return this.config.scrollType;
  };

  CartesianAxis.prototype._processAxisBreak = function _processAxisBreak() {
    var axis = this,
        axisConfig = axis.config,
        breakPoints,
        count,
        i,
        len;

    axisConfig.breakPoints = [];
    breakPoints = axisConfig.axisBreak.split('|');
    for (i = 0, len = breakPoints.length, count = 0; i < len; i += 1) {
      breakPoints[i] = breakPoints[i].split(',');
      if (!isNaN(breakPoints[i][0]) && !isNaN(breakPoints[i][1])) {
        axisConfig.breakPoints[count] = {
          start: (0, _lib.pluckNumber)(breakPoints[i][0]),
          end: (0, _lib.pluckNumber)(breakPoints[i][1]),
          length: (0, _lib.pluckNumber)(breakPoints[i][2], 0)
        };
        count += 1;
      }
    }
    axisConfig.breakPoints.sort(function (a, b) {
      return a.start - b.start;
    });
    axisConfig.hasBreakPoints = true;
    axis._validateBreakPoints();
  };

  CartesianAxis.prototype._validateBreakPoints = function _validateBreakPoints() {
    var axis = this,
        axisConfig = axis.config,
        breakPoints = axisConfig.breakPoints,
        totalBreakAmount = 0,
        i,
        len = breakPoints.length;

    for (i = 0; i < len; i += 1) {
      totalBreakAmount += breakPoints[i].end - breakPoints[i].start;
    }
    axisConfig.totalBreakAmount = totalBreakAmount;
  };

  CartesianAxis.prototype._getRelativeBreakValue = function _getRelativeBreakValue(value) {
    var axis = this,
        axisConfig = axis.config,
        breakPoints = axisConfig.breakPoints,
        i,
        len = breakPoints.length,
        valueDeletion = 0;

    for (i = 0; i < len; i += 1) {
      if (value >= breakPoints[i].start && value <= breakPoints[i].end) {
        return breakPoints[i].start - valueDeletion;
      } else if (value < breakPoints[i].start) {
        break;
      }
      valueDeletion += breakPoints[i].end - breakPoints[i].start;
    }
    return value - valueDeletion;
  };

  CartesianAxis.prototype._getRealBreakValue = function _getRealBreakValue(value) {
    var axis = this,
        axisConfig = axis.config,
        breakPoints = axisConfig.breakPoints,
        i,
        len = breakPoints.length;

    for (i = 0; i < len; i += 1) {
      if (value >= breakPoints[i].start) {
        value += breakPoints[i].end - breakPoints[i].start;
      } else if (value < breakPoints[i].start) {
        return value;
      }
    }
    return value;
  };

  /**
   * Gets the Raphael text element associated with a label at the specified index
   * @param  {number} index The index from which to fetch the label element
   * @return {Object}       The label element
   */


  CartesianAxis.prototype._getLabelElement = function _getLabelElement(index) {
    var axis = this,
        axisConfig = axis.config,
        element;

    if (axisConfig.hasCategory) {
      element = axisConfig && axisConfig.categoryLabel && axisConfig.categoryLabel[index];
    } else {
      element = axis.graphics && axis.getGraphicalElement('labels') && axis.getGraphicalElement('labels')[index];
    }
    return element;
  };

  /**
   * Given an interval, this changes the number formatter in use at present
   * @param  {number} interval The interval to adjust the number formatter against
   */


  CartesianAxis.prototype._adjustNumberFormatter = function _adjustNumberFormatter(interval) {
    var axis = this,
        axisConfig = axis.config,
        axisIndex = axisConfig.axisIndex,
        isVertical = axisConfig.isVertical,
        chart = axis.getFromEnv('chart'),
        numberFormatter = chart.getFromEnv('number-formatter'),
        defaultDecimalPrecision = axisConfig._defaultDecimalPrecision,
        defaultForceDecimal = axisConfig._defaultForceDecimal,
        dec,
        beforeZero = 0,
        numberFormatterSetting;

    if (isVertical || axisConfig.numberFormatterFn === 'yAxis') {
      numberFormatterSetting = (numberFormatter.Y[axisIndex] || numberFormatter.Y[0]).yAxisLabelConf;
    } else {
      numberFormatterSetting = numberFormatter.paramX;
    }
    defaultDecimalPrecision !== UNDEF ? numberFormatterSetting.decimalprecision = defaultDecimalPrecision : axisConfig._defaultDecimalPrecision = numberFormatterSetting.decimalprecision;

    defaultForceDecimal !== UNDEF ? numberFormatterSetting.forcedecimals = defaultForceDecimal : axisConfig._defaultForceDecimal = numberFormatterSetting.forcedecimals;

    // If integer part is greater than zero no need of adjustment
    if (parseInt(interval, 10) > 0) {
      return;
    }
    // Get the fraction part as a string
    dec = interval.toString().split('.')[1];
    if (dec) {
      // Extract the number of zero in the begining because if no of decimal in numberFormatter is
      // less or equal to the number zero then same number may repeat.
      beforeZero = dec.match(/^[0]*/)[0].length;
      if (beforeZero + 1 > numberFormatterSetting.decimalprecision) {
        numberFormatterSetting.forcedecimals = 1;
      }
      numberFormatterSetting.decimalprecision = mathMax(beforeZero + 1, numberFormatterSetting.decimalprecision);
    }
  };

  /**
   * Function set the div interval and set the max and min value used by axis.
   * This function is called internally to adjust the div interval when the chart dimension is
   * changed.
   */


  CartesianAxis.prototype._setTickIntervalAfterZoom = function _setTickIntervalAfterZoom() {
    var axis = this,
        axisConfig = axis.config,

    // chart = axis.getFromEnv('chart'),
    // viewPortConfig = chart.config.viewPortConfig,
    // isVertical = axisConfig.isVertical,
    axisRange = axisConfig.axisRange,
        numDivLines = axisConfig.numDivLines,
        setAdaptiveMin = axisConfig.setAdaptiveMin,
        adjustDiv = axisConfig.adjustDiv,
        attr = axisConfig.rawAttr,
        setMinAsZero,
        stopMaxAtZero,
        axisLimits,
        AxisMaxValue,
        AxisMinValue,
        max,
        min,
        scale;
    if (axisConfig.hasCategory) {
      return;
    }
    scale = axis.getZoomScale();
    // Setting the required variable used to calculate the div interval
    max = (0, _lib.pluckNumber)(attr.axisrange ? attr.axisrange.max : axisRange.max);
    min = (0, _lib.pluckNumber)(attr.axisrange ? attr.axisrange.min : axisRange.min);
    AxisMaxValue = axisRange.max;
    AxisMinValue = axisRange.min;

    setMinAsZero = stopMaxAtZero = !setAdaptiveMin;
    adjustDiv = (0, _lib.pluckNumber)(scale === 1 ? axisConfig.adjustDiv : 0);
    // Calling the getAxisLimits from lib to calculate the best possible div interval
    // TODO : improve the function getAxisLimits
    axisLimits = (0, _lib.getAxisLimits)(max, min, AxisMaxValue, AxisMinValue, stopMaxAtZero, setMinAsZero, numDivLines * scale, adjustDiv);
    // Saving the data to the axis
    axis.setAxisRange({
      max: Number((0, _lib.toPrecision)(axisLimits.Max, 10)),
      min: Number((0, _lib.toPrecision)(axisLimits.Min, 10)),
      tickInterval: Number((0, _lib.toPrecision)(axisLimits.divGap, 10))
    });
    // axisRange.min = Number(toPrecision(axisLimits.Min,10));
    // axisRange.max = Number(toPrecision(axisLimits.Max, 10));
    // axisRange.tickInterval = Number(toPrecision(axisLimits.divGap, 10));
    axis._adjustNumberFormatter(axisRange.tickInterval);
    // check for zero value to break infinite loop
    if (axisRange.tickInterval === 0) {
      axisRange.tickInterval = 1;
    }
  };

  /**
   * Function help to extract the all attribute from parent to its child
   * @param {Object} obj The Object for which the attribute to be extracted
   * @param {Object} attribObj the attribute object
   */


  CartesianAxis.prototype._extractAttribToEnd = function _extractAttribToEnd(obj, attribObj) {
    var axis = this,
        ind;

    obj._attrib = (0, _lib.extend2)({}, attribObj);
    obj._attrib = (0, _lib.extend2)(obj._attrib, _getAttribAsObj(obj));
    for (ind in obj) {
      if (obj.hasOwnProperty(ind) && !!obj[ind] && _typeof(obj[ind]) === 'object' && ind !== '_attrib') {
        axis._extractAttribToEnd(obj[ind], obj._attrib);
      }
    }
  };

  /**
   * function used internally to shift the vline left of the given index to the direction defined
   * @param {number} index The index right of whose every vline will be shifted
   * @param {number} shift no of place by which the label will be shifted
   * @param {string} direction direction to be shifted right or left
   */


  CartesianAxis.prototype._shiftVline = function _shiftVline(index, shift, direction) {
    var axis = this,
        axisConfig = axis.config,
        vline = axisConfig.categories.vline,
        catLen = axisConfig.categories.category.length,
        len = vline.length,
        i,
        curVline;

    for (i = 0; i < len; i += 1) {
      curVline = vline[i];
      if (curVline.startIndex >= index) {
        if (direction === 'right') {
          curVline.startIndex += shift;
        } else {
          curVline.startIndex -= shift;
        }
        // if vline get out of canvas delete the vline
        if (curVline.startIndex - shift < 0 || curVline.startIndex - shift >= catLen) {
          vline.splice(i, 1);
          len -= 1;
          i -= 1;
        }
      }
    }
  };

  /**
   * Function returning is the axis is in zoomed condition or not
   * @return {boolean} is the axis in zoomed condition
   */


  CartesianAxis.prototype._isZoomed = function _isZoomed() {
    var axis = this,
        axisLimits = axis.getLimit(),
        decimalPrecision = 4,
        visibleLength = getRoundedDecimal(axis.getVisibleLength(), decimalPrecision),
        totalLength = getRoundedDecimal(axisLimits.max - axisLimits.min, decimalPrecision);

    return visibleLength < totalLength;
  };

  /**
   * Given an object, this method calculates and modifies the object to have some special path
   * related attributes.
   * @param  {Object} obj             [description]
   * @param  {number} value           [description]
   * @param  {number} plotLineWidth   [description]
   * @param  {Object} getPixelOptions [description]
   * @return {Object}                 [description]
   */


  CartesianAxis.prototype._calculatePath = function _calculatePath(obj, value, plotLineWidth, getPixelOptions) {
    var axis = this,
        axisConfig = axis.config,
        isVertical = axisConfig.isVertical,
        canvas = axisConfig.canvas,
        chart = axis.getFromEnv('chart'),
        chartConfig = chart.config,
        canvasBottom = canvas.canvasBottom || chartConfig.canvasBottom,
        canvasLeft = canvas.canvasLeft || chartConfig.canvasLeft,
        canvasRight = canvas.canvasRight || chartConfig.canvasRight,
        canvasTop = canvas.canvasTop || chartConfig.canvasTop,
        crispPath;

    crispPath = getCrispPath(['M', isVertical ? canvasLeft : axis.getPixel(value, getPixelOptions), isVertical ? axis.getPixel(value, getPixelOptions) : canvasTop, 'L', isVertical ? canvasRight : axis.getPixel(value, getPixelOptions), isVertical ? axis.getPixel(value, getPixelOptions) : canvasBottom], plotLineWidth);
    obj.path = crispPath.path;

    obj['shape-rendering'] = crispPath.isCrisped ? CRISP : UNDEF;
    return obj;
  };

  CartesianAxis.prototype._getIntervalArr = function _getIntervalArr(args) {
    var axis = this,
        axisConfig = axis.config,
        axisLabelConfig = axisConfig.labels,
        axisRange = axisConfig.axisRange,
        axisMin = axisRange.min,
        increment = axisRange.tickInterval * (args && args.step || 1),
        returnArr = [],
        getLimit,
        visibleMin,
        visibleMax,
        min,
        max,
        i,
        value;

    getLimit = this.getVisibleConfig();
    visibleMin = getLimit.minValue - (args && args.minPad || 0);
    visibleMax = getLimit.maxValue + (args && args.maxPad || 0);

    min = (0, _lib.toPrecision)(axisMin + increment * Math.floor(Math.abs(axisMin - visibleMin) / increment), 10);
    max = (0, _lib.toPrecision)(axisMin + increment * Math.ceil(Math.abs(visibleMax - axisMin) / increment), 10);

    if (min === max) {
      return [min];
    }

    if (axisLabelConfig.drawNormalVal) {
      for (i = (0, _lib.toPrecision)(min + increment, 10); i < max; i = (0, _lib.toPrecision)(i + increment, 10)) {
        if (axisConfig.hasBreakPoints) {
          value = (0, _lib.toPrecision)(axis._getRealBreakValue(i), 10);
        } else {
          value = (0, _lib.toPrecision)(i, 10);
        }
        returnArr.push(value);
      }
    }
    if (axisLabelConfig.drawLimitVal) {
      returnArr.push(max, min);
    }

    returnArr.indexOf(0) !== -1 && returnArr.splice(returnArr.indexOf(0), 1);

    if (axisConfig.showZeroPlane && axisConfig.showZeroPlaneValue && axisMin <= 0 && max >= 0) {
      returnArr.push(0);
    }

    return returnArr.sort(function (a, b) {
      return a - b;
    });
  };

  CartesianAxis.prototype._getCategoryArr = function _getCategoryArr() {
    var axis = this,
        axisConfig = axis.config,
        isVertical = axisConfig.isVertical,
        tempStep = 0,
        category,
        i,
        max,
        min,
        curCategory,
        getLimit,
        curCategoryValue,
        increment,
        intervalWidth,
        checkForLimit,
        retArr = [];

    // NOTE: animateCategories seems to be legacy code. It was present at one point to force the
    // first incoming category to be drawn outside the canvas bounds.

    // if (axisConfig.isCategoryAnimate && axisConfig.animateCategories) {
    //     category = axisConfig.animateCategories;
    // } else {
    category = axisConfig.categories.category;
    // }
    min = 0;
    max = category ? category.length - 1 : 0;
    if (isVertical) {
      intervalWidth = mathAbs(axis.getPixel(0) - axis.getPixel(1));
      // check for overlap if there is any make the step such that no overlap happens
      if (axisConfig.labelMaxH > intervalWidth) {
        tempStep = mathCeil(axisConfig.labelMaxH / intervalWidth);
      }
      if (tempStep > axisConfig.labels.step) {
        axisConfig.labels.step = tempStep;
      }
    }
    increment = axisConfig.labels.step > 0 ? axisConfig.labels.step : 1;
    // if not zoomed dont check for limit
    checkForLimit = axis._isZoomed();

    getLimit = this.getVisibleConfig();

    // main loop where the drawing starts
    for (i = min; i <= max; i += increment) {
      curCategory = category[i];

      if (!curCategory) {
        continue;
      }

      // TODO : need to
      curCategoryValue = (0, _lib.pluckNumber)(curCategory.x, curCategory.y, i);
      if ((0, _lib.pluckNumber)(curCategory.showlabel, axisConfig.showLabels, 1) === 0) {
        continue;
      }
      // if value is not between the visual limit increment it and continue
      if (checkForLimit && (curCategoryValue < getLimit.minValue || curCategoryValue > getLimit.maxValue)) {
        continue;
      }
      if ((axisConfig.xAxisLabelMode === 'auto' || axisConfig.xAxisLabelMode === 'mixed') && (axisConfig.showZeroPlane === 0 || axisConfig.showZeroPlaneValue === 0) && curCategoryValue === 0) {
        continue;
      }
      // if values are not limit value and label drawing is off other
      // than limit increment it and continue
      if (!axisConfig.labels.drawNormalVal && !(axisConfig.labels.drawLimitVal && (i === min || i === max))) {
        continue;
      }
      if (!axisConfig.labels.drawNormalVal && !(i === min || i === max)) {
        continue;
      }
      // if value are limit value but limit value are not mean to be drawn
      if (!axisConfig.labels.drawLimitVal && (i === min || i === max)) {
        continue;
      }
      retArr.push({
        index: i,
        value: curCategoryValue
      });
    }

    return retArr;
  };

  /**
   * Function called by the placeAxis when there is requirement to calculate or recalculate the space
   * management
   * @param {number} maxWidth The maximum width that is available for space management
   * @return {Object} Left and right defining how much space is used in left and right
   */


  CartesianAxis.prototype._placeVerticalAxis = function _placeVerticalAxis(maxWidth) {
    var axis = this,
        axisConfig = axis.config,
        chart = axis.getFromEnv('chart'),
        chartConfig = chart.config,
        smartLabel = chart.getFromEnv('smartLabel'),
        axisRange = axisConfig.axisRange,
        axisNameData = axisConfig.name,
        isOpposit = axisConfig.isOpposit,
        numberFormatter = axis.getFromEnv('number-formatter'),
        canvasHeight = chartConfig.canvasHeight,
        axisValuePadding = axisConfig.labelPadding = (0, _lib.pluckNumber)(axisConfig.rawAttr.axisValuePadding, 4),
        axisNamePadding = (0, _lib.pluckNumber)(axisConfig.rawAttr.axisNamePadding, 5),
        useEllipsesWhenOverflow = axisConfig.useEllipsesWhenOverflow,
        nameStyle = axisConfig.name.style,
        trendStyle = axisConfig.trend.trendStyle,
        axisName = axisConfig.axisName,
        trendlines = axisConfig.trendLines,
        drawLabelsOpposit = axisConfig.drawLabelsOpposit,
        drawAxisNameOpposit = axisConfig.drawAxisNameOpposit,
        j,
        jLen,
        axisLabelWidth = 0,
        labelWidth = 0,
        nameWidth = 0,
        trendLeftWidth = 0,
        trendRightWidth = 0,
        retObj = {
      left: 0,
      right: 0
    },
        maxLeftTrendValue = '',
        maxRightTrendValue = '',
        reserveNameHeight = 0,
        numberFormatterFn,
        axisSmartName,
        axisSmartTrendValue,
        trendTextFromValue,
        i,
        max,
        min,
        text,
        dimention,
        iLim,
        trendObj,
        valueOnRight,
        axisLineThickness,
        startTValue,
        endTValue;

    if (chartConfig.viewPortConfig && chartConfig.viewPortConfig.scaleY !== 1) {
      axisConfig._setRangeAgain = true;
    }
    axisConfig._setRangeAgain && axis._setTickIntervalAfterZoom();
    // If the value padding id negative make it 2 default value
    axisConfig.oriCanvasHeight = canvasHeight;
    if (axisValuePadding < 0) {
      axisConfig.labelPadding = 2;
    }
    if (axisConfig.drawTick && axisConfig.tickLength) {
      axisLineThickness = axisConfig.axisLineThickness + axisConfig.tickLength;
    } else {
      axisLineThickness = axisConfig.axisLineThickness;
    }
    // if axis line is shown adjust the space accordingly w.r.t width
    if (axisConfig.showAxisLine) {
      // recalculate the label padding
      axisConfig.labelPadding = (0, _lib.pluckNumber)(axisValuePadding, 2) + axisLineThickness;
      if (axisConfig.labelPadding < 0) {
        axisConfig.labelPadding = (axisConfig.axisLineThickness < 0 ? 0 : axisLineThickness) + 2;
      }
      // adjust the maxWidth accordingly
      maxWidth -= axisConfig.axisLineThickness;
    } else {
      // if the axis line is not shown adjust the label padding and maxWidth accordingly
      axisConfig.labelPadding = (0, _lib.pluckNumber)(axisValuePadding, 2);
      if (axisConfig.labelPadding < 0) {
        axisConfig.labelPadding = 2;
      }
    }
    max = axisRange.max;
    min = axisRange.min;
    // store the configuration of the axis
    axisConfig.name.rotation = 0;
    axisConfig.labels.step = axisConfig.labelStep;
    axisConfig.labels.isDraw = 1;
    axisConfig.lines.isDraw = 1;
    axisConfig.band.isDraw = 1;
    axisConfig.labels.drawNormalVal = axisConfig.showDivLineValues;
    axisConfig.labels.drawLimitVal = axisConfig.showLimits;

    reserveNameHeight = nameStyle.lineHeight;
    reserveNameHeight = Number(reserveNameHeight.replace(/px/i, ''));
    if (reserveNameHeight < maxWidth) {
      maxWidth -= reserveNameHeight;
    }
    // store the configuration if to draw the limit values
    if (axisConfig.showLimits !== 1 && axisConfig.showDivLineValues !== 1) {
      axisConfig.labels.isDraw = 0;
    }

    // using the smart label to get the max width among all the labels
    dimention = axisConfig.drawLabels ? axis._getVMaxLabelDimention(maxWidth - axisConfig.labelPadding) : { width: 0, height: 0 };
    if (dimention.width + axisConfig.labelPadding > maxWidth && !axisConfig.hasCategory || dimention.width === 0) {
      axisConfig.labels.isDraw = 0;
    }
    if (axisConfig.labels.isDraw) {
      axisConfig.labelMaxW = dimention.width;
      axisConfig.labelMaxH = dimention.height;
      axisLabelWidth = dimention.width + axisConfig.labelPadding;
      labelWidth = axisLabelWidth;
    }
    // the width left after label is drawn

    // space management for trend lines
    // check if trend line is available and is active axis
    if (axisConfig.drawTrendLines && axisConfig.drawTrendLabels && trendlines) {
      if (axisConfig.isPercent) {
        numberFormatterFn = numberFormatter.percentValue;
      } else if (axisConfig.isVertical) {
        numberFormatterFn = numberFormatter.yAxis;
      } else {
        numberFormatterFn = numberFormatter.xAxis;
      }

      smartLabel.useEllipsesOnOverflow(chartConfig.useEllipsesWhenOverflow);
      // for trend line
      smartLabel.setStyle({
        fontSize: trendStyle.fontSize,
        fontFamily: trendStyle.fontFamily,
        lineHeight: trendStyle.lineHeight,
        fontWeight: trendStyle.fontWeight
      });
      // iterate through every trend line to get the trend line max width for both left and right
      for (j = 0, jLen = trendlines.length; j < jLen; j += 1) {
        for (i = 0, iLim = trendlines[j].line && trendlines[j].line.length; i < iLim; i += 1) {
          trendObj = trendlines[j].line[i];
          startTValue = numberFormatter.getCleanValue((0, _lib.pluck)(trendObj.startvalue, trendObj.value, 0));
          endTValue = (0, _lib.pluckNumber)(trendObj.endvalue, startTValue);
          if (startTValue <= max && startTValue >= min && endTValue <= max && endTValue >= min) {
            if (axisConfig.isOpposit) {
              trendObj.valueonright = 1;
            }
            valueOnRight = (0, _lib.pluckNumber)(trendObj.valueonright, 0);
            trendTextFromValue = valueOnRight === 1 ? trendObj.endvalue || trendObj.startvalue : trendObj.startvalue || trendObj.endvalue;
            text = (0, _lib.parseUnsafeString)(trendObj.origText || trendObj.displayvalue || trendTextFromValue || '');
            if (text === trendTextFromValue) {
              text = '' + numberFormatterFn.call(numberFormatter, text);
            }
            // if the value is displayed on right side
            if (valueOnRight) {
              if (text.length > maxRightTrendValue.length) {
                maxRightTrendValue = text;
              }
            } else {
              // if the value is on left side
              if (text.length > maxLeftTrendValue.length) {
                maxLeftTrendValue = text;
              }
            }
          }
        }
      }
      // get the width and store it accordingly
      dimention = smartLabel.getOriSize(maxRightTrendValue);
      trendRightWidth = dimention.width + axisConfig.labelPadding;
      dimention = smartLabel.getOriSize(maxLeftTrendValue);
      trendLeftWidth = dimention.width + axisConfig.labelPadding;
      if (isOpposit) {
        // managing space and truncating label value if required
        if (trendRightWidth > labelWidth && trendRightWidth > maxWidth) {
          trendRightWidth = maxWidth;
        }
        // update the label width if trend label width is added
        labelWidth = mathMax(labelWidth, trendRightWidth + axisConfig.labelPadding);
        if (trendLeftWidth > maxWidth - labelWidth) {
          trendLeftWidth = mathMin(trendLeftWidth, maxWidth - labelWidth);
        }
      } else {
        // managing space and truncating label value if required
        if (trendLeftWidth > labelWidth && trendLeftWidth > maxWidth) {
          trendLeftWidth = maxWidth;
        }
        // update the label width if trend label width is added
        labelWidth = mathMax(labelWidth, trendLeftWidth + axisConfig.labelPadding);
        if (trendRightWidth > maxWidth - labelWidth) {
          trendRightWidth = mathMin(trendRightWidth, maxWidth - labelWidth);
        }
      }
      // truncate the trend label if required
      for (j = 0, jLen = trendlines.length; j < jLen; j += 1) {
        for (i = 0, iLim = trendlines[j].line && trendlines[j].line.length; i < iLim; i += 1) {
          trendObj = trendlines[j].line[i];
          startTValue = numberFormatter.getCleanValue((0, _lib.pluck)(trendObj.startvalue, trendObj.value, 0));
          endTValue = (0, _lib.pluckNumber)(trendObj.endvalue, startTValue);
          if (Number(trendObj.valueonright) === 1) {
            text = trendObj.origText || trendObj.displayvalue || '' + endTValue || '';
          } else {
            text = trendObj.origText || trendObj.displayvalue || '' + startTValue || '';
          }
          text = (0, _lib.parseUnsafeString)('' + text);
          if (Number(text) === endTValue || Number(text) === startTValue) {
            text = '' + numberFormatterFn.call(numberFormatter, text);
          }
          trendObj.origText = text;
          valueOnRight = (0, _lib.pluckNumber)(trendObj.valueonright, 0);
          // get the smart label value for right side labels
          if (valueOnRight) {
            axisSmartTrendValue = smartLabel.getSmartText(text, trendRightWidth, chart.canvasHeight, useEllipsesWhenOverflow);
          } else {
            // get the smart label value for the left side label
            axisSmartTrendValue = smartLabel.getSmartText(text, labelWidth, chart.canvasHeight, useEllipsesWhenOverflow);
          }
          // store the value to be displayed
          trendObj.displayvalue = axisSmartTrendValue.text;
          // if tool text is to be shown or not
          if (axisSmartTrendValue.tooltext) {
            trendObj.valueToolText = axisSmartTrendValue.tooltext;
          } else {
            delete trendObj.valueToolText;
          }
        }
      }
    }

    maxWidth += reserveNameHeight;
    // For axis name
    // labelWidth include the left trend label width
    // checking if is possible to draw the axis name
    if (!axisConfig.drawAxisName || maxWidth - labelWidth - trendRightWidth <= 0 || axisName === '') {
      axisNameData.isDraw = false;
      axisNameData.value = '';
    } else {
      // set the smart label style for axis name
      smartLabel.setStyle({
        fontSize: nameStyle.fontSize,
        fontFamily: nameStyle.fontFamily,
        lineHeight: nameStyle.lineHeight,
        fontWeight: nameStyle.fontWeight
      });
      // make isDraw true so that it is drawn
      axisNameData.isDraw = true;
      // if rotation is enabled get the axis name width by smart text height
      if (axisConfig.rotateAxisName) {
        // set the rotation
        axisConfig.name.rotation = isOpposit ? 90 : 270;
        axisSmartName = smartLabel.getSmartText(axisName, canvasHeight, maxWidth - labelWidth - trendRightWidth);
        axisNameData.value = axisName;
        // store the max width
        axisConfig.nameMaxW = mathMin(axisSmartName.height);
        // get the total name width with padding
        nameWidth = axisConfig.nameMaxW + axisNamePadding;
      } else {
        // if no rotation is there
        axisSmartName = smartLabel.getSmartText(axisName, maxWidth - labelWidth - trendRightWidth, canvasHeight);
        axisNameData.value = axisName;
        axisConfig.nameMaxW = mathMin(axisSmartName.width, maxWidth - labelWidth);
        axisConfig.nameMaxH = axisSmartName.height;
        if (axisConfig.axisNameWidth >= 0) {
          axisConfig.nameMaxW = mathMin(axisConfig.nameMaxW, axisConfig.axisNameWidth);
        }
        // get the total name width with padding
        nameWidth = axisConfig.nameMaxW + axisNamePadding;
      }
    }

    // returning the value of how much space has been taken
    if (isOpposit) {
      if (drawLabelsOpposit) {
        retObj.left += mathMax(axisLabelWidth, trendLeftWidth);
        retObj.right += trendRightWidth;
      } else {
        retObj.left += trendLeftWidth;
        retObj.right += mathMax(axisLabelWidth, trendRightWidth);
      }
      if (drawAxisNameOpposit) {
        axisConfig.axisNamePadding = retObj.left + axisNamePadding;
        retObj.left += nameWidth;
      } else {
        axisConfig.axisNamePadding = retObj.right + axisNamePadding;
        retObj.right += nameWidth;
      }
    } else {
      if (drawLabelsOpposit) {
        retObj.left += trendLeftWidth;
        retObj.right += mathMax(axisLabelWidth, trendRightWidth);
      } else {
        retObj.left += mathMax(axisLabelWidth, trendLeftWidth);
        retObj.right += trendRightWidth;
      }
      if (drawAxisNameOpposit) {
        axisConfig.axisNamePadding = retObj.right + axisNamePadding;
        retObj.right += nameWidth;
      } else {
        axisConfig.axisNamePadding = retObj.left + axisNamePadding;
        retObj.left += nameWidth;
      }
    }
    if (axisNameData.isDraw && axisConfig.axisNamePadding + axisConfig.nameMaxW > maxWidth) {
      axisConfig.axisNamePadding = maxWidth - axisConfig.nameMaxW;
      nameWidth = axisConfig.nameMaxW + axisConfig.axisNamePadding - labelWidth;
    }
    return retObj;
  };

  /**
   * Function called by the placeAxis when there is requirement to calculate or recalculate
   * the space management
   * @param  {number} maxHeight The maximum height that is available for space management
   * @return {Object}             Bottom defining how much space is used in bottom
   */


  CartesianAxis.prototype._placeHorizontalAxis = function _placeHorizontalAxis(maxHeight) {
    var axis = this,
        axisConfig = axis.config,
        chart = axis.getFromEnv('chart'),
        chartConfig = chart.config,
        smartLabel = chart.getFromEnv('smartLabel'),
        axisRange = axisConfig.axisRange,
        axisNameData = axisConfig.name,
        isOpposit = axisConfig.isOpposit,
        numberFormatter = chart.getFromEnv('number-formatter'),
        drawLabelsOpposit = axisConfig.drawLabelsOpposit,
        drawAxisNameOpposit = axisConfig.drawAxisNameOpposit,
        axisLabelHeight = 0,
        canvasWidth = chartConfig.canvasWidth,
        axisValuePadding = axisConfig.labelPadding = (0, _lib.pluckNumber)(axisConfig.rawAttr.axisValuePadding, 4),
        axisNamePadding = (0, _lib.pluckNumber)(axisConfig.rawAttr.axisNamePadding, 5),
        useEllipsesWhenOverflow = axisConfig.useEllipsesWhenOverflow,
        nameStyle = axisConfig.name.style,
        trendStyle = axisConfig.trend.trendStyle,
        axisName = axisConfig.axisName,
        vtrendlines = axisConfig.vTrendLines,
        valueOnRight,
        trendTextFromValue,
        j,
        jLen,
        labelHeight = 0,
        nameHeight = 0,
        retObj = {
      top: 0,
      bottom: 0
    },
        trendMaxHeight = 0,
        reserveNameHeight = 0,
        axisSmartName,
        i,
        max,
        min,
        text,
        iLim,
        heightLeft,
        trendObj,
        axisSmartTrendValue,
        trendHeight,
        dimention,
        numberFormatterFn,
        axisLineThickness,
        startTValue,
        endTValue;

    if (chartConfig.viewPortConfig && chartConfig.viewPortConfig.scaleX !== 1) {
      axisConfig._setRangeAgain = true;
    }
    axisConfig._setRangeAgain && axis._setTickIntervalAfterZoom();
    // If the value padding id negative make it 2 default value
    if (axisValuePadding < 0) {
      axisConfig.labelPadding = 2;
    }
    if (axisConfig.drawTick && axisConfig.tickLength) {
      axisLineThickness = axisConfig.axisLineThickness + axisConfig.tickLength;
    } else {
      axisLineThickness = axisConfig.axisLineThickness;
    }
    // if axis line is shown adjust the space accordingly w.r.t width
    if (axisConfig.showAxisLine) {
      // recalculate the label padding
      axisConfig.labelPadding = (0, _lib.pluckNumber)(axisValuePadding, 2) + axisLineThickness;
      if (axisConfig.labelPadding < 0) {
        axisConfig.labelPadding = (axisConfig.axisLineThickness < 0 ? 0 : axisLineThickness) + 2;
      }
      // adjust the maxHeight accordingly
      maxHeight -= axisConfig.axisLineThickness;
    } else {
      // if the axis line is not shown adjust the label padding and maxWidth accordingly
      axisConfig.labelPadding = (0, _lib.pluckNumber)(axisValuePadding, 2);
      if (axisConfig.labelPadding < 0) {
        axisConfig.labelPadding = 2;
      }
    }

    max = axisRange.max;
    min = axisRange.min;

    // For axis label
    // store the configuration of the axis
    axisConfig.labels.rotation = 0;
    axisConfig.labels.step = axisConfig.labelStep;
    axisConfig.labels.isDraw = 1;
    axisConfig.lines.isDraw = 1;
    axisConfig.band.isDraw = 1;
    axisConfig.labels.drawNormalVal = axisConfig.showDivLineValues;
    axisConfig.labels.drawLimitVal = axisConfig.showLimits;

    reserveNameHeight = nameStyle.lineHeight;
    reserveNameHeight = Number(reserveNameHeight.replace(/px/i, ''));
    if (reserveNameHeight < maxHeight) {
      maxHeight -= reserveNameHeight;
    }

    // checking is rotation is applied for labels by external attribute rotateLabels and
    // label display is not set to stagger or none then rotate
    if (axisConfig.rotateLabels && axisConfig.labelDisplay !== 'stagger' && axisConfig.labelDisplay !== 'none') {
      axisConfig.labelDisplay = 'rotate';
    }

    // store the configuration if to draw the limit values
    if (axisConfig.showLimits !== 1 && axisConfig.showDivLineValues !== 1) {
      axisConfig.labels.isDraw = 0;
    }

    // using the smart label to get the max width or height among all the labels
    dimention = axisConfig.drawLabels ? axis._getHMaxLabelDimention(maxHeight - axisConfig.labelPadding) : { width: 0, height: 0 };

    if (axisConfig.labels.rotation) {
      // if rotation is on the smart text width is applicable
      if (dimention.width + axisConfig.labelPadding > maxHeight && !axisConfig.hasCategory) {
        axisConfig.labels.isDraw = 0;
      }
    } else {
      // the smart text height is applicable
      if (dimention.height + axisConfig.labelPadding > maxHeight && !axisConfig.hasCategory) {
        axisConfig.labels.isDraw = 0;
      }
    }
    if (axisConfig.labels.isDraw) {
      // set the max width and height for rotation or non rotation
      if (axisConfig.labels.rotation) {
        axisConfig.labelMaxW = dimention.height;
        axisConfig.labelMaxH = dimention.width;
        axisLabelHeight = dimention.width + axisConfig.labelPadding;
      } else {
        axisConfig.labelMaxW = dimention.width;
        axisConfig.labelMaxH = dimention.height;
        axisLabelHeight = dimention.height + axisConfig.labelPadding;
      }
      labelHeight = axisLabelHeight;
    }
    labelHeight = mathMax(labelHeight, axisConfig.labelPadding);
    // the height left after label is drawn
    heightLeft = labelHeight <= maxHeight ? maxHeight - labelHeight : maxHeight;

    // space management for trend lines
    // check if vertical trend line is available and is active axis
    if (axisConfig.drawTrendLines && axisConfig.drawTrendLabels && vtrendlines && axisConfig.isActive) {
      if (axisConfig.isPercent) {
        numberFormatterFn = axis.getFromEnv('number-formatter').percentValue;
      } else if (axisConfig.isVertical) {
        numberFormatterFn = axis.getFromEnv('number-formatter').yAxis;
      } else {
        numberFormatterFn = axis.getFromEnv('number-formatter').xAxis;
      }
      smartLabel.useEllipsesOnOverflow(chartConfig.useEllipsesWhenOverflow);
      // for trend line
      smartLabel.setStyle({
        fontSize: trendStyle.fontSize,
        fontFamily: trendStyle.fontFamily,
        lineHeight: trendStyle.lineHeight,
        fontWeight: trendStyle.fontWeight
      });
      // iterate through every trend line to get the trend line max width for both left and right
      for (j = 0, jLen = vtrendlines.length; j < jLen; j += 1) {
        for (i = 0, iLim = vtrendlines[j].line && vtrendlines[j].line.length; i < iLim; i += 1) {
          trendObj = vtrendlines[j].line[i];
          startTValue = numberFormatter.getCleanValue((0, _lib.pluck)(trendObj.startvalue, trendObj.value, 0));
          endTValue = (0, _lib.pluckNumber)(trendObj.endvalue, startTValue);
          if (startTValue <= max && startTValue >= min && endTValue <= max && endTValue >= min) {
            valueOnRight = (0, _lib.pluckNumber)(trendObj.valueonright, 0);
            trendTextFromValue = valueOnRight === 1 ? trendObj.endvalue || trendObj.startvalue : trendObj.startvalue || trendObj.endvalue;
            text = (0, _lib.parseUnsafeString)(trendObj.origText || trendObj.displayvalue || trendTextFromValue || '');
            if (text === trendTextFromValue) {
              text = '' + numberFormatterFn.call(chart.getFromEnv('number-formatter'), text);
            }
            trendObj.origText = text;
            axisSmartTrendValue = smartLabel.getSmartText(text, chart.canvasWidth, trendStyle.lineHeight, useEllipsesWhenOverflow);
            trendHeight = axisSmartTrendValue.height + 2;
            // checking if space available for trend label value to be drawn
            // if not make the display value empty
            if (heightLeft - trendHeight < 0) {
              trendObj.displayvalue = '';
            } else {
              // set the display value
              trendObj.displayvalue = axisSmartTrendValue.text;
              trendMaxHeight = trendMaxHeight < axisSmartTrendValue.height ? axisSmartTrendValue.height : trendMaxHeight;
            }
            // check tooltext is available which will help to draw tooltext on hover
            if (axisSmartTrendValue.tooltext) {
              trendObj.valueToolText = axisSmartTrendValue.tooltext;
            } else {
              delete trendObj.valueToolText;
            }
          }
        }
      }
    }
    // adjust the height left
    heightLeft -= trendMaxHeight;
    // recalculate the label height
    labelHeight += trendMaxHeight;

    heightLeft += reserveNameHeight;
    maxHeight += reserveNameHeight;
    // For axis name
    // checking if is possible to draw the axis name
    if (!axisConfig.drawAxisName || heightLeft <= 0 || axisName === '') {
      axisNameData.isDraw = false;
      axisNameData.value = '';
    } else {
      // set the smart label style for axis name
      smartLabel.setStyle({
        fontSize: nameStyle.fontSize,
        fontFamily: nameStyle.fontFamily,
        lineHeight: nameStyle.lineHeight,
        fontWeight: nameStyle.fontWeight
      });
      // make isDraw true so that it is drawn
      axisNameData.isDraw = true;
      axisSmartName = smartLabel.getSmartText(axisName, canvasWidth, heightLeft);
      axisNameData.value = axisName;
      // store the max width
      axisConfig.nameMaxW = canvasWidth;
      // store the max height
      axisConfig.nameMaxH = axisSmartName.height;
      // get the total name height with padding
      nameHeight = axisSmartName.height + axisNamePadding;
      // total padding from after which the drawing of axis can be start so that this point of drawing
      // axis name need not to recalculate
      axisConfig.axisNamePadding = axisNamePadding + labelHeight;
      if (axisConfig.axisNamePadding + axisSmartName.height > maxHeight) {
        axisConfig.axisNamePadding = maxHeight - axisSmartName.height;
        nameHeight = axisSmartName.height + axisConfig.axisNamePadding - labelHeight;
      }
    }
    if (isOpposit) {
      if (drawLabelsOpposit) {
        retObj.bottom += axisLabelHeight + trendMaxHeight;
      } else {
        retObj.top += axisLabelHeight;
        retObj.bottom += trendMaxHeight;
      }
      axisConfig.trendBottomPadding = retObj.bottom - trendMaxHeight + 2;
      if (drawAxisNameOpposit) {
        // axisConfig.axisNamePadding = retObj.bottom + axisNamePadding;
        retObj.bottom += nameHeight;
      } else {
        // axisConfig.axisNamePadding = retObj.top + axisNamePadding;
        retObj.top += nameHeight;
      }
    } else {
      if (drawLabelsOpposit) {
        retObj.top += axisLabelHeight;
        retObj.bottom += trendMaxHeight;
      } else {
        retObj.bottom += axisLabelHeight + trendMaxHeight;
      }
      axisConfig.trendBottomPadding = retObj.bottom - trendMaxHeight + 2;
      if (drawAxisNameOpposit) {
        // axisConfig.axisNamePadding = retObj.top + axisNamePadding;
        retObj.top += nameHeight;
      } else {
        // axisConfig.axisNamePadding = retObj.bottom + axisNamePadding;
        retObj.bottom += nameHeight;
      }
    }
    // returning the value of how much space has been taken
    // if (isOpposit) {
    //     retObj.top =  labelHeight + nameHeight;
    // } else {
    //     retObj.bottom =  labelHeight + nameHeight;
    // }
    return retObj;
  };

  /**
   * Function will give the hidth height of the maximum label present
   * @param {number} maxHeight The maximum height of the label
   * @return {Object} Object   Containing the width and height of the max length label
   */


  CartesianAxis.prototype._getHMaxLabelDimention = function _getHMaxLabelDimention(maxHeight) {
    var axis = this,
        axisConfig = axis.config,
        chart = axis.getFromEnv('chart'),
        chartConfig = chart.config,
        smartLabel = chart.getFromEnv('smartLabel'),
        axisRange = axisConfig.axisRange,
        labels = axisConfig.labels,
        labelDisplay = axisConfig.labelDisplay,
        slantLabel = axisConfig.slantLabel,
        labelStyle = labels.style,
        userMaxLabelHeight = axisConfig.maxLabelHeight,
        increment = axisRange.tickInterval,
        staggerLines = axisConfig.staggerLines,
        labelStep = axisConfig.labelStep,
        canvasLeft = chartConfig.canvasLeft,
        canvasRight = chartConfig.canvasRight,
        rWidthAdjstFactor = staggerLines - 2,
        sWidthAdjstFactor,
        staggerLineAvailed,
        max = axisRange.max,
        min = axisRange.min,
        maxTextSize = 0,
        allCategories = axisConfig.categories && axisConfig.categories.category,
        categoryLength = 0,
        singleCategory,
        overriddenStyle,
        intervalWidth,
        maxLabelObj = {
      text: UNDEF,
      width: 0,
      style: UNDEF
    },
        maxLabelHeight = 0,
        smartLabelText,
        axisXPadding = 4,
        getAllottedWidth,
        getAllottedHeight,
        confMeasurement,
        updateCategoryMeta = _lib.stubFN,
        finalRotationDecision = _lib.stubFN,
        reCalculateStaggerLines = _lib.stubFN,
        testString = 'WWW',
        W = 'W',
        minPxPerLabel = 60,
        categoryAxisMeasurement = {},
        maxText,
        firstLabel,
        lastLabel,
        i,
        text,
        value,
        numberFormatterFn,
        retObj,
        cumulativeSum = 0,
        defTextPadding = 2,
        reCalrequired = false,
        skipCount = 0,
        defaultSpanRadius = 2,
        lastStepX,
        forceHeight,
        categoryCalculationInitiated = false,
        refSmartText,
        limit,
        minIrrPx,
        prevCategory,
        lastMinIrrStep = Number.POSITIVE_INFINITY,
        firstCategory,
        lastCategory,
        catLength,
        isZoomed,
        prevStyleStr,
        currStyleStr,
        minIrrStep = Number.POSITIVE_INFINITY; // minimum-irregular-step

    if (axisConfig.hasCategory && (!allCategories || allCategories.length === 0)) {
      return {
        width: 0,
        height: 0
      };
    }

    if (labelDisplay === 'rotate') {
      axisConfig.rotateLabels = 1;
    }

    if (!axisConfig.hasCategory) {
      axisConfig.irregularCatAxis = false;
    }

    sWidthAdjstFactor = rWidthAdjstFactor === 0 ? 1 : rWidthAdjstFactor === 1 ? 1.5 : rWidthAdjstFactor;

    smartLabel.useEllipsesOnOverflow(chartConfig.useEllipsesWhenOverflow);
    smartLabel.setStyle({
      fontSize: labelStyle.fontSize,
      fontFamily: labelStyle.fontFamily,
      lineHeight: labelStyle.lineHeight,
      fontWeight: labelStyle.fontWeight
    });

    /**
     * Gets the distance between the left and right margins
     * @param {number} x        Any integer between min or max
     * @param {string} position The side which sould be taken as reference for calculation. Can be 'left'
     *                          or 'right'
     * @return {number} The distance from a point to left or right extremes
     */
    function getMarginalDistance(x, position) {
      switch (position.toLowerCase()) {
        case 'left':
          return Math.abs(axis._getCustomPixel(x));

        case 'right':
          return Math.abs(chartConfig.width - axis._getCustomPixel(x));
      }
    }

    if (axisConfig.irregularCatAxis) {
      allCategories.sort(function (m, n) {
        return m.x - n.x;
      });
      // If it is an irregular cat axis the calculation of intervalWidth would not be straight
      // forward.
      // Finds the minimum difference between all the legend
      for (i = 0, categoryLength = allCategories.length; i < categoryLength; i++) {
        singleCategory = allCategories[i];

        if (lastStepX !== UNDEF) {
          minIrrStep = Math.abs(singleCategory.x - lastStepX);

          minIrrPx = mathAbs(axis._getCustomPixel(min) - axis._getCustomPixel(min + minIrrStep));
          smartLabel.setStyle(singleCategory.style || {});
          refSmartText = smartLabel.getOriSize(W);
          limit = refSmartText.width;

          // (limit * 1.2) calculates extra space around the label. 10% of the original size to
          // the left and 10% to the right
          if (minIrrPx < limit * 1.2) {
            singleCategory.label = '';
            minIrrStep = lastMinIrrStep;
            continue;
          }

          // Saves individual interval width on right side for each labels insted of the common
          // one
          prevCategory._individualIWR = minIrrPx;

          // Saves individual interval width on left side for each labels insted of the common
          // one
          singleCategory._individualIWL = minIrrPx;
          lastMinIrrStep = minIrrStep;
        }

        prevCategory = singleCategory;
        lastStepX = singleCategory.x;
      }

      if (minIrrStep === Number.POSITIVE_INFINITY) {
        // If only one label is found
        // Minimum step would be minimum of distance from the point to the right side and
        // from the leftside
        minIrrStep = Math.floor(Math.min(singleCategory.x, max - singleCategory.x));

        // The final minIrrStep would be the maximum of the previous calculation and the
        // defaultSpanRadius, as the defaultSpanRadius would be the least space available
        minIrrStep = Math.max(minIrrStep, 2 * defaultSpanRadius);
      }

      for (i = 0, categoryLength = allCategories.length; i < categoryLength; i++) {
        singleCategory = allCategories[i];

        // Since now there is a scope of leaving space for the end values so making width infinite
        // will truncate the end labels unnecessarily
        if (!i) {
          singleCategory._individualIWL = Infinity;
          // getMarginalDistance(singleCategory.x, 'left');
        }

        if (i === categoryLength - 1) {
          singleCategory._individualIWR = Infinity;
          // getMarginalDistance(singleCategory.x, 'right');
        }

        singleCategory.individualIW = Math.min(singleCategory._individualIWL, singleCategory._individualIWR);
      }

      // Intermediate intervalWidth calculation to get the intervalWidth w.r.t minIrrStep only without
      // considering the marginal labels overflow
      intervalWidth = mathAbs(axis._getCustomPixel(min) - axis._getCustomPixel(min + minIrrStep));

      // Takes care of the marginal labels overflow by calculating the minimum of the left available,
      // right available space and previously get intervalWidth

      intervalWidth = Math.min(2 * getMarginalDistance(allCategories[0].x, 'left'), 2 * getMarginalDistance(allCategories[categoryLength - 1].x, 'right'), intervalWidth);
    } else {
      intervalWidth = mathAbs(axis._getCustomPixel(min) - axis._getCustomPixel(min + increment));
    }

    // Override the max height if the user has given his own value
    maxHeight = userMaxLabelHeight || maxHeight;

    /*
      * The root definitation of measurements functions of the category axis.
      * If a new measurement object is created by a id, a new object is created if not already saved in
      * store. If the object is created first time,  the new object will get the properties of the root.
      * The new measurement could override any existing feature.
      *
      * __root__ is an internal property.
      */
    categoryAxisMeasurement.__root__ = {
      /*
        * Get the allotted height for individual label.
        * @param categoryIndex {Integer} - index of the category
        */
      getHeight: function getHeight(i) {
        var cat = allCategories[i],
            lineHeight = cat._ovrStyle.lineHeight,
            lineHeightInt = parseInt(lineHeight.replace(/(\d+)px/, '$1'), 10);

        return lineHeightInt;
      },

      /*
        * Get the allotted height for individual label.
        */
      getWidth: function getWidth() {
        return maxHeight;
      },

      getCalculatedLabelStep: function getCalculatedLabelStep(allCatArr) {
        var _i = 0,
            _l = allCatArr.length,
            _maxSpan = Number.NEGATIVE_INFINITY,
            _maxCatObj = {},
            styleStr,
            style,
            label,
            _cat,
            key,
            possibleLabelsNo,
            labelCount = 0,
            referenceSide,
            slHeight,
            _fStep;

        if (axisConfig.irregularCatAxis) {
          return axisConfig.labelStep;
        }
        for (; _i < _l; _i++) {
          _cat = allCatArr[_i];

          // // @todo validate whether the neighbour labels should use the space of an emty label
          // if (!(_cat && _cat.label)) {
          //     continue;
          // }

          if (!_cat) {
            continue;
          }
          _cat.label || (_cat.label = '');

          overriddenStyle = {
            fontSize: labelStyle.fontSize,
            fontFamily: labelStyle.fontFamily,
            lineHeight: labelStyle.lineHeight,
            fontWeight: labelStyle.fontWeight
          };

          labelCount++;
          _cat.style = _cat.style || {};
          (0, _lib.extend2)(overriddenStyle, _cat.style);
          styleStr = overriddenStyle.fontSize + overriddenStyle.fontFamily + overriddenStyle.lineHeight + overriddenStyle.fontWeight;
          if (_maxCatObj[styleStr]) {
            if (_cat.label.length > _maxCatObj[styleStr].label.length) {
              _maxCatObj[styleStr].label = _cat.label;
            }
          } else {
            _maxCatObj[styleStr] = {
              label: _cat.label,
              style: overriddenStyle
            };
          }
        }
        for (key in _maxCatObj) {
          if (_maxCatObj.hasOwnProperty(key)) {
            style = _maxCatObj[key].style;
            label = _maxCatObj[key].label;
            style.lineHeight = (0, _lib.setLineHeight)(style);

            smartLabel.setStyle(style);

            axisConfig.rotateLabels && (slHeight = parseInt(style.lineHeight.replace(/(\d+)px/, '$1'), 10));

            smartLabelText = smartLabel.getSmartText(label, UNDEF, slHeight);

            referenceSide = axisConfig.rotateLabels === 0 ? smartLabelText.width > minPxPerLabel ? minPxPerLabel : smartLabelText.width : smartLabelText.height;

            _maxSpan = Math.max(referenceSide, _maxSpan);
          }
        }
        possibleLabelsNo = Math.floor(mathAbs(axis._getCustomPixel(max) - axis._getCustomPixel(min)) / _maxSpan);

        if (labelCount <= possibleLabelsNo) {
          return axisConfig.labelStep;
        }

        _fStep = Math.max(Math.ceil(labelCount / possibleLabelsNo), axisConfig.labelStep);
        intervalWidth = mathAbs(axis._getCustomPixel(min) - axis._getCustomPixel(min + _fStep));

        // intervalWidth = axisConfig.rotateLabels === 0 ? Math.min(intervalWidth, minPxPerLabel) :
        //     intervalWidth;

        // intervalWidth -= axisXPadding;
        return _fStep;
      }
    };

    // This is the container where all other properties / states are set and get. This is to reduce
    // number of attributed directly put on categoryAxisMeasurement object
    categoryAxisMeasurement._inProp = {};

    /*
      * Get a copy of the default configuration created by the id. If the configration was retrieved
      * using some id previously, and same is requested, it returns the saved one. If it was never
      * requested before a new copy is created and returned.
      */
    categoryAxisMeasurement.getCopyById = function (id) {
      var cam = this,
          propStore = cam._inProp,
          root = cam.__root__,
          copyStore = propStore.copyStore,
          copyById;

      copyStore = copyStore || {};
      copyById = copyStore[id];

      // If a copy is found in core, return it
      if (copyById) {
        return copyById;
      }

      // Create a new copy copying all the properties from the root and retirn it
      (0, _lib.extend2)(copyById = copyStore[id] = {}, root);
      return copyById;
    };

    if (axisConfig.hasCategory) {
      // Category axis label orientation
      switch (labelDisplay) {
        case 'rotate':
          if (slantLabel) {
            labels.rotation = 300;
          } else {
            labels.rotation = 270;
          }

          confMeasurement = categoryAxisMeasurement.getCopyById('rotate');
          break;

        case 'stagger':
          confMeasurement = categoryAxisMeasurement.getCopyById('stagger');

          confMeasurement.getHeight = function (categoryIndex) {
            var allCat, cat, catStyle, metrics;

            allCat = axisConfig.categories.category;
            cat = allCat[categoryIndex];
            catStyle = cat && cat.style || (cat.style = {});

            overriddenStyle = {
              fontSize: labelStyle.fontSize,
              fontFamily: labelStyle.fontFamily,
              lineHeight: labelStyle.lineHeight,
              fontWeight: labelStyle.fontWeight
            };

            (0, _lib.extend2)(overriddenStyle, catStyle);

            smartLabel.setStyle(overriddenStyle);
            metrics = smartLabel.getOriSize(cat.label);

            return metrics.height;
          };

          confMeasurement.getWidth = function (cat) {
            return cat.individualIW ? cat.individualIW : 2 * intervalWidth * sWidthAdjstFactor - axisXPadding;
          };

          reCalculateStaggerLines = function reCalculateStaggerLines(categories) {
            var category,
                categoryLength = categories.length,
                lastElement,
                defLineHeight,
                lastCSum = 0,
                index,
                rSum,
                calStaggerLines,
                itrStep,
                smartTestText;

            smartLabel.setStyle(labelStyle);
            smartTestText = smartLabel.getOriSize(testString);

            defLineHeight = smartTestText.height;

            // If the cumulative sum of the last element is same or less than  the sum of
            // heights of all the elements, the value of staggerLines can be derived
            // mathematically from a equation.
            // If n be the number of labels in stagger and l be the height of one label and
            // h is the allotted height to draw the labels.
            // n = floor(h / l)

            lastElement = categories[categoryLength - 1];

            if (Math.floor(lastElement._cumulativeSum) <= Math.ceil(categoryLength * (defLineHeight + defTextPadding))) {
              // Calulate the stagger lines from the equation
              calStaggerLines = Math.floor(maxHeight / defLineHeight);

              // If the value of the staggerLines is less than the maximum stagger possible,
              // keep the one user has given
              staggerLines = calStaggerLines - staggerLines < 0 ? calStaggerLines : staggerLines;
            } else {
              // Calculate the max staggerLine if all of the labels have same style. This
              // reduces the number of iterations
              calStaggerLines = Math.floor(maxHeight / (defLineHeight + 2 * defTextPadding));
              do {
                // Reset last cumulative sum to zero if the staggerLines needs to be
                // re-calculated
                lastCSum = 0;
                itrStep = calStaggerLines;
                for (index = itrStep - 1, categoryLength = categories.length; index < categoryLength;) {
                  // Since the step is more than one, it is possible that the last couple
                  // of elements remain un iterated. This detects this and if it happens
                  // moves to the left
                  if (categoryLength - index < calStaggerLines) {
                    index = categoryLength - 1;
                  }

                  category = categories[index];

                  // Get the height of the block, if it was placed in stagger
                  rSum = category._cumulativeSum - lastCSum;

                  if (~~rSum > -~maxHeight) {
                    // If the block length is greater than the allotted height, break
                    // the flow
                    reCalrequired = true;
                    break;
                  } else {
                    reCalrequired = false;
                  }

                  lastCSum = category._cumulativeSum;
                  index += itrStep;
                }
              } while (calStaggerLines-- && reCalrequired);

              calStaggerLines++;

              // If the value of the staggerLines is less than the maximum stagger possible,
              // keep the one user has given
              staggerLines = Math.min(staggerLines, calStaggerLines);
            }
          };

          updateCategoryMeta = function updateCategoryMeta(categories) {
            var category,
                catStyle,
                categoryLength,
                catLineHeight,
                index,
                nonSkipCount = 0;

            for (index = 0, categoryLength = categories.length; index < categoryLength; index++) {
              category = categories[index];

              if (category.stepSkipped) {
                continue;
              }

              catStyle = category && category.style || {};

              if (!(catLineHeight = catStyle.lineHeight)) {
                catLineHeight = labelStyle.lineHeight;
              }
              staggerLineAvailed = nonSkipCount++ % staggerLines;
              if (staggerLineAvailed) {
                category.labelPadding = catLineHeight.replace(/px/i, '') * staggerLineAvailed;
              } else {
                category.labelPadding = 0;
              }
            }
          };
          break;

        case 'none':
          confMeasurement = categoryAxisMeasurement.getCopyById('none');
          // The user does not need any of management to happen hence unlimited space is returned.
          confMeasurement.getHeight = _lib.stubFN;
          confMeasurement.getWidth = _lib.stubFN;
          finalRotationDecision = _lib.stubFN;

          if (axisConfig.rotateLabels) {
            if (slantLabel) {
              labels.rotation = 300;
            } else {
              labels.rotation = 270;
            }

            // If rotation is applied, the label is calculated with unlimited space but when
            // rendered, the chart resizes to its maximum limit, keeping the label space
            // unmanaged
            forceHeight = maxHeight;
          }

          confMeasurement.getCalculatedLabelStep = function () {
            return axisConfig.labelStep;
          };

          break;

        default:
          // If labelDisplay is automatic
          confMeasurement = categoryAxisMeasurement.getCopyById('auto');
          confMeasurement.getHeight = function () {
            return maxHeight;
          };
          confMeasurement.getWidth = function (cat) {
            return cat.individualIW ? cat.individualIW : intervalWidth - 2 * axisXPadding;
          };

          finalRotationDecision = function finalRotationDecision(style, categories) {
            var autoWrapLimit, absMaxSmartText, i, categoryLength, category, catStyle;

            if (axisConfig.irregularCatAxis) {
              return;
            }

            smartLabel.setStyle(style);
            absMaxSmartText = smartLabel.getOriSize(testString);
            autoWrapLimit = absMaxSmartText.width;

            if (autoWrapLimit >= intervalWidth && axisConfig.rotateLabels !== 0) {
              labels.rotation = slantLabel ? 300 : 270;
              labels.forceRotate = true;

              confMeasurement = categoryAxisMeasurement.getCopyById('rotate');
              getAllottedWidth = confMeasurement.getWidth;
              getAllottedHeight = confMeasurement.getHeight;

              maxLabelObj.width = 0;
              for (i = 0, categoryLength = categories.length; i < categoryLength; i++) {
                category = categories[i];

                if (!(category && (category.label || category.oriLabel)) || (0, _lib.pluckNumber)(category.showlabel, axisConfig.showLabels, 1) === 0 || category.stepSkipped === true) {
                  continue;
                }

                catStyle = category._ovrStyle;
                smartLabel.setStyle({
                  fontSize: catStyle.fontSize,
                  fontFamily: catStyle.fontFamily,
                  lineHeight: catStyle.lineHeight,
                  fontWeight: catStyle.fontWeight
                });
                smartLabelText = smartLabel.getSmartText(category.oriLabel, getAllottedWidth(category), getAllottedHeight(i));

                category.label = smartLabelText.text;
                category.labelTooltext = smartLabelText.tooltext;
                category._sLabel = smartLabelText;
                // @todo Don't do it from here. Do it from the loop from where it is getting
                // called
                if (maxLabelObj.width < smartLabelText.width) {
                  maxLabelObj.text = smartLabelText.text;
                  maxLabelObj.width = smartLabelText.width;
                  maxLabelObj.style = catStyle;
                }
              }
              maxText = maxLabelObj.text;
            }
          };

          break;
      }

      getAllottedWidth = confMeasurement.getWidth;
      getAllottedHeight = confMeasurement.getHeight;

      labelStep = axisConfig.labels.step = axisConfig.labelStep = axisConfig._oriLabelStep;
      labelStep = axisConfig.labels.step = axisConfig.labelStep = confMeasurement.getCalculatedLabelStep(allCategories);

      for (i = 0, categoryLength = allCategories.length; i < categoryLength; i++) {
        singleCategory = allCategories[i];

        if (!(singleCategory && (singleCategory.label || singleCategory.oriLabel)) || (0, _lib.pluckNumber)(singleCategory.showlabel, axisConfig.showLabels, 1) === 0) {
          continue;
        }

        categoryCalculationInitiated = true;

        overriddenStyle = {
          fontSize: labelStyle.fontSize,
          fontFamily: labelStyle.fontFamily,
          lineHeight: labelStyle.lineHeight,
          fontWeight: labelStyle.fontWeight
        };

        (0, _lib.extend2)(overriddenStyle, singleCategory.style);
        overriddenStyle.lineHeight = (0, _lib.setLineHeight)(overriddenStyle);
        currStyleStr = overriddenStyle.fontSize + overriddenStyle.fontFamily + overriddenStyle.lineHeight + overriddenStyle.fontWeight;
        // Note setStyle is very expansive
        if (currStyleStr !== prevStyleStr) {
          smartLabel.setStyle(overriddenStyle);
          prevStyleStr = currStyleStr;
        }
        if (i % labelStep) {
          // If labelStep is provided, sets a flag so that other module knows about it
          singleCategory.stepSkipped = true;
          // Keep count of the skipped elements
          skipCount++;
          continue;
        } else {
          singleCategory.stepSkipped = false;
        }

        singleCategory._ovrStyle = overriddenStyle;
        smartLabelText = smartLabel.getSmartText(singleCategory.oriLabel || singleCategory.label, getAllottedWidth(singleCategory), getAllottedHeight(i));
        cumulativeSum += singleCategory._nLineHeight = smartLabelText.height + defTextPadding;

        singleCategory._cumulativeSum = cumulativeSum;

        singleCategory.oriLabel = singleCategory.oriLabel || singleCategory.label;
        singleCategory.label = smartLabelText.text;
        singleCategory.labelTooltext = smartLabelText.tooltext;
        singleCategory._sLabel = smartLabelText;

        if (maxLabelObj.width < smartLabelText.oriTextWidth) {
          (0, _lib.extend2)(maxLabelObj, smartLabelText);
          maxLabelObj.style = overriddenStyle;
        }

        if (maxLabelHeight < smartLabelText.height) {
          maxLabelHeight = smartLabelText.height;
        }
      }

      if (!categoryCalculationInitiated) {
        return {
          height: 0,
          width: 0
        };
      }

      reCalculateStaggerLines(allCategories, skipCount);
      updateCategoryMeta(allCategories, skipCount);
      finalRotationDecision(maxLabelObj.style, allCategories);

      maxText = maxLabelObj.text || '';
      if (axisConfig.xAxisLabelMode === 'mixed') {
        if (axisConfig.isPercent) {
          numberFormatterFn = chart.getFromEnv('number-formatter').percentValue;
        } else {
          numberFormatterFn = chart.getFromEnv('number-formatter').xAxis;
        }
        // calculating the label max width and height
        maxTextSize = maxText.length;
        for (i = min; i <= max; i += increment) {
          if (axisConfig.hasBreakPoints) {
            value = axis._getRealBreakValue(i);
          } else {
            value = i;
          }
          text = '' + numberFormatterFn.call(chart.getFromEnv('number-formatter'), value, axisConfig.axisIndex);
          if (text.length > maxTextSize) {
            maxText = text;
            maxTextSize = text.length;
          }
        }
      }

      maxLabelObj.height = Math.max(maxLabelHeight, maxLabelObj.height || 0);

      catLength = allCategories.length;
      for (i = 0, categoryLength = allCategories.length; i < categoryLength; i++) {
        firstCategory = allCategories[i];

        if (firstCategory._sLabel) {
          break;
        }
      }

      for (categoryLength = allCategories.length, i = categoryLength - 1; i >= 0; i--) {
        lastCategory = allCategories[i];

        if (lastCategory._sLabel) {
          break;
        }
      }

      isZoomed = axis._isZoomed();
      if (!labels.rotation && !isZoomed && firstCategory._sLabel) {
        axisConfig.axisEndLabelDisplaySpace.left = Math.max(canvasLeft - (axis._getCustomPixel(firstCategory.x || 0) - firstCategory._sLabel.width / 2), 0);

        axisConfig.axisEndLabelDisplaySpace.right = Math.max(axis._getCustomPixel(lastCategory.x || catLength - 1) + lastCategory._sLabel.width / 2 - canvasRight, 0);
      } else {
        axisConfig.axisEndLabelDisplaySpace.left = 0;
        axisConfig.axisEndLabelDisplaySpace.right = 0;
      }

      retObj = maxLabelObj;
    } else {
      if (axisConfig.numberFormatterFn) {
        numberFormatterFn = chart.getFromEnv('number-formatter')[axisConfig.numberFormatterFn];
      } else if (axisConfig.isPercent) {
        numberFormatterFn = chart.getFromEnv('number-formatter').percentValue;
      } else {
        numberFormatterFn = chart.getFromEnv('number-formatter').xAxis;
      }
      // calculating the label max width and height
      // TODO : smartly calculate the max width height
      for (i = min; i <= max; i += increment) {
        if (axisConfig.hasBreakPoints) {
          value = (0, _lib.toPrecision)(axis._getRealBreakValue(i), 10);
        } else {
          value = (0, _lib.toPrecision)(i, 10);
        }
        text = '' + numberFormatterFn.call(chart.getFromEnv('number-formatter'), value, axisConfig.axisIndex);
        if (i === min) {
          firstLabel = text;
        }
        if (i === max) {
          lastLabel = text;
        }
        if (text.length > maxTextSize) {
          maxText = text;
          maxTextSize = text.length;
        }
      }
      smartLabel.setStyle({
        fontSize: labelStyle.fontSize,
        fontFamily: labelStyle.fontFamily,
        lineHeight: labelStyle.lineHeight,
        fontWeight: labelStyle.fontWeight
      });

      retObj = smartLabel.getOriSize(maxText || '');

      // Decide the rotations of the labels
      if (labelDisplay === 'rotate') {
        labels.rotation = 270;
      }
      if (axisConfig.rotateLabels) {
        if (slantLabel) {
          labels.rotation = 300;
        } else {
          labels.rotation = 270;
        }
      }
      if (!labels.rotation) {
        firstLabel = smartLabel.getOriSize(firstLabel || '');
        lastLabel = smartLabel.getOriSize(lastLabel || '');
        axisConfig.axisEndLabelDisplaySpace.left = firstLabel.width / 2 + 2;
        axisConfig.axisEndLabelDisplaySpace.right = lastLabel.width / 2 + 2;
      }
    }

    if (axisConfig.hasCategory && labelDisplay === 'stagger') {
      retObj.height = staggerLines * maxLabelObj.height;
    }

    // If the label height is forcefully curbed, this happens when the label is larger than the the max
    // allowed height, redefine the width (since it only happens when labeldisplay is none in rotate
    // mode).

    retObj.width = forceHeight ? Math.min(forceHeight, retObj.width) : retObj.width;
    retObj.width = (0, _lib.pluckNumber)(retObj.width);
    retObj.maxWidth = (0, _lib.pluckNumber)(retObj.maxWidth);
    return retObj;
  };

  /**
   * Function will give the height of the maximum label present
   * @param {number}  maxWidth The maximum height of the label
   * @return {Object} Object containing the width and height of the max length label
   */


  CartesianAxis.prototype._getVMaxLabelDimention = function _getVMaxLabelDimention(maxWidth) {
    var axis = this,
        axisConfig = axis.config,
        chart = axis.getFromEnv('chart'),
        chartConfig = chart.config,
        smartLabel = chart.getFromEnv('smartLabel'),
        axisRange = axisConfig.axisRange,
        labelStyle = axisConfig.labels.style,
        increment = axisRange.tickInterval,
        useEllipsesWhenOverflow = axisConfig.useEllipsesWhenOverflow,
        maxLabelWidthPercent = axisConfig.maxLabelWidthPercent,
        max = axisRange.max,
        min = axisRange.min,
        maxTextSize = 0,
        categories = chart.jsonData.categories,
        maxTextDimention = {
      height: 0,
      width: 0
    },
        maxText,
        tempMaxWidth,
        i,
        value,
        text,
        allCategories,
        categoryLength,
        singleCategory,
        smartLabelText,
        numberFormatterFn,
        categoriesStyle = {},
        categoryStyle,
        singleCategoryStyle;

    smartLabel.useEllipsesOnOverflow(chartConfig.useEllipsesWhenOverflow);
    smartLabel.setStyle({
      fontSize: labelStyle.fontSize,
      fontFamily: labelStyle.fontFamily,
      lineHeight: labelStyle.lineHeight,
      fontWeight: labelStyle.fontWeight
    });

    if (axisConfig.hasCategory) {
      if (categories) {
        categoriesStyle = {
          fontFamily: categories[0].font,
          fontSize: categories[0].fontsize,
          color: categories[0].fontcolor
        };
      }
      if (maxLabelWidthPercent) {
        tempMaxWidth = maxLabelWidthPercent / 100 * chartConfig.width;
        if (tempMaxWidth < maxWidth) {
          maxWidth = tempMaxWidth;
        }
      }
      allCategories = axisConfig.categories.category;
      for (i = 0, categoryLength = allCategories.length; i < categoryLength; i++) {
        singleCategory = allCategories[i];
        if ((0, _lib.pluckNumber)(singleCategory.showlabel, axisConfig.showLabels) === 0) {
          continue;
        }
        categoryStyle = {
          fontFamily: (0, _lib.pluck)(singleCategory.font, singleCategory.labelfont, categoriesStyle.fontFamily, labelStyle.fontFamily),
          fontSize: (0, _lib.pluck)(singleCategory.fontsize, singleCategory.labelfontsize, categoriesStyle.fontSize, labelStyle.fontSize).replace(/px/i, '') + 'px',
          fontWeight: labelStyle.fontWeight == NORMALSTRING ? (0, _lib.pluckNumber)(singleCategory.fontbold, singleCategory.labelfontbold, 0) ? 'bold' : NORMALSTRING : labelStyle.fontWeight,
          fontStyle: labelStyle.fontStyle == NORMALSTRING ? (0, _lib.pluckNumber)(singleCategory.fontitalic, singleCategory.labelfontitalic, 0) ? 'italic' : NORMALSTRING : labelStyle.fontStyle
        };
        singleCategoryStyle = {
          fontFamily: (0, _lib.pluck)(categoryStyle.fontFamily, categoriesStyle.fontFamily, labelStyle.fontFamily),
          fontSize: (0, _lib.pluck)(categoryStyle.fontSize, categoriesStyle.fontSize, labelStyle.fontSize),
          fontWeight: (0, _lib.pluck)(categoryStyle.fontWeight, labelStyle.fontWeight),
          fontStyle: (0, _lib.pluck)(categoryStyle.fontStyle, labelStyle.fontStyle)
        };
        singleCategoryStyle.lineHeight = (0, _lib.setLineHeight)(singleCategoryStyle);
        smartLabel.setStyle(singleCategoryStyle);
        smartLabelText = smartLabel.getSmartText(singleCategory.oriLabel || singleCategory.label, maxWidth, labelStyle.lineHeight, useEllipsesWhenOverflow);

        singleCategory.oriLabel = singleCategory.oriLabel || singleCategory.label;
        singleCategory.label = text = smartLabelText.text;
        singleCategory.labelTooltext = smartLabelText.tooltext;

        if (smartLabelText.width > maxTextSize) {
          maxTextDimention = smartLabelText;
          maxTextSize = smartLabelText.width;
        }
      }
      return maxTextDimention;
    } else {
      if (axisConfig.numberFormatterFn) {
        numberFormatterFn = chart.getFromEnv('number-formatter')[axisConfig.numberFormatterFn];
      } else if (axisConfig.isPercent) {
        numberFormatterFn = chart.getFromEnv('number-formatter').percentValue;
      } else {
        numberFormatterFn = chart.getFromEnv('number-formatter').yAxis;
      }
      // calculating the label max width and height
      // TODO : smartly calculate the max width height
      for (i = min; i <= max; i += increment) {
        if (axisConfig.hasBreakPoints) {
          value = (0, _lib.toPrecision)(axis._getRealBreakValue(i), 10);
        } else {
          value = (0, _lib.toPrecision)(i, 10);
        }
        text = '' + numberFormatterFn.call(chart.getFromEnv('number-formatter'), value, axisConfig.axisIndex);
        if (text.length > maxTextSize) {
          maxText = text;
          maxTextSize = text.length;
        }
      }
    }

    return smartLabel.getOriSize(maxText);
  };

  /**
   * Calculates the parameters necessary to draw the components of the chart.
   * In addition, it also calculates and draws the axis labels and ticks
   */


  CartesianAxis.prototype._drawComponents = function _drawComponents() {
    var axis = this,
        axisConfig = axis.config,
        is3d = axis.getFromEnv('chart').is3D,
        tempAxis = axis.getFromEnv('tempAxis'),
        decimalPrecision = 4,
        savedAxisLength = tempAxis && tempAxis.axisLength,
        savedAxisX = tempAxis && tempAxis.axisX,
        savedAxisY = tempAxis && tempAxis.axisY,
        currentAxisLength = axis.config.axisDimention.axisLength,
        currentAxisX = axis.config.axisDimention.x,
        currentAxisY = axis.config.axisDimention.y,
        preLineDrawState,
        preBandDrawState;

    savedAxisLength = savedAxisLength && getRoundedDecimal(savedAxisLength, decimalPrecision);
    currentAxisLength = getRoundedDecimal(currentAxisLength, decimalPrecision);

    getRoundedDecimal(axis.getVisibleLength(), decimalPrecision);

    axisConfig.drawAxisName && axis._drawAxisName();
    axisConfig.drawAxisLine && axis._drawAxisLine();
    axisConfig.drawAxisLine && axisConfig.hasBreakPoints && axis._drawBreakPoints();
    if (!axisConfig.isActive) {
      preLineDrawState = axisConfig.lines.isDraw;
      preBandDrawState = axisConfig.band.isDraw;
      axisConfig.lines.isDraw = 0;
      axisConfig.band.isDraw = 0;
    }
    if (!axisConfig.hasCategory) {
      axisConfig.drawLabels && axis._drawLabel();
      axisConfig.drawPlotlines && axis._drawPlotLine();
    } else {
      axisConfig.drawLabels && axis._drawCategory();
      axisConfig.drawOnlyCategoryLine && axis._drawCategoryLine();
    }
    if (!axisConfig.hasCategory || axisConfig.xAxisLabelMode === 'auto') {
      axisConfig.drawPlotBands && !axisConfig.hasBreakPoints && !is3d && axis._calculateCategoryPlotBand();
    } else {
      axisConfig.drawPlotlines && axis._drawCategoryVline();
      axisConfig.drawPlotlines && !is3d && axis._drawCategoryPlotLine();
      axisConfig.drawPlotBands && !axisConfig.hasBreakPoints && !is3d && axis._calculateCategoryPlotBand();
      if (axisConfig.xAxisLabelMode === 'mixed') {
        axisConfig.drawPlotBands && !axisConfig.hasBreakPoints && !is3d && axis._calculateCategoryPlotBand();
      }
    }
    if (!axisConfig.isActive) {
      axisConfig.lines.isDraw = preLineDrawState;
      axisConfig.band.isDraw = preBandDrawState;
    }
    axisConfig.drawTrendLines && axis._drawTrendLine();

    if (!axis.config.scrollBarDrawn) {
      axis._drawScrollBar();
    } else {
      if (savedAxisLength !== currentAxisLength || axis.getVisibleLength() !== (tempAxis && tempAxis.visibleLength) || savedAxisX !== currentAxisX || savedAxisY !== currentAxisY) {
        axis._drawScrollBar();
      }
    }
    axisConfig.isConfigured = false;
  };

  /**
   * Disposes the scroll bas associated with the axis if it is drawn
   */


  CartesianAxis.prototype._disposeScrollBar = function _disposeScrollBar() {
    var axis = this,
        axisConfig = axis.config,
        axisComponents = axis._components,
        scrollBar = axisComponents.scrollBar;

    if (axisConfig.scrollBarDrawn) {
      scrollBar.hide();
      // delete axisComponents.scrollBar;
      axisConfig.scrollBarDrawn = false;
    }
  };

  /**
   * Function is called internally by the axis class draw function to draw the axis labels
   */


  CartesianAxis.prototype._drawLabel = function _drawLabel() {
    var axis = this,
        axisConfig = axis.config,
        canvas = axisConfig.canvas,
        axisDimention = axisConfig.axisDimention || {},
        chart = axis.getFromEnv('chart'),
        chartConfig = chart.config,
        axisRange = axisConfig.axisRange,
        isOpposit = axisConfig.isOpposit,
        labels = axisConfig.labels,
        style = labels.style,
        elementRecycle,
        i,
        ln,
        isVertical = axisConfig.isVertical,
        max = axisRange.max,
        min = axisRange.min,
        canvasTop = canvas.canvasTop || chartConfig.canvasTop,
        canvasLeft = canvas.canvasLeft || chartConfig.canvasLeft,
        canvasBottom = canvas.canvasBottom || chartConfig.canvasBottom,
        canvasRight = canvas.canvasRight || chartConfig.canvasRight,
        axisContainer = axisConfig.axisContainer,
        axisPadding = axisConfig.labelPadding,
        showUpperLimit = axisConfig.showUpperLimit,
        paper = chart.getFromEnv('paper'),
        extremeLabels = axisConfig.extremeLabels,
        axisStartPosition = isVertical ? axisDimention.x : axisDimention.y,
        axisEndPosition = axisDimention.opposite,
        textlabels = axis.getGraphicalElement('labels'),
        animElems = [],
        textElement,
        labelRotation,
        labelLineHeight,
        tempStep,
        intervalWidth,
        numberFormatterFn,
        css = {
      fontFamily: style.fontFamily,
      fontSize: style.fontSize,
      fontWeight: style.fontWeight,
      fontStyle: style.fontStyle,
      lineHeight: style.lineHeight
    },
        numberFormat,
        axisAttrObj,
        axisAttrObjPre,
        value,
        intervalArr,
        intervalArrStr;

    if (!axis.getFromEnv('numericPlotLabelER')) {
      axis.addToEnv('numericPlotLabelER', new _elementRecycler2['default']());
    }
    elementRecycle = axis.getFromEnv('numericPlotLabelER');

    labelLineHeight = style.lineHeight;
    if (labelLineHeight) {
      if (labelLineHeight.indexOf('px') !== -1) {
        labelLineHeight = parseFloat(labelLineHeight.replace('px', ''));
      }
    }
    textlabels && (textlabels.length = 0);
    // checking if labels are to be drawn user can decide or can be decided by axis placeAxis function
    if (axisConfig.labels.isDraw) {
      // check with the drawAxisNameOpposit to finally decide the name should be draw on which side
      if (axisConfig.drawLabelsOpposit) {
        isOpposit = !isOpposit;
        axisStartPosition = axisEndPosition;
      }
      // interval width to check if there is any overlap
      intervalWidth = mathAbs(axis.getPixel(min) - axis.getPixel(min + axisRange.tickInterval));

      // Common style attribute for both axis
      axisAttrObj = {
        fill: style.color,
        'line-height': labelLineHeight,
        'font-size': style.fontSize,
        'opacity': 1
      };

      labelRotation = axisConfig.labels.rotation;

      // check if label overlap
      if (isVertical) {
        // check for overlap if there is any make the step such that no overlap happens
        if (axisConfig.labelMaxH > intervalWidth && !axisConfig.hasCategory) {
          tempStep = mathCeil(axisConfig.labelMaxH / intervalWidth);
        }
        // Fix the alignment
        axisAttrObj['text-anchor'] = isOpposit ? POSITION_START : POSITION_END;
      } else {
        // check for overlap if there is any make the step such that no overlap happens
        if (axisConfig.labelMaxW > intervalWidth && !axisConfig.hasCategory) {
          tempStep = mathCeil(axisConfig.labelMaxW / intervalWidth);
        }
        // Fix the alignment
        if (labelRotation) {
          axisAttrObj['text-anchor'] = isOpposit ? POSITION_START : POSITION_END;
          axisAttrObj['vertical-align'] = 'center';
        } else {
          axisAttrObj['vertical-align'] = isOpposit ? POSITION_BOTTOM : POSITION_TOP;
        }
      }
      if (tempStep > axisConfig.labels.step) {
        axisConfig.labels.step = tempStep;
      }

      intervalArr = this._getIntervalArr({ step: axisConfig.labels.step });

      intervalArrStr = [];

      numberFormat = axisConfig.numberFormatterFn ? axisConfig.numberFormatterFn : axisConfig.isPercent ? 'percentValue' : isVertical ? 'yAxis' : 'xAxis';

      numberFormatterFn = axis.getFromEnv('number-formatter')[numberFormat];

      axisContainer.css(css);
      extremeLabels.firstLabel = {};
      extremeLabels.lastLabel = {};

      for (i = 0, ln = intervalArr.length; i < ln; i += 1) {
        intervalArrStr[i] = '' + intervalArr[i];
      }
      // This will help to manage which element are to be kept for later use
      elementRecycle.preProcessor();
      elementRecycle.insertReserveElement('label', intervalArrStr);
      // main loop where the drawing starts
      for (i = 0, ln = intervalArr.length; i < ln; i += 1) {
        value = intervalArr[i];
        axisAttrObj.text = '' + numberFormatterFn.call(axis.getFromEnv('number-formatter'), value, axisConfig.axisIndex);
        // make the attribute ready to use
        if (isVertical) {
          // y-axis
          axisAttrObj.x = isOpposit ? (axisStartPosition || canvasRight) + axisPadding : (axisStartPosition || canvasLeft) - axisPadding;
          axisAttrObj.y = axis.getPixel(value, { wrtVisible: true });
        } else {
          // x-axis
          axisAttrObj.x = axis.getPixel(value, { wrtVisible: true });
          axisAttrObj.y = isOpposit ? (axisStartPosition || canvasTop) - axisPadding : (axisStartPosition || canvasBottom) + axisPadding;
          // checking if the label overlap with the last label
          if (i !== max && showUpperLimit && axisAttrObj.x + axisConfig.labelMaxW > canvasRight) {
            continue;
          }
        }
        // If labels shift is applicable (Specially for 3D) then apply the changes
        if (labels.shiftX) {
          axisAttrObj.x += labels.shiftX;
        }
        if (labels.shiftY) {
          axisAttrObj.y += labels.shiftY;
        }

        axisAttrObjPre = (0, _lib.extend2)({}, axisAttrObj);
        axisAttrObjPre.opacity = 0;
        if (axis.getFromEnv('tempAxis')) {
          axisAttrObjPre.x = isVertical ? axisAttrObj.x : axis.getPixel(value, {
            preValue: true,
            wrtVisible: true
          });
          axisAttrObjPre.y = isVertical ? axis.getPixel(value, {
            preValue: true,
            wrtVisible: true
          }) : axisAttrObj.y;
        }

        textElement = elementRecycle.getElementIfExist('label', intervalArr[i]);
        if (textElement) {
          if (!textElement.isOtherElem) {
            axisAttrObjPre = UNDEF;
          }
          textElement = textElement.elem;
        } else {
          textElement = paper.text(axisContainer);
          // First time creation the element create at 0,0
          !axisAttrObjPre && (axisAttrObjPre = (0, _lib.extend2)({}, axisAttrObj));
          elementRecycle.insertElement('label', intervalArr[i], textElement);
        }
        // textlabels[i] = textElement;
        axis.addGraphicalElement('labels', textElement, true, i);

        axisAttrObj.transform = paper.getSuggestiveRotation(labelRotation, axisAttrObj.x, axisAttrObj.y);
        axisAttrObjPre && (axisAttrObjPre.transform = paper.getSuggestiveRotation(labelRotation, axisAttrObjPre.x, axisAttrObjPre.y));

        axis.addComponentInfo('label', {
          label: {
            fill: axisAttrObj.fill,
            'font-size': axisAttrObj['font-size'],
            'line-height': axisAttrObj['line-height'],
            opacity: axisAttrObj.opacity,
            value: value,
            'text-anchor': axisAttrObj['text-anchor'],
            rotation: labelRotation
          }
        });

        animElems.push({
          el: textElement,
          preAttrs: (0, _lib.extend2)({}, axisAttrObjPre),
          attrs: (0, _lib.extend2)({}, axisAttrObj),
          animType: 'linear',
          animConfig: [{
            start: 0,
            end: 1
          }]
        });

        if (intervalArr[i] === max) {
          extremeLabels.lastLabel.graphic = textElement;
        } else if (intervalArr[i] === min) {
          extremeLabels.firstLabel.graphic = textElement;
        }
        textElement._labelValue = intervalArr[i];
      }
      elementRecycle.processOldElem('label', function (key, elem) {
        if (axisAttrObj) {
          animElems.push({
            el: elem,
            attrs: {
              x: isVertical ? axisAttrObj.x : axis.getPixel(key, { wrtVisible: true }),
              y: isVertical ? axis.getPixel(key, { wrtVisible: true }) : axisAttrObj.y,
              'opacity': 0
            },
            animType: 'linear',
            animConfig: [{
              start: 0,
              end: 1
            }]
          });
        } else {
          elem.hide();
        }
      });
    } else {
      elementRecycle.preProcessor();
    }
    // hiding the extra elements which can be used later
    elementRecycle.postProcessor(function (el) {
      animElems.push({
        el: el,
        attrs: {
          'opacity': 0
        },
        animType: 'linear',
        animConfig: [{
          start: 0,
          end: 1
        }]
      });
    });

    axis._registerVerticalAxisAnims(animElems);
  };
  /**
   * Function is called internally by the axis class draw function to draw the axis name
   */


  CartesianAxis.prototype._drawAxisName = function _drawAxisName() {
    var axis = this,
        axisConfig = axis.config,
        canvas = axisConfig.canvas,
        chart = axis.getFromEnv('chart'),
        chartConfig = chart.config,
        axisDimention = axisConfig.axisDimention || {},
        style = axisConfig.name.style,
        axisName = axisConfig.name.value,
        isVertical = axisConfig.isVertical,
        isOpposit = axisConfig.isOpposit,
        smartLabel = chart.getFromEnv('smartLabel'),
        canvasBottom = canvas.canvasBottom || chartConfig.canvasBottom,
        canvasLeft = canvas.canvasLeft || chartConfig.canvasLeft,
        canvasRight = canvas.canvasRight || chartConfig.canvasRight,
        canvasTop = canvas.canvasTop || chartConfig.canvasTop,
        canvasHeight = canvas.canvasHeight || chartConfig.canvasHeight,
        canvasWidth = canvas.canvasWidth || chartConfig.canvasWidth,
        axisNameContainer = axisConfig.axisNameContainer,
        axisNamePadding = axisConfig.axisNamePadding,
        axisNameMaxH = axisConfig.nameMaxH,
        axisNameMaxW = axisConfig.nameMaxW,
        axisStartPosition = isVertical ? axisDimention.x : axisDimention.y,
        axisEndPosition = axisDimention.opposite,
        isOpposite = !isVertical,
        // not support for secondary axis
    axisNameGroup = axis.getGraphicalElement('axisName') || {},
        rotation = (0, _lib.pluckNumber)(axisConfig.name.rotation, !isOpposite ? 270 : 90),
        paper = axis.getFromEnv('paper'),
        css = {
      fontFamily: style.fontFamily,
      fontSize: style.fontSize,
      lineHeight: style.lineHeight,
      fontWeight: style.fontWeight,
      fontStyle: style.fontStyle
    },
        animElems = [],

    // animateAxis = axisConfig.animateAxis,
    // animationDuration,
    // transposeAnimDuration,
    axisAttrObj,
        axisSmartName,
        axisNameElement,
        tooltext,
        nameHeightAvail,
        nameHeight,
        yPos;
    // animObj,
    // dummyObj,
    // animType;

    axisNameElement = axisNameGroup;
    // checking if name is to be drawn user can decide or can be decided by axis placeAxis function
    if (axisConfig.name.isDraw) {
      // animationDuration = chart.get('config', 'animationObj');
      // animObj = animationDuration.animObj;
      // dummyObj = animationDuration.dummyObj;
      // transposeAnimDuration = animationDuration.transposeAnimDuration;
      // animType = animationDuration.animType;
      // common attribute style
      axisAttrObj = {
        fontFamily: style.fontFamily,
        fill: style.color,
        'vertical-align': 'center',
        'font-size': style.fontSize,
        'line-height': style.lineHeight
      };

      smartLabel.useEllipsesOnOverflow(chartConfig.useEllipsesWhenOverflow);
      // make the smart label ready to use for use of drawing the name
      smartLabel.setStyle({
        fontSize: style.fontSize,
        fontFamily: style.fontFamily,
        lineHeight: style.lineHeight,
        fontWeight: style.fontWeight
      });

      // check with the drawAxisNameOpposit to finally decide the name should be draw on which side
      if (axisConfig.drawAxisNameOpposit) {
        isOpposit = !isOpposit;
        axisStartPosition = axisEndPosition;
      }

      // preparing the attributes
      // y-axis
      if (isVertical) {
        // Only for candleStick chart as it has two axis whose yaxis name should be in one line.
        if (axisConfig.relativeAxis && axisConfig.relativeAxis.config && axisConfig.relativeAxis.config.axisNamePadding) {
          axisNamePadding = mathMax(axisConfig.relativeAxis.config.axisNamePadding, axisNamePadding);
        }
        if (isOpposit && chartConfig.canvasMarginRight) {
          axisNamePadding = mathMax(axisNamePadding, chartConfig.canvasMarginRight - chartConfig.marginLeft - axisNameMaxW);
        }
        if (!isOpposit && chartConfig.canvasMarginLeft) {
          axisNamePadding = mathMax(axisNamePadding, chartConfig.canvasMarginLeft - chartConfig.marginRight - axisNameMaxW);
        }
        // if rotation is there get the axis name from the smartText accordingly
        if (axisConfig.axisNameAlignCanvas || chartConfig.captionalignment && chartConfig.captionalignment == 'left') {
          nameHeightAvail = canvasHeight;
        } else {
          nameHeightAvail = mathMax(canvasHeight, axisConfig.oriCanvasHeight || 0);
        }

        if (rotation) {
          axisSmartName = smartLabel.getSmartText(axisName, nameHeightAvail, axisNameMaxW);
          tooltext = axisSmartName.tooltext;
          nameHeight = axisSmartName.width;
        } else {
          axisSmartName = smartLabel.getSmartText(axisName, axisNameMaxW, nameHeightAvail);
          tooltext = axisSmartName.tooltext;
          nameHeight = axisSmartName.height;
        }
        if (axisConfig.drawAxisNameFromBottom) {
          yPos = canvasBottom - nameHeight / 2;
        } else {
          yPos = nameHeight > canvasHeight ? chartConfig.height / 2 : canvasTop + canvasHeight / 2;
        }
        // attach the attributes
        axisAttrObj.text = axisSmartName.text;
        axisAttrObj.x = isOpposit ? (axisStartPosition || canvasRight) + axisNamePadding + axisNameMaxW / 2 : (axisStartPosition || canvasLeft) - axisNamePadding - axisNameMaxW / 2;
        axisAttrObj.y = yPos;
      } else {
        // xAxis
        axisSmartName = smartLabel.getSmartText(axisName, canvasWidth, axisNameMaxH);
        tooltext = axisSmartName.tooltext;
        if (isOpposit && chartConfig.canvasMarginTop) {
          axisNamePadding = mathMax(axisNamePadding, chartConfig.canvasMarginTop - chartConfig.marginTop - axisNameMaxH);
        }
        if (!isOpposit && chartConfig.canvasMarginBottom) {
          axisNamePadding = mathMax(axisNamePadding, chartConfig.canvasMarginBottom - chartConfig.marginBottom - axisNameMaxH);
        }
        axisAttrObj.text = axisSmartName.text;
        axisAttrObj.x = canvasLeft + canvasWidth / 2;
        axisAttrObj.y = isOpposit ? (axisStartPosition || canvasTop) - axisNamePadding - axisNameMaxH / 2 : (axisStartPosition || canvasBottom) + axisNamePadding + axisNameMaxH / 2;
      }
      axisAttrObj.transform = paper.getSuggestiveRotation(isVertical ? rotation : 0, axisAttrObj.x, axisAttrObj.y);
      // check if extra element is present don't draw it just use it by changing the attributes
      if (axis.getGraphicalElement('axisName')) {
        axisAttrObj.visibility = visibleStr;
        // TODO if text is transformed with same matrix for more than two time follower elements
        // displaced
        // if (transposeAnimDuration && animateAxis) {
        //     axisNameElement.animateWith(dummyObj, animObj,axisAttrObj,
        //         transposeAnimDuration, animType);
        // } else {
        //     axisNameElement.attr(axisAttrObj);
        // }
        animElems.push({
          el: axisNameElement,
          attrs: (0, _lib.extend2)({}, axisAttrObj),
          animType: 'linear',
          animConfig: [{
            start: 0,
            end: 1
          }]
        });
        if (axisConfig.showTooltip && tooltext) {
          axisNameElement.trackTooltip(true);
        }
        axisNameElement.css(css);
      } else {
        axisNameElement = paper.text(axisAttrObj, css, axisNameContainer).tooltip(tooltext);

        if (axisConfig.showTooltip && tooltext) {
          axisNameElement.trackTooltip(true);
        }
      }

      if (axisSmartName.text !== '') {
        axisNameElement.attr({
          'text-bound': [style.backgroundColor, style.borderColor, style.borderThickness, style.borderPadding, style.borderRadius, style.borderDash]
        });
      } else {
        axisNameElement.attr({
          'text-bound': []
        });
      }
      axis.addGraphicalElement('axisName', axisNameElement);
    } else {
      if (axis.getGraphicalElement('axisName')) {
        axis.getGraphicalElement('axisName').attr({
          visibility: hiddenStr
        });
      }
    }
    axis._registerVerticalAxisAnims(animElems);
  };
  /**
   * Function is called internally by the axis class draw function to draw the axis plot lines
   */


  CartesianAxis.prototype._drawPlotLine = function _drawPlotLine() {
    var axis = this,
        axisConfig = axis.config,
        axisRange = axisConfig.axisRange,
        increment = axisRange.tickInterval,

    // chart = axis.getFromEnv('chart'),
    // is3d = axis.getFromEnv('chart').is3D,
    // chartComponents = chart.components,
    max = axisRange.max,
        min = axisRange.min,

    // axisPlotLineContainerBottom = axisConfig.axisPlotLineContainer,
    // axisPlotLineContainerTop = axisConfig.axisPlotLineContainerTop,
    showCanvasBorder = axisConfig.showCanvasBorder,

    // paper = chartComponents.paper,
    // plotLine = axis.graphics.line || (axis.graphics.line = []),
    // elementRecycle = axis.numericPlotLineER || (axis.numericPlotLineER = new ElementRecycle()),
    plotLineColor = convertColor(axisConfig.divLineColor, axisConfig.divLineAlpha),
        plotLineWidth = axisConfig.divLineThickness,
        plotLineDashStyle = axisConfig.divLineIsDashed ? (0, _lib.getDashStyle)(axisConfig.divLineDashLen, axisConfig.divLineDashGap) : DASH_DEF,
        zeroPlaneColor = convertColor(axisConfig.zeroPlaneColor, axisConfig.zeroPlaneAlpha),
        zeroPlaneThickness = axisConfig.zeroPlaneThickness,

    // animElems = [],
    // lineElement,
    axisAttrObj,
        i,
        ln,
        value,

    // axisPlotLineContainer,
    intervalWidth,

    // axisAttrObjPre,
    // intervalArrStr,
    intervalArr;

    axisAttrObj = {
      stroke: plotLineColor,
      'stroke-width': plotLineWidth,
      'stroke-dasharray': plotLineDashStyle,
      opacity: 1
    };
    // get the interval width of the div lines in pixel
    intervalWidth = mathAbs(axis.getPixel(min) - axis.getPixel(min + increment));
    // Check if drawing band and line is possible for now it is set to 10 px
    if (intervalWidth < 2) {
      axisConfig.lines.isDraw = 0;
    }
    intervalArr = this._getIntervalArr({ step: 1, minPad: increment, maxPad: increment });
    // intervalArrStr = [];

    // for (i = 0, ln = intervalArr.length; i < ln; i += 1) {
    //   intervalArrStr[i] = '' + intervalArr[i];
    // }
    // This will help to manage which element are to be kept for later use
    // elementRecycle.preProcessor();
    // elementRecycle.insertReserveElement('line', intervalArrStr);

    // checking if lines are to be drawn user can decide
    if (axisConfig.lines.isDraw) {
      // axisPlotLineContainer = axisPlotLineContainerBottom;

      for (i = 0, ln = intervalArr.length; i < ln; i += 1) {
        value = intervalArr[i];
        // condition check for zero plane
        if (axisConfig.showZeroPlane === 0 && value === 0 || showCanvasBorder && (value === max || value === min)) {
          continue;
        }
        // attach the required attributes for zeroplane if applicable
        // if (i === 0 && axisConfig.showZeroPlane === 1 && axisConfig.showZeroPlaneValue === 1) {
        if (value === 0 && value !== min && value !== max) {
          axisAttrObj.stroke = zeroPlaneColor;
          axisAttrObj['stroke-width'] = zeroPlaneThickness;
          // if (axisConfig.showZeroPlaneOnTop && !is3d) {
          //   axisPlotLineContainer = axisPlotLineContainerTop;
          // }
        } else {
          axisAttrObj.stroke = plotLineColor;
          axisAttrObj['stroke-width'] = plotLineWidth;
        }

        // axis._calculatePath(axisAttrObj, value, plotLineWidth, { wrtVisible: true });

        // axisAttrObjPre = extend2({}, axisAttrObj);
        // axisAttrObjPre.opacity = 0;
        // if (axis.savedAxis) {
        //   axis._calculatePath(axisAttrObjPre, value, plotLineWidth, {
        //     preValue: true,
        //     wrtVisible: true
        //   });
        // }
        // lineElement = elementRecycle.getElementIfExist('line', intervalArr[i]);
        // if (lineElement) {
        //   if (!lineElement.isOtherElem) {
        //     axisAttrObjPre = UNDEF;
        //   }
        //   lineElement = lineElement.elem;
        //   axisPlotLineContainer.appendChild(lineElement);
        // } else {
        //   lineElement = paper.path(axisPlotLineContainer);
        //   // First time creation the element create at 0,0
        //   !axisAttrObjPre && (axisAttrObjPre = extend2({}, axisAttrObj));
        //   elementRecycle.insertElement('line', intervalArr[i], lineElement);
        // }
        // plotLine[i] = lineElement;

        axis.addComponentInfo('line', {
          value: value,
          opacity: axisAttrObj.opacity,
          'shape-rendering': axisAttrObj['shape-rendering'],
          stroke: axisAttrObj.stroke,
          'stroke-dasharray': axisAttrObj['stroke-dasharray'],
          'stroke-width': axisAttrObj['stroke-width']
        });

        // animElems.push({
        //   el: lineElement,
        //   preAttrs: extend2({}, axisAttrObjPre),
        //   attrs: extend2({}, axisAttrObj),
        //   animType: 'linear',
        //   animConfig: [{
        //     start: 0,
        //     end: 1
        //   }]
        // });
      }
      // elementRecycle.processOldElem('line', function (key, elem) {
      //   animElems.push({
      //     el: elem,
      //     attrs: axis._calculatePath({'opacity': 0}, key, plotLineWidth, { wrtVisible: true }),
      //     animType: 'linear',
      //     animConfig: [{
      //       start: 0,
      //       end: 1
      //     }]
      //   });
      // });
    } /* else { */
    // elementRecycle.preProcessor();
    // }

    // elementRecycle.postProcessor(function (el) {
    //   animElems.push({
    //     el: el,
    //     attrs: {
    //       'opacity': 0
    //     },
    //     animType: 'linear',
    //     animConfig: [{
    //       start: 0,
    //       end: 1
    //     }]
    //   });
    // });

    // axis._registerVerticalAxisAnims(animElems);
  };
  /**
   * Function is called internally by the axis class draw function to draw the axis line
   */


  CartesianAxis.prototype._drawAxisLine = function _drawAxisLine() {
    var axis = this,
        axisConfig = axis.config,
        isVertical = axisConfig.isVertical,
        isOpposit = axisConfig.isOpposit,
        canvas = axisConfig.canvas,
        chart = axis.getFromEnv('chart'),
        chartConfig = chart.config,

    // chartComponents = chart.components,
    breakPoints = axisConfig.breakPoints,
        canvasBottom = canvas.canvasBottom || chartConfig.canvasBottom,
        canvasLeft = canvas.canvasLeft || chartConfig.canvasLeft,
        canvasRight = canvas.canvasRight || chartConfig.canvasRight,
        canvasTop = canvas.canvasTop || chartConfig.canvasTop,
        axisDimention = axisConfig.axisDimention || {},
        axisStartPosition = isVertical ? axisDimention.x : axisDimention.y,
        drawAxisLineWRTCanvas = axisConfig.drawAxisLineWRTCanvas,
        FCChartObj = chart.jsonData.chart,
        paper = axis.getFromEnv('paper'),
        elementRecycle,
        axisLineGroup = axisConfig.axisAxisLineContainerBottom,
        tickAttrObj = {},
        animElems = [],
        AxisLineElement,
        linePath,
        xAxisLineLeftExten,
        fixPoint,
        breakPixel,
        tickEndPoint,
        value,
        pixelValue,
        tickElement,
        i,
        len,
        crispPath,
        axisAttrObjPreFn,
        intervalArr,
        ln;

    if (!axis.getFromEnv('axisLineER')) {
      axis.addToEnv('axisLineER', new _elementRecycler2['default']());
    }
    elementRecycle = axis.getFromEnv('axisLineER');

    xAxisLineLeftExten = (0, _lib.pluckNumber)(FCChartObj.showyaxisline, FCChartObj.showyaxisline) === 1 ? (0, _lib.pluckNumber)(FCChartObj.yaxislinethickness, FCChartObj.pyaxislinethickness, 1) : 0;

    elementRecycle.preProcessor();
    axisAttrObjPreFn = function axisAttrObjPreFn(attrs) {
      return function () {
        this.attr(attrs);
      };
    };
    // checking if axis lines are to be drawn user can decide or can be decided by axis placeAxis
    // function
    if (axisConfig.showAxisLine) {
      // initiate the line path element
      if (isVertical) {
        if (isOpposit) {
          axisStartPosition = drawAxisLineWRTCanvas ? canvasRight : axisStartPosition || canvasRight;
          fixPoint = axisStartPosition + axisConfig.axisLineThickness / 2;
        } else {
          axisStartPosition = drawAxisLineWRTCanvas ? canvasLeft : axisStartPosition || canvasLeft;
          fixPoint = axisStartPosition - axisConfig.axisLineThickness / 2;
        }

        if (axisConfig.hasBreakPoints) {
          linePath = ['M', fixPoint, canvasBottom, 'L'];
          for (i = 0, len = breakPoints.length; i < len; i += 1) {
            breakPixel = axis.getPixel(breakPoints[i].start);
            linePath.push(fixPoint, breakPixel, 'M', fixPoint, breakPixel - 4, 'L');
          }
          linePath.push(fixPoint, canvasTop);
        } else {
          crispPath = getCrispPath(['M', fixPoint, canvasBottom, 'L', fixPoint, canvasTop], axisConfig.axisLineThickness);
          linePath = crispPath.path;
        }
      } else {
        if (isOpposit) {
          axisStartPosition = drawAxisLineWRTCanvas ? canvasTop : axisStartPosition || canvasTop;
          fixPoint = axisStartPosition - axisConfig.axisLineThickness / 2;
        } else {
          axisStartPosition = drawAxisLineWRTCanvas ? canvasBottom : axisStartPosition || canvasBottom;
          fixPoint = axisStartPosition + axisConfig.axisLineThickness / 2;
        }

        if (axisConfig.hasBreakPoints) {
          linePath = ['M', canvasLeft - xAxisLineLeftExten, fixPoint, 'L'];
          for (i = 0, len = breakPoints.length; i < len; i += 1) {
            breakPixel = axis.getPixel(breakPoints[i].start);
            linePath.push(breakPixel, fixPoint, 'M', breakPixel - 4, fixPoint, 'L');
          }
          linePath.push(canvasRight, fixPoint);
        } else {
          crispPath = getCrispPath(['M', canvasLeft - xAxisLineLeftExten, fixPoint, 'L', canvasRight, fixPoint], axisConfig.axisLineThickness);
          linePath = crispPath.path;
        }
      }
      AxisLineElement = elementRecycle.getElementIfExist('line', 'axis-line');
      if (AxisLineElement) {
        AxisLineElement = AxisLineElement.elem;
      } else {
        AxisLineElement = paper.path(axisLineGroup);
        elementRecycle.insertElement('line', 'axis-line', AxisLineElement);
      }

      animElems.push({
        el: AxisLineElement,
        attrs: { opacity: 0 },
        animType: 'linear',
        animConfig: [{
          syncWith: 'initial',
          start: 0,
          end: 1
        }]
      });

      animElems.push({
        el: AxisLineElement,
        attrs: { opacity: 1 },
        animType: 'linear',
        animConfig: [{
          hookFn: axisAttrObjPreFn({
            path: linePath,
            stroke: axisConfig.axisLineColor,
            'stroke-linecap': BUTT,
            'stroke-width': axisConfig.axisLineThickness,
            'shape-rendering': crispPath.isCrisped ? CRISP : UNDEF
          }),
          start: 0,
          end: 1
        }]
      });

      if (axisConfig.drawTick && axisConfig.tickLength) {
        tickAttrObj = {
          stroke: axisConfig.tickColor,
          'stroke-width': axisConfig.tickWidth
        };
        if (isVertical) {
          if (isOpposit) {
            tickEndPoint = fixPoint + axisConfig.tickLength;
          } else {
            tickEndPoint = fixPoint - axisConfig.tickLength;
          }
        } else {
          if (isOpposit) {
            tickEndPoint = fixPoint - axisConfig.tickLength;
          } else {
            tickEndPoint = fixPoint + axisConfig.tickLength;
          }
        }
        intervalArr = this._getIntervalArr();

        for (i = 0, ln = intervalArr.length; i < ln; i += 1) {
          value = intervalArr[i];
          pixelValue = axis.getPixel(value);
          if (isVertical) {
            // y-axis
            tickAttrObj.path = 'M' + fixPoint + ' ' + pixelValue + 'L' + tickEndPoint + ' ' + pixelValue;
          } else {
            // x-axis
            tickAttrObj.path = 'M' + pixelValue + ' ' + fixPoint + 'L' + pixelValue + ' ' + tickEndPoint;
          }
          tickElement = elementRecycle.getElementIfExist('line', value);
          if (tickElement) {
            tickElement = tickElement.elem;
          } else {
            tickElement = paper.path(axisLineGroup);
            elementRecycle.insertElement('line', value, tickElement);
          }

          animElems.push({
            el: tickElement,
            attrs: { opacity: 0 },
            animType: 'linear',
            animConfig: [{
              syncWith: 'initial',
              start: 0,
              end: 1
            }]
          });

          animElems.push({
            el: tickElement,
            attrs: { opacity: 1 },
            animType: 'linear',
            animConfig: [{
              hookFn: axisAttrObjPreFn((0, _lib.extend2)({}, tickAttrObj)),
              start: 0,
              end: 1
            }]
          });
          axis.addGraphicalElement('axisLine', tickElement, true, i);
        }
      }
    }
    elementRecycle.postProcessor(function (el) {
      animElems.push({
        el: el,
        attrs: {
          'opacity': 0
        },
        animType: 'linear',
        animConfig: [{
          syncWith: 'initial',
          start: 0,
          end: 1
        }]
      });
    });
    axis._registerVerticalAxisAnims(animElems);
  };
  /**
   * Function used to draw the broken axis breakage points
   */


  CartesianAxis.prototype._drawBreakPoints = function _drawBreakPoints() {
    var axis = this,
        axisConfig = axis.config,
        isVertical = axisConfig.isVertical,
        canvas = axisConfig.canvas,
        chart = axis.getFromEnv('chart'),
        chartConfig = chart.config,
        breakPoints = axisConfig.breakPoints,
        canvasLeft = canvas.canvasLeft || chartConfig.canvasLeft,
        paper = axis.getFromEnv('paper'),
        brokeLine = axis.graphics.brokeLine || [],
        layers = axis.getGraphicalElement(),
        breakDist = 4,
        breakWidth = 8,
        breakWidthBy2 = breakWidth / 2,
        animateAxis = axisConfig.animateAxis,
        animationDuration,
        transposeAnimDuration,
        BrokenLineElement,
        linePath,
        fixPoint,
        breakPixel,
        i,
        len,
        counter,
        animObj,
        dummyObj,
        animType;

    if (axisConfig.showAxisLine) {
      animationDuration = chart.get('config', 'animationObj');
      animObj = animationDuration.animObj;
      dummyObj = animationDuration.dummyObj;
      transposeAnimDuration = animationDuration.transposeAnimDuration;
      animType = animationDuration.animType;
      // initiate the line path element
      for (i = 0, len = breakPoints.length; i < len; i += 1) {
        // draw axis line
        if (isVertical) {
          fixPoint = canvasLeft - axisConfig.axisLineThickness / 2;
          breakPixel = axis.getPixel(breakPoints[i].start);
          linePath = ['M', fixPoint - breakWidthBy2, breakPixel + breakDist / 3, 'L', fixPoint + breakWidthBy2, breakPixel - breakDist / 3, 'M', fixPoint - breakWidthBy2, breakPixel - breakDist * 2 / 3, 'L', fixPoint + breakWidthBy2, breakPixel - breakDist * 4 / 3];
        } else {
          linePath = ['M', 0, 0];
        }
        // if element is there just change the attributes
        if (brokeLine[i]) {
          BrokenLineElement = brokeLine[i];
          if (transposeAnimDuration && animateAxis) {
            BrokenLineElement.animateWith(dummyObj, animObj, {
              path: linePath,
              stroke: axisConfig.axisLineColor,
              'stroke-width': axisConfig.axisLineThickness
            }, transposeAnimDuration, animType);
          } else {
            BrokenLineElement.attr({
              path: linePath,
              stroke: axisConfig.axisLineColor,
              'stroke-width': axisConfig.axisLineThickness
            });
          }
        } else {
          // draw freshly the axis line
          BrokenLineElement = paper.path({
            path: linePath,
            stroke: axisConfig.axisLineColor,
            'stroke-width': axisConfig.axisLineThickness
          }, layers.axisLineGroup);
          brokeLine[i] = BrokenLineElement;
        }
        counter += 1;
      }
      if (brokeLine[counter]) {
        for (i = counter; i < brokeLine.length; i++) {
          brokeLine[i].attr({
            path: []
          });
        }
      }
    } else {
      // make the element ready to draw for next time if required
      if (brokeLine[counter]) {
        for (i = counter; i < brokeLine.length; i++) {
          brokeLine[i].attr({
            path: []
          });
        }
      }
    }
    axis.graphics.brokeLine = brokeLine;
  };
  /**
   * Function is called internally by the axis class draw function to draw the axis plot bands
   */


  CartesianAxis.prototype._calculateCategoryPlotBand = function _calculateCategoryPlotBand() {
    var axis = this,
        axisConfig = axis.config,
        axisRange = axisConfig.axisRange,

    // canvas = axisConfig.canvas,
    // chart = axis.getFromEnv('chart'),
    // chartConfig = chart.config,
    // chartComponents = chart.components,
    // canvasLeft = canvas.canvasLeft || chartConfig.canvasLeft,
    // canvasTop = canvas.canvasTop || chartConfig.canvasTop,
    // canvasHeight = canvas.canvasHeight || chartConfig.canvasHeight,
    // canvasWidth = canvas.canvasWidth || chartConfig.canvasWidth,
    increment = axisRange.tickInterval,

    // isVertical = axisConfig.isVertical,
    // isReverse = axisConfig.isReverse,
    min = axisRange.min,

    // axisBandContainer = axisConfig.axisBandContainer,
    // paper = chartComponents.paper,
    // axisBand = axis.graphics.band || (axis.graphics.band = []),
    // elementRecycle = axis.numericPlotBandER || (axis.numericPlotBandER = new ElementRecycle()),
    showAlternateGridColor = axisConfig.showAlternateGridColor,
        alternateGridColor = axisConfig.alternateGridColor,
        alternateGridAlpha = axisConfig.alternateGridAlpha,

    // animElems = [],
    axisAttrObj,

    // axisAttrObjPreFn,
    colorDetector,
        i,
        ln,
        value,
        bandWidth,

    // bandPreAttr,
    // pvr,
    // bandElement,
    // intervalWidth,
    intervalArr;

    // get the interval width of the div lines in pixel
    // intervalWidth = mathAbs(axis.getPixel(min) - axis.getPixel(min + increment));

    // Check if drawing band and line is possible for now it is set to 10 px
    // if (intervalWidth < 2) {
    //   axisConfig.band.isDraw = 0;
    // }
    intervalArr = this._getIntervalArr({ step: 1, minPad: increment, maxPad: increment });
    // elementRecycle.preProcessor();
    // axisAttrObjPreFn = function (attrs) {
    //   return function () {
    //     this.attr(attrs);
    //   };
    // };
    // checking if lines are to be drawn user can decide
    if (showAlternateGridColor && axisConfig.band.isDraw) {
      // alternate band color is decided by this variable
      colorDetector = mathRound(((intervalArr[0] || 0) - min) / increment) + 1;

      // common attributes
      axisAttrObj = {
        fill: (0, _lib.toRaphaelColor)(convertColor(alternateGridColor, alternateGridAlpha)),
        'stroke-width': 0,
        opacity: alternateGridAlpha
      };
      // pixel to value ratio
      // pvr = axis.pvr;
      for (i = 0, ln = intervalArr.length; i < ln; i += 1, colorDetector += 1) {
        // if this should be colored band or not
        if (colorDetector % 2 !== 0) {
          continue;
        }
        value = intervalArr[i];
        // calculate the band width
        // if this is zero plane
        bandWidth = mathAbs(value - intervalArr[i + 1]) || increment;

        // attached attributes
        // if (isVertical) {
        // y-axis
        // axisAttrObj.x = canvasLeft;
        // axisAttrObj.y = axis.getPixel((isReverse ? value : value + mathAbs(bandWidth)), {
        //   wrtVisible: true
        // });
        // axisAttrObj.width = canvasWidth;
        // axisAttrObj.height = mathAbs(bandWidth * pvr);
        // } else {
        // x-axis
        // axisAttrObj.x = axis.getPixel(value, { wrtVisible: true });
        // axisAttrObj.y = canvasTop;
        // axisAttrObj.width = mathAbs(bandWidth * pvr);
        // axisAttrObj.height = canvasHeight;
        // }

        // bandElement = elementRecycle.getElementIfExist('rect', intervalArr[i]);
        // if (bandElement) {
        //   bandElement = bandElement.elem;
        // } else {
        //   bandElement = paper.rect(axisBandContainer);
        //   elementRecycle.insertElement('rect', intervalArr[i], bandElement);
        // }

        // animElems.push({
        //   el: bandElement,
        //   attrs: {opacity: 0},
        //   animType: 'linear',
        //   animConfig: [{
        //     syncWith: 'initial',
        //     start: 0,
        //     end: 1
        //   }]
        // });

        // bandPreAttr = {
        //   x: axisAttrObj.x,
        //   y: axisAttrObj.y,
        //   width: axisAttrObj.width,
        //   height: axisAttrObj.height
        // };

        // if (!axis.savedAxis) {
        //   bandPreAttr.fill = axisAttrObj.fill;
        // }

        axis.addComponentInfo('band', {
          fill: axisAttrObj.fill,
          opacity: axisAttrObj.opacity,
          'stroke-width': axisAttrObj['stroke-width'],
          bandWidth: bandWidth,
          value: value
        });

        // animElems.push({
        //   el: bandElement,
        //   attrs: extend2({}, axisAttrObj),
        //   animType: 'linear',
        //   animConfig: [{
        //     hookFn: axisAttrObjPreFn(bandPreAttr),
        //     syncWith: 'final',
        //     start: 0,
        //     end: 1
        //   }]
        // });

        // axisBand[i] = bandElement;
      }
    }
    // elementRecycle.postProcessor(function (el) {
    //   animElems.push({
    //     el: el,
    //     attrs: {
    //       'opacity': 0
    //     },
    //     animType: 'linear',
    //     animConfig: [{
    //       syncWith: 'initial',
    //       start: 0,
    //       end: 1
    //     }]
    //   });
    // });
    // axis._registerVerticalAxisAnims(animElems);
  };

  /**
   * Once the drawing parameters of a component is calculated, they are saved in the axis instance
   * with the given name.
   * @param {string} name The name by which to save the calculated parameters
   * @param {Object} obj  An object containing the calculated parameters of the component
   */


  CartesianAxis.prototype.addComponentInfo = function addComponentInfo(name, obj) {
    this.getFromEnv('componentInfo')[sanitiseComponentName(name)].push(obj);
  };

  /**
   * Gets the calculated drawing parameters of an axis component
   * @param  {string} name The name of the component whose drawing parameters are required
   * @return {Object}      The drawing parameters of the given component
   */


  CartesianAxis.prototype.getComponentInfo = function getComponentInfo(name) {
    return this.getFromEnv('componentInfo')[sanitiseComponentName(name)];
  };

  /**
   * Function is called internally by the axis class draw function to draw the axis trend line and zone
   */


  CartesianAxis.prototype._drawTrendLine = function _drawTrendLine() {
    var axis = this,
        axisConfig = axis.config,
        isVertical = axisConfig.isVertical,

    // is3d = chart.is3D,
    // isSingleStepAnim = chartComponents.animationManager.isSingleStepAnim,
    axisIndex = axisConfig.axisIndex,
        numberFormatter = axis.getFromEnv('number-formatter'),

    // canvasBottom = canvas.canvasBottom || chartConfig.canvasBottom,
    // canvasLeft = canvas.canvasLeft || chartConfig.canvasLeft,
    // canvasRight = canvas.canvasRight || chartConfig.canvasRight,
    // canvasTop = canvas.canvasTop || chartConfig.canvasTop,
    // canvasHeight = canvas.canvasHeight || chartConfig.canvasHeight,
    // canvasWidth = canvas.canvasWidth || chartConfig.canvasWidth,
    axisRange = axisConfig.axisRange,
        max = axisRange.max,
        min = axisRange.min,

    // maxPx,
    // minPx,
    style = axisConfig.trend.trendStyle,

    // axisPadding = axisConfig.labelPadding,
    // axisTrendContainerTop = axisConfig.axisTrendContainerTop,
    // axisTrendContainerBottom = axisConfig.axisTrendContainerBottom,
    // axisTrendLabelContainer = axisConfig.axisTrendLabelContainer,
    // paper = chartComponents.paper,
    // axisTrend = axis.components.trendObj || (axis.components.trendObj = []),
    // elementRecycle = axis.trendLineER || (axis.trendLineER = new ElementRecycle()),
    // css = {
    //   fontFamily: style.fontFamily,
    //   fontSize: style.fontSize,
    //   lineHeight: style.lineHeight,
    //   fontWeight: style.fontWeight,
    //   fontStyle: style.fontStyle
    // },
    vtrendlines = axisConfig.vTrendLines,
        trendlines = axisConfig.trendLines,
        checkForLimit = true,

    // drawTrendLabels = axisConfig.drawTrendLabels,
    // axisDimention = axisConfig.axisDimention || {},
    // animElems = [],
    // axisAttrObjPreFn,
    // animationDuration,
    // transposeAnimDuration,
    i,
        iLim,
        j,
        jLen,
        toolText,

    // axisTrendContainer,
    // counter = 0,
    // trendElement,
    // trendLabelElement,
    comTrendLines,
        isTrendZone,
        axisDrawingAttrObj,
        axisTextAttrObj,
        getLimit,
        trendObj,
        text,
        valueOnRight,
        startValue,
        endValue,

    // startValuePixel,
    // endValuePixel,
    strokeWidth,

    // showOnTop,
    // fixedTrendLabelPos,
    // fixedTrendLabelPosRight,
    NFMethodName;
    // animObj,
    // dummyObj,
    // animType,
    // crispPath;

    // get the visible range
    getLimit = this.getVisibleConfig();
    if (axisConfig.hasBreakPoints) {
      getLimit.minValue = axis._getRealBreakValue(getLimit.minValue);
      getLimit.maxValue = axis._getRealBreakValue(getLimit.maxValue);
    }
    checkForLimit = axis._isZoomed();
    if (!checkForLimit) {
      getLimit.minValue = min;
      getLimit.maxValue = max;
    } /* else { */
    // maxPx = mathMax(axis.getPixel(getLimit.minValue, { wrtVisible: true }),
    //   axis.getPixel(getLimit.maxValue, { wrtVisible: true }));
    // minPx = mathMin(axis.getPixel(getLimit.minValue, { wrtVisible: true }),
    //   axis.getPixel(getLimit.maxValue, { wrtVisible: true }));
    // }
    // if (vtrendlines) {
    // fixedTrendLabelPos = isOpposit ? (axisDimention.opposite || canvasBottom) -
    //   (axisConfig.trendBottomPadding || 0) : (axisDimention.y || canvasBottom) +
    //   (axisConfig.trendBottomPadding || 0);
    // } else {
    // fixedTrendLabelPos = isOpposit ? (axisDimention.opposite || canvasLeft) + (axisPadding || 0) :
    // (axisDimention.x || canvasLeft) - (axisPadding || 0);
    // fixedTrendLabelPosRight = isOpposit ? (axisDimention.x || canvasRight) + (axisPadding || 0) :
    // (axisDimention.opposite || canvasRight) + (axisPadding || 0);
    // }
    // elementRecycle.preProcessor();
    // axisAttrObjPreFn = function (attrs) {
    //   return function () {
    //     this.attr(attrs);
    //   };
    // };

    // get the trend line object
    comTrendLines = trendlines || vtrendlines;
    if (comTrendLines) {
      for (j = 0, jLen = comTrendLines.length; j < jLen; j += 1) {
        for (i = 0, iLim = comTrendLines[j].line && comTrendLines[j].line.length; i < iLim; i += 1) {
          trendObj = comTrendLines[j].line[i];
          NFMethodName = isVertical ? 'yAxis' : 'xAxis';
          startValue = trendObj.startvalue || trendObj.value || 0;
          startValue = numberFormatter.getCleanValue((0, _lib.pluck)(trendObj.startvalue, trendObj.value, 0));
          endValue = Number(trendObj.endvalue) || UNDEF;
          toolText = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(trendObj.tooltext, comTrendLines[0].tooltext, axisConfig.trendlineToolText)));
          toolText = (0, _lib.parseTooltext)(toolText, [7, 15, 16, 17, 18, 19], {
            startValue: startValue,
            startDataValue: numberFormatter[NFMethodName](startValue, axisIndex),
            endValue: endValue || startValue,
            endDataValue: numberFormatter[NFMethodName](endValue || startValue, axisIndex),
            axisName: axisConfig.axisName
          }, trendObj);
          if (startValue > max || startValue < min || endValue > max || endValue < min) {
            continue;
          }
          // checking for if the trend line is inside visual range
          if (vtrendlines && startValue >= getLimit.minValue && startValue <= getLimit.maxValue || endValue && endValue >= getLimit.minValue && endValue <= getLimit.maxValue || endValue && startValue <= getLimit.minValue && endValue >= getLimit.maxValue || // Next check for trendline
          trendlines && startValue > getLimit.minValue && startValue <= getLimit.maxValue || endValue && endValue >= getLimit.minValue && endValue <= getLimit.maxValue || endValue && startValue >= getLimit.minValue && endValue <= getLimit.maxValue) {
            // prepare the trend line or zone path and attributes
            if (vtrendlines) {
              // y-axis
              text = (0, _lib.parseUnsafeString)(trendObj.displayvalue || '');
              // startValuePixel = axis.getPixel(axisConfig.hasBreakPoints ?
              //   axis._getRelativeBreakValue(startValue) : startValue, { wrtVisible: true });
              isTrendZone = (0, _lib.pluckNumber)(trendObj.istrendzone, axisConfig.isTrendZone, 1);
              // endValuePixel = endValue ?
              //   axis.getPixel(axisConfig.hasBreakPoints ?
              //     axis._getRelativeBreakValue(endValue) : endValue, { wrtVisible: true }) : 0;
              // trend zone
              if (endValue !== UNDEF && endValue !== '' && endValue !== startValue && isTrendZone) {
                axisDrawingAttrObj = {
                  fill: convertColor((0, _lib.pluck)(trendObj.color, axisConfig.trendlineColor), (0, _lib.pluck)(trendObj.alpha, axisConfig.trendlineAlpha, 40)),
                  'stroke-width': 0
                  // path: ['M', startValuePixel, canvasTop,
                  //   'L', startValuePixel, canvasBottom,
                  //   'L', endValuePixel, canvasBottom,
                  //   'L', endValuePixel, canvasTop, 'Z']
                };
                axisTextAttrObj = {
                  fill: convertColor((0, _lib.pluck)(trendObj.color, style.color), (0, _lib.pluck)(trendObj.alpha, axisConfig.trendlineAlpha, 99)),
                  'vertical-align': POSITION_TOP,
                  'text': text
                  // 'x': startValuePixel + ((endValuePixel - startValuePixel) / 2),
                  // 'y': fixedTrendLabelPos
                };
              } else {
                // trend line
                strokeWidth = (0, _lib.pluckNumber)(trendObj.thickness, axisConfig.trendlineThickness, 1);
                // strokeWidth = strokeWidth > canvasWidth ? 1 : strokeWidth;
                // crispPath = endValue ?
                //   getCrispPath(['M', startValuePixel, canvasTop,
                //     'L', endValuePixel, canvasBottom], strokeWidth) :
                //   getCrispPath(['M', startValuePixel, canvasTop,
                //     'L', startValuePixel, canvasBottom], strokeWidth);
                axisDrawingAttrObj = {
                  stroke: convertColor((0, _lib.pluck)(trendObj.color, axisConfig.trendlineColor), (0, _lib.pluck)(trendObj.alpha, axisConfig.trendlineAlpha, 99)),
                  'stroke-width': strokeWidth,
                  'stroke-dasharray': (0, _lib.pluck)(trendObj.dashed, axisConfig.trendlinesAreDashed) === _lib.ONESTRING ? (0, _lib.getDashStyle)((0, _lib.pluckNumber)(trendObj.dashlen, axisConfig.trendlinesDashLen), (0, _lib.pluckNumber)(trendObj.dashgap, axisConfig.trendlinesDashGap)) : DASH_DEF
                  // 'shape-rendering': crispPath.isCrisped ? CRISP : UNDEF
                  // path: crispPath.path
                };
                axisTextAttrObj = {
                  fill: convertColor((0, _lib.pluck)(trendObj.color, style.color), (0, _lib.pluck)(trendObj.alpha, axisConfig.trendlineAlpha, 99)),
                  'vertical-align': POSITION_TOP,
                  'text': text
                  // 'x': endValue ? endValuePixel : startValuePixel,
                  // 'y': fixedTrendLabelPos
                };
              }
              // checking if the text is out of viewport
              // if (checkForLimit && (!drawTrendLabels || axisTextAttrObj.x > maxPx ||
              //   axisTextAttrObj.x < minPx)) {
              //   axisTextAttrObj.text = '';
              // }
            } else if (trendlines) {
              // x-axis
              text = (0, _lib.parseUnsafeString)(trendObj.displayvalue || '');
              valueOnRight = (0, _lib.pluckNumber)(trendObj.valueonright, 0);
              isTrendZone = (0, _lib.pluckNumber)(trendObj.istrendzone, axisConfig.isTrendZone, 0);
              // startValuePixel = axis.getPixel(startValue, { wrtVisible: true });
              // endValuePixel = endValue ? axis.getPixel(endValue, { wrtVisible: true }) : 0;
              if (endValue !== UNDEF && endValue !== '' && endValue !== startValue && isTrendZone) {
                // trend zone
                axisDrawingAttrObj = {
                  fill: convertColor((0, _lib.pluck)(trendObj.color, axisConfig.trendlineColor), (0, _lib.pluck)(trendObj.alpha, axisConfig.trendlineAlpha, 40)),
                  'stroke-width': 0
                  // path: ['M', canvasLeft, startValuePixel,
                  //   'L', canvasRight, startValuePixel,
                  //   'L', canvasRight, endValuePixel,
                  //   'L', canvasLeft, endValuePixel, 'Z']
                };
                axisTextAttrObj = {
                  'text-anchor': valueOnRight ? POSITION_START : POSITION_END,
                  fill: convertColor((0, _lib.pluck)(trendObj.color, style.color), (0, _lib.pluck)(trendObj.alpha, axisConfig.trendlineAlpha, 99)),
                  'text': text
                  // 'x': valueOnRight ? fixedTrendLabelPosRight : fixedTrendLabelPos,
                  // 'y': startValuePixel + ((endValuePixel - startValuePixel) / 2)
                };
              } else {
                // trend line
                strokeWidth = (0, _lib.pluckNumber)(trendObj.thickness, axisConfig.trendlineThickness, 1);
                // strokeWidth = strokeWidth > canvasHeight ? 1 : strokeWidth;
                // crispPath = endValue ?
                //   getCrispPath(['M', canvasLeft, startValuePixel,
                //     'L', canvasRight, endValuePixel, 'Z'], strokeWidth) :
                //   getCrispPath(['M', canvasLeft, startValuePixel,
                //     'L', canvasRight, startValuePixel, 'Z'], strokeWidth);
                axisDrawingAttrObj = {
                  stroke: convertColor((0, _lib.pluck)(trendObj.color, axisConfig.trendlineColor), (0, _lib.pluck)(trendObj.alpha, axisConfig.trendlineAlpha, 99)),
                  'stroke-width': strokeWidth,
                  'stroke-dasharray': (0, _lib.pluck)(trendObj.dashed, axisConfig.trendlinesAreDashed) === _lib.ONESTRING ? (0, _lib.getDashStyle)((0, _lib.pluckNumber)(trendObj.dashlen, axisConfig.trendlinesDashLen), (0, _lib.pluckNumber)(trendObj.dashgap, axisConfig.trendlinesDashGap)) : DASH_DEF
                  // 'shape-rendering': crispPath.isCrisped ? CRISP : UNDEF,
                  // path: crispPath.path
                };
                axisTextAttrObj = {
                  'text-anchor': valueOnRight ? POSITION_START : POSITION_END,
                  fill: convertColor((0, _lib.pluck)(trendObj.color, style.color), (0, _lib.pluck)(trendObj.alpha, axisConfig.trendlineAlpha, 99)),
                  'text': text
                  // 'x': valueOnRight ? fixedTrendLabelPosRight : fixedTrendLabelPos,
                  // 'y': endValue ? valueOnRight ? endValuePixel :
                  //   startValuePixel : startValuePixel
                };
              }
              // checking if the text is out of viewport
              // if (checkForLimit && (!drawTrendLabels || axisTextAttrObj.y > maxPx ||
              //   axisTextAttrObj.y < minPx)) {
              //   axisTextAttrObj.text = '';
              // }
            }
            // if show on top or bottom set the container accordingly
            // showOnTop = pluckNumber(trendObj.showontop);
            // if (!is3d && (showOnTop === 1 || axisConfig.showTrendlinesOnTop === 1)) {
            //   axisTrendContainer = axisTrendContainerTop;
            // } else {
            //   axisTrendContainer = axisTrendContainerBottom;
            // }

            axisTextAttrObj['text-bound'] = axisTextAttrObj.text ? [style.backgroundColor, style.borderColor, style.borderThickness, style.borderPadding, style.borderRadius, style.borderDash] : [];
            // trendElement = elementRecycle.getElementIfExist('path', counter);
            // if (trendElement) {
            //   trendElement = trendElement.elem;
            // } else {
            //   trendElement = paper.path(axisTrendContainer);
            //   elementRecycle.insertElement('path', counter, trendElement);
            // }
            // trendLabelElement = elementRecycle.getElementIfExist('text', counter);
            // if (trendLabelElement) {
            //   trendLabelElement = trendLabelElement.elem;
            // } else {
            //   trendLabelElement = paper.text(axisTrendLabelContainer);
            //   elementRecycle.insertElement('text', counter, trendLabelElement);
            // }
            // trendLabelElement.css(css);

            if (!(axisConfig.showTooltip && trendObj.valueToolText) || !(axisConfig.showTooltip && toolText)) {
              toolText = '';
            }

            axis.addComponentInfo('trend', {
              marker: {
                isZone: isTrendZone,
                startValue: startValue,
                endValue: endValue,
                fill: axisDrawingAttrObj.fill,
                stroke: axisDrawingAttrObj.stroke,
                strokeWidth: axisDrawingAttrObj['stroke-width'],
                strokeDashArray: axisDrawingAttrObj['stroke-dasharray'],
                shapeRendering: axisDrawingAttrObj['shape-rendering']
              },
              label: {
                fill: axisTextAttrObj.fill,
                text: axisTextAttrObj.text,
                textAnchor: axisTextAttrObj['text-anchor'],
                textBound: axisTextAttrObj['text-bound'],
                valueOnRight: (0, _lib.pluckNumber)(trendObj.valueonright, 0),
                toolText: toolText
              },
              showOnTop: (0, _lib.pluckNumber)(trendObj.showontop)
            });

            // if (isSingleStepAnim) {
            //   animElems.push({
            //     el: trendElement,
            //     attrs: extend2({opacity: 1}, axisDrawingAttrObj),
            //     animType: 'linear',
            //     animConfig: [{
            //       syncWith: 'final',
            //       start: 0,
            //       end: 1
            //     }]
            //   });
            //
            //   animElems.push({
            //     el: trendLabelElement,
            //     attrs: extend2({opacity: 1}, axisTextAttrObj),
            //     animType: 'linear',
            //     animConfig: [{
            //       syncWith: 'final',
            //       start: 0,
            //       end: 1
            //     }]
            //   });
            // } else {
            //   animElems.push({
            //     el: trendElement,
            //     attrs: {opacity: 0},
            //     animType: 'linear',
            //     animConfig: [{
            //       syncWith: 'initial',
            //       start: 0,
            //       end: 1
            //     }]
            //   });
            //
            //   animElems.push({
            //     el: trendLabelElement,
            //     attrs: {opacity: 0, 'text-bound': []},
            //     animType: 'linear',
            //     animConfig: [{
            //       syncWith: 'initial',
            //       start: 0,
            //       end: 1
            //     }]
            //   });
            //
            //   animElems.push({
            //     el: trendElement,
            //     attrs: extend2({opacity: 1}, axisDrawingAttrObj),
            //     animType: 'linear',
            //     animConfig: [{
            //       hookFn: axisAttrObjPreFn({
            //         path: axisDrawingAttrObj.path
            //       }),
            //       syncWith: 'final',
            //       start: 0,
            //       end: 1
            //     }]
            //   });
            //
            //   animElems.push({
            //     el: trendLabelElement,
            //     attrs: extend2({opacity: 1}, axisTextAttrObj),
            //     animType: 'linear',
            //     animConfig: [{
            //       hookFn: axisAttrObjPreFn({
            //         x: axisTextAttrObj.x,
            //         y: axisTextAttrObj.y
            //       }),
            //       syncWith: 'final',
            //       start: 0,
            //       end: 1
            //     }]
            //   });
            // }

            // axisTrend[counter] = {
            //   label: trendLabelElement,
            //   drawing: trendElement
            // };
            // if (axisConfig.showTooltip && trendObj.valueToolText) {
            //   trendLabelElement.trackTooltip(true);
            // } else {
            //   trendLabelElement.trackTooltip(false);
            // }
            // if (axisConfig.showTooltip && toolText) {
            //   trendElement.tooltip(toolText).trackTooltip(true);
            // } else {
            //   trendElement.trackTooltip(false);
            // }
            // counter += 1;
          }
        }
      }
    }
    // elementRecycle.postProcessor(function (el) {
    //   animElems.push({
    //     el: el,
    //     attrs: {
    //       'opacity': 0,
    //       'text-bound': []
    //     },
    //     animType: 'linear',
    //     animConfig: [{
    //       syncWith: 'initial',
    //       start: 0,
    //       end: 1
    //     }]
    //   });
    // });
    // axis._registerVerticalAxisAnims(animElems);
  };

  /**
   * Draws the category labels of the axis
   */


  CartesianAxis.prototype._drawCategory = function _drawCategory() {
    var axis = this,
        axisConfig = axis.config,
        axisDimention = axisConfig.axisDimention || {},
        canvas = axisConfig.canvas,
        chart = axis.getFromEnv('chart'),
        chartConfig = chart.config,
        isOpposit = axisConfig.isOpposit,
        labels = axisConfig.labels,
        elementRecycle,
        style = labels.style,
        isVertical = axisConfig.isVertical,
        canvasBottom = canvas.canvasBottom || chartConfig.canvasBottom,
        canvasLeft = canvas.canvasLeft || chartConfig.canvasLeft,
        canvasRight = canvas.canvasRight || chartConfig.canvasRight,
        canvasTop = canvas.canvasTop || chartConfig.canvasTop,
        axisContainer = axisConfig.axisContainer,
        axisPadding = axisConfig.labelPadding,
        paper = axis.getFromEnv('paper'),
        axisStartPosition = isVertical ? axisDimention.x : axisDimention.y,
        axisEndPosition = axisDimention.opposite,
        categoryLabel = axis.config.categoryLabel || (axis.config.categoryLabel = []),
        categories = chart.jsonData.categories,
        categoriesStyle = {},

    // chartState = chart.state,
    raiseEvent = function raiseEvent(event) {
      return function (data) {
        var ele = this;
        _lib.plotEventHandler.call(ele, chart, data, event);
      };
    },

    // isRealTime,
    animElems = [],
        category,
        i,
        max,
        min,
        curCategory,
        textElement,
        text,
        labelRotation,
        labelLineHeight,
        labelLineHeightpx,
        addCategoryPadding,
        css,
        categoryStyleFontFamily,
        categoryStyleFontSize,
        categoryStyleFontWeight,
        categoryStyleFontStyle,
        ParentCss,
        axisAttrObj,
        fontColor,
        pos,
        curCategoryValue,
        increment,
        labelBox,
        categoryArr,
        categoryArrStr,
        ln,
        axisAttrObjPre,
        tempStep,
        intervalWidth;

    if (!axis.getFromEnv('catLabelER')) {
      axis.addToEnv('catLabelER', new _elementRecycler2['default']());
    }
    elementRecycle = axis.getFromEnv('catLabelER');

    // isRealTime = (chartState === 'realTimeUpdate');

    // NOTE: animateCategories seems to be legacy code. It was present at one point to force the
    // first incoming category to be drawn outside the canvas bounds.

    // if (axisConfig.isCategoryAnimate && axisConfig.animateCategories) {
    //     category = axisConfig.animateCategories;
    // } else {
    category = axisConfig.categories.category;
    // }
    min = 0;
    max = category ? category.length - 1 : 0;
    // Draw the category line
    axis._drawCategoryLine(category, min, max);

    // checking if labels are to be drawn user can decide or can be decided by axis placeAxis function
    if (axisConfig.labels.isDraw) {
      if (isVertical) {
        intervalWidth = mathAbs(axis.getPixel(0) - axis.getPixel(1));
        // check for overlap if there is any make the step such that no overlap happens
        if (axisConfig.labelMaxH > intervalWidth) {
          tempStep = mathCeil(axisConfig.labelMaxH / intervalWidth);
        }
        if (tempStep > axisConfig.labels.step) {
          axisConfig.labels.step = tempStep;
        }
      }
      increment = axisConfig.labels.step > 0 ? axisConfig.labels.step : 1;

      labelRotation = axisConfig.labels.rotation;

      // check with the drawAxisNameOpposit to finally decide the name should be draw on which
      // side
      if (axisConfig.drawLabelsOpposit) {
        isOpposit = !isOpposit;
        axisStartPosition = axisEndPosition;
      }

      if (categories && categories[0] && axisConfig.xAxisLabelMode !== 'auto') {
        categoriesStyle.fontFamily = categories[0].font;
        categoriesStyle.fontSize = categories[0].fontsize;
        categoriesStyle.color = categories[0].fontcolor;
      }

      ParentCss = {
        fontFamily: (0, _lib.pluck)(categoriesStyle.fontFamily, style.fontFamily),
        fontSize: (0, _lib.pluck)(categoriesStyle.fontSize, style.fontSize),
        fontWeight: (0, _lib.pluck)(style.fontWeight),
        fontStyle: (0, _lib.pluck)(style.fontStyle)
      };
      ParentCss.lineHeight = (0, _lib.setLineHeight)(ParentCss);
      axisContainer.css(ParentCss);

      categoryArr = this._getCategoryArr({ step: 1, minPad: increment, maxPad: increment });
      categoryArrStr = [];

      for (i = 0, ln = categoryArr.length; i < ln; i += 1) {
        categoryArrStr[i] = '' + categoryArr[i].value;
      }
      // This will help to manage which element are to be kept for later use
      elementRecycle.preProcessor();
      elementRecycle.insertReserveElement('label', categoryArrStr);
      // main loop where the drawing starts
      for (i = 0, ln = categoryArr.length; i < ln; i += 1) {
        curCategory = category[categoryArr[i].index];
        // TODO : need to
        curCategoryValue = categoryArr[i].value;
        categoryStyleFontFamily = (0, _lib.pluck)(curCategory.font, curCategory.labelfont);
        categoryStyleFontSize = (0, _lib.pluck)(curCategory.fontsize, curCategory.labelfontsize);
        categoryStyleFontWeight = (0, _lib.pluck)(curCategory.fontbold, curCategory.labelfontbold) ? (0, _lib.pluckNumber)(curCategory.fontbold, curCategory.labelfontbold, 0) ? 'bold' : NORMALSTRING : UNDEF;
        categoryStyleFontStyle = (0, _lib.pluck)(curCategory.fontitalic, curCategory.labelfontitalic) ? (0, _lib.pluckNumber)(curCategory.fontitalic, curCategory.labelfontitalic, 0) ? 'italic' : NORMALSTRING : UNDEF;
        fontColor = convertColor((0, _lib.pluck)(curCategory.fontcolor, curCategory.labelfontcolor, categoriesStyle.color, style.color), (0, _lib.pluckNumber)(curCategory.labelalpha, axisConfig.rawAttr.labelFontAlpha, chart.singleseries ? UNDEF : curCategory.alpha, 100));
        if (categoryStyleFontFamily || categoryStyleFontSize || categoryStyleFontWeight || categoryStyleFontStyle) {
          css = {};
          categoryStyleFontFamily && (css.fontFamily = categoryStyleFontFamily);
          categoryStyleFontSize && (css.fontSize = categoryStyleFontSize);
          categoryStyleFontWeight && (css.fontWeight = categoryStyleFontWeight);
          categoryStyleFontStyle && (css.fontStyle = categoryStyleFontStyle);
          css.lineHeight = categoryStyleFontSize ? (0, _lib.setLineHeight)(css) : ParentCss.lineHeight;
        } else {
          css = UNDEF;
        }

        if (css || ParentCss) {
          labelLineHeightpx = (css || ParentCss).lineHeight;
          if (labelLineHeightpx.indexOf('px') !== -1) {
            labelLineHeight = labelLineHeightpx.replace(/px/i, '');
            labelLineHeight = parseFloat(labelLineHeight);
          }
        }

        // make the attribute ready to use
        pos = axis.getPixel(curCategoryValue, { wrtVisible: true });
        if (isVertical) {
          // y-axis
          text = curCategory.label || '';
          // @temp
          addCategoryPadding = Number(curCategory.labelPadding) || 0;
          axisAttrObj = {
            fill: fontColor,
            'line-height': labelLineHeight,
            opacity: 1,
            'text-anchor': isOpposit ? POSITION_START : POSITION_END,
            'text': text,
            cursor: curCategory.link || curCategory.labellink || style.labelLink ? POINTER : '',
            'x': isOpposit ? (axisStartPosition || canvasRight) + axisPadding : (axisStartPosition || canvasLeft) - axisPadding,
            'y': addCategoryPadding ? pos + addCategoryPadding : pos
          };
        } else {
          // x-axis
          text = curCategory.label || '';
          addCategoryPadding = Number(curCategory.labelPadding) || 0;
          axisAttrObj = {
            fill: fontColor,
            'line-height': labelLineHeight,
            opacity: 1,
            'text': text,
            cursor: curCategory.link || curCategory.labellink || style.labelLink ? POINTER : '',
            'x': pos,
            'y': isOpposit ? (axisStartPosition || canvasTop) - axisPadding : (axisStartPosition || canvasBottom) + axisPadding
          };
          if (labelRotation) {
            axisAttrObj['text-anchor'] = isOpposit ? POSITION_START : POSITION_END;
            axisAttrObj['vertical-align'] = 'center';
          } else {
            axisAttrObj['text-anchor'] = POSITION_MIDDLE;
            axisAttrObj['vertical-align'] = isOpposit ? POSITION_BOTTOM : POSITION_TOP;
          }
          if (addCategoryPadding) {
            if (isOpposit) {
              axisAttrObj.y -= addCategoryPadding;
            } else {
              axisAttrObj.y += addCategoryPadding;
            }
          }
        }

        labelBox = {
          label: curCategory.label,
          lineHeight: labelLineHeightpx,
          border: (0, _lib.pluckNumber)(curCategory.borderthickness, curCategory.labelborderthickness) ? (0, _lib.pluckNumber)(curCategory.borderthickness, curCategory.labelborderthickness, 1) + 'px solid' : '',
          borderColor: curCategory.bordercolor || curCategory.labelbordercolor ? convertColor(curCategory.bordercolor || curCategory.labelbordercolor, (0, _lib.pluckNumber)(curCategory.borderalpha, curCategory.labelborderalpha, curCategory.alpha, curCategory.labelalpha, 100)) : _lib.BLANKSTRING,
          borderThickness: (0, _lib.pluckNumber)(curCategory.borderthickness, curCategory.labelborderthickness),
          borderPadding: (0, _lib.pluckNumber)(curCategory.borderpadding, curCategory.labelborderpadding),
          borderRadius: (0, _lib.pluckNumber)(curCategory.borderradius, curCategory.labelborderradius),
          backgroundColor: curCategory.bgcolor || curCategory.labelbgcolor ? convertColor(curCategory.bgcolor || curCategory.labelbgcolor, (0, _lib.pluckNumber)(curCategory.bgalpha, curCategory.labelbgalpha, curCategory.alpha, curCategory.labelalpha, axisConfig.rawAttr.labelFontAlpha, 100)) : _lib.BLANKSTRING,
          borderDash: (0, _lib.pluckNumber)(curCategory.borderdashed, curCategory.labelborderdashed, 0) ? (0, _lib.getDashStyle)((0, _lib.pluckNumber)(curCategory.borderdashlen, curCategory.labelborderdashlen, 4), (0, _lib.pluckNumber)(curCategory.borderdashgap, curCategory.labelborderdashgap, 2)) : (0, _lib.pluckNumber)(curCategory.borderdashed, curCategory.labelborderdashed) === 0 ? DASH_DEF : style.borderDash
        };
        if (!curCategory.label) {
          axisAttrObj['text-bound'] = [];
        } else {
          axisAttrObj['text-bound'] = [(0, _lib.pluck)(labelBox.backgroundColor, style.backgroundColor), (0, _lib.pluck)(labelBox.borderColor, style.borderColor), (0, _lib.pluck)(labelBox.borderThickness, style.borderThickness), (0, _lib.pluck)(labelBox.borderPadding, style.borderPadding), (0, _lib.pluck)(labelBox.borderRadius, style.borderRadius), (0, _lib.pluck)(labelBox.borderDash, style.borderDash)];
        }

        // If labels shift is applicable (Specially for 3D) then apply the changes
        if (labels.shiftX) {
          axisAttrObj.x += labels.shiftX;
        }
        if (labels.shiftY) {
          axisAttrObj.y += labels.shiftY;
        }

        axisAttrObjPre = (0, _lib.extend2)({}, axisAttrObj);
        axisAttrObjPre.opacity = 0;
        if (axis.getFromEnv('tempAxis')) {
          axisAttrObjPre.x = isVertical ? axisAttrObj.x : axis.getPixel(curCategoryValue, {
            preValue: true,
            wrtVisible: true
          });
          axisAttrObjPre.y = isVertical ? axis.getPixel(curCategoryValue, {
            preValue: true,
            wrtVisible: true
          }) : axisAttrObj.y;
        }
        textElement = elementRecycle.getElementIfExist('label', curCategoryValue);
        if (textElement) {
          if (!textElement.isOtherElem) {
            axisAttrObjPre = UNDEF;
          }
          textElement = textElement.elem;
        } else {
          textElement = paper.text(axisContainer);
          textElement.click(raiseEvent('dataLabelClick')).hover(raiseEvent('dataLabelRollOver'), raiseEvent('dataLabelRollOut'));
          elementRecycle.insertElement('label', curCategoryValue, textElement);
        }
        textElement.data(EVENTARGS, {
          link: curCategory.link || curCategory.labellink || style.labelLink,
          text: axisAttrObj.text,
          index: i
        });
        textElement.css({
          fontFamily: css && css.fontFamily ? css.fontFamily : ParentCss.fontFamily,
          fontSize: css && css.fontSize ? css.fontSize : ParentCss.fontSize,
          fontWeight: css && css.fontWeight ? css.fontWeight : ParentCss.fontWeight,
          fontStyle: css && css.fontStyle ? css.fontStyle : ParentCss.fontStyle
        });
        categoryLabel[i] = textElement;

        axisAttrObj.transform = paper.getSuggestiveRotation(labelRotation, axisAttrObj.x, axisAttrObj.y);
        axisAttrObjPre && (axisAttrObjPre.transform = paper.getSuggestiveRotation(labelRotation, axisAttrObjPre.x, axisAttrObjPre.y));
        // if (isRealTime) {
        //   textElement.attr( extend2({}, axisAttrObj));
        // } else {

        axis.addComponentInfo('label', {
          cursor: axisAttrObj.cursor,
          fill: axisAttrObj.fill,
          'line-height': axisAttrObj['line-height'],
          opacity: axisAttrObj.opacity,
          value: axisAttrObj.text,
          'text-anchor': axisAttrObj['text-anchor'],
          'text-bound': axisAttrObj['text-bound'],
          rotation: labelRotation,
          'vertical-align': axisAttrObj['vertical-align']
        });

        if (curCategory.labelTooltext) {
          this.getFromEnv('toolTipController').enableToolTip(textElement, curCategory.labelTooltext);
        } else {
          this.getFromEnv('toolTipController').disableToolTip(textElement);
        }

        animElems.push({
          el: textElement,
          preAttrs: (0, _lib.extend2)({}, axisAttrObjPre),
          attrs: (0, _lib.extend2)({}, axisAttrObj),
          animType: 'linear',
          animConfig: [{
            start: 0,
            end: 1
          }]
        });
        // }
      }
      elementRecycle.processOldElem('label', function (key, elem) {
        if (axisAttrObj) {
          animElems.push({
            el: elem,
            attrs: {
              x: isVertical ? axisAttrObj.x : axis.getPixel(key),
              y: isVertical ? axis.getPixel(key) : axisAttrObj.y,
              'opacity': 0,
              'text-bound': []
            },
            animType: 'linear',
            animConfig: [{
              start: 0,
              end: 1
            }]
          });
        } else {
          elem.hide();
        }
      });
    } else {
      elementRecycle.preProcessor();
    }
    elementRecycle.postProcessor(function (el) {
      animElems.push({
        el: el,
        attrs: {
          'opacity': 0,
          'text-bound': []
        },
        animType: 'linear',
        animConfig: [{
          start: 0,
          end: 1
        }]
      });
    });
    axis._registerHorizontalAxisAnims(animElems);
  };

  /**
   * Calculates the parameters necessary for drawing the category lines
   * @param  {Object} category The category being calculated
   * @param  {number} min      The minimum category
   * @param  {number} max      The maximum category
   */


  CartesianAxis.prototype._drawCategoryLine = function _drawCategoryLine(category, min, max) {
    var axis = this,
        axisConfig = axis.config,
        chart = axis.getFromEnv('chart'),

    // axisPlotLineContainer = axisConfig.axisPlotLineContainer,
    showCanvasBorder = axisConfig.showCanvasBorder,
        xAxisLabelMode = axisConfig.xAxisLabelMode,

    // paper = chartComponents.paper,
    colorM = axis.getFromEnv('color-manager'),

    // categoryLabelLine = axis.components.categoryLabelLine || (axis.components.categoryLabelLine = []),
    categories = chart.jsonData.categories,

    // elementRecycle = axis.catLineER || (axis.catLineER = new ElementRecycle()),
    categoriesStyle = {},

    // animElems = [],
    categoryLineArr = [],

    // categoryArrStr = [],
    i,
        curCategory,
        getLimit,
        categoryLineAttr,

    // categoryLine,
    curCategoryValue,
        checkForLimit,
        ln,
        catLineWidth;
    // categoryLineAttrPre;

    // checking if labels are to be drawn user can decide or can be decided by axis placeAxis function
    if (!category) {
      if (axisConfig.isCategoryAnimate && axisConfig.animateCategories) {
        category = axisConfig.animateCategories;
      } else {
        category = axisConfig.categories.category;
      }
    }
    min = min || 0;
    max = max || category ? category.length - 1 : 0;
    if (axisConfig.drawPlotlines) {
      // if not zoomed dont check for limit
      checkForLimit = axis._isZoomed();

      getLimit = this.getVisibleConfig();

      if (categories && categories[0]) {
        categoriesStyle.verticalLineColor = categories[0].verticallinecolor;
        categoriesStyle.verticalLineAlpha = categories[0].verticallinealpha;
        categoriesStyle.verticalLineThickness = categories[0].verticallinethickness;
        categoriesStyle.verticalLineDashed = categories[0].verticallinedashed;
        categoriesStyle.verticalLineDashLen = categories[0].verticallinedashlen;
        categoriesStyle.verticalLineDashGap = categories[0].verticallinedashgap;
      }

      // main loop where the drawing starts
      for (i = min; i <= max; i += 1) {
        curCategory = category[i];
        curCategoryValue = (0, _lib.pluckNumber)(curCategory.x, curCategory.y, categoryLineArr[i]);
        if (!curCategory || showCanvasBorder && (xAxisLabelMode === 'auto' || xAxisLabelMode === 'mixed') && (i === max || i === min)) {
          continue;
        }

        if (Number(curCategory.showverticalline) !== 1) {
          continue;
        }
        // if value is not between the visual limit increment it and continue
        if (checkForLimit && (curCategoryValue < getLimit.minValue || curCategoryValue > getLimit.maxValue)) {
          continue;
        }
        categoryLineArr.push({
          value: curCategoryValue,
          index: i
        });
        // categoryArrStr.push('' + curCategoryValue);
      }
      // elementRecycle.preProcessor();
      // elementRecycle.insertReserveElement('line', categoryArrStr);
      for (i = 0, ln = categoryLineArr.length; i < ln; i += 1) {
        curCategory = category[categoryLineArr[i].index];
        curCategoryValue = categoryLineArr[i].value;

        catLineWidth = (0, _lib.pluckNumber)(curCategory.linethickness, categoriesStyle.verticalLineThickness, 1);

        categoryLineAttr = {
          opacity: 1,
          stroke: convertColor((0, _lib.pluck)(curCategory.linecolor, categoriesStyle.verticalLineColor, axisConfig.divLineColor, colorM.getColor('divLineColor')), (0, _lib.pluck)(curCategory.linealpha, categoriesStyle.verticalLineAlpha, colorM.getColor('divLineAlpha'))),
          'stroke-width': catLineWidth,
          'stroke-dasharray': (0, _lib.pluckNumber)(curCategory.linedashed, categoriesStyle.verticalLineDashed, 0) ? (0, _lib.getDashStyle)((0, _lib.pluckNumber)(curCategory.linedashLen, categoriesStyle.verticalLineDashLen, 4), (0, _lib.pluckNumber)(curCategory.linedashgap, categoriesStyle.verticalLineDashGap, 2)) : DASH_DEF
        };

        // axis._calculatePath(categoryLineAttr, curCategoryValue, catLineWidth);

        // categoryLineAttrPre = extend2({}, categoryLineAttr);
        // categoryLineAttrPre.opacity = 0;
        // if (axis.savedAxis) {
        //   axis._calculatePath(categoryLineAttrPre, curCategoryValue, catLineWidth, {preValue: true});
        // }
        // categoryLine = elementRecycle.getElementIfExist('line', curCategoryValue);
        // if (categoryLine) {
        //   if (!categoryLine.isOtherElem) {
        //     categoryLineAttrPre = UNDEF;
        //   }
        //   categoryLine = categoryLine.elem;
        // } else {
        //   categoryLine = paper.path(axisPlotLineContainer);
        //   elementRecycle.insertElement('line', curCategoryValue, categoryLine);
        // }
        // categoryLabelLine[i] = categoryLine;

        axis.addComponentInfo('line', {
          value: curCategoryValue,
          opacity: categoryLineAttr.opacity,
          'shape-rendering': categoryLineAttr['shape-rendering'],
          stroke: categoryLineAttr.stroke,
          'stroke-dasharray': categoryLineAttr['stroke-dasharray'],
          'stroke-width': categoryLineAttr['stroke-width']
        });

        // animElems.push({
        //   el: categoryLine,
        //   preAttrs: extend2({}, categoryLineAttrPre),
        //   attrs: extend2({}, categoryLineAttr),
        //   animType: 'linear',
        //   animConfig: [{
        //     start: 0,
        //     end: 1
        //   }]
        // });
      }
      // elementRecycle.processOldElem('line', function (key, elem) {
      //   animElems.push({
      //     el: elem,
      //     attrs: axis._calculatePath({opacity: 0}, key, catLineWidth),
      //     animType: 'linear',
      //     animConfig: [{
      //       start: 0,
      //       end: 1
      //     }]
      //   });
      // });
      // axis._registerHorizontalAxisAnims(animElems);
    } /* else { */
    // elementRecycle.preProcessor();
    // }
    // elementRecycle.postProcessor(function (el) {
    //   animElems.push({
    //     el: el,
    //     attrs: {
    //       'opacity': 0
    //     },
    //     animType: 'linear',
    //     animConfig: [{
    //       start: 0,
    //       end: 1
    //     }]
    //   });
    // });
  };
  /**
   * Function is called internally by the axis class draw function to draw the category vLines
   */


  CartesianAxis.prototype._drawCategoryVline = function _drawCategoryVline() {
    var axis = this,
        axisConfig = axis.config,
        axisRange = axisConfig.axisRange,
        min = axisRange.min,
        max = axisRange.max,

    // canvas = axisConfig.canvas,
    chart = axis.getFromEnv('chart'),
        chartConfig = chart.config,
        chartStyle = chartConfig.style || {},

    // chartComponents = chart.components,
    // paper = chartComponents.paper,
    // canvasBottom = canvas.canvasBottom || chartConfig.canvasBottom,
    // canvasLeft = canvas.canvasLeft || chartConfig.canvasLeft,
    // canvasRight = canvas.canvasRight || chartConfig.canvasRight,
    // canvasTop = canvas.canvasTop || chartConfig.canvasTop,
    // canvasHeight = canvas.canvasHeight || chartConfig.canvasHeight,
    // canvasWidth = canvas.canvasWidth || chartConfig.canvasWidth,
    category = axisConfig.categories.category,
        isHorizontal = axisConfig.isVertical,

    // smartLabel = chart.linkedItems.smartLabel,
    // axisPlotLineContainerTop = axisConfig.axisPlotLineContainerTop,
    // axisPlotLineContainer = axisConfig.axisPlotLineContainer,
    // vlineLabelContainer = axisConfig.vlineLabelContainer,
    // isRelativeAxisInverse = axisConfig.isRelativeAxisInverse,
    divlineStyle = {
      fontFamily: chartConfig.style.inCanfontFamily,
      fontSize: chartConfig.style.inCanfontSize,
      color: chartConfig.style.inCancolor,
      lineHeight: chartConfig.style.inCanLineHeight
    },

    // categoryVline = axis.components.categoryVline || (axis.components.categoryVline = []),
    // categoryVlineLabel = axis.components.categoryVlineLabel || (axis.components.categoryVlineLabel = []),
    // elementRecycle = axis.categoryvLineER || (axis.categoryvLineER = new ElementRecycle()),
    infoObj = {
      marker: {},
      label: {}
    },

    // counter = 0,
    // labelCounter = 0,
    // animElems = [],
    // axisAttrObjPreFn,
    vlines,
        len,
        vline,
        label,
        i,
        showLabelBorder,

    // showLabelBackground,
    labelHAlign,
        labelVAlign,
        labelPosition,
        linePosition,
        showVLines,
        alpha,
        color,
        bgColor,
        thickness,
        isDashed,
        dashLen,
        fontSizeInt,
        dashGap,

    // vLineContainer,
    vLineDrawingAttrObj,
        css,
        vLineTextAttrObj,

    // vLineElement,
    // vLineLabelElement,
    labelColor,
        labelRotation,
        categoryStart,
        categoryEnd,
        categoryStartPos,
        posRelCategory,
        borderPadding,
        isExtreme,
        animationShift,
        finalValue,
        checkForLimit,
        getLimit,
        vlineStartIndex;
    // crispPath;

    if (axisConfig.isCategoryVlineAnimate && axisConfig.animateCategoriesVline) {
      vlines = axisConfig.animateCategoriesVline;
    } else {
      vlines = axisConfig.categories.vline;
    }
    len = vlines.length;
    // if not zoomed dont check for limit
    checkForLimit = axis._isZoomed();

    // elementRecycle.preProcessor();
    // axisAttrObjPreFn = function (attrs) {
    //   return function () {
    //     this.attr(attrs);
    //   };
    // };

    getLimit = this.getVisibleConfig();
    for (i = 0; i < len; i++) {
      vline = vlines[i];
      label = (0, _lib.parseUnsafeString)(vline.label);
      showLabelBorder = Boolean((0, _lib.pluckNumber)(vline.showlabelborder, axisConfig.showVLineLabelBorder, 1));
      // showLabelBackground = Boolean(pluckNumber(vline.showlabelbackground, 1));
      labelHAlign = (0, _lib.pluck)(vline.labelhalign, isHorizontal ? POSITION_START : POSITION_MIDDLE);
      if (labelHAlign === 'center') {
        labelHAlign = POSITION_MIDDLE;
      } else if (labelHAlign === 'left') {
        labelHAlign = POSITION_START;
      } else if (labelHAlign === 'right') {
        labelHAlign = POSITION_END;
      }
      labelVAlign = (0, _lib.pluck)(vline.labelvalign, isHorizontal ? POSITION_MIDDLE : POSITION_BOTTOM).toLowerCase();
      if (labelVAlign === POSITION_MIDDLE) {
        labelVAlign = 'center';
      } else if (labelVAlign === POSITION_TOP) {
        labelVAlign = POSITION_BOTTOM;
      } else if (labelVAlign === POSITION_BOTTOM) {
        labelVAlign = POSITION_TOP;
      }
      /** TODO: need to calculate in px, to set y */
      labelPosition = (0, _lib.pluckNumber)(vline.labelposition, 0);
      linePosition = (0, _lib.pluckNumber)(vline.lineposition, 0.5);
      showVLines = (0, _lib.pluckNumber)(vline.showvlines, axisConfig.showVLines, 1);
      alpha = (0, _lib.pluckNumber)(vline.alpha, axisConfig.vLineAlpha, 80);
      color = (0, _lib.pluck)(vline.color, axisConfig.vLineColor).replace(/^#?/, '#');
      // bgColor = showLabelBackground ? pluck(vline.labelbgcolor, axisConfig.vLineLabelBgColor,
      //   '333333').replace(/^#?/, '#') :  BLANKSTRING;
      labelColor = (0, _lib.pluck)(vline.labelcolor, axisConfig.vLineLabelColor, vline.color, chartStyle.inCancolor, axisConfig.vLineColor).replace(/^#?/, '#');
      thickness = (0, _lib.pluckNumber)(vline.thickness, axisConfig.vLineThickness, 1);
      borderPadding = 2;
      isDashed = Boolean(Number((0, _lib.pluck)(vline.dashed, 0)));
      dashLen = (0, _lib.pluckNumber)(vline.dashlen, 5);
      dashGap = (0, _lib.pluckNumber)(vline.dashgap, 2);
      fontSizeInt = divlineStyle.fontSize;
      fontSizeInt = parseInt(fontSizeInt.replace(/px/i, ''), 10);
      labelRotation = (0, _lib.pluckNumber)(vline.rotatelabel, axisConfig.rotateVLineLabels) ? 270 : 0;

      linePosition = linePosition < 0 || linePosition > 1 ? 0.5 : linePosition;
      labelPosition = labelPosition < 0 || labelPosition > 1 ? 0 : labelPosition;
      // smartLabel.useEllipsesOnOverflow(chartConfig.useEllipsesWhenOverflow);
      // smartLabel.setStyle(divlineStyle);

      color = convertColor(color, showVLines ? alpha : '0');

      // if (Number(vline.showontop) === 1 || axisConfig.showVLinesOnTop === 1) {
      //   vLineContainer = axisPlotLineContainerTop;
      // } else {
      //   vLineContainer = axisPlotLineContainer;
      // }

      isExtreme = false;
      // For realtime charts if animation is there in vline drawing
      vlineStartIndex = vline.animate && !isHorizontal ? vline.startIndex + 1 : vline.startIndex;
      categoryStart = category[vlineStartIndex];
      categoryEnd = category[vlineStartIndex + 1];
      // invalid vline or vline at the end
      if (!categoryStart) {
        categoryStartPos = category[0] && category[0].x ? min : -1;
        isExtreme = true;
      } else if (!categoryEnd) {
        categoryStartPos = category[0] && category[0].x ? max : axisConfig.oriCatLen;
        isExtreme = true;
      }
      if (!isExtreme) {
        categoryStartPos = (0, _lib.pluckNumber)(categoryStart.x, categoryStart.y, vlineStartIndex);
        posRelCategory = (categoryStartPos - (0, _lib.pluckNumber)(categoryEnd.x, categoryEnd.y, vlineStartIndex + 1)) * linePosition;
      } else {
        posRelCategory = linePosition;
      }
      finalValue = categoryStartPos + mathAbs(posRelCategory);
      // if value is not between the visual limit increment it and continue
      if (checkForLimit && (finalValue < getLimit.minValue || finalValue > getLimit.maxValue)) {
        continue;
      }
      if (!vline.animate && (finalValue < min || finalValue > max) || vline.animate && (finalValue < min || finalValue > max + animationShift)) {
        continue;
      }
      // posRelCategory = axis.getPixel(finalValue, { wrtVisible: true });

      vLineDrawingAttrObj = {
        opacity: 1,
        stroke: color,
        'stroke-width': thickness,
        'stroke-dasharray': isDashed ? (0, _lib.getDashStyle)(dashLen, dashGap) : DASH_DEF
      };
      vLineTextAttrObj = {
        opacity: 1,
        'text': label,
        'text-anchor': labelHAlign,
        'vertical-align': labelVAlign,
        'text-bound': []
      };
      css = {
        fill: showVLines ? labelColor : color,
        fontSize: divlineStyle.fontSize,
        fontFamily: divlineStyle.fontFamily,
        lineHeight: divlineStyle.lineHeight,
        backgroundColor: bgColor
      };

      // if (isHorizontal) {
      // crispPath = getCrispPath([M, canvasLeft, posRelCategory,
      //   L, canvasRight, posRelCategory], thickness);
      // vLineDrawingAttrObj.path = crispPath.path;
      // vLineTextAttrObj.x = canvasLeft + canvasWidth * (isRelativeAxisInverse ? 1 - labelPosition :
      //                       labelPosition);
      // vLineTextAttrObj.y = posRelCategory;
      // } else {
      // crispPath = getCrispPath([M, posRelCategory, canvasTop,
      //   L, posRelCategory, canvasBottom], thickness);
      // vLineDrawingAttrObj.path = crispPath.path;
      // vLineTextAttrObj.x = posRelCategory;
      // vLineTextAttrObj.y = canvasTop + canvasHeight * (isRelativeAxisInverse ? 1 - labelPosition :
      //                       labelPosition);
      // }
      // vLineDrawingAttrObj['shape-rendering'] = crispPath.isCrisped ? CRISP : UNDEF;
      // if (labelHAlign == POSITION_START) {
      //   vLineTextAttrObj.x += borderPadding;
      // } else if (labelHAlign == POSITION_END) {
      //   vLineTextAttrObj.x -= borderPadding;
      // }
      // if (labelVAlign == POSITION_TOP) {
      //   vLineTextAttrObj.Y += borderPadding;
      // } else if (labelVAlign == POSITION_BOTTOM) {
      //   vLineTextAttrObj.Y -= borderPadding;
      // }
      // vLineElement = elementRecycle.getElementIfExist('path', counter);
      // if (vLineElement) {
      //   vLineElement = vLineElement.elem;
      // } else {
      //   vLineElement = paper.path(vLineContainer);
      //   elementRecycle.insertElement('path', counter, vLineElement);
      // }
      // vLineContainer.appendChild(vLineElement);
      // animElems.push({
      //   el: vLineElement,
      //   attrs: {opacity: 0},
      //   animType: 'linear',
      //   animConfig: [{
      //     syncWith: 'initial',
      //     start: 0,
      //     end: 1
      //   }]
      // });

      infoObj.marker = {
        opacity: vLineDrawingAttrObj.opacity,
        stroke: vLineDrawingAttrObj.stroke,
        'stroke-dasharray': vLineDrawingAttrObj['stroke-dasharray'],
        'stroke-width': vLineDrawingAttrObj['stroke-width'],
        position: linePosition,
        value: finalValue,
        showOnTop: Number(vline.showontop) === 1 || axisConfig.showVLinesOnTop === 1
      };

      // animElems.push({
      //   el: vLineElement,
      //   attrs: extend2({}, vLineDrawingAttrObj),
      //   animType: 'linear',
      //   animConfig: [{
      //     hookFn: axisAttrObjPreFn({
      //       path: vLineDrawingAttrObj.path
      //     }),
      //     syncWith: 'final',
      //     start: 0,
      //     end: 1
      //   }]
      // });

      if (label) {
        // vLineLabelElement = elementRecycle.getElementIfExist('text', labelCounter);
        // if (vLineLabelElement) {
        //   vLineLabelElement = vLineLabelElement.elem;
        // } else {
        //   vLineLabelElement = paper.text(vlineLabelContainer);
        // elementRecycle.insertElement('text', labelCounter, vLineLabelElement);
        // }
        // vLineLabelElement.css(css);
        // vLineTextAttrObj.transform = paper.getSuggestiveRotation(labelRotation,
        //                           vLineTextAttrObj.x, vLineTextAttrObj.y);
        vLineTextAttrObj['text-bound'] = [bgColor, showVLines && showLabelBorder ? color : _lib.BLANKSTRING, showVLines && showLabelBorder ? 1 : 0, borderPadding, UNDEF, showVLines && showLabelBorder ? 'solid' : _lib.BLANKSTRING];

        // animElems.push({
        //   el: vLineLabelElement,
        //   attrs: {opacity: 0, 'text-bound': []},
        //   animType: 'linear',
        //   animConfig: [{
        //     syncWith: 'initial',
        //     start: 0,
        //     end: 1
        //   }]
        // });

        infoObj.label = {
          value: label,
          opacity: vLineTextAttrObj.opacity,
          rotation: labelRotation,
          position: labelPosition,
          'text-anchor': vLineTextAttrObj['text-anchor'],
          'vertical-align': vLineTextAttrObj['vertical-align'],
          'text-bound': vLineTextAttrObj['text-bound'],
          css: css
        };

        // animElems.push({
        //   el: vLineLabelElement,
        //   attrs: extend2({opacity: 1}, vLineTextAttrObj),
        //   animType: 'linear',
        //   animConfig: [{
        //     hookFn: axisAttrObjPreFn({
        //       x: vLineTextAttrObj.x,
        //       y: vLineTextAttrObj.y
        //     }),
        //     syncWith: 'final',
        //     start: 0,
        //     end: 1
        //   }]
        // });
        // labelCounter++;
        // categoryVlineLabel[labelCounter] = vLineLabelElement;
      }
      // categoryVline[counter] = vLineElement;

      axis.addComponentInfo('catVLine', infoObj);

      // counter++;
    }
    // elementRecycle.postProcessor(function (el) {
    //   animElems.push({
    //     el: el,
    //     attrs: {
    //       'opacity': 0,
    //       'text-bound': []
    //     },
    //     animType: 'linear',
    //     animConfig: [{
    //       syncWith: 'initial',
    //       start: 0,
    //       end: 1
    //     }]
    //   });
    // });
    // axis._registerVerticalAxisAnims(animElems);
  };
  /**
   * Function is called internally by the axis class draw function to draw the category axis plot lines
   */


  CartesianAxis.prototype._drawCategoryPlotLine = function _drawCategoryPlotLine() {
    var axis = this,
        axisConfig = axis.config,
        axisRange = axisConfig.axisRange,
        max = axisRange.max,
        min = axisRange.min,

    // chart = axis.getFromEnv('chart'),
    // chartComponents = chart.components,
    category = axisConfig.categories.category,
        len = category.length,

    // axisPlotLineContainerBottom = axisConfig.axisPlotLineContainer,
    // paper = chartComponents.paper,
    plotLine = axis.getGraphicalElement('line'),

    // elementRecycle = axis.numericPlotLineER || (axis.numericPlotLineER = new ElementRecycle()),
    counter = 0,
        plotLineColor = convertColor(axisConfig.divLineColor, axisConfig.divLineAlpha),
        plotLineWidth = axisConfig.divLineThickness,
        plotLineDashStyle = axisConfig.divLineIsDashed ? (0, _lib.getDashStyle)(axisConfig.divLineDashLen, axisConfig.divLineDashGap) : DASH_DEF,

    // animElems = [],
    increment,

    // lineElement,
    getLimit,
        axisAttrObj,

    // axisAttrObjPre,
    loopMin,
        loopMax,
        i,
        ln,
        value,

    // axisPlotLineContainer,
    intervalArr = [];
    // intervalArrStr = [];

    axisAttrObj = {
      stroke: plotLineColor,
      'stroke-width': plotLineWidth,
      'stroke-dasharray': plotLineDashStyle,
      opacity: 1
    };
    // checking for pure category axis exclude bubble scatter
    if (category[0] && (category[0].x !== UNDEF || category[0].y !== UNDEF)) {
      // hiding the extra elements for later use
      if (plotLine && plotLine[counter] && axisConfig.xAxisLabelMode === 'categories') {
        for (i = counter; i < plotLine.length; i++) {
          plotLine[i].attr({
            opacity: 0
          });
        }
      }
      return;
    }
    // elementRecycle.preProcessor();
    // checking if lines are to be drawn user can decide
    if (axisConfig.lines.isDraw && axisConfig.categoryNumDivLines) {
      if (axisConfig.categoryDivLinesFromZero) {
        min = 0;
        max = len - 1;
      }
      increment = mathAbs(max - min) / (axisConfig.categoryNumDivLines + 1);
      increment = increment === 0 ? 1 : increment; // check for infinite loop
      // intelligently calculate the loop max and loop min from the visual active dataset
      // get the visible configuration means the value between the dataset is visible
      getLimit = this.getVisibleConfig();
      // calculate the loopMin loopMax with padding of three increment units in pixel
      loopMin = min + increment * mathFloor((getLimit.minValue - increment * 3 - min) / increment);
      loopMax = min + increment * mathFloor((getLimit.maxValue + increment * 3 - min) / increment);
      // if the loopMin or loopMax cross the min and max limit of data then adjust it
      loopMin = loopMin < min ? min : loopMin;
      loopMax = loopMax > max ? max : loopMax;

      loopMin += increment;
      loopMax -= increment;

      // axisPlotLineContainer = axisPlotLineContainerBottom;

      for (i = loopMin; i <= loopMax; i += increment) {
        if (axisConfig.hasBreakPoints) {
          value = axis._getRealBreakValue(i);
        } else {
          value = i;
        }
        intervalArr.push(value);
        // intervalArrStr[i] = '' + value;
      }
      // This will help to manage which element are to be kept for later use
      // elementRecycle.insertReserveElement('line', intervalArrStr);

      for (i = 0, ln = intervalArr.length; i < ln; i += 1) {
        value = intervalArr[i];
        // axis._calculatePath(axisAttrObj, value, plotLineWidth);

        // axisAttrObjPre = extend2({}, axisAttrObj);
        // axisAttrObjPre.opacity = 0;
        // if (axis.savedAxis) {
        //   axis._calculatePath(axisAttrObjPre, value, plotLineWidth, {preValue: true});
        // }
        // lineElement = elementRecycle.getElementIfExist('line', intervalArr[i]);
        // if (lineElement) {
        //   if (!lineElement.isOtherElem) {
        //     axisAttrObjPre = UNDEF;
        //   }
        //   lineElement = lineElement.elem;
        //   axisPlotLineContainer.appendChild(lineElement);
        // } else {
        // lineElement = paper.path(axisPlotLineContainer);
        // // First time creation the element create at 0,0
        // !axisAttrObjPre && (axisAttrObjPre = extend2({}, axisAttrObj));
        // // elementRecycle.insertElement('line', intervalArr[i], lineElement);
        // }
        // plotLine[i] = lineElement;

        axis.addComponentInfo('line', {
          value: value,
          stroke: axisAttrObj.stroke,
          'stroke-width': axisAttrObj['stroke-width'],
          'stroke-dasharray': axisAttrObj['stroke-dasharray'],
          opacity: 1
        });

        // animElems.push({
        //   el: lineElement,
        //   preAttrs: extend2({}, axisAttrObjPre),
        //   attrs: extend2({}, axisAttrObj),
        //   animType: 'linear',
        //   animConfig: [{
        //     start: 0,
        //     end: 1
        //   }]
        // });
      }
      // elementRecycle.processOldElem('line', function (key, elem) {
      //   animElems.push({
      //     el: elem,
      //     attrs: axis._calculatePath({'opacity': 0}, key, plotLineWidth),
      //     animType: 'linear',
      //     animConfig: [{
      //       start: 0,
      //       end: 1
      //     }]
      //   });
      // });
    }
    // elementRecycle.postProcessor(function (el) {
    //   animElems.push({
    //     el: el,
    //     attrs: {
    //       'opacity': 0
    //     },
    //     animType: 'linear',
    //     animConfig: [{
    //       start: 0,
    //       end: 1
    //     }]
    //   });
    // });
    // axis._registerHorizontalAxisAnims(animElems);
  };
  /**
   * Function is called internally by the axis class draw function to draw the axis plot bands
   */


  CartesianAxis.prototype._drawCategoryPlotBand = function _drawCategoryPlotBand() {
    var axis = this,
        axisConfig = axis.config,
        axisRange = axisConfig.axisRange,
        max = axisRange.max,
        min = axisRange.min,

    // canvas = axisConfig.canvas,
    // chart = axis.getFromEnv('chart'),
    // chartConfig = chart.config,
    // chartComponents = chart.components,
    category = axisConfig.categories.category,
        len = category.length,

    // canvasLeft = canvas.canvasLeft || chartConfig.canvasLeft,
    // canvasRight = canvas.canvasRight || chartConfig.canvasRight,
    // canvasTop = canvas.canvasTop || chartConfig.canvasTop,
    // canvasHeight = canvas.canvasHeight || chartConfig.canvasHeight,
    // canvasWidth = canvas.canvasWidth || chartConfig.canvasWidth,
    // isVertical = axisConfig.isVertical,
    // axisBandContainer = axisConfig.axisBandContainer,
    // paper = chartComponents.paper,
    // axisBand = axis.graphics.band || (axis.graphics.band = []),
    // elementRecycle = axis.catPlotBandER || (axis.catPlotBandER = new ElementRecycle()),
    showAlternateGridColor = axisConfig.showAlternateGridColor,
        alternateGridColor = axisConfig.alternateGridColor,
        alternateGridAlpha = axisConfig.alternateGridAlpha,
        categoryDivLinesFromZero = axisConfig.categoryDivLinesFromZero,

    // animElems = [],
    // axisAttrObjPreFn,
    increment,
        axisAttrObj,
        getLimit,
        colorDetector,
        loopMin,
        loopMax,
        i;
    // bandWidth,
    // pvr,
    // bandElement;

    // checking for pure category axis exclude bubble scatter
    if (category[0] && (category[0].x !== UNDEF || category[0].y !== UNDEF)) {
      // hiding the extra elements for later use
      // elementRecycle.preProcessor();
      // elementRecycle.postProcessor(function (el) {
      //   el.attr({
      //     opacity: 0
      //   });
      // });
      return;
    }
    // elementRecycle.preProcessor();
    // axisAttrObjPreFn = function (attrs) {
    //   return function () {
    //     this.attr(attrs);
    //   };
    // };
    // checking if lines are to be drawn user can decide
    if (showAlternateGridColor && axisConfig.band.isDraw && axisConfig.categoryNumDivLines) {
      if (categoryDivLinesFromZero) {
        min = 0;
        max = len - 1;
      }
      increment = mathAbs(max - min) / (axisConfig.categoryNumDivLines + 1);
      increment = increment === 0 ? 1 : increment; // check for infinite loop
      // intelligently calculate the loop max and loop min from the visual active dataset
      // get the visible configuration means the value between the dataset is visible
      getLimit = axis.getVisibleConfig();
      // calculate the loopMin loopMax with padding of three increment units in pixel
      loopMin = min + increment * mathFloor((getLimit.minValue - increment * 3 - min) / increment);
      loopMax = min + increment * mathFloor((getLimit.maxValue + increment * 3 - min) / increment);
      // if the loopMin or loopMax cross the min and max limit of data then adjust it
      loopMin = loopMin < min ? min : loopMin;
      loopMax = loopMax > max ? max : loopMax;
      // alternate band color is decided by this variable
      colorDetector = mathRound((loopMin - min) / increment);
      loopMin += increment;
      // loopMax -= increment;

      // common attributes
      axisAttrObj = {
        fill: (0, _lib.toRaphaelColor)(convertColor(alternateGridColor, alternateGridAlpha)),
        'stroke-width': 0
      };
      // pixel to value ratio
      // pvr = axis.pvr;

      for (i = loopMin; i - increment < loopMax; colorDetector += 1, i += increment) {
        // if this should be colored band or not
        if (colorDetector % 2 !== 0) {
          continue;
        }
        // calculate the band width
        // if (i === loopMin) {
        // without the padding there is a gap before the starting plotband
        // bandWidth = increment + mathAbs(axis.getValue(0)) + 1;
        // } else if (i === loopMax) {
        //   bandWidth = increment + mathAbs(axis.getValue(canvasRight - canvasLeft) - max);
        // } else {
        //   bandWidth = increment;
        // }

        // attached attributes
        // if (isVertical) {
        // y-axis
        // axisAttrObj.x = canvasLeft;
        // axisAttrObj.y = i === loopMax ? axis.getPixel(i - mathAbs(increment),
        //     { wrtVisible: true }) :
        //   axis.getPixel(i - mathAbs(bandWidth),
        //     { wrtVisible: true });
        // axisAttrObj.width = canvasWidth;
        // axisAttrObj.height = mathAbs(bandWidth * pvr);
        // } else {
        // x-axis
        // axisAttrObj.x = i === loopMax ? axis.getPixel(i - mathAbs(increment),
        //     { wrtVisible: true }) :
        //   axis.getPixel(i - mathAbs(bandWidth),
        //     { wrtVisible: true });
        // axisAttrObj.y = canvasTop;
        // axisAttrObj.width = mathAbs(bandWidth * pvr);
        // axisAttrObj.height = canvasHeight;
        // }
        // bandElement = elementRecycle.getElementIfExist('rect', i);
        // if (bandElement) {
        //   bandElement = bandElement.elem;
        // } else {
        //   bandElement = paper.rect(axisBandContainer);
        //   elementRecycle.insertElement('rect', i, bandElement);
        // }

        // animElems.push({
        //   el: bandElement,
        //   attrs: {opacity: 0},
        //   animType: 'linear',
        //   animConfig: [{
        //     syncWith: 'initial',
        //     start: 0,
        //     end: 1
        //   }]
        // });

        axis.addComponentInfo('catBand', {
          categoryIncrement: increment,
          fill: axisAttrObj.fill,
          'stroke-width': axisAttrObj['stroke-width'],
          loopMin: loopMin,
          loopMax: loopMax,
          i: i,
          min: min,
          max: max
        });

        // animElems.push({
        //   el: bandElement,
        //   attrs: extend2({opacity: 1}, axisAttrObj),
        //   animType: 'linear',
        //   animConfig: [{
        //     hookFn: axisAttrObjPreFn({
        //       x: axisAttrObj.x,
        //       y: axisAttrObj.y,
        //       width: axisAttrObj.width,
        //       height: axisAttrObj.height
        //     }),
        //     syncWith: 'final',
        //     start: 0,
        //     end: 1
        //   }]
        // });
        // axisBand[i] = bandElement;
      }
    }
    // elementRecycle.postProcessor(function (el) {
    //   animElems.push({
    //     el: el,
    //     attrs: {
    //       'opacity': 0
    //     },
    //     animType: 'linear',
    //     animConfig: [{
    //       syncWith: 'initial',
    //       start: 0,
    //       end: 1
    //     }]
    //   });
    // });
    // axis._registerHorizontalAxisAnims(animElems);
  };

  /**
   * Clears the calculated parameters of all components
   */


  CartesianAxis.prototype.clearComponentInfo = function clearComponentInfo() {
    var componentInfo = this.getFromEnv('componentInfo'),
        key;

    for (key in componentInfo) {
      if (componentInfo.hasOwnProperty(key)) {
        componentInfo[key] = [];
      }
    }
  };
  /**
   * The function is called whenever there is need to draw the axis or update the axis
   * NOTE : before calling the function placeAxis must be called to manage the space
   */


  CartesianAxis.prototype.draw = function draw() {
    var axis = this,
        axisConfig = axis.config,
        canvas = axisConfig.canvas,
        chart = axis.getFromEnv('chart'),
        chartConfig = chart.config,
        isVertical = axisConfig.isVertical,
        paper = axis.getFromEnv('paper'),
        viewPortConfig = chartConfig.viewPortConfig,
        limitUpdaters = axis.getChildren().limitUpdater,
        viewPortRatio = axisConfig.viewPortRatio || {},
        canvasLeft = canvas.canvasLeft || chartConfig.canvasLeft,
        canvasTop = canvas.canvasTop || chartConfig.canvasTop,
        canvasWidth = canvas.canvasWidth || chartConfig.canvasWidth,
        canvasHeight = canvas.canvasHeight || chartConfig.canvasHeight,

    // axisDimension = axisConfig.axisDimention || {},
    // axisLength = axisDimension.axisLength,
    axisContainer = axisConfig.axisContainer,
        axisLabelContainerTop = axisConfig.axisLabelContainerTop,
        axisPlotLineContainer = axisConfig.axisPlotLineContainer,
        axisPlotLineContainerTop = axisConfig.axisPlotLineContainerTop,
        vlineLabelContainer = axisConfig.vlineLabelContainer,
        axisBandContainer = axisConfig.axisBandContainer,
        axisNameContainer = axisConfig.axisNameContainer,
        axisTrendContainerTop = axisConfig.axisTrendContainerTop,
        axisTrendContainerBottom = axisConfig.axisTrendContainerBottom,
        axisTrendLabelContainer = axisConfig.axisTrendLabelContainer,
        axisAxisLineContainer = axisConfig.axisAxisLineContainer,
        axisAxisLineContainerBottom = axisConfig.axisAxisLineContainerBottom,
        plotLineWidth = axisConfig.divLineThickness || 0,
        childContainers = chart.getChildContainer(),
        axisBottom = childContainers.axisBottomGroup,
        axisTop = childContainers.axisTopGroup,

    // axisZoom = axis.getZoomScale(),
    // apparentScrollPos = axisConfig.apparentScrollPos,
    // animateAxis = axisConfig.animateAxis,
    animElems = [],

    // animationDuration,
    // transposeAnimDuration,
    axisBandGroup,
        axisPlotLineGroup,
        axisPlotLineGroupTop,
        axisLineGroup,
        axisNameGroup,
        axisLabelGroup,
        axisLabelGroupTop,
        axisTrendGroupTop,
        axisTrendGroupBottom,
        dx,
        dy,
        originY,
        originX,

    // animObj,
    // dummyObj,
    plotLineClipRect;

    axis.clearComponentInfo();
    // axis._setActualScrollPos(_calculateScrollPosition(apparentScrollPos, axisZoom, axisLength));
    // axis.referencePoints = axis._getReferencePoints();

    originY = viewPortConfig.y * viewPortConfig.scaleY;
    originX = viewPortConfig.x * viewPortConfig.scaleX;

    // animationDuration = chart.get('config', 'animationObj');
    // animObj = animationDuration.animObj;
    // dummyObj = animationDuration.dummyObj;
    // transposeAnimDuration = animationDuration.transposeAnimDuration;

    if (isVertical) {
      plotLineClipRect = canvasLeft + ',' + (canvasTop - plotLineWidth) + ',' + canvasWidth + ',' + (canvasHeight + plotLineWidth * 2);
    } else {
      plotLineClipRect = canvasLeft - plotLineWidth + ',' + canvasTop + ',' + (canvasWidth + plotLineWidth * 2) + ',' + canvasHeight;
    }

    // creating the axis elements group unique throughout the charts
    // axisBandGroup holding the axisBandContainer
    axisBandGroup = axis.getContainer('axisBandGroup') || axis.addContainer('axisBandGroup', paper.group('dataset-Band-group', axisBottom));
    // axisPlotLineGroup holding the axisplotLineContainer
    axisPlotLineGroup = axis.getContainer('axisPlotLineGroup') || axis.addContainer('axisPlotLineGroup', paper.group('dataset-Line-group', axisBottom));
    // axisTrendGroupBottom hold trendContainer below the dataset
    axisTrendGroupBottom = axis.getContainer('axisTrendGroupBottom') || axis.addContainer('axisTrendGroupBottom', paper.group('dataset-Trend-group-bottom', axisBottom));
    axisPlotLineGroupTop = axis.getContainer('axisPlotLineGroupTop') || axis.addContainer('axisPlotLineGroupTop', paper.group('dataset-Line-group-top', axisTop));
    // axisNameGroup hold the name container
    axisNameGroup = axis.getContainer('axisNameGroup') || axis.addContainer('axisNameGroup', paper.group('dataset-Name-group', axisBottom));
    // axisLineGroup hold the axis line  element
    axisLineGroup = axis.getContainer('axisLineGroup') || axis.addContainer('axisLineGroup', paper.group('axis-Line-group', axisTop));
    // axisTrendGroupTop hold trendContainer top of the dataset
    axisTrendGroupTop = axis.getContainer('axisTrendGroupTop') || axis.addContainer('axisTrendGroupTop', paper.group('dataset-Trend-group-top', axisTop));
    // axisLabelGroup hold the label container
    axisLabelGroup = axis.getContainer('axisLabelGroup') || axis.addContainer('axisLabelGroup', paper.group('dataset-Label-group', axisBottom));
    // axisLabelGroup hold the label container
    axisLabelGroupTop = axis.getContainer('axisLabelGroupTop') || axis.addContainer('axisLabelGroupTop', paper.group('dataset-Label-group', axisTop));

    // creating the container group for every axis there will be
    // note : if new container added add it to hide and show
    if (!axisContainer) {
      // contains all the axis label
      axisConfig.axisContainer = axisContainer = paper.group('dataset-axis', axisLabelGroup);
    }
    if (!axisLabelContainerTop) {
      axisConfig.axisLabelContainerTop = axisLabelContainerTop = paper.group('dataset-top-label', axisLabelGroupTop);
    }
    if (!axisAxisLineContainer) {
      axisConfig.axisAxisLineContainer = axisAxisLineContainer = paper.group('axis-line-tick', axisLineGroup);
    }
    if (!vlineLabelContainer) {
      axisConfig.vlineLabelContainer = vlineLabelContainer = paper.group('axis-vline-label', axisLineGroup);
    }
    if (!axisBandContainer) {
      // contain axis band
      axisConfig.axisBandContainer = axisBandContainer = paper.group('dataset-axis-bands', axisBandGroup);
      axisBandContainer.attr({
        'clip-rect': canvasLeft + ',' + canvasTop + ',' + canvasWidth + ',' + canvasHeight
      });
    } else {
      // clip the container according to canvas width and height
      // if (transposeAnimDuration && animateAxis) {
      //     axisBandContainer.animateWith(dummyObj, animObj,{
      //         'clip-rect': canvasLeft+','+canvasTop+','+canvasWidth+
      //         ','+canvasHeight
      //     }, transposeAnimDuration, animationDuration.animType);
      // } else {
      //     axisBandContainer.attr({
      //         'clip-rect': canvasLeft+','+canvasTop+','+canvasWidth+
      //         ','+canvasHeight
      //     });
      // }
      animElems.push({
        el: axisBandContainer,
        attrs: {
          'clip-rect': canvasLeft + ',' + canvasTop + ',' + canvasWidth + ',' + canvasHeight
        },
        animType: 'linear',
        animConfig: [{
          syncWith: 'initial',
          start: 0,
          initial: 1
        }]
      });
    }
    if (!axisPlotLineContainer) {
      // contain all plot lines
      axisConfig.axisPlotLineContainer = axisPlotLineContainer = paper.group('dataset-axis-lines', axisPlotLineGroup);
      // clip the container according to canvas width and height
      axisPlotLineContainer.attr({
        'clip-rect': plotLineClipRect
      });
    } else {
      // clip the container according to canvas width and height
      // if (transposeAnimDuration && animateAxis) {
      //     axisPlotLineContainer.animateWith(dummyObj, animObj,{
      //         'clip-rect': plotLineClipRect
      //     }, transposeAnimDuration, animationDuration.animType);
      // } else {
      //     axisPlotLineContainer.attr({
      //         'clip-rect': plotLineClipRect
      //     });
      // }
      animElems.push({
        el: axisPlotLineContainer,
        attrs: {
          'clip-rect': plotLineClipRect
        },
        animType: 'linear',
        animConfig: [{
          syncWith: 'initial',
          start: 0,
          initial: 1
        }]
      });
    }
    if (!axisPlotLineContainerTop) {
      // contain all plot lines
      axisConfig.axisPlotLineContainerTop = axisPlotLineContainerTop = paper.group('dataset-axis-lines-top', axisPlotLineGroupTop);
      // clip the container according to canvas width and height
      axisPlotLineContainerTop.attr({
        'clip-rect': plotLineClipRect
      });
    } else {
      // clip the container according to canvas width and height
      // if (transposeAnimDuration && animateAxis) {
      //     axisPlotLineContainerTop.animateWith(dummyObj, animObj,{
      //         'clip-rect': plotLineClipRect
      //     }, transposeAnimDuration, animationDuration.animType);
      // } else {
      //     axisPlotLineContainerTop.attr({
      //         'clip-rect': plotLineClipRect
      //     });
      // }
      animElems.push({
        el: axisPlotLineContainerTop,
        attrs: {
          'clip-rect': plotLineClipRect
        },
        animType: 'linear',
        animConfig: [{
          syncWith: 'initial',
          start: 0,
          initial: 1
        }]
      });
    }
    if (!axisTrendContainerTop) {
      // contain trend elements on top of data
      axisConfig.axisTrendContainerTop = axisTrendContainerTop = paper.group('dataset-axis-trend-top', axisTrendGroupTop);
      // clip the container according to canvas width and height
      axisTrendContainerTop.attr({
        'clip-rect': canvasLeft + ',' + canvasTop + ',' + canvasWidth + ',' + canvasHeight
      });
    } else {
      // if (transposeAnimDuration && animateAxis) {
      //     axisTrendContainerTop.animateWith(dummyObj, animObj,{
      //         'clip-rect': canvasLeft+','+canvasTop+','+canvasWidth+
      //         ','+canvasHeight
      //     }, transposeAnimDuration, animationDuration.animType);
      // } else {
      //     axisTrendContainerTop.attr({
      //         'clip-rect': canvasLeft+','+canvasTop+','+canvasWidth+
      //         ','+canvasHeight
      //     });
      // }
      animElems.push({
        el: axisTrendContainerTop,
        attrs: {
          'clip-rect': canvasLeft + ',' + canvasTop + ',' + canvasWidth + ',' + canvasHeight
        },
        animType: 'linear',
        animConfig: [{
          syncWith: 'initial',
          start: 0,
          initial: 1
        }]
      });
    }
    if (!axisTrendContainerBottom) {
      // contain trend elements on bottom of data
      axisConfig.axisTrendContainerBottom = axisTrendContainerBottom = paper.group('dataset-axis-trend-bottom', axisTrendGroupBottom);
      // clip the container according to canvas width and height
      axisTrendContainerBottom.attr({
        'clip-rect': canvasLeft + ',' + canvasTop + ',' + canvasWidth + ',' + canvasHeight
      });
    } else {
      // clip the container according to canvas width and height
      // if (transposeAnimDuration && animateAxis) {
      //     axisTrendContainerBottom.animateWith(dummyObj, animObj,{
      //         'clip-rect': canvasLeft+','+canvasTop+','+canvasWidth+
      //         ','+canvasHeight
      //     }, transposeAnimDuration, animationDuration.animType);
      // } else {
      //     axisTrendContainerBottom.attr({
      //         'clip-rect': canvasLeft+','+canvasTop+','+canvasWidth+
      //         ','+canvasHeight
      //     });
      // }
      animElems.push({
        el: axisTrendContainerBottom,
        attrs: {
          'clip-rect': canvasLeft + ',' + canvasTop + ',' + canvasWidth + ',' + canvasHeight
        },
        animType: 'linear',
        animConfig: [{
          syncWith: 'initial',
          start: 0,
          initial: 1
        }]
      });
    }
    if (!axisTrendLabelContainer) {
      // contain trend label elements
      axisConfig.axisTrendLabelContainer = axisTrendLabelContainer = paper.group('dataset-axis-trend-label', axisTrendGroupTop);
    }
    if (!axisNameContainer) {
      // contain the axis name
      axisConfig.axisNameContainer = axisNameContainer = paper.group('dataset-axis-name', axisNameGroup);
    }
    if (!axisAxisLineContainerBottom) {
      axisConfig.axisAxisLineContainerBottom = axisAxisLineContainerBottom = paper.group('axis-line-tick-bottom', axisBottom);
    }

    // On zoom condition
    if (viewPortRatio.scaleX !== viewPortConfig.scaleX || viewPortRatio.scaleY !== viewPortConfig.scaleY) {
      viewPortRatio.scaleX = viewPortConfig.scaleX;
      viewPortRatio.scaleY = viewPortConfig.scaleY;

      axis._drawComponents();
    } else {
      // On pan condition
      // while panning no need to clip only transform accordingly
      if (isVertical) {
        // dy is the amount of the dataset transform vertically
        dy = originY - viewPortConfig.y * viewPortConfig.scaleY;
        vlineLabelContainer.transform('t0,' + dy);
        axisContainer.transform('t0,' + dy);
        axisLabelContainerTop.transform('t0,' + dy);
        axisPlotLineContainer.transform('t0,' + dy);
        axisPlotLineContainerTop.transform('t0,' + dy);
        axisBandContainer.transform('t0,' + dy);
        axisTrendContainerTop.transform('t0,' + dy);
        axisTrendContainerBottom.transform('t0,' + dy);
      } else {
        // dx is the amount of the dataset transform horizontally
        dx = originX - viewPortConfig.x * viewPortConfig.scaleX;
        vlineLabelContainer.transform('t' + dx + ',0');
        axisContainer.transform('t' + dx + ',0');
        axisLabelContainerTop.transform('t' + dx + ',0');
        axisPlotLineContainer.transform('t' + dx + ',0');
        axisPlotLineContainerTop.transform('t' + dx + ',0');
        axisBandContainer.transform('t' + dx + ',0');
        axisTrendContainerTop.transform('t' + dx + ',0');
        axisTrendContainerBottom.transform('t' + dx + ',0');
      }
      // draw the axis elements
      axis._drawComponents();
      axis.translateRTGroups();
      axis._registerVerticalAxisAnims(animElems);
    }

    // limitUpdaters && limitUpdaters.forEach(limitUpdater => limitUpdater.onUpperLimitUpdate(e => {
    //   if (e.keyCode === 13 && Number(e.target.value)) {
    //     let min = this.getLimit().min;
    //
    //     this.setAxisConfig({
    //       axisMaxValue: e.target.value,
    //       axisMinValue: min,
    //       showUpperLimit: true
    //     });
    //     this.setDataLimit(e.target.value, min);
    //   }
    // }));

    (0, _eventApi.addListener)('internal.animationComplete', function () {
      limitUpdaters && limitUpdaters.forEach(function (limitUpdater) {
        limitUpdater.draw();
      });
    });

    axis.addToEnv('tempAxis', {
      canvasHeight: axis.config.canvas.canvasHeight,
      canvasWidth: axis.config.canvas.canvasWidth,
      canvasLeft: axis.config.canvas.canvasLeft,
      canvasRight: axis.config.canvas.canvasRight,
      canvasBottom: axis.config.canvas.canvasBottom,
      canvasTop: axis.config.canvas.canvasTop,

      visibleRange: axis.getVisibleConfig(),
      visibleLength: axis.getVisibleLength(),

      axisLength: axis.config.axisDimention.axisLength,
      axisOpposite: axis.config.axisDimention.opposite,
      axisY: axis.config.axisDimention.y,
      axisX: axis.config.axisDimention.x,

      axisRangeMin: axis.config.axisRange.min,
      axisRangeMax: axis.config.axisRange.max,
      axisTickInterval: axis.config.axisRange.tickInterval,

      axisIsReverse: axis.config.isReverse,
      axisIsVertical: axis.config.isVertical,
      axisHasBreakPoints: axis.config.hasBreakPoints,

      viewPortScaleY: axis.getFromEnv('chart').config.viewPortConfig.scaleY,
      viewPortY: axis.getFromEnv('chart').config.viewPortConfig.y,
      viewPortScaleX: axis.getFromEnv('chart').config.viewPortConfig.scaleX,
      viewPortX: axis.getFromEnv('chart').config.viewPortConfig.x,

      chartHeight: axis.getFromEnv('chart').config.canvasHeight,
      chartWidth: axis.getFromEnv('chart').config.canvasWidth,
      chartLeft: axis.getFromEnv('chart').config.canvasLeft,
      chartRight: axis.getFromEnv('chart').config.canvasRight,
      chartBottom: axis.getFromEnv('chart').config.canvasBottom,
      chartTop: axis.getFromEnv('chart').config.canvasTop,

      pvr: axis.config.pvr,
      refVal: axis.config.refVal,
      refVisibleVal: axis.config.refVisibleVal
    });
  };

  CartesianAxis.prototype.getBreakPoints = function getBreakPoints() {
    var axis = this,
        axisConfig = axis.config;

    if (axisConfig.hasBreakPoints) {
      return axisConfig.breakPoints;
    } else {
      return false;
    }
  };

  /**
   * Function define the canvas diameter if not axis will take it from the default chart canvas
   * @param {Object} data containing the axis dimentions
   */


  CartesianAxis.prototype.setCanvas = function setCanvas(data) {
    var axis = this,
        axisConfig = axis.config;

    axisConfig.canvas = data;
  };

  /**
   * Function to get the base position of the axis. Base required for plots like column, area etc.
   * @return {number} the base value
   */


  CartesianAxis.prototype.getAxisBase = function getAxisBase() {
    var axis = this,
        axisConfig = axis.config,
        max = axisConfig.axisRange.max,
        min = axisConfig.axisRange.min;
    // For inverse axis charts, columns should not be hanging from top when all data is positive
    return min < 0 && max > 0 ? 0 : max <= 0 ? max : min;
  };

  /**
   * Function returning values for respective pixel passed
   * @param {number} pixel the pixel value for which the (X or Y) value is required
   * @param {Object} options An object which indicates whether values should be w.r.t. the visible range
   * @return {number} Value for which the pixel is passed
   */


  CartesianAxis.prototype.getValue = function getValue(pixel, options) {
    var axis = this,
        axisConfig = axis.config,
        wrtVisible = options && options.wrtVisible,
        refVal = wrtVisible ? axisConfig.refVisibleVal : axisConfig.refVal,
        pvr = axis.config.pvr;

    return refVal + (pixel - axisConfig.refPx) / pvr;
  };

  /**
   * Returns the difference between the visible max value and the visible min value
   * @return {number} The visible range
   */


  CartesianAxis.prototype.getVisibleLength = function getVisibleLength() {
    var axis = this,
        limit = axis.getVisibleConfig();

    return mathAbs(limit.maxValue - limit.minValue);
  };

  /**
   * Function used to set the category of the axis if required and also act as the min max setter of the
   * axis having category
   * @param  {Array}   categories     An array of categories
   * @param  {boolean} isOnlyCategory Indicates if this is the only category
   */


  CartesianAxis.prototype.setCategory = function setCategory(categories, isOnlyCategory) {
    var axis = this,
        chart = axis.getFromEnv('chart'),
        cats = chart.jsonData.categories,
        catData = cats && cats[0] || {},
        axisConfig = axis.config,

    // axisRange = axisConfig.axisRange,
    len = categories && categories.length,
        startPad = axisConfig.startPad || 0,
        endPad = axisConfig.endPad || 0,
        countCat = 0,
        isOnlyCategoryBool = isOnlyCategory !== UNDEF ? isOnlyCategory : true,
        axisLimits,
        catIndex,
        catIdMap,
        index,
        category,
        vline,
        catX;

    // Set the category flag to true
    axisConfig.hasCategory = 1;

    // Initialize the category object
    axisConfig.categories = {};
    // this will store only the category not the vline
    category = axisConfig.categories.category = [];
    // this will store only the vline
    vline = axisConfig.categories.vline = [];
    // This array will map the category with the category id
    catIdMap = axisConfig.categories.catIdMap = {};

    axisConfig.isCategoryAnimate = false;
    axisConfig.isCategoryVlineAnimate = false;

    /**
     * Extracts the style information of a category
     * @param {Object} cat The category whose style information is required
     */
    function extractStyleInfo(cat) {
      var sAttrMap = {
        'labelfont': ['fontFamily'],
        'labelfontcolor': ['fontColor'],
        'labelfontsize': ['fontSize', function (val) {
          return val ? (0, _lib.pluckNumber)(val) + 'px' : UNDEF;
        }],
        'labelfontbold': ['fontWeight', function (val) {
          return val ? 'bold' : NORMALSTRING;
        }],
        'labelfontitalic': ['fontStyle', function (val) {
          return val ? 'italic' : NORMALSTRING;
        }],
        'labelfontalpha': ['fontAlpha']
      },
          defFn = function defFn(val) {
        return val;
      },
          styleExists = false,
          attrKey,
          attrVal,
          secAttrVal,
          style = {},
          attrRule,
          mappedAttr,
          mapFn,
          mappedVal;

      for (attrKey in catData) {
        if (attrKey === 'category' || attrKey in cat) {
          continue;
        }

        attrVal = catData[attrKey];
        cat[attrKey] = attrVal;
      }

      for (attrKey in sAttrMap) {
        attrRule = sAttrMap[attrKey];
        mappedAttr = attrRule[0];
        mapFn = attrRule[1] || defFn;

        attrVal = cat[attrKey];
        secAttrVal = cat[mappedAttr.toLowerCase()];

        if (attrVal !== UNDEF || secAttrVal !== UNDEF) {
          if ((mappedVal = mapFn(attrVal)) !== UNDEF || (mappedVal = mapFn(secAttrVal)) !== UNDEF) {
            style[mappedAttr] = mappedVal;
            styleExists = true;
          }
        }

        if (styleExists) {
          cat.style = style;
        }
      }
    }

    // Storing category and vline
    for (index = 0; index < len; index += 1) {
      catIndex = categories[index];
      if (!catIndex) {
        catIndex = {};
      }
      // For category axis which gets placed with x (Candlestick).
      // for normal category catX = NaN
      catX = Number(catIndex.x);
      if (!(catIndex.vline === TRUE_STRING || catIndex.vline === true || catIndex.vline === 1 || catIndex.vline === ONE_STRING)) {
        // parse and store the category ID
        if (catIndex.id) {
          catIdMap[catIndex.id.toLowerCase()] = {
            catObj: catIndex,
            index: index
          };
        }
        // parse and store style
        extractStyleInfo(catIndex);

        // if (catX === catX)
        if (catX) {
          // If catX is present, save the integer value
          catIndex.x = catX;
          // And set a flag to indicate irregular category axis
          axisConfig.irregularCatAxis = true;
        }

        category.push(catIndex);
        category[countCat].label = (0, _lib.parseUnsafeString)(category[countCat].label);

        countCat += 1;
      } else {
        catIndex.startIndex = category.length - 1;
        vline.push(catIndex);
      }
    }

    axisConfig.oriCatLen = countCat - 1;
    // situation for which only one category is there then make axis padding to 0.5 if padding not
    // provided
    if (countCat === 1) {
      if (startPad === 0) {
        startPad = 0.5;
      }
      if (endPad === 0) {
        endPad = 0.5;
      }
    }

    if (isOnlyCategoryBool) {
      // code for adding the axis limits
      axisLimits = {
        Max: countCat - 1 + endPad,
        Min: -startPad,
        divGap: 1
      };

      axis.setAxisRange({
        max: Number((0, _lib.toPrecision)(axisLimits.Max, 10)),
        min: Number((0, _lib.toPrecision)(axisLimits.Min, 10)),
        tickInterval: Number((0, _lib.toPrecision)(axisLimits.divGap, 10))
      });
      // axisRange.min = Number(toPrecision(axisLimits.Min,10));
      // axisRange.max = Number(toPrecision(axisLimits.Max, 10));
      // axisRange.tickInterval = Number(toPrecision(axisLimits.divGap, 10));
    }
    axisConfig.isConfigured = true;
  };

  /**
   * Function used to update the category property
   * @param {number} id the id of the cateory
   * @param {Object} object The object containing the attribute to be updated
   */


  CartesianAxis.prototype.updateCategory = function updateCategory(id, object) {
    var axis = this,
        axisConfig = axis.config,
        category,
        prop;

    category = axisConfig.categories.category;
    if (category[id]) {
      for (prop in object) {
        if (object.hasOwnProperty(prop)) {
          category[id][prop] = object[prop];
        }
      }
    }
    axisConfig.isConfigured = true;
  };

  /**
   * Function helps to insert category dynamically
   * @param {number} index the index from which the category will be inserted
   * @param {Array} data the array containing the list of categories and vlines
   * @param {boolean} adjustRange decided the axis range will be redefined or not
   */


  CartesianAxis.prototype.categoryInsert = function categoryInsert(index, data, adjustRange) {
    var axis = this,
        axisConfig = axis.config,

    // axisRange = axisConfig.axisRange,
    len = data.length,
        endPad = axisConfig.endPad || 0,
        category,
        vline,
        catIdMap,
        i,
        catIndex;

    category = axisConfig.categories.category;
    catIdMap = axisConfig.categories.catIdMap;
    vline = axisConfig.categories.vline;
    // storing category and vline
    for (i = 0; i < len; i += 1) {
      catIndex = data[i];
      if (!(catIndex.vline === TRUE_STRING || catIndex.vline === true || catIndex.vline === 1 || catIndex.vline === ONE_STRING)) {
        // parse and store the category ID
        if (catIndex.id) {
          catIdMap[catIndex.id] = {
            catObj: catIndex,
            i: index
          };
        }
        category.splice(index, 0, catIndex);
        index += 1;
      } else {
        catIndex.startIndex = index - 2;
        vline.push(catIndex);
      }
    }

    if (adjustRange) {
      // axisRange.max = Number(toPrecision(category.length  - 1 + endPad, 10));
      axis.setAxisRange({
        max: Number((0, _lib.toPrecision)(category.length - 1 + endPad, 10))
      });
    }
    axisConfig.isConfigured = true;
  };

  /**
   * Function helps to delete the category starting from the startIndex upto the length
   * @param {number} startIndex the starting position of the index from which the data will be remove
   * @param {number} length the length upto which the array will be deleted
   * @param {boolean} adjustRange if the range will be redifined
   */


  CartesianAxis.prototype.categoryDelete = function categoryDelete(startIndex, length, adjustRange) {
    var axis = this,
        axisConfig = axis.config,
        axisRange = axisConfig.axisRange,
        animate = true,
        animateCategories,
        animateVline,
        i,
        len,
        category;

    if (animate) {
      axisConfig.isCategoryAnimate = true;
      animateCategories = axisConfig.animateCategories = axisConfig.categories.category.slice();
      // TODO must be generalized
      for (i = 0, len = animateCategories.length; i < len; i++) {
        animateCategories[i].animate = true;
        animateCategories[i].leftShift = length;
        animateCategories[i]['delete'] = i < length;
      }
      axisConfig.isCategoryVlineAnimate = true;
      animateVline = axisConfig.animateCategoriesVline = axisConfig.categories.vline.slice();
      for (i = 0, len = animateVline.length; i < len; i++) {
        animateVline[i].animate = true;
        animateVline[i].leftShift = length;
      }
    }
    category = axisConfig.categories.category;
    category.splice(startIndex, length);
    axis._shiftVline(startIndex, length, 'left');
    if (adjustRange) {
      // axisRange.max -= length;
      axis.setAxisRange({
        max: axisRange.max - length
      });
    }
    axisConfig.isConfigured = true;
  };

  /**
   * Update the category of the specific index
   * @param {number} index the index for which the category will be updated
   * @param {Object} data the category data
   */


  CartesianAxis.prototype.categoryUpdate = function categoryUpdate(index, data) {
    var axis = this,
        axisConfig = axis.config,
        category;

    category = axisConfig.categories.category;
    if (category[index]) {
      category[index] = data;
    }
    axisConfig.isConfigured = true;
  };

  /**
   * Gets the translation string of the category for realtime updates
   * @param  {number} x The amount by which to translate the category in the x direction
   */


  CartesianAxis.prototype.categoryTranslate = function categoryTranslate(x) {
    var axis = this,
        axisConfig = axis.config,
        diff = axis.getPixel(1) - axis.getPixel(0),
        translationStr;

    x = (x || 0) * diff;

    if (axisConfig.isReverse) {
      x = -x;
    }

    translationStr = ['T', x, ',', '0'].join('');

    axis.realTimeTranslatableGroups = [{
      group: axisConfig.axisContainer,
      translationStr: translationStr
    }, {
      group: axisConfig.axisBandContainer,
      translationStr: translationStr
    }, {
      group: axisConfig.axisPlotLineContainer,
      translationStr: translationStr
    }, {
      group: axisConfig.axisTrendContainerBottom,
      translationStr: translationStr
    }, {
      group: axisConfig.axisTrendLabelContainer,
      translationStr: translationStr
    }];
  };

  /**
   * Translates the real time groups of the axis
   */


  CartesianAxis.prototype.translateRTGroups = function translateRTGroups() {
    var axis = this,
        translatableGroups = axis.realTimeTranslatableGroups,
        key,
        translationObj,
        translationGrp,
        translationStr;

    for (key in translatableGroups) {
      if (translatableGroups.hasOwnProperty(key)) {
        translationObj = translatableGroups[key];
        translationGrp = translationObj.group;
        translationStr = translationObj.translationStr;
        translationGrp.attr({
          transform: translationStr
        });
        axis.getFromEnv('animationManager').registerAnimation([{
          data: [{
            el: translationGrp,
            attrs: {
              transform: 'T0,0'
            }
          }]
        }], 'plot');
      }
    }

    axis.fireEvent('internal.axiscategorytranslated', {
      translationString: translationStr
    });
  };

  /**
   * Shift the labels by the  x and y amounts given
   * @param  {number} x The amount of x shift
   * @param  {number} y The amount of y shift
   */


  CartesianAxis.prototype.shiftLabels = function shiftLabels(x, y) {
    var axis = this,
        axisConfig = axis.config,
        labels = axisConfig.labels;

    // This will help to shift the labels accordingly
    labels.shiftX = x;
    labels.shiftY = y;
  };

  /**
   * Function to shift the axis drawing
   * @param {number} startPad start padding in values
   * @param {number} endPad end Padding in values
   */


  CartesianAxis.prototype.setAxisPadding = function setAxisPadding(startPad, endPad) {
    var axis = this,
        axisConfig = axis.config;

    startPad = axisConfig.startPad = (0, _lib.pluckNumber)(startPad, 0);
    endPad = axisConfig.endPad = (0, _lib.pluckNumber)(endPad, 0);

    if (axisConfig.oriCatLen === 0) {
      if (startPad === 0) {
        startPad = 0.5;
      }
      if (endPad === 0) {
        endPad = 0.5;
      }
    }
    if (axisConfig.hasCategory) {
      if (axisConfig.oriCatLen >= 0) {
        axis.setAxisRange({
          max: axisConfig.oriCatLen + endPad,
          min: -startPad
        });
      }
    } else {
      if (axisConfig.originalMax && axisConfig.originalMin) {
        axis.setDataLimit(axisConfig.originalMax, axisConfig.originalMin);
      }
    }
  };

  /**
   * Function to set the axis config from (used for axis configuration) out side.
   * @param {Object} data Axis config object the values to be changed
   */


  CartesianAxis.prototype.setAxisConfig = function setAxisConfig(data) {
    var axis = this,
        axisConfig = axis.config,
        prop;

    for (prop in data) {
      if (data.hasOwnProperty(prop)) {
        axisConfig[prop] = data[prop];
      }
    }
  };

  /**
   * Function to get the axis config.
   * @param {string} name Name of the configuration
   * @return {any} Value of the configuration
   */


  CartesianAxis.prototype.getAxisConfig = function getAxisConfig(name) {
    var axis = this,
        axisConfig = axis.config;
    if (name) {
      return axisConfig[name];
    } else {
      return axisConfig;
    }
  };

  /**
   * Function to set the axis data from (used for axis drawing) out side.
   * @param {Object} data Axis data object the values to be changed
   */


  CartesianAxis.prototype.setLabelConfig = function setLabelConfig(data) {
    var axis = this,
        axisConfig = axis.config,
        labelConfig = axisConfig.labels,
        prop;

    for (prop in data) {
      if (data.hasOwnProperty(prop)) {
        labelConfig[prop] = data[prop];
      }
    }
  };

  /**
   * Function to set the axis range from (used for axis drawing) out side.
   * @param {Object} data Axis range object the values to be changed
   */


  CartesianAxis.prototype.setAxisRange = function setAxisRange(data) {
    // TODO: Janitorial service
    var axis = this,
        axisConfig = axis.config,
        axisRange = axisConfig.axisRange,
        tempAxis,
        tempAxisRange,
        prop;

    for (prop in data) {
      // TODO: Please review this condition. The commented code was present previously.
      // Removing it seems to have no noticable effect. Instead everything seems to work even better.
      if (data.hasOwnProperty(prop) /* && axisRange[prop] !== undefined */) {
          axisRange[prop] = data[prop];
        }
    }

    axis.setVisibleConfig(axisRange.min, axisRange.max);

    if (axisConfig.isReverse) {
      axisConfig.refVal = axisRange.max;
    } else {
      axisConfig.refVal = axisRange.min;
    }

    if (axis.getFromEnv('tempAxis')) {
      tempAxis = axis.getFromEnv('tempAxis');
      tempAxisRange = {
        max: tempAxis.axisRangeMax,
        min: tempAxis.axisRangeMin,
        tickInterval: tempAxis.axisTickInterval
      };

      if (tempAxisRange.max !== axisRange.max || tempAxisRange.min !== axisRange.min || tempAxisRange.tickInterval !== axisRange.tickInterval) {
        // Something has changed in the axis.
        // This flag is used to register its animation as an axis.
        axisConfig.rangeChanged = true;
      } else {
        // Nothing has changed in the axis.
        axisConfig.rangeChanged = false;
      }
    }
  };

  CartesianAxis.prototype.getAxisEndLabelDisplaySpace = function getAxisEndLabelDisplaySpace() {
    var axis = this,
        axisConfig = axis.config;

    return axisConfig.axisEndLabelDisplaySpace || {};
  };

  /**
   * Gets the number of div lines in the axis
   * @return {number} The number of div lines
   */


  CartesianAxis.prototype.getDivLineCount = function getDivLineCount() {
    var axis = this,
        axisConfig = axis.config,
        axisRange = axisConfig.axisRange;

    return mathAbs((axisRange.max - axisRange.min) / axisRange.tickInterval) - 1;
  };

  /**
   * Get the label text by the category id
   * @param {number} categoryId The category ID for which the label will be returned
   * @return {Object} Contains the label and the tooltext associated with the category ID
   */


  CartesianAxis.prototype.getLabel = function getLabel(categoryId) {
    var axis = this,
        axisConfig = axis.config,
        category = axisConfig.categories && axisConfig.categories.category[categoryId],
        macroIndices = [3],
        parserConfig = {};

    if (category && category.tooltext) {
      parserConfig.label = category.label;
      category.tooltext = (0, _lib.parseTooltext)(category.tooltext, macroIndices, parserConfig);
    }

    return {
      label: category && (category.oriLabel || category.label),
      tooltext: category && category.tooltext
    };
  };

  /**
   * Spl function for heatmap to get the category details by its category ID
   * @param {string} categoryId The category id
   * @return {Object} Detail category object
   */


  CartesianAxis.prototype.getCategoryFromId = function getCategoryFromId(categoryId) {
    var axis = this,
        axisConfig = axis.config,
        category = axisConfig.categories && axisConfig.categories.catIdMap[categoryId];

    if (category) {
      return category;
    } else {
      return {};
    }
  };

  CartesianAxis.prototype.getCategoryPositionById = function getCategoryPositionById(categoryId) {
    var axis = this,
        axisConfig = axis.config,
        category = axisConfig.categories && axisConfig.categories.catIdMap[categoryId];

    if (category) {
      return category.catObj.x || category.index;
    } else {
      return false;
    }
  };

  /**
   * Function give the closest div point from the given point
   * @param  {number} value value of the point for which the closest div is required
   * @param  {number} stretch value by which the closest div will be decided
   * @return {number} Value of the closest div relative to the given value
   */


  CartesianAxis.prototype.getClosestDiv = function getClosestDiv(value, stretch) {
    var axis = this,
        axisConfig = axis.config,
        axisRange = axisConfig.axisRange,
        hasCategory = axisConfig.hasCategory,
        increment = axisRange.tickInterval,
        min = axisRange.min,
        ret = value,
        loopStart,
        loopIncrement,
        valueDiff,
        v1,
        v2;

    if (hasCategory) {
      loopStart = 0;
      loopIncrement = 1;
      stretch = stretch || loopIncrement / 2;
    } else {
      loopStart = min;
      loopIncrement = increment;
      stretch = stretch || loopIncrement / 2;
    }

    valueDiff = value - loopStart;

    // Distance from lower div line value to user value
    v1 = valueDiff % loopIncrement;

    // Distance from upper div line value to user value
    v2 = loopIncrement - v1;

    // for zero value
    if (axisConfig.showZeroPlaneValue && value - v1 < 0 && value > 0) {
      v1 = value;
    }

    if (axisConfig.showZeroPlaneValue && value + v2 > 0 && value < 0) {
      v2 = -value;
    }

    if (v1 <= v2) {
      if (v1 <= stretch) {
        ret = value - v1;
      }
    } else {
      if (v2 <= stretch) {
        ret = value + v2;
      }
    }

    return ret;
  };

  /**
   * Function set the starting point for drawing the axis and the axis drawing width/height
   * @param {Object} data Contains the x, y, length and whether the axis is drawn on the opposite side
   */


  CartesianAxis.prototype.setAxisDimention = function setAxisDimention(data) {
    var axis = this,
        axisConfig = axis.config,
        chart = axis.getFromEnv('chart'),
        chartConfig = chart.config,
        axisDimention = axisConfig.axisDimention || (axisConfig.axisDimention = {}),
        tempAxis;

    axisDimention.opposite = (0, _lib.pluckNumber)(data.opposite, axisDimention.opposite);
    axisDimention.x = (0, _lib.pluckNumber)(data.x, axisDimention.x, chartConfig.canvasLeft);
    axisDimention.y = (0, _lib.pluckNumber)(data.y, axisDimention.y, chartConfig.canvasTop);
    axisDimention.axisLength = (0, _lib.pluckNumber)(data.axisLength, axisDimention.axisLength);

    if (axisConfig.isVertical) {
      axisConfig.refPx = axisDimention.y;
    } else {
      axisConfig.refPx = axisDimention.x;
    }

    axis.getPVR();

    if (axis.getFromEnv('tempAxis')) {
      tempAxis = axis.getFromEnv('tempAxis');
      if (tempAxis.axisLength !== axisDimention.axisLength || tempAxis.axisOpposite !== axisDimention.opposite || tempAxis.axisY !== axisDimention.y || tempAxis.axisX !== axisDimention.x) {
        // The axis dimensions have changed.
        // This flag is used to register its animation as an axis.
        axisConfig.dimensionChanged = true;
      } else {
        // No dimensions have changed.
        // Its animations will be registered as a plot.
        axisConfig.dimensionChanged = false;
      }
    }
  };

  /**
   * Calculate the categories on basis of xAxisLabelMode values
   */


  CartesianAxis.prototype.calculateCategoriesOnLabelMode = function calculateCategoriesOnLabelMode() {
    var axis = this,
        axisConfig = axis.config,
        xAxisLabelMode = axisConfig.xAxisLabelMode,
        categories = (0, _assign2['default'])([], axis.config.categories.category),
        numberFormatter = axis.getFromEnv('number-formatter'),
        numberFormatterFn,
        axisRange,
        tempCat,
        increment,
        i,
        len,
        numericLineStyle,
        iReal,
        intelligentIncrement = function intelligentIncrement() {
      // if the zero plane is true and zero is between previous element and the next element
      // make zero the next element
      if (i < 0 && i + increment > 0) {
        i = 0;
        iReal += increment;
      } else {
        // if i is less than iReal then previous i was zeroPlane so make i to iReal
        if (i < iReal) {
          i = iReal;
        } else {
          // increment normally
          i += increment;
          iReal += increment;
        }
      }
    };

    axisRange = axis.getLimit();
    increment = axisRange.tickInterval;

    if (xAxisLabelMode === 'mixed' || xAxisLabelMode === 'auto' || !(categories && categories.length > 0)) {
      tempCat = [];
      numberFormatterFn = numberFormatter.xAxis;
      if (xAxisLabelMode === 'mixed') {
        for (i = 0, len = categories.length; i < len; i += 1) {
          tempCat[categories[i].x || categories[i].y || i] = true;
        }
      } else {
        categories = [];
      }
      numericLineStyle = axis.getAxisConfig();
      for (iReal = i = axisRange.min, len = axisRange.max; i <= len;) {
        if (!tempCat[i]) {
          categories.push({
            'label': _lib.BLANKSTRING + numberFormatterFn.call(numberFormatter, i),
            'x': i,
            'showverticalline': i === 0 ? numericLineStyle.showZeroPlane : 1,
            'isNumeric': true,
            linecolor: i === 0 ? numericLineStyle.zeroPlaneColor : numericLineStyle.divLineColor,
            linealpha: i === 0 ? numericLineStyle.zeroPlaneAlpha : numericLineStyle.divLineAlpha,
            linethickness: i === 0 ? numericLineStyle.zeroPlaneThickness : numericLineStyle.divLineThickness,
            linedashed: numericLineStyle.divLineIsDashed,
            linedashLen: numericLineStyle.divLineDashLen,
            linedashgap: numericLineStyle.divLineDashGap
          });
        }
        intelligentIncrement();
      }
      axis.setCategory(categories, false);
    }
  };

  /**
   * Function set the div interval and set the max and min value used by axis
   * This function is called externally by the chart to adjust or define the axis limits
   * @param {number} max maximum limit of axis from the data
   * @param {number} min minimum limit of axis from the data
   */


  CartesianAxis.prototype.setDataLimit = function setDataLimit(max, min) {
    var axis = this,
        axisConfig = axis.config,
        axisRange = axisConfig.axisRange,
        AxisMaxValue = axisConfig.isPercent ? 100 : axisConfig.axisMaxValue,
        AxisMinValue = axisConfig.isPercent ? 0 : axisConfig.axisMinValue,
        numDivLines = axisConfig.numDivLines,
        setAdaptiveMin = axisConfig.setAdaptiveMin,
        adjustDiv = axisConfig.adjustDiv,
        startPad = axisConfig.startPad || 0,
        endPad = axisConfig.endPad || 0,
        setMinAsZero,
        stopMaxAtZero,
        axisLimits;

    axisConfig.originalMax = max;
    axisConfig.originalMin = min;

    max = axisConfig.isPercent ? 100 : max + endPad;
    min = axisConfig.isPercent ? 0 : min - startPad;

    setMinAsZero = stopMaxAtZero = !setAdaptiveMin;

    if (axisConfig.hasBreakPoints) {
      max -= axisConfig.totalBreakAmount;
    }

    // Calling the getAxisLimits from lib to calculate the best possible div interval
    // TODO : improve the function getAxisLimits
    axisLimits = (0, _lib.getAxisLimits)((0, _lib.pluckNumber)(max, AxisMaxValue), (0, _lib.pluckNumber)(min, AxisMinValue), AxisMaxValue, AxisMinValue, stopMaxAtZero, setMinAsZero, numDivLines, adjustDiv);

    // Saving the data to the axis
    axis.setAxisRange({
      max: Number((0, _lib.toPrecision)(axisLimits.Max, 10)),
      min: Number((0, _lib.toPrecision)(axisLimits.Min, 10)),
      tickInterval: Number((0, _lib.toPrecision)(axisLimits.divGap, 10))
    });
    // axisRange.min = Number(toPrecision(axisLimits.Min,10));
    // axisRange.max = Number(toPrecision(axisLimits.Max, 10));
    // axisRange.tickInterval = Number(toPrecision(axisLimits.divGap, 10));
    axis._adjustNumberFormatter(axisRange.tickInterval);
    // check for zero value to break infinite loop
    if (axisRange.tickInterval === 0) {
      axisRange.tickInterval = 1;
    }
    axis.getCategoryLen() > 0 && axis.calculateCategoriesOnLabelMode();
  };

  /**
   * Sets the visible range of the axis. Also sets axis's reference values and re-calculates PVR.
   * @param  {number} minValue The minimum value of the area to be visible
   * @param  {number} maxValue The maximum value of the area to be visible
   * @return {boolean} Whether the visible range of the axis was successfully set or not
   */


  CartesianAxis.prototype.setVisibleConfig = function setVisibleConfig(minValue, maxValue) {
    var axis = this,
        axisConfig = axis.config,
        range = axisConfig.axisRange,
        scrollType = axis.getScrollType(),
        axisScroll,
        translationStr,
        zoom,
        maxZoomLimit = axisConfig.maxZoomLimit;

    // TODO: Add sanity checks for max greater than min etc
    if (minValue > maxValue) {
      return false;
    }

    zoom = (range.max - range.min) / (maxValue - minValue);

    if (maxZoomLimit && zoom > maxZoomLimit) {
      return false;
    }

    axisConfig.minVisibleValue = minValue;
    axisConfig.maxVisibleValue = maxValue;

    if (axisConfig.isReverse) {
      axisConfig.refVisibleVal = maxValue;
    } else {
      axisConfig.refVisibleVal = minValue;
    }

    if (scrollType === 'always') {
      axis.setScrollEnabled(true);
    } else if (scrollType === 'smart') {
      if (axis._isZoomed()) {
        axis.setScrollEnabled(true);
      } else {
        axis.setScrollEnabled(false);
      }
    } else if (scrollType === 'none' && axis.isScrollEnabled()) {
      axis.setScrollEnabled(false);
    }

    axis.getPVR();

    if (axis.getFromEnv('tempAxis')) {
      axis.asyncDraw();
      axisScroll = -axis.getTranslation();
      if (axisConfig.isVertical) {
        translationStr = ['T', 0, ',', axisScroll].join('');
      } else {
        translationStr = ['T', axisScroll, ',', 0].join('');
      }
      axisConfig.axisContainer.attr({
        transform: translationStr
      });
      axisConfig.axisBandContainer.attr({
        transform: translationStr
      });
      axisConfig.axisPlotLineContainer.attr({
        transform: translationStr
      });
      axisConfig.axisTrendContainerBottom.attr({
        transform: translationStr
      });
      axisConfig.axisTrendContainerTop.attr({
        transform: translationStr
      });
    }

    axis.fireEvent('visiblerangeset', {
      minValue: axisConfig.minVisibleValue,
      maxValue: axisConfig.maxVisibleValue
    });
    // return info that value was successfully set
    return true;
  };

  /**
   * Gets the visible min and max values from the axis
   * @return {Object} Contains minValue and maxValue, the min and max values of the visible area
   */


  CartesianAxis.prototype.getVisibleConfig = function getVisibleConfig() {
    var axisConfig = this.config;

    return {
      min: axisConfig.minVisibleValue,
      max: axisConfig.maxVisibleValue,
      minValue: axisConfig.minVisibleValue,
      maxValue: axisConfig.maxVisibleValue
    };
  };

  /**
   * Function used to calculate the pixel to value ratio and return it
   * @return {number} The pixel to value ratio
   */


  CartesianAxis.prototype.getPVR = function getPVR() {
    var axis = this,
        axisConfig = axis.config,
        isReverse = axisConfig.isReverse,
        axisDimention = axisConfig.axisDimention || {},
        visibleConfig = axis.getVisibleConfig(),
        visibleSpan = visibleConfig.maxValue - visibleConfig.minValue,
        axisLength = axisDimention.axisLength,
        pvr = axisLength / visibleSpan;

    if (pvr) {
      if (isReverse) {
        axisConfig.pvr = -pvr;
      } else {
        axisConfig.pvr = pvr;
      }
    }

    return axisConfig.pvr;
  };

  /**
   * Gets the PVR of the axis with respect to the given length
   * @param  {number} length The length with respect to which the PVR is required
   * @return {number} The calculated PVR with respect to the given length
   */


  CartesianAxis.prototype.getCustomPVR = function getCustomPVR(length) {
    var axis = this,
        axisConfig = axis.config,
        isReverse = axisConfig.isReverse,
        visibleConfig = axis.getVisibleConfig(),
        visibleSpan = visibleConfig.maxValue - visibleConfig.minValue,
        pvr = length / visibleSpan;

    if (isReverse) {
      return -pvr;
    }
    return pvr;
  };

  /**
   * Function returning the pixel for respective value passed
   * @param {number} value   The value for which the pixel value is required
   * @param {Object} options The object containing information about whether the axis should
   *                         return values w.r.t. the old axis OR w.r.t. the visible range
   * @return {number} The pixel corresponding to the given value
   */


  CartesianAxis.prototype.getPixel = function getPixel(value, options) {
    var axis = this,
        axisConfig = axis.config,
        isOld = options && options.preValue,
        wrtVisible = options && options.wrtVisible,
        refVal = wrtVisible ? axisConfig.refVisibleVal : axisConfig.refVal,
        tempAxis = axis.getFromEnv('tempAxis'),
        pvr = axisConfig.pvr;
    // Calculate the pixel to value ratio
    if (isOld && tempAxis) {
      refVal = wrtVisible ? tempAxis.refVisibleVal : tempAxis.refVal;
      pvr = axis.getOldPVR();
    }

    if (!pvr) {
      return 0;
    }

    if (axisConfig.hasBreakPoints) {
      value = axis._getRelativeBreakValue(value);
    }

    return axisConfig.refPx + (value - refVal) * pvr;
  };

  /**
   * Function returning the pixel for respective value and length passed to it
   * @param {number} value   The value for which the pixel value is required
   * @param {number} length  The length with respect to which the pixel is required
   * @param {Object} options The object containing information about whether the axis should
   *                         return values w.r.t. the old axis OR w.r.t. the visible range
   * @return {number} The pixel corresponding to the given value and length
   */


  CartesianAxis.prototype._getCustomPixel = function _getCustomPixel(value, length, options) {
    var axis = this,
        chart = axis.getFromEnv('chart'),
        axisConfig = axis.config,
        chartConfig = chart.config,
        canvas = axisConfig.canvas,
        wrtVisible = options && options.wrtVisible,
        refVal = wrtVisible ? axisConfig.refVisibleVal : axisConfig.refVal,
        refPx = axisConfig.refPx || axis.getPixel(axisConfig.refVal),
        pvr;

    // TODO: Review usage of getPixel above

    if (axisConfig.isVertical) {
      length = length || canvas.canvasHeight || chartConfig.canvasHeight;
    } else {
      length = length || canvas.canvasWidth || chartConfig.canvasWidth;
    }
    pvr = axis.getCustomPVR(length);

    if (axisConfig.hasBreakPoints) {
      value = axis._getRelativeBreakValue(value);
    }

    return refPx + (value - refVal) * pvr;
  };

  /**
   * Function returning limit of the axis
   * @return {Object} ({min:number,max: number}) return an object with axis limits as property
   */


  CartesianAxis.prototype.getLimit = function getLimit() {
    var axis = this,
        axisConfig = axis.config,
        axisRange = axisConfig.axisRange,
        max = axisRange.max,
        min = axisRange.min;

    return {
      min: min,
      max: max,
      tickInterval: axisRange.tickInterval
    };
  };

  /**
   * Function used by the chart to get the pixel value of respective data value
   * See the getPixel function for details.
   * @param {number} value The value for which the pixel value is required
   * @param {Object} option The configuration object to determine the value of the pixel returned
   * @return {number} The pixel value of the given value
   */


  CartesianAxis.prototype.getAxisPosition = function getAxisPosition(value, option) {
    return this.getPixel(value, option);
  };

  /**
   * Gets the pixel to value ratio with respect to the saved axis
   * @return {number} The pvr w.r.t. the old axis
   */


  CartesianAxis.prototype.getOldPVR = function getOldPVR() {
    var tempAxis = this.getFromEnv('tempAxis');
    return tempAxis ? tempAxis.pvr : this.config.pvr;
  };

  /**
   * Gets the reference pixel associated with the axis
   * @return {number} The reference pixel
   */


  CartesianAxis.prototype.getReferencePixel = function getReferencePixel() {
    return this.config.refPx;
  };

  /**
   * Gets the reference value of the axis
   * @return {number} The reference value
   */


  CartesianAxis.prototype.getReferenceValue = function getReferenceValue() {
    return this.config.refVal;
  };

  /**
   * The visible reference value of the axis
   * @return {number} The visible reference value
   */


  CartesianAxis.prototype.getReferenceVisibleValue = function getReferenceVisibleValue() {
    return this.config.refVisibleVal;
  };

  /**
   * Hides the axis components
   */


  CartesianAxis.prototype.hide = function hide() {
    var axis = this,
        axisConfig = axis.config;

    if (!axisConfig.axisContainer) {
      return;
    }
    axisConfig.axisLabelContainerTop.hide();
    axisConfig.axisContainer.hide();
    axisConfig.axisPlotLineContainer.hide();
    axisConfig.axisPlotLineContainerTop.hide();
    axisConfig.axisBandContainer.hide();
    axisConfig.axisNameContainer.hide();
    axisConfig.axisTrendContainerTop.hide();
    axisConfig.axisTrendContainerBottom.hide();
    axisConfig.axisTrendLabelContainer.hide();
    axisConfig.axisAxisLineContainer.hide();
    axisConfig.axisAxisLineContainerBottom.hide();
  };

  /**
   * Hides the axis components
   */


  CartesianAxis.prototype.show = function show() {
    var axis = this,
        axisConfig = axis.config;

    if (!axisConfig.axisContainer) {
      return;
    }
    axisConfig.axisLabelContainerTop.show();
    axisConfig.axisContainer.show();
    axisConfig.axisPlotLineContainer.show();
    axisConfig.axisPlotLineContainerTop.show();
    axisConfig.axisBandContainer.show();
    axisConfig.axisNameContainer.show();
    axisConfig.axisTrendContainerTop.show();
    axisConfig.axisTrendContainerBottom.show();
    axisConfig.axisTrendLabelContainer.show();
    axisConfig.axisAxisLineContainer.show();
    axisConfig.axisAxisLineContainerBottom.show();
  };

  /**
   * Sets up the scroll bar associated with the axis and attaches it as a component of the axis.
   * Also sets the handler function to be executed when the scroll bar is dragged.
   */


  CartesianAxis.prototype.createScrollBar = function createScrollBar() {
    var axis = this,
        axisConfig = axis.config,
        axisComponents = axis._components,
        chart = axis.getFromEnv('chart'),
        tb,
        Scroller,
        scrollConf,

    // scrollItem,
    scrollBarComponent = axisComponents.scrollBar,
        scrollDimensions,
        toolBoxAPI;

    if (axisConfig.scrollBarCreated) {
      return;
    }

    scrollConf = chart.scrollConf = {
      isHorizontal: !axisConfig.isVertical
    };

    tb = chart.getFromEnv('toolbox');
    toolBoxAPI = chart.getFromEnv('toolBoxAPI');
    Scroller = toolBoxAPI.Scroller;

    // Fetching the scroll Items.
    // scrollItem = scrollBar && getScrollItems()[0];
    if (!scrollBarComponent) {
      // adding the scrollbar.
      axisComponents.scrollBar = new Scroller(scrollConf, tb.idCount, tb.pId).attachEventHandlers({
        // Attach the callback for scroll Interaction.
        'scroll': function scroll(scrollPercent) {
          var apparentScrollPos = axis.config.isReverse ? 1 - scrollPercent : scrollPercent,
              axisMax = axisConfig.axisRange.max,
              axisMin = axisConfig.axisRange.min,
              axisRange = axisMax - axisMin,
              visibleConfig = axis.getVisibleConfig(),
              visibleMin = visibleConfig.minValue,
              visibleMax = visibleConfig.maxValue,
              visibleRange = visibleMax - visibleMin,
              scrollRatio = visibleRange / axisRange,
              visualRange = scrollRatio * axisRange,
              movableRange = axisRange - visualRange,
              actualscrollPos = movableRange * apparentScrollPos,
              actualScrollStart = axisMin + actualscrollPos,
              actualScrollEnd = actualScrollStart + visualRange;

          chart.state = 'noAnim';

          axis.setVisibleConfig(actualScrollStart, actualScrollEnd);
        }
      });
      axisComponents.scrollBar.setConfiguaration(chart.scrollConf);
      scrollDimensions = axisComponents.scrollBar.getLogicalSpace();
      chart._allocateSpace({
        bottom: chart.config.shift = chart.config.scrollEnabled === false ? 0 : scrollDimensions.height + axisComponents.scrollBar.conf.padding
      });
    }
    axisConfig.scrollBarCreated = true;
  };

  /**
   * Returns the amount by which the visible window is translated with respect to the axis'
   * reference point
   * @return {number} The translation amount
   */


  CartesianAxis.prototype.getTranslation = function getTranslation() {
    var axis = this,
        axisConfig = axis.config,
        ret = axis.getPixel(axisConfig.refVisibleVal) - axisConfig.refPx;

    return ret;
  };

  /**
   * Invokes createScrollBar() and sets a configuration parameter to enable the scrollbar
   * @param  {boolean} bool Whether scrolling is enabled or not
   */


  CartesianAxis.prototype.setScrollEnabled = function setScrollEnabled(bool) {
    this.config.scrollEnabled = bool;
    if (bool) {
      this.createScrollBar();
      this.getFromEnv('tempAxis') && this.asyncDraw();
    } else {
      this._disposeScrollBar();
    }
  };

  /**
   * Returns the current status of the scroll bar
   * @return {boolean} Whether scrolling is enabled or disabled
   */


  CartesianAxis.prototype.isScrollEnabled = function isScrollEnabled() {
    return this.config.scrollEnabled;
  };

  /**
   * This function is to reset the drawing of category axis related items which is not required
   * for numeric axis drawing this is required is category axis is changed to numeric axis
   */


  CartesianAxis.prototype.resetNumericAxisComponents = function resetNumericAxisComponents() {
    var axis = this,
        numericPlotLineER = axis.getFromEnv('numericPlotLineER'),
        numericPlotLabelER = axis.getFromEnv('numericPlotLabelER');

    if (!numericPlotLineER || !numericPlotLabelER) {
      return;
    }

    numericPlotLineER.preProcessor();
    numericPlotLabelER.preProcessor();
    numericPlotLineER.postProcessor(function (el) {
      el.attr({
        opacity: '0'
      });
    });
    numericPlotLabelER.postProcessor(function (el) {
      el.attr({
        opacity: '0'
      });
    });
  };

  /**
   * This function is to reset the drawing of numeric axis related items which is not required
   * for category axis drawing this is required is numeric axis is changed to category axis
   */


  CartesianAxis.prototype.resetCategoryAxisComponents = function resetCategoryAxisComponents() {
    var axis = this,
        categoryvLineER = axis.categoryvLineER,
        catLabelER = axis.getFromEnv('catLabelER'),
        catLineER = axis.catLineER;

    categoryvLineER.preProcessor();
    catLabelER.preProcessor();
    catLineER.preProcessor();

    categoryvLineER.postProcessor(function (el) {
      el.attr({
        opacity: 0,
        'text-bound': []
      });
    });
    catLabelER.postProcessor(function (el) {
      el.attr({
        opacity: 0,
        'text-bound': []
      });
    });
    catLineER.postProcessor(function (el) {
      el.attr({
        opacity: 0
      });
    });
  };

  /**
   * Function called by the chart when there is requirement to calculate or recalculate the space
   * management this function must be called every time when chart dimension is changed
   * @param {number} maxLimit The maximum width/height that is available for space management
   * @return {Object} Left and right defining how much space is used in left and right
   */


  CartesianAxis.prototype.placeAxis = function placeAxis(maxLimit) {
    var axis = this,
        isVertical = axis.config.isVertical;
    if (isVertical) {
      return axis._placeVerticalAxis(maxLimit);
    } else {
      return axis._placeHorizontalAxis(maxLimit);
    }
  };

  /**
   * Function to get the category length
   * @return {number} The number of caltegories associated with the axis
   */


  CartesianAxis.prototype.getCategoryLen = function getCategoryLen() {
    return this.config.categories ? this.config.categories.category.length : 0;
  };

  /**
   * Returns a a number after formatting it through the number formatter
   * @param  {number} num The number to be formatted
   * @param  {Any}    abs Absolute value
   * @return {string}     The formatted value
   */


  CartesianAxis.prototype.getCleanValue = function getCleanValue(num, abs) {
    var axis = this,
        numberFormatter = axis.getFromEnv('number-formatter');
    return numberFormatter.getCleanValue(num, abs);
  };

  CartesianAxis.prototype.dataLabels = function dataLabels(value) {
    var axis = this,
        axisIndex = axis.config.axisIndex,
        numberFormatter = axis.getFromEnv('number-formatter');
    return numberFormatter.dataLabels(value, axisIndex);
  };

  /**
   * Sets the number formatter associated with a specific axis instance
   * @param {Object} numberFormatter An instance of NumberFormatter to be associated with the axis
   */


  CartesianAxis.prototype.setNumberFormatter = function setNumberFormatter(numberFormatter) {
    var axis = this;
    axis.components.numberFormatter = numberFormatter;
  };

  CartesianAxis.prototype.getType = function getType() {
    return 'axis';
  };

  CartesianAxis.prototype.getName = function getName() {
    return 'cartesian';
  };

  return CartesianAxis;
}(_componentInterface2['default']);

exports['default'] = CartesianAxis;
exports._drawScrollBar = _drawScrollBar;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports._createDatasets = undefined;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(14);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _column = __webpack_require__(8);

var _column2 = _interopRequireDefault(_column);

var _column3 = __webpack_require__(15);

var _column4 = _interopRequireDefault(_column3);

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */


var __createDatasets = function __createDatasets() {
  var iapi = this,
      jsonData = iapi.jsonData,
      datasetsJSON = jsonData.dataset,
      children = iapi.getChildren(),
      canvas = children.canvas[0],
      vCanvas = void 0,
      datasetParent = vCanvas = canvas.getChildren('vCanvas')[0],
      DsGroupClass = void 0,
      DSClass = void 0,
      dsType = iapi.defaultDatasetType || '',
      groupManager = void 0;

  if (!datasetsJSON) {
    iapi.setChartMessage();
  }

  DsGroupClass = iapi.getDSGroupdef();
  (0, _lib.componentFactory)(vCanvas, DsGroupClass, 'datasetGroup_' + dsType);
  groupManager = vCanvas.getChildren('datasetGroup_' + dsType);
  groupManager && (datasetParent = groupManager[0]);
  DSClass = iapi.getDSdef();

  (0, _lib.datasetFactory)(datasetParent, DSClass, 'dataset', datasetsJSON.length, datasetsJSON);
};
/**
 * Class for multiseries column charts and who depend on this class
 * @type {class}
 */

var MSColumn2D = function (_MSCartesian) {
  _inherits(MSColumn2D, _MSCartesian);

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  MSColumn2D.getName = function getName() {
    return 'MSColumn2D';
  };

  /**
   * constructor function of this class
   */


  function MSColumn2D() {
    _classCallCheck(this, MSColumn2D);

    var _this = _possibleConstructorReturn(this, _MSCartesian.call(this));

    _this.type = 'ChartAPI';
    _this.name = 'mscolumn2d';
    _this.friendlyName = 'Multi-series Column Chart';
    _this.defaultDatasetType = 'column';
    _this.customConfigFn = '_createDatasets';
    _this.eiMethods = {};
    return _this;
  }

  /**
   * parse defualt configuration of the chart
   */


  MSColumn2D.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _MSCartesian.prototype.__setDefaultConfig.call(this);
    this.config.enablemousetracking = true;
  };
  /**
   * function to  create dataset, groupmaneger.
   * assign dataset to group manager.
   **/


  MSColumn2D.prototype._createDatasets = function _createDatasets() {
    __createDatasets.call(this);
  };
  /**
   * This method return the dataset definations for this charts
   * @return {Object}       Column dataset definition
   */


  MSColumn2D.prototype.getDSdef = function getDSdef() {
    return _column2['default'];
  };
  /**
   * This method return the dataset-group definations for this charts
   * @return {Object}       Multiseries column group definition
   */


  MSColumn2D.prototype.getDSGroupdef = function getDSGroupdef() {
    return _column4['default'];
  };

  return MSColumn2D;
}(_fusioncharts2['default']);

exports._createDatasets = __createDatasets;
exports['default'] = MSColumn2D;

/***/ }),
/* 24 */,
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.ToolBarFactoryHelper = exports.defTextStyle = exports.defaultHToolbarConf = exports.defaultGroupConf = undefined;

var _lib = __webpack_require__(5);

var UNDEF = void 0,
    convertColor = _lib.graphics.convertColor,
    defaultGroupConf = {
  hPadding: 3,
  vPadding: 3,
  borderRadius: 2,
  fill: convertColor('DBDBDB', 100),
  borderColor: convertColor('B2B1B1', 100),
  borderThickness: 1,
  offsetAdjustment: 1,
  radius: 1,
  spacing: 6
},
    defaultHToolbarConf = {
  hPadding: 3,
  vPadding: 3,
  borderRadius: 0,
  fill: convertColor('EBEBEB', 100),
  borderColor: convertColor('D1D0D0', 100),
  borderThickness: 1,
  offsetAdjustment: 1,
  radius: 0
},
    defTextStyle = {
  'fontFamily': 'Verdana,sans',
  'fontSize': '12px',
  fill: UNDEF,
  'fontStyle': 'normal',
  'fontWeight': 'normal'
},
    ToolBarFactoryHelper = {
  setComponentPool: function setComponentPool(componentPool) {
    return this.componentPool = componentPool;
  },
  getOptions: function getOptions() {
    return this.options;
  },
  getComponentPool: function getComponentPool() {
    return this.componentPool;
  },
  setOptions: function setOptions(options) {
    return this.options = options;
  },
  componentPool: {},
  options: {}
}; /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */

exports.defaultGroupConf = defaultGroupConf;
exports.defaultHToolbarConf = defaultHToolbarConf;
exports.defTextStyle = defTextStyle;
exports.ToolBarFactoryHelper = ToolBarFactoryHelper;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.SymbolStore = exports.RSymbolFns = exports.getEventHandlersFor = exports.mergeConf = exports.normalizeTarget = exports.isDIV = exports.hashCode = undefined;

var _iterator = __webpack_require__(9);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(10);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2['default'] === "function" && typeof _iterator2['default'] === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2['default'] === "function" && obj.constructor === _symbol2['default'] && obj !== _symbol2['default'].prototype ? "symbol" : typeof obj; };

var _domEvent = __webpack_require__(34);

var _domEvent2 = _interopRequireDefault(_domEvent);

var _redraphael = __webpack_require__(17);

var _redraphael2 = _interopRequireDefault(_redraphael);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var UNDEF = void 0,
    TEXTBOX_SYMBOL = 'Internal_CB',
    RSymbolFns = function () {
  return {
    CB_NOT_CHECKED: function CB_NOT_CHECKED(posx, posy, rad) {
      var x = posx,
          y = posy,
          r = rad,
          x0 = x - r,
          y0 = y - r;

      return ['M', x0, y0];
    },
    CB_CHECKED: function CB_CHECKED(posx, posy, rad) {
      var x = posx,
          y = posy,
          r = rad,
          rq = r / 4,
          rtq = 3 * rq,
          x0 = x - rtq,
          y0 = y,
          x1 = x - rq,
          y1 = y + r,
          x2 = x + r,
          y2 = y - r;

      return ['M', x0, y0, 'L', x1, y1, x2, y2];
    }
  };
}(),

/*
 * Global symbolStore to store all the symbols and their definitions.
 * If a symbol is re-registered, it will be overridden.
 */
SymbolStore = function () {
  // Default symbols for checkbox. Just the box outside
  _redraphael2['default'].addSymbol(TEXTBOX_SYMBOL, RSymbolFns.CB_NOT_CHECKED);

  return {
    /*
     * Registers individual or group of icons.
     */
    register: function register() {
      var symbolName, symbolDrawingFn, symbolRegObj, itrObj;

      if (arguments.length === 1) {
        // Only one argument is given, possibility is that the whole object is passed. This object contains
        // all the symbol definiation and drawing function
        symbolRegObj = arguments[0];

        if (!((symbolRegObj !== null || symbolRegObj !== UNDEF) && (typeof symbolRegObj === 'undefined' ? 'undefined' : _typeof(symbolRegObj)) === 'object')) {
          // If no object is passed, return silently.
          return;
        }
        // Adds a iterator pointer to the object
        itrObj = symbolRegObj;
      } else if (arguments.length > 1) {
        // If two or more parameters are passed, take those (or the first two) and assume that individual
        // symbol has been sent to register.
        symbolName = arguments[0];
        symbolDrawingFn = arguments[1];

        if (typeof symbolName !== 'string' || typeof symbolDrawingFn !== 'function') {
          // symbolName is not given in string format or the symbol function has noot ben provided
          // return silently
          return;
        }

        // Prepare a object for iteration
        itrObj = {};
        itrObj[symbolName] = symbolDrawingFn;
      } else {
        return;
      }

      for (symbolName in itrObj) {
        symbolDrawingFn = itrObj[symbolName];

        if (!{}.hasOwnProperty.call(itrObj, symbolName)) {
          // If its a symbol in the prototype chain, ignore it as redefinition might happen, which is
          // not expected
          continue;
        }

        // Sent it to raphael for registration
        _redraphael2['default'].addSymbol(symbolName, symbolDrawingFn);
      }
    }
  };
}();

function hashCode(str) {
  if (typeof str === 'number') {
    str = '\'' + str + '\'';
  }
  return str.split('').reduce(function (a, b) {
    a = (a << 5) - a + b.charCodeAt(0);
    return a & a;
  }, 0);
}

function isDIV(ele) {
  if (ele && ele.nodeName && ele.nodeName.toUpperCase() === 'DIV') {
    return true;
  }

  return false;
}

function normalizeTarget(target, evt) {
  var clientRect;
  if (target.getBBox) {
    return target;
  }
  clientRect = target.getBoundingClientRect();
  target.getBBox = function () {
    return {
      x: evt.x,
      y: evt.y,
      width: clientRect.right - clientRect.left,
      height: clientRect.bottom - clientRect.top,
      isArtificial: true
    };
  };

  return target;
}

function mergeConf(source, sink, theirsMergeEnabled) {
  var key, sourceVal;
  for (key in source) {
    sourceVal = source[key];
    if (sourceVal === UNDEF || sourceVal === null) {
      continue;
    }
    if (theirsMergeEnabled) {
      if (sink[key]) {
        continue;
      }
      sink[key] = sourceVal;
    } else {
      sink[key] = sourceVal;
    }
  }
}

function getEventHandlersFor(eventName, node) {
  switch (eventName) {
    case 'click':
      return function (mouseClickFn) {
        _domEvent2['default'].listen(node, 'click', function (e) {
          e.target && e.target.parentNode && mouseClickFn.call(e.target);
        });
      };

    case 'hover':
      return function (mouseOverFn, mouseOutFn) {
        _domEvent2['default'].listen(node, 'pointerhover', function (e) {
          e.target && e.target.parentNode && (e.state === 'start' ? mouseOverFn : mouseOutFn).call(e.target);
        });
      };
  }
}

//   // Readymade symbol functions for internal use

// class RSymbolFns {
//   static CB_NOT_CHECKED (posx, posy, rad) {
//     var x = posx,
//       y = posy,
//       r = rad,
//       x0 = x - r,
//       y0 = y - r;

//     return ['M', x0, y0];
//   }
//   static CB_CHECKED (posx, posy, rad) {
//     var x = posx,
//       y = posy,
//       r = rad,
//       rq = r / 4,
//       rtq = 3 * rq,
//       x0 = x - rtq,
//       y0 = y,
//       x1 = x - rq,
//       y1 = y + r,
//       x2 = x + r,
//       y2 = y - r;

//     return ['M', x0, y0, 'L', x1, y1, x2, y2];
//   }
// }

exports.hashCode = hashCode;
exports.isDIV = isDIV;
exports.normalizeTarget = normalizeTarget;
exports.mergeConf = mergeConf;
exports.getEventHandlersFor = getEventHandlersFor;
exports.RSymbolFns = RSymbolFns;
exports.SymbolStore = SymbolStore;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _line = __webpack_require__(11);

var _line2 = _interopRequireDefault(_line);

var _lib = __webpack_require__(5);

var _mssplinearea = __webpack_require__(45);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var UNDEF,
    M = 'M',
    L = 'L',
    Z = 'Z',
    C = 'C',
    math = Math,
    mathSqrt = math.sqrt,
    mathAbs = math.abs;

var MSSplineDataset = function (_LineDataset) {
  _inherits(MSSplineDataset, _LineDataset);

  function MSSplineDataset() {
    _classCallCheck(this, MSSplineDataset);

    var _this = _possibleConstructorReturn(this, _LineDataset.call(this));

    _this.type = 'spline';
    return _this;
  }

  MSSplineDataset.prototype.configure = function configure(datasetObj) {
    _LineDataset.prototype.configure && _LineDataset.prototype.configure.call(this, datasetObj);
    _mssplinearea._calculateMaxMin.call(this);
  };

  MSSplineDataset.prototype.getSplinePath = function getSplinePath(dataTemp, yAxis, num) {
    var getSlope = function getSlope(x1, y1, x2, y2) {
      return (y2 - y1) / (x2 - x1);
    },
        getPointY = function getPointY(x, m, x1, y1) {
      return (x - x1) * m + y1;
    },
        getPointX = function getPointX(y, m, x1, y1) {
      return (y - y1) / m + x1;
    },
        evalX = function evalX(x1, y1, x2, y2) {
      var sinTheta = (y2 - y1) / mathSqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)),
          rearPart = mathAbs(0.5 * sinTheta),
          frontPart = 1 - rearPart;
      return x1 * rearPart + x2 * frontPart;
    },
        cmrcManager = function cmrcManager(curveArr, appendClosePath, endXPos, endYPos) {
      var len = curveArr.length,
          lastCurveCommandArr = curveArr[len - 1],
          len2 = lastCurveCommandArr.length,
          command = lastCurveCommandArr[0],
          lastRecorderXPos = lastCurveCommandArr[len2 - 2];

      // drawing can not continue with less that two cordinates
      if (len2 < 3) {
        return;
      }

      if ((command === 'R' || command === 'C') && len2 === 3) {
        // draw a straight line instead
        curveArr[len - 1][0] = L;
      }

      if (appendClosePath) {
        curveArr.push([L, lastRecorderXPos, endYPos, endXPos, endYPos, 'Z']);
      }
    },
        chart = this.getFromEnv('chart'),

    // take the series type
    seriesType = chart.defaultDatasetType,
        isSplineArea = /area/ig.test(seriesType),
        yBasePos = yAxis.getAxisPosition(yAxis.getAxisBase()),
        minimizeTendency = chart.config.minimizetendency,
        arrS = [null],
        curvePath = [],
        linePath = [],
        R = 'R',
        lastArrLength,
        lastObj,
        y1,
        y0,
        y2,
        x1,
        x0,
        x2,
        lastYPos,
        lastXPos,
        lineArrLen,
        slope,
        point,
        anchorX,
        anchorY,
        anchorX0,
        anchorY0,
        slopePrev,
        arrLen,
        startingIndex,
        tempArr,
        startXPos,
        prevPoint,
        nextPoint,
        i,
        len;

    for (i = 0, len = dataTemp.length; i < len; i += 1) {
      point = dataTemp[i];
      prevPoint = dataTemp[i - 1] || {};
      nextPoint = dataTemp[i + 1] || {};

      x1 = point.x;
      y1 = point.y;
      x0 = prevPoint.x;
      y0 = prevPoint.y;
      x2 = nextPoint.x;
      y2 = nextPoint.y;

      lastYPos = point.lastYPos;
      lastXPos = point.lastXPos;
      arrLen = curvePath.length;
      lineArrLen = linePath.length;

      if (minimizeTendency) {
        // The new algo to find the spline path
        if (lastYPos !== null) {
          lastObj = tempArr;
          if (i === dataTemp.length - 1) {
            slopePrev = arrS[i - startingIndex - 1];
            anchorX = (x1 + x0) / 2;
            anchorX0 = anchorX;
            anchorY0 = getPointY(anchorX0, slopePrev, x0, y0);

            if (y0 > y1 && anchorY0 < y1 || y0 < y1 && anchorY0 > y1) {
              anchorY0 = y1;
              anchorX0 = getPointX(anchorY0, slopePrev, x0, y0);
            }

            tempArr.push(anchorX0, anchorY0, anchorX, (y1 + y0) / 2, x1, y1);

            curvePath.push(tempArr);
            linePath.push(tempArr);

            isSplineArea && cmrcManager(curvePath, true, startXPos, yBasePos);
            isSplineArea && cmrcManager(linePath, false);
          } else {
            slopePrev = arrS[i - startingIndex - 1];

            // High and Low
            if (y0 > y1 && y2 >= y1 || y0 < y1 && y2 <= y1) {
              slope = 0;
              anchorX = evalX(x0, y0, x1, y1);
              anchorY = y1;

              if (i - startingIndex !== 1) {
                anchorX0 = anchorX;
                anchorY0 = getPointY(anchorX0, slopePrev, x0, y0);

                if (y0 > y1 && anchorY0 < y1 || y0 < y1 && anchorY0 > y1) {
                  anchorY0 = y1;
                  anchorX0 = getPointX(anchorY0, slopePrev, x0, y0);
                }
                tempArr.push(anchorX0, anchorY0, anchorX, anchorY, x1, y1);
              } else {
                tempArr.push((x1 + x0) / 2, (y1 + y0) / 2, anchorX, anchorY, x1, y1);
              }
            } else if (y0 === y1) {
              slope = 0;
              tempArr.push(x0, y0, x1, y1, x1, y1);
              // Rise and decline
            } else if (y0 > y1 && y1 > y2 || y0 < y1 && y1 < y2) {
              slope = getSlope(x0, y0, x2, y2);
              anchorX = evalX(x0, y0, x1, y1);
              anchorY = getPointY(anchorX, slope, x1, y1);

              if (y0 > y1 && anchorY > y0 || y0 < y1 && anchorY < y0) {
                anchorY = y0;
                anchorX = getPointX(anchorY, slope, x1, y1);
              }

              if (i - startingIndex !== 1) {
                anchorX0 = anchorX;
                anchorY0 = getPointY(anchorX0, slopePrev, x0, y0);

                if (y0 > y1 && anchorY0 < y1 || y0 < y1 && anchorY0 > y1) {
                  anchorY0 = y1;
                  anchorX0 = getPointX(anchorY0, slopePrev, x0, y0);
                }
                tempArr.push(anchorX0, anchorY0, anchorX, anchorY, x1, y1);
              } else {
                tempArr.push((x1 + x0) / 2, (y1 + y0) / 2, anchorX, anchorY, x1, y1);
              }
            }
            arrS.push(slope);
          }
        } else if (lastYPos === null && i !== 0) {
          // Raphael Catmull-Rom Curve To fix
          // We can not draw a curve with two datapoints
          // If we have only 2 datapoints, we push the last one again
          lastObj || (lastObj = []);
          if (lastObj[0] === C) {
            curvePath.push(tempArr);
            linePath.push(tempArr);

            isSplineArea && cmrcManager(curvePath, true, startXPos, yBasePos);
            isSplineArea && cmrcManager(linePath, false);
          }

          curvePath.push([M, x1, y1]);
          linePath.push([M, x1, y1]);
          startXPos = x1;
          tempArr = [C];
          startingIndex = i;
          arrS = [null];
        } else {
          // first start
          curvePath.push([M, x1, y1]);
          // line
          linePath.push([M, x1, y1]);
          // store the staring x position
          // this will be nedded to close the line
          startXPos = x1;
          tempArr = [C];
          startingIndex = i;
        }
      } else {
        // Default algo to find the spline path
        if (lastYPos !== null) {
          // This means we have a two consecutive valid points
          // and we will draw a curve.
          if (arrLen >= 2) {
            // This means atleast one command with two values has been inserted.
            // If the last inserted command is not a Catmull-Rom curve command R
            // we have to push one.
            if (curvePath[arrLen - 1][0] === M) {
              curvePath.push([R]);
            }
            // line
            if (linePath[lineArrLen - 1][0] === M) {
              linePath.push([R]);
            }
            // update properties
            arrLen = curvePath.length;
            lineArrLen = linePath.length;
            lastObj = curvePath[arrLen - 1];
            lastArrLength = lastObj.length;
            curvePath[arrLen - 1].push(x1);
            curvePath[arrLen - 1].push(y1);
            //
            linePath[lineArrLen - 1].push(x1);
            linePath[lineArrLen - 1].push(y1);
            // Now for all area charts we need to close path when drawing ends
            // In this case if we have reached the end of data, we close.
            if (i === num - 1) {
              // End of drawing
              // Conncet only if the last command is a curve
              if (lastObj[0] === R) {
                // apply Catmull-Rom-Curve management.
                cmrcManager(curvePath, true, startXPos, yBasePos);
                cmrcManager(linePath, false);
              }
            }
          } else {
            // first start
            curvePath.push([M, lastXPos, lastYPos]);
            curvePath.push([R, x1, y1]);
            // line
            linePath.push([M, lastXPos, lastYPos]);
            linePath.push([R, x1, y1]);
            // store the staring x position
            // this will be nedded to close the line
            startXPos = lastXPos;
          }
        } else if (lastYPos === null && arrLen >= 2) {
          // Raphael Catmull-Rom Curve To fix
          // We can not draw a curve with two datapoints
          // If we have only 2 datapoints, we push the last one again
          lastObj = curvePath[arrLen - 1];
          if (lastObj[0] === R) {
            cmrcManager(curvePath, true, startXPos, yBasePos);
            cmrcManager(linePath, false);
          }

          curvePath.push([M, x1, y1]);
          linePath.push([M, x1, y1]);
          startXPos = x1;
        }
      }
    }

    // If the line is Drawn [R] not closed [!Z] and we have reached the end,
    // We need to close the path with the previous one
    lastObj = curvePath[curvePath.length - 1];
    if (isSplineArea && lastObj) {
      lastArrLength = lastObj.length;
      if (lastObj[lastArrLength - 1] !== Z && (lastObj[0] === R || lastObj[0] === C)) {
        // apply Catmull-Rom-Curve management.
        cmrcManager(curvePath, true, startXPos, yBasePos);
        cmrcManager(linePath, false);
      }
    }

    if (!isSplineArea) {
      curvePath = minimizeTendency ? curvePath : linePath;
      curvePath.length >= 2 && cmrcManager(curvePath, false);
    }

    return {
      closedPath: curvePath,
      openPath: linePath
    };
  };

  /**
   * Function to draw line
   * @param {Object} anim The animation object which will be passed to animation manager. All
   *                      animation configuration should be pushed into this.
   * Line chart has a setLevel attribute 'color', thus line segments can have different colors,
   * but a line path can support only one color, so we are making multiple paths depending on the
   * color applied. lineOb is object having all line elements and key is the color and stroke combined,
   * thus all line segment having same color is grouped under one key. elements having different
   * line color is animated by fading in and out, on main color's line element transition is applied.
   */


  MSSplineDataset.prototype.drawCommonElements = function drawCommonElements(anim) {
    var dataset = this,
        dataStore = dataset.components.data,
        dsConfig = dataset.config,
        connectNullData = Number(dataset.getFromEnv('chartConfig').connectnulldata),
        xAxis = dataset.getFromEnv('xAxis'),
        yAxis = dataset.getFromEnv('yAxis'),

    // styles
    lineDashStyle = dsConfig.lineDashStyle,
        lineThickness = dsConfig.linethickness,
        dataTemp = [],
        lastYPos = null,
        lastXPos,
        colorHash,
        lineColorObj = {
      color: dsConfig.linecolor,
      alpha: dsConfig.alpha
    },
        lim = {
      x: xAxis.getLimit(),
      y: yAxis.getLimit()
    },
        i,
        ii = dataStore.length,
        lineOb = dataset.lineOb || {},
        dataObj,
        config,
        setValue,
        startIndex = 0,
        endIndex,
        tempStore = [];

    // Setting min and max pixels
    lim.x.minPixel = xAxis.getPixel(lim.x.min);
    lim.x.maxPixel = xAxis.getPixel(lim.x.max);
    lim.y.minPixel = yAxis.getPixel(lim.y.min);
    lim.y.maxPixel = yAxis.getPixel(lim.y.max);
    lim.y.base = yAxis.getPixel(0);
    lim.x.base = xAxis.getPixel(0);

    for (i = 0; i < ii; ++i) {
      dataObj = dataStore[i];
      if (!dataObj) {
        continue;
      }

      config = dataObj.config || {};
      setValue = config.setValue;
      config._Pbx = UNDEF;
      config._Pby = UNDEF;

      // Pushing configurations to save
      // reference for later
      tempStore[i] = {
        config: {
          _Px: config._Px,
          _Py: config._Py,
          setValue: config.setValue
        }
      };

      if (!connectNullData && (setValue === null || setValue === UNDEF)) {
        lastYPos = null;
        continue;
      }
      dataTemp.push({
        x: config._Px,
        y: config._Py,
        lastYPos: lastYPos,
        lastXPos: lastXPos
      });
      lastYPos = config._Py;
      lastXPos = config._Px;
    }
    dsConfig.pathStartIndex = startIndex;
    dsConfig.pathEndIndex = endIndex;

    colorHash = 'default';
    lineOb[colorHash] = lineOb[colorHash] || {};
    lineOb[colorHash].used = true;
    lineOb[colorHash].path = [{
      pathArr: dataset.getSplinePath(dataTemp, yAxis).closedPath,
      path2Arr: [],
      getPathArr: dataset.getPathArr
    }];
    lineOb[colorHash].attr = {
      'stroke-dasharray': lineDashStyle,
      'stroke-width': lineThickness,
      'stroke': (0, _lib.toRaphaelColor)(lineColorObj),
      'stroke-linecap': 'round'
    };
    dataset.animateCommonElements(lineOb, anim, lim);
    // Saving for next
    dataset.lineOb = lineOb;
    dsConfig.prevLim = lim;
    // Storing current datastore
    dsConfig.prevDataStore = tempStore;
  };
  /**
   * Returns the name of the component
   * @return {string} The name of the component, in this case 'column'.
   */


  MSSplineDataset.prototype.getName = function getName() {
    return 'spline';
  };

  return MSSplineDataset;
}(_line2['default']);

exports['default'] = MSSplineDataset;

/***/ }),
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

var global    = __webpack_require__(32)
  , core      = __webpack_require__(19)
  , ctx       = __webpack_require__(174)
  , hide      = __webpack_require__(48)
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , IS_WRAP   = type & $export.W
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , expProto  = exports[PROTOTYPE]
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
    , key, own, out;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if(own && key in exports)continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function(C){
      var F = function(a, b, c){
        if(this instanceof C){
          switch(arguments.length){
            case 0: return new C;
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if(IS_PROTO){
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library` 
module.exports = $export;

/***/ }),
/* 32 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(179)
  , defined = __webpack_require__(111);
module.exports = function(it){
  return IObject(defined(it));
};

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _libExtend = __webpack_require__(185);

var _libExtend2 = _interopRequireDefault(_libExtend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var SPACE = ' ',
    win = window,
    doc = win.document,
    hasTouch = 'ontouchstart' in win,


/*
* Basic Events
* ~type {object} BE
*/
BE = {
  click: 'click',
  touchstart: 'touchstart',
  touchend: 'touchend',
  touchmove: 'touchmove',
  mousedown: 'mousedown',
  mouseup: 'mouseup',
  mousemove: 'mousemove',
  mouseout: 'mouseout',
  mouseover: 'mouseover',
  keydown: 'keydown'
},

/*
* An abstraction layer
* ~type {object} gestures
*/
gestures = function () {
  var retObj = {},
      gesture;

  retObj.pointerdrag = {
    start: [BE.mousedown],
    end: [BE.mouseup],
    onStart: [BE.mousemove],
    postHandlers: {},
    preHandlers: {}
  };

  retObj.pointerhover = {
    start: [BE.mouseover],
    end: [BE.mouseout]
  };

  retObj.click = {
    start: [BE.click]
  };

  /* retObj.drag = {
      start: [retObj.pointerdrag, retObj.touchdrag]
  };
   retObj.hover = {
      start: [retObj.pointerhover]
  }; */

  retObj.escape = {
    start: [BE.keydown],
    preHandlers: {
      start: function start(event) {
        /**
         * @todo check the event keyCode and return true is it corresponds to
         * escape key.
         */
        event = event || win.event;
        if (event.keyCode && event.keyCode === 27) {
          return true;
        }
        return false;
      }
    }
  };

  if (hasTouch) {
    gesture = retObj.pointerdrag;

    gesture.start.push(BE.touchstart);
    gesture.end.push(BE.touchend);
    gesture.onStart.push(BE.touchmove);

    gesture.postHandlers.onStart = function (event) {
      if (event.preventDefault) {
        event.preventDefault();
      } else {
        event.returnValue = false;
      }
    };
  }

  return retObj;
}(),
    gDefs;

/*
  * Define generic gestures in terms of sequence of DOM events depending on the
  * browser.
  */
function defineGestures() {
  var gestureMap = (0, _libExtend2['default'])({}, gestures); /** @todo reduce dependency on lib functions as much as possible */
  // browType = getBrowserClass();

  // switch (browType) {

  //      // Add browser vendor specific code here defining each gesture as a
  //      // sequence of events.

  //     default:
  //         break;
  // }

  return gestureMap;
}

gDefs = defineGestures();

/*
  * Gets the class of browser.
  *
  * ~returns {string} class
  *
  * ~todo classification parameters have to be decided upon.
  */
// function getBrowserClass() {
//     var browType = '';

//     return browType;
// }

/*
  * Creates a new instance of the DOM Event wrapper.
  * ~constructor
  * ~todo Enable handling of custom events.
  */
function DOMEventFx() {
  var
  /*
  * ~private {object} eventHandlerMap A map of all the handlers
  * created per event type.
  */
  eventHandlerMap = {},


  /*
  * ~private {object} gestureHandlerMap A map of all the handlers
  * created per gesture type.
  */
  gestureHandlerMap = {},


  /*
  * Binds a DOM event to a handler function.
  *
  * ~param {Element} elem The DOM element pertaining to the event.
  * ~param {string} event Event type that needs to be listened to.
  * ~param {function} handlerFn The function that gets called when the event
  * is triggered.
  *
  * ~returns {undefined}
  */
  addHandler = doc.addEventListener ? function (elem, event, handlerFn) {
    elem.addEventListener(event, handlerFn, false);
  } : function (elem, event, handlerFn) {
    elem.attachEvent('on' + event, handlerFn);
  },


  /*
  * Removes the binding of the event handler with the DOM.
  *
  * ~param {Element} elem The DOM element pertaining to the event.
  * ~param {string} event Event type for which the existing handler
  * must be detached.
  * ~param {function} handlerFn The handler function.
  *
  * ~returns {undefined}
  */
  removeHandler = doc.removeEventListener ? function (elem, event, handlerFn) {
    elem.removeEventListener(event, handlerFn, false);
  } : function (elem, event, handlerFn) {
    elem.detachEvent('on' + event, handlerFn);
  },


  /*
  * Function that finally calls the addHandler to bind the event with
  * a wrapper handler(start/end/closure).
  *
  * ~param {DOM Element} elem
  * ~param {string} event
  * ~param {object} handlerObj
  * ~param {string} [attachTo=closure] The wrapper to which to bind.
  *
  * ~return {function} The unbinding function.
  */
  addEventHandler = function addEventHandler(elem, event, handlerObj, attachTo) {
    /**
     * @todo event can later be an array once we start supporting
     * complex gestures.
     */
    var unlistener;
    attachTo = attachTo || 'closure';

    // Attach the handler to the DOM element.
    addHandler(elem, event, handlerObj[attachTo]);
    unlistener = function unlistener() {
      removeHandler(elem, event, handlerObj[attachTo]);
    };

    return unlistener;
  },


  /*
    * Converts the gesture in to a sequence of events and adds handlers
    * to the events.
    *
    * ~param {DOM Element} elem The target element.
    * ~param {string} gesture The name of the gesture.
    * ~param {object} handlerObj The object containing all the binding
    * related information.
    *
    * ~returns {array} unlisteners An array of functions that can be
    * invoked to unbind the handlers.
    */
  addGestureHandler = function addGestureHandler(elem, gesture, handlerObj) {
    var unlisteners = [],
        eventArr,
        each,
        i,
        def;

    def = gDefs[gesture];

    /*
      * The handler wrapper that must be called when the event
      * corresponding to the start to the gesture is triggered.
      *
      * ~param {object} event The browser event object.
      *
      * ~return {undefined}
      */
    handlerObj.start = function (event) {
      var onStartArr = def.onStart,
          endArr = def.end,
          startUn = [],
          endUn = [],
          i = onStartArr && onStartArr.length || 0;

      event = event || win.event;
      // startUn and endUn are arrays that contain functions to
      // unbind the handlers that were bound at the start of the
      // gesture.
      while (i--) {
        startUn.push(addEventHandler(elem, onStartArr[i], handlerObj, 'onStart'));
      }

      i = endArr && endArr.length || 0;

      while (i--) {
        endUn.push(addEventHandler(elem, endArr[i], handlerObj, 'end'));
      }

      // Storing in the handlerObj
      handlerObj.startUn = handlerObj.startUn ? handlerObj.startUn.concat(startUn) : startUn;
      handlerObj.endUn = handlerObj.endUn ? handlerObj.endUn.concat(endUn) : endUn;
      handlerObj.state = 'start';
      handlerObj.closure(event);
    };

    handlerObj.onStart = function (event) {
      event = event || win.event;
      handlerObj.state = 'on';

      if (handlerObj.gDef && handlerObj.gDef.preHandlers && typeof handlerObj.gDef.preHandlers.onStart === 'function') {
        handlerObj.gDef.preHandlers.onStart(event);
      }

      handlerObj.closure(event);

      if (handlerObj.gDef && handlerObj.gDef.postHandlers && typeof handlerObj.gDef.postHandlers.onStart === 'function') {
        handlerObj.gDef.postHandlers.onStart(event);
      }
    };

    /*
      * The handler wrapper that must be called when the event
      * corresponding to the end to the gesture is triggered.
      *
      * ~param {object} event The browser event object.
      *
      * ~return {undefined}
      */
    handlerObj.end = function (event) {
      var startUn = handlerObj.startUn,
          endUn = handlerObj.endUn,
          i = startUn && startUn.length || 0;

      event = event || win.event;
      // Unbinding the events that were bound to when the gesture
      // had started.
      while (i--) {
        startUn[i]();
      }
      delete handlerObj.startUn;
      handlerObj.startUn = [];

      i = endUn && endUn.length || 0;

      while (i--) {
        endUn[i]();
      }
      delete handlerObj.endUn;
      handlerObj.endUn = [];

      handlerObj.state = 'end';
      handlerObj.closure(event);
    };

    // Gesture
    if (def) {
      eventArr = def.start;
      i = eventArr.length;

      while (i--) {
        each = eventArr[i];
        if (each) {
          // Listen to only the event that corresponds to the
          // start of the gesture.
          unlisteners.push(addEventHandler(elem, each, handlerObj, 'start'));
        }
      }
    }

    return unlisteners;
  },


  /*
    * Unbinding the handler/gesture.
    *
    * ~param {DOM Element} elem The target element.
    * ~param {string} gesture The name of the gesture.
    * ~param {object} handlerObj The object containing all the binding
    * related information.
    *
    */
  removeGestureHandler = function removeGestureHandler(elem, gesture, handlerObj) {
    var eventArr, each, i, def;

    def = gDefs[gesture];

    // Gesture
    if (def) {
      eventArr = def.start;
      i = eventArr.length;

      while (i--) {
        each = eventArr[i];
        if (each) {
          removeHandler(elem, each, handlerObj.start);
        }
      }
    }
  },
      getHandlerClosure = function getHandlerClosure(handlerObj) {
    return function (event) {
      var ctxt = handlerObj.context || handlerObj.elem,
          eventObj;

      eventObj = {
        data: handlerObj.data,
        type: handlerObj.type,
        state: handlerObj.state,
        isGesture: handlerObj.isGesture,
        target: event.target || event.srcElement,
        originalEvent: event
        // more properties to be added here
      };
      event = event || win.event;
      handlerObj.handler.call(ctxt, eventObj);
    };
  };

  /*
    * Clean up the eventHandlerMap if and when elements get deleted. (or
    * handlers get reassigned or overwritten?)
    * ~returns {undefined}
    */
  // garbageCollector = function () {
  /**
   * @todo Go through all the existing handler objects and delete
   * the ones that do not have a proper elem or handler property.
   *
   * @todo Try to listen to events that are fired when DOM tree changes.
   * and start the garbageCollector then.
   *
   */
  // };

  return {

    /*
      * External API to attach the handler to DOM element
      * ~param {DOM} elem The element to which the event listener
      * has to be attached.
      * ~param {string} gestures Gestures are a sequence of events.
      * ~param {function} handlers A single handler or if it is
      * an array will have a one-to-one mapping with gestures.
      * ~param {object} data The data that should be passed to the
      * handler when it is invoked
      * ~param {type} context The context in which the handler should
      * be invoked.
      *
      * ~returns {object} An object containing the method to detach
      * the handlers that have been bound to elem.
      */
    listen: function listen(elem, gestures, handlers, data, context) {
      var dem = this,
          gestureArr = typeof gestures === 'string' ? gestures.split(SPACE) : gestures,
          i = gestureArr.length,
          unlisteners = [],
          addToUnlistener = function addToUnlistener(elem, type, handler) {
        unlisteners.push(function () {
          dem.unlisten(elem, type, handler);
        });
      },
          handlerMap,
          gesture,
          handlerObj,
          isGesture,
          handler;

      if (!elem.ownerDocument || elem.ownerDocument !== doc) {
        // elem is a not a DOM element.
        while (i--) {
          gesture = gestureArr[i];
          handler = typeof handlers === 'function' ? handlers : handlers[i];

          // Internal object maintained by the event fx.
          // Should not be exposed outside.
          handlerObj = {
            handler: handler,
            elem: elem,
            type: gesture,
            isGesture: isGesture,
            data: data,
            context: context,
            start: [],
            end: [],
            links: {
              prev: null,
              next: null
            }
          };

          // Encapsulate the actual handler call within a closure so that it is
          // easier to invoke the handler in a particular context and pass
          // parameters to it.
          handlerObj.closure = getHandlerClosure(handlerObj);

          handlerMap = eventHandlerMap[gesture];
          if (!handlerMap) {
            handlerMap = eventHandlerMap[gesture] = [];
          }
          handlerMap.push(handlerObj);

          addEventHandler(elem, gesture, handlerObj);

          // Adding the unlisteners in a closure to
          // unlisten each of individual events.
          addToUnlistener(elem, gesture, handler);
        }
      } else {
        while (i--) {
          gesture = gestureArr[i];
          isGesture = Boolean(gDefs[gesture]);
          handler = typeof handlers === 'function' ? handlers : handlers[i];

          // Internal object maintained by the event fx.
          // Should not be exposed outside.
          handlerObj = {
            handler: handler,
            elem: elem,
            type: gesture,
            isGesture: isGesture,
            gDef: isGesture ? gDefs[gesture] : null,
            data: data,
            context: context,
            start: [],
            end: [],
            links: {
              prev: null,
              next: null
            }
          };

          // Encapsulate the actual handler call within a closure so that it is
          // easier to invoke the handler in a particular context and pass
          // parameters to it.
          handlerObj.closure = getHandlerClosure(handlerObj);

          // If the listener is supposed to listen to a gesture
          if (isGesture) {
            handlerMap = gestureHandlerMap[gesture];
            if (!handlerMap) {
              handlerMap = gestureHandlerMap[gesture] = [];
            }
            handlerMap.push(handlerObj);

            addGestureHandler(elem, gesture, handlerObj);
          } else {
            // else listening to a DOM event (future: custom event)
            handlerMap = eventHandlerMap[gesture];
            if (!handlerMap) {
              handlerMap = eventHandlerMap[gesture] = [];
            }
            handlerMap.push(handlerObj);

            addEventHandler(elem, gesture, handlerObj);
          }

          // Adding the unlisteners in a closure to
          // unlisten each of individual events.
          addToUnlistener(elem, gesture, handler);
        }
      }

      // Pass an object containing a method to unbind the handler for
      // ease of use.
      return {
        unlisten: function unlisten() {
          var i = unlisteners.length;
          while (i--) {
            unlisteners[i]();
          }
          // clear the unlisteners
          unlisteners.length = 0;
          unlisteners = null;
        }
      };
    },

    /*
      * External API to detach the handler from the DOM element.
      *
      * ~param {DOM} elem
      * ~param {string} gesture
      * ~param {function} handler
      *
      * ~returns {boolean} retVal
      */
    unlisten: function unlisten(elem, gesture, handler) {
      var isGesture = Boolean(gDefs[gesture]),
          eventHandlers,
          retVal = false,
          i,
          hObj;

      // Iterate over the array of handler objects for the event type
      // and remove when the element and handler of a handler object
      // matches the ones passed as arguments.
      if (!isGesture) {
        eventHandlers = eventHandlerMap[gesture];
        i = eventHandlers && eventHandlers.length || 0;

        while (i--) {
          hObj = eventHandlers[i];
          if (hObj.handler === handler && hObj.elem === elem) {
            removeHandler(elem, gesture, hObj.closure);
            eventHandlers.splice(i, 1);
            retVal = true;
          }
        }
      } else {
        eventHandlers = gestureHandlerMap[gesture];
        i = eventHandlers && eventHandlers.length || 0;

        while (i--) {
          hObj = eventHandlers[i];
          if (hObj.handler === handler && hObj.elem === elem) {
            removeGestureHandler(elem, gesture, hObj);
            eventHandlers.splice(i, 1);
            retVal = true;
          }
        }
      }

      return retVal;
    },

    /*
      * External API to fire an event on a particular DOM element.
      * ~param {object} elem
      * ~param {string} event
      * ~param {object} eventArguments
      * ~param {function} defaultFunction
      *
      * ~returns {undefined}
      */
    fire: function fire(elem, event, eventArguments, defaultFunction) {
      var eventHandlers, i, hObj, eventObj;

      // If elem is a custom object
      if (!elem.ownerDocument || elem.ownerDocument !== doc) {
        eventHandlers = eventHandlerMap[event];
        i = eventHandlers && eventHandlers.length || 0;

        while (i--) {
          hObj = eventHandlers[i];
          if (hObj.elem === elem) {
            hObj.closure(eventArguments);
          }
        }
      } else {
        // For non-IE browsers
        if (doc.createEvent) {
          eventObj = doc.createEvent('HTMLEvents');
          eventObj.initEvent(event, true, true);
          if (eventArguments) {
            if (eventArguments.originalEvent) {
              eventArguments.originalEvent = eventObj;
            } else {
              (0, _libExtend2['default'])(eventObj, eventArguments);
            }
          }

          // If the event can be called as a function on the element
          // like blur, focus etc then first call them.
          if (typeof elem[event] === 'function') {
            elem[event]();
          }
          elem.dispatchEvent(eventObj);
          if (defaultFunction && !eventObj.returnValue) {
            defaultFunction(eventObj);
          }
        } else {
          // IE
          eventObj = doc.createEventObject();
          eventObj.eventType = event;
          if (eventArguments) {
            if (eventArguments.originalEvent) {
              eventArguments.originalEvent = eventObj;
            } else {
              (0, _libExtend2['default'])(eventObj, eventArguments);
            }
          }

          // If the event can be called as a function on the element
          // like blur, focus etc then first call them.
          if (typeof elem[event] === 'function') {
            elem[event]();
          }

          elem.fireEvent('on' + event, eventObj);
          if (defaultFunction && !eventObj.returnValue) {
            defaultFunction(eventObj);
          }
        }
      }
    }
  };
}

exports['default'] = new DOMEventFx();

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(14);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var TRUE_STRING = 'true',
    ONE_STRING = '1',

/*
  * Seggregates the original data to data and vline.
  * @param data: Original data used for seggregation.
  * @return Object: JSON data to be used further by the child components, e.g. dataSet.
*/
_dataSegregator = function _dataSegregator(data) {
  var dataOnlyArr = [];

  (0, _lib.fcEach)(data, function (datum) {
    if (!(datum.vline === TRUE_STRING || datum.vline === true || datum.vline === 1 || datum.vline === ONE_STRING)) {
      dataOnlyArr.push(datum);
    }
  });
  return {
    data: dataOnlyArr
  };
};

var SSCartesian = function (_MSCartesian) {
  _inherits(SSCartesian, _MSCartesian);

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  SSCartesian.getName = function getName() {
    return 'SSCartesian';
  };

  function SSCartesian() {
    _classCallCheck(this, SSCartesian);

    var _this = _possibleConstructorReturn(this, _MSCartesian.call(this));

    _this.hasLegend = false;
    return _this;
  }

  SSCartesian.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _MSCartesian.prototype.__setDefaultConfig && _MSCartesian.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }

    config.linethickness = 4;
  };
  /**
   * function to  create dataset.
   * assign dataset to vCanvas.
   **/


  SSCartesian.prototype._createDatasets = function _createDatasets() {
    var iapi = this,
        children = iapi.getChildren(),
        canvas = children.canvas[0],
        datasetParent = canvas.getChildren('vCanvas')[0],
        dataObj = iapi.jsonData,
        dataset = dataObj.dataset,
        data = dataObj.data || dataset && dataset[0].data,
        DSClass,
        datasetJSON;

    datasetJSON = _dataSegregator(data);

    if (!(data && data.length !== 0)) {
      iapi.setChartMessage();
      return;
    }
    DSClass = iapi.getDSdef();
    (0, _lib.datasetFactory)(datasetParent, DSClass, 'dataset', 1, [datasetJSON]);
  };

  SSCartesian.prototype._setCategories = function _setCategories() {
    var iapi = this,
        dataObj = iapi.jsonData,
        xAxis = iapi.getChildren('xAxis'),
        dataset = dataObj.dataset,
        categories = dataObj.data || dataset && dataset[0].data;
    xAxis[0].setCategory(categories);
  };

  return SSCartesian;
}(_fusioncharts2['default']);

exports['default'] = SSCartesian;

/***/ }),
/* 36 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _assign = __webpack_require__(13);

var _assign2 = _interopRequireDefault(_assign);

var _componentInterface = __webpack_require__(6);

var _componentInterface2 = _interopRequireDefault(_componentInterface);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var UNDEF,
    COLOR_WHITE = '#ffffff',
    COLOR_E3E3E3 = '#e3e3e3',
    STR_DEF = 'default',
    COLOR_EFEFEF = '#efefef',
    COLOR_C2C2C2 = '#c2c2c2',
    activatedBtnConfig = {
  config: {
    hover: {
      fill: COLOR_WHITE,
      'stroke-width': 1,
      stroke: '#aaaaaa',
      cursor: 'pointer'
    },
    normal: {
      fill: COLOR_WHITE,
      stroke: COLOR_C2C2C2,
      'stroke-width': 1,
      cursor: 'pointer'
    },
    disable: {
      fill: COLOR_WHITE,
      'stroke-width': 1,
      stroke: COLOR_E3E3E3,
      'stroke-opacity': 1,
      cursor: 'pointer'
    },
    pressed: {
      fill: COLOR_EFEFEF,
      'stroke-width': 1,
      stroke: COLOR_C2C2C2,
      cursor: 'pointer'
    }
  },
  'button-disabled': false,
  fill: [COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, true],
  'stroke': COLOR_C2C2C2,
  'stroke-opacity': 1
},
    disableBtnConfig = {
  config: {
    hover: {
      fill: COLOR_WHITE,
      'stroke-width': 1,
      stroke: COLOR_E3E3E3,
      cursor: STR_DEF
    },
    normal: {
      fill: COLOR_WHITE,
      stroke: COLOR_E3E3E3,
      'stroke-width': 1,
      cursor: STR_DEF
    },
    disable: {
      fill: COLOR_WHITE,
      'stroke-width': 1,
      stroke: COLOR_E3E3E3,
      'stroke-opacity': 1,
      cursor: STR_DEF
    },
    pressed: {
      fill: COLOR_WHITE,
      'stroke-width': 1,
      stroke: COLOR_E3E3E3,
      cursor: STR_DEF
    }
  },
  fill: [COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, true],
  'button-disabled': false,
  'stroke': COLOR_E3E3E3,
  'stroke-opacity': 1
};
/**
 * Base class for all input components,
 * all input components must inherit base, which include common or basic functions
 * like enable disable drawButton etc. Also intitializes some basic states and save some
 * required components like chart, canvas.
 */

var InputBase = function (_ComponentInterface) {
  _inherits(InputBase, _ComponentInterface);

  // Inherited component must define tags array
  // to mark all the resources they use
  function InputBase() {
    _classCallCheck(this, InputBase);

    var _this = _possibleConstructorReturn(this, _ComponentInterface.call(this));

    _this.tags = [];
    _this.state = {};
    _this.components = {};
    !_this.options && (_this.options = {});
    return _this;
  }

  /**
   * Add external configurations to current configurations
   */


  InputBase.prototype.setConfigure = function setConfigure(configObj) {
    (0, _assign2['default'])(this.config, configObj);
  };

  InputBase.prototype.configure = function configure() {
    var chart = this.getFromEnv('chart');
    this.canvas = chart.getChildren('canvas')[0];
    this.chart = chart;
    this.asyncDraw();
  };

  InputBase.prototype.defineOptions = function defineOptions(options) {
    !this.options && (this.options = {});
    this.options = (0, _assign2['default'])(this.options, options || {});
    return this;
  };
  /*
    Function to toggle current state
  */


  InputBase.prototype.toggle = function toggle() {
    this.isEnabled() ? this.disable() : this.enable();
  };

  InputBase.prototype.enable = function enable() {
    this.state.enabled = true;
    this.asyncDraw(true);
  };

  InputBase.prototype.disable = function disable() {
    this.state.enabled = false;
    this.asyncDraw(true);
  };

  InputBase.prototype.isEnabled = function isEnabled() {
    return this.state.enabled;
  };

  InputBase.prototype.isDisabled = function isDisabled() {
    return this.state.enabled;
  };
  /**
   * function to dispose current instance of input
  */


  InputBase.prototype.dispose = function dispose() {
    var button = this.button ? this.button : this.config && this.config.button;
    button && button.dispose();
    this.disable();
  };
  /** Function to check if type is valid and is same as this
  * component's type
  */


  InputBase.prototype.similarTags = function similarTags(tags) {
    var foundTags = [],
        thisTags = this.tags;
    tags.forEach(function (tag) {
      if (~thisTags.indexOf(tag)) {
        foundTags.push(tag);
      }
    });
    return foundTags;
  };
  /**
   * Generate an event with user specified attributes
   * @param {Object} extraAttributes
   */


  InputBase.prototype.getEvent = function getEvent(extraAttributes) {
    // Inherited components need to define their type
    // Returning event with optional extra attribute
    return (0, _assign2['default'])({
      component: this,
      enabled: this.state.enabled,
      type: this.tags.slice(0)
    }, extraAttributes);
  };
  // Function to call hookFn if provided in options


  InputBase.prototype._preHookFn = function _preHookFn() {
    var input = this,
        options = input.options;
    options.hookFn && typeof options.hookFn === 'function' && options.hookFn.apply(input, arguments);
  };
  /** Helper function to create buttons
   * take an options Object
   * Structure of options
   * {
   *  icon: 'zoomInIcon',
   *  handlers: {
   *    click: function () {},
   *    tooltext: 'Hello I'ma button!
   *  }
   * }
   */


  InputBase.prototype.createButton = function createButton(options) {
    var canvas = this.canvas,
        toolBox,
        toolBoxAPI,
        group,

    // SymbolStore,
    _Symbol,
        button,
        chart = canvas.getFromEnv('chart');
    toolBox = chart.getFromEnv('toolbox');
    toolBoxAPI = chart.getFromEnv('toolBoxAPI');
    _Symbol = toolBoxAPI.Symbol;
    // SymbolStore = toolBoxAPI.SymbolStore;
    group = (chart.getChildren('chartMenuBar') || chart.getChildren('actionBar')).componentGroups[0];
    // Add the symbols in the chartMenuBar
    button = new _Symbol(options.icon, UNDEF, toolBox.idCount++, toolBox.pId).attachEventHandlers(options.handlers);
    group.addSymbol(button, true);
    setTimeout(function () {
      button.node && button.node.attr(activatedBtnConfig);
    });
    button.isEnabled = true;
    button.enable = function () {
      button.isEnabled = true;
      setTimeout(function () {
        button.node && button.node.attr(activatedBtnConfig);
      });
    };

    button.disable = function () {
      button.isEnabled = false;
      setTimeout(function () {
        button.node && button.node.attr(disableBtnConfig);
      });
    };
    return button;
  };

  return InputBase;
}(_componentInterface2['default']);

exports['default'] = InputBase;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var anObject       = __webpack_require__(63)
  , IE8_DOM_DEFINE = __webpack_require__(175)
  , toPrimitive    = __webpack_require__(113)
  , dP             = Object.defineProperty;

exports.f = __webpack_require__(39) ? Object.defineProperty : function defineProperty(O, P, Attributes){
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if(IE8_DOM_DEFINE)try {
    return dP(O, P, Attributes);
  } catch(e){ /* empty */ }
  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
  if('value' in Attributes)O[P] = Attributes.value;
  return O;
};

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(49)(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});

/***/ }),
/* 40 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
/* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */
/**
 * Scheduler component responsible for the execution of jobs in a priority basis.
 * @private
 * @module fusioncharts.renderer.javascript.schedular
 */

var jobList = [],
    pausedList = {},
    priorityList = [],
    jobByID = {},
    jobCount = 0,
    win = window,
    minMsThreshold = 16,
    schedular = {},
    jobFrame = win.requestAnimationFrame || win.webkitRequestAnimationFrame || win.mozRequestAnimationFrame || win.oRequestAnimationFrame || win.msRequestAnimationFrame || function (callback) {
  setTimeout(callback, minMsThreshold);
},


/**
* This function is used to execute the registerted jobs, called from executeFrame
* @param  {boolean} sameThreadCall         Used to determine if the function is called from the
*                                          same reqFrame or a differnt one
* @param  {boolean} fullFrameExecutionDone Used to determine if any fullFrame job is executed
*                                          in the current frame
* @return {Object}                         Determines whether any job is executed or not, and
*                                          if the job is a fullFrame job.
*/
executeJobs = function executeJobs(sameThreadCall, fullFrameExecutionDone) {
  var jobObj,
      jobFound = false,
      fullFrameJob,
      actualJobExecuted;

  while (!jobFound) {
    if (jobObj = jobList[0]) {
      fullFrameJob = jobObj.fullFrameJob;
      if (sameThreadCall) {
        if (fullFrameExecutionDone && fullFrameJob) {
          return false;
        }
      }
      jobList.splice(0, 1);
      priorityList[jobObj.priority] -= 1;
      if (jobByID[jobObj.jobID] && !jobObj.executed) {
        actualJobExecuted = jobFound = true;
        !sameThreadCall && jobList.length > 0 && jobFrame(executeFrame);
        jobObj.job();
        jobObj.executed = true;
        delete jobByID[jobObj.jobID];
      }
    } else {
      jobFound = true;
    }
  }
  return {
    jobFound: actualJobExecuted,
    fullFrameJob: fullFrameJob
  };
},


/**
* This function is called in each requestFrame
*/
executeFrame = function executeFrame() {
  var startTime = new Date().getTime(),
      minElapsedMsThreshold = 15,
      nextJobDetails,
      fullFrameExecutionDone,
      sameThreadCall;
  // Calling multiple functions in a single frame if the time of execution for the prev fn is
  // less than 15ms
  do {
    nextJobDetails = executeJobs(sameThreadCall, fullFrameExecutionDone);
    sameThreadCall = true;
    fullFrameExecutionDone = fullFrameExecutionDone || nextJobDetails.fullFrameJob;
  } while (nextJobDetails.jobFound && new Date().getTime() - startTime < minElapsedMsThreshold);
};

/**
 * This function is used to add a new job to the schedular
 * @param  {Function} job          The actual fucntion(job) to be executed.
 * @param  {number}   priority     The priority of the job same as cpu job scheduling
 * @param  {boolean}  fullFrameJob If set to true, then only this job will be executed in a single
 *                                 requestFrame. Other jobs with fullFrameJob set to true will be
 *                                 executed in the next requestFrame. But a non-fullFrameJob and a
 *                                 fullFrameJob can be executed in a single requestFrame if time
 *                                 permits.
 * @param  {boolean}  addToTop     If two jobs with same priority are set to be executed then it
 *                                 is executed as FIFO. But if addToTop is set to true then the
 *                                 second job is executed before the first job.
 * @return {number}                A unique job id.
 */
schedular.addJob = function (job, priority, fullFrameJob, addToTop) {
  var jobID,
      jobObj,
      i,
      position = 0,
      loopLimit = addToTop ? priority - 1 : priority;

  if (typeof job === 'function') {
    jobID = 'JOB' + ++jobCount + (priority || 1);
    // Creating custom job object.
    jobObj = {
      job: job,
      priority: priority,
      fullFrameJob: fullFrameJob,
      jobID: jobID
    };
  } else {
    // Applicable during resuming a paused job.
    jobObj = job;
  }

  // Getting the postion where the job is to be added in the jobList array.
  for (i = 0; i <= loopLimit; i++) {
    position += priorityList[i] || 0;
  }

  jobList.splice(position, 0, jobObj);

  jobByID[jobID] = jobObj;
  // Incrementing the priority list array as per the job priority.
  priorityList[priority] = (priorityList[priority] || 0) + 1;

  jobList.length === 1 && jobFrame(executeFrame);
  return jobID;
};

/**
 * This function is used to remove a registered job
 * @param {number} jobID The unique job id
 */
schedular.removeJob = function (jobID) {
  if (jobByID[jobID]) {
    delete jobByID[jobID];
  }
};

/**
 * This function is used to pause a scheduled job.
 * @param  {number}  jobID The unique job id
 * @return {boolean}       Returns false if the given job ID is not found. Else it deletes the
 *                         job and returns undefined.
 */
schedular.pauseExecution = function (jobID) {
  if (jobByID[jobID]) {
    pausedList[jobByID[jobID]] = jobByID[jobID];
    delete jobByID[jobID];
  } else {
    return false;
  }
};

/**
 * This function is used to resume a scheduled job.
 * @param  {number}   jobID The unique job id
 * @return {boolean}       Returns false if the given job ID could not be found. Else, it
 *                         executes the job and returns undefined
 */
schedular.resumeExecution = function (jobID) {
  var jobObj = pausedList[jobID];
  if (jobObj) {
    schedular.addJob(jobObj);
    delete pausedList[jobID];
  } else {
    return false;
  }
};

exports['default'] = schedular;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(327), __esModule: true };

/***/ }),
/* 43 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(370)
  , defined = __webpack_require__(132);
module.exports = function(it){
  return IObject(defined(it));
};

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports._calculateMaxMin = undefined;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _area = __webpack_require__(20);

var _area2 = _interopRequireDefault(_area);

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var win = window,
    Image = win.Image,
    BLANKSTRING = '',

// hot tracker threshold in pixels
HTP = _lib.hasTouch ? _lib.TOUCH_THRESHOLD_PIXELS : _lib.CLICK_THRESHOLD_PIXELS,
    hiddenStr = _lib.preDefStr.hiddenStr,
    SETROLLOVERATTR = _lib.preDefStr.setRolloverAttrStr,
    SETROLLOUTATTR = _lib.preDefStr.setRolloutAttrStr,
    M = 'M',
    L = 'L',
    Z = 'Z',
    C = 'C',
    math = Math,
    mathSqrt = math.sqrt,
    mathMin = math.min,
    mathMax = math.max,
    mathAbs = math.abs,
    MAX_MITER_LINEJOIN = 2,

/**
 * getSplineExtremities is called to get back the maximum and minimum y values of the vertical envelope
 * of a spline. The data may contain null data values, to be tackled based on the connectNullData setting.
 * For connectNullData = 0, the curve splits into separate spline curves, to be tackled via recursivion,
 * as below. The parameters index and limits are left blank for the initial call to this method, used only
 * for recursion, tackled from within the method.
 */
getSplineExtremities = function getSplineExtremities(data, chartWidth, connectNullData, index, limits) {
  // array to hold the pertinent data only, required for gradients' calculations
  var arrKnot = [],
      validValueFound = false,
      u = index || 0;

  limits = limits || { max: Number.MIN_VALUE, min: Number.MAX_VALUE };

  // populating arrKnot with pertinent data by iterating and checking
  for (; u < data.length; ++u) {
    // checking for if the first valid data value is found
    if (!validValueFound) {
      // if data value is valid
      if (!isNaN(data[u].config.setValue) && data[u].config.setValue !== null) {
        validValueFound = true;
        // just ingore the null/invalid data value, for the first valid data value is yet to be found
      } else {
        continue;
      }
      // reach this position if the first valid data value is found for this data value itself
      arrKnot.push({
        index: u,
        y: data[u].config.setValue
      });
      // if valid first data value is already found
    } else {
      // for invalid data value
      if (isNaN(data[u].config.setValue) || data[u].config.setValue === null) {
        if (connectNullData) {
          // just ignore the data
          continue;
        } else {
          // split here, to end the curve and start a new curve
          break;
        }
      } else {
        arrKnot.push({
          index: u,
          y: data[u].config.setValue
        });
      }
    }
  }
  // spline curve is possible for a set of plots with more than 2 points
  if (arrKnot.length > 2) {
    // Examine the spline curve to find the min-max vertically
    evalSplineExtremities(arrKnot, chartWidth, limits);
  }
  // recursion is required for the case of a series splitted into multiple subset of points due to
  // existence of null data entries in the series
  if (u < data.length && !connectNullData) {
    getSplineExtremities(data, chartWidth, connectNullData, u, limits);
  }
  return limits;
},

/**
 *
 * evalSplineExtremities is called to evaluate the vertical extremities of the bounding box of the spline.
 */
evalSplineExtremities = function evalSplineExtremities(arrKnot, chartWidth, limits) {
  // object to store gradients at spline plots
  var objGrad = {},
      u,
      i,
      t,
      calcValue,
      delX;

  // Below, each gradient is initialised to zero
  for (i = 0; i < arrKnot.length; ++i) {
    // getting the original index for this data
    t = arrKnot[i].index;
    // initialised to zero
    objGrad['D' + t] = 0;
  }

  // The following iteration is a mathematical purpose - iterative method of approximation with faster
  // convergence. The more the number of iteration, more precise are the approximate solutions.
  for (u = 0; u < 10; ++u) {
    // iteration for convergence towards actual solutions
    for (i = 0; i < arrKnot.length; ++i) {
      if (i === 0) {
        calcValue = (3 * (arrKnot[i + 1].y - arrKnot[i].y) - objGrad['D' + arrKnot[i + 1].index]) / 2;
      } else if (i === arrKnot.length - 1) {
        calcValue = (3 * (arrKnot[i].y - arrKnot[i - 1].y) - objGrad['D' + arrKnot[i - 1].index]) / 2;
      } else {
        calcValue = (3 * (arrKnot[i + 1].y - arrKnot[i - 1].y) - objGrad['D' + arrKnot[i + 1].index] - objGrad['D' + arrKnot[i - 1].index]) / 4;
      }
      // gradient value updated in repository for use in subsequent loop/turn for faster convergence
      objGrad['D' + arrKnot[i].index] = calcValue;
    }
  }

  // Since, canvas width is not ready as yet, chart width is used instead to get as close as possible to
  // the required x-interval between two consecutive spline plots
  delX = Math.round(chartWidth / (arrKnot.length - 1));

  // each spline constitutes of a number of smaller curves, each joining two consecutive pioints.
  for (i = 1; i < arrKnot.length; ++i) {
    // find the max-min y-values for the bounding box of the unit curve
    getSegmentExtremities(i, arrKnot, objGrad, limits, delX);
  }
},

/**
 * getSegmentExtremities method is aclled to process unit curves constituting a spline
 * and evaluate the vertical limits of the curve.
 */
getSegmentExtremities = function getSegmentExtremities(index, data, objGradientStore, limits, delX) {
  // storing the reference of the repository of coordinates of the points
  var arrKnot = data,
      i = index,
      j = 0,
      slope1,
      slope2,
      a1,
      a2,
      a3,
      a4,
      maxY,
      minY,
      k,
      n,
      t,
      y1;

  // slopes of the curve at the two extremes of the spline
  slope1 = objGradientStore['D' + arrKnot[j].index];
  slope2 = objGradientStore['D' + arrKnot[i].index];
  // calculating the four coefficients characterising the cubic polynomial
  a1 = arrKnot[j].y;
  a2 = slope1;
  a3 = 3 * (arrKnot[i].y - arrKnot[j].y) - 2 * slope1 - slope2;
  a4 = 2 * (arrKnot[j].y - arrKnot[i].y) + slope1 + slope2;

  maxY = limits.max;
  minY = limits.min;

  for (k = 0, n = delX; k <= n; k++) {
    t = k / n;
    y1 = a1 + a2 * t + a3 * t * t + a4 * t * t * t;

    if (y1 < minY) {
      minY = y1;
    }

    if (y1 > maxY) {
      maxY = y1;
    }
  }

  limits.max = maxY;
  limits.min = minY;
},
    _calculateMaxMin2 = function _calculateMaxMin2() {
  var dataset = this,
      conf = dataset.config,
      chart = dataset.getFromEnv('chart'),
      chartConf = dataset.getFromEnv('chartConfig'),
      chartWidth = chart.origRenderWidth,
      connectNullData = chartConf.connectnulldata,
      minimizeTendency = chartConf.minimizetendency,
      dataStore = dataset.components.data,
      infMin = Number.MIN_VALUE,
      infMax = Number.MAX_VALUE,
      limits;
  if (minimizeTendency === 0) {
    limits = getSplineExtremities(dataStore, chartWidth, connectNullData);
    conf.maxValue = mathMax(conf.maxValue, limits.max);
    conf.minValue = mathMin(conf.minValue, limits.min);
    if (conf.maxValue === infMin) {
      conf.maxValue = 0;
    }
    if (conf.minValue === infMax) {
      conf.minValue = 0;
    }
  }
};

var MSSplineAreaDataset = function (_AreaDataset) {
  _inherits(MSSplineAreaDataset, _AreaDataset);

  function MSSplineAreaDataset() {
    _classCallCheck(this, MSSplineAreaDataset);

    var _this = _possibleConstructorReturn(this, _AreaDataset.call(this));

    _this.drawCommonElements = _lib.stubFN;
    return _this;
  }

  MSSplineAreaDataset.prototype.configure = function configure(datasetObj) {
    var dataset = this;
    _AreaDataset.prototype.configure && _AreaDataset.prototype.configure.call(this, datasetObj);
    dataset._calculateMaxMin();
  };

  MSSplineAreaDataset.prototype._calculateMaxMin = function _calculateMaxMin() {
    _calculateMaxMin2.call(this);
  };

  MSSplineAreaDataset.prototype.getSplinePath = function getSplinePath(dataTemp, yAxis, num, minTend) {
    var getSlope = function getSlope(x1, y1, x2, y2) {
      return (y2 - y1) / (x2 - x1);
    },
        getPointY = function getPointY(x, m, x1, y1) {
      return (x - x1) * m + y1;
    },
        getPointX = function getPointX(y, m, x1, y1) {
      return (y - y1) / m + x1;
    },
        evalX = function evalX(x1, y1, x2, y2) {
      var sinTheta = (y2 - y1) / mathSqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)),
          rearPart = mathAbs(0.5 * sinTheta),
          frontPart = 1 - rearPart;
      return x1 * rearPart + x2 * frontPart;
    },
        cmrcManager = function cmrcManager(curveArr, appendClosePath, endXPos, endYPos) {
      var len = curveArr.length,
          lastCurveCommandArr = curveArr[len - 1],
          len2 = lastCurveCommandArr.length,
          command = lastCurveCommandArr[0],
          lastRecorderXPos = lastCurveCommandArr[len2 - 2];

      // drawing can not continue with less that two cordinates
      if (len2 < 3) {
        return;
      }

      if ((command === 'R' || command === C) && len2 === 3) {
        // draw a straight line instead
        curveArr[len - 1][0] = L;
      }

      if (appendClosePath) {
        curveArr.push([L, lastRecorderXPos, endYPos, endXPos, endYPos, Z]);
        // curveArr.push([L, endXPos, endYPos]);
        // curveArr.push([Z]);
      }
    },
        dataset = this,
        JSONData = dataset.JSONData,
        chart = dataset.getFromEnv('chart'),

    // take the series type
    seriesType = JSONData.renderas || chart.defaultDatasetType,
        isSplineArea = /area/ig.test(seriesType),
        minimizeTendency = minTend,
        arrS = [null],
        curvePath = [],
        linePath = [],
        yBase = yAxis.getAxisBase(),
        yBasePos = yAxis.getAxisPosition(yBase),
        R = 'R',
        lastArrLength,
        lastObj,
        y1,
        y0,
        y2,
        x1,
        x0,
        x2,
        lastYPos,
        lastXPos,
        lineArrLen,
        slope,
        point,
        anchorX,
        anchorY,
        anchorX0,
        anchorY0,
        slopePrev,
        arrLen,
        startingIndex,
        tempArr,
        startXPos,
        prevPoint,
        nextPoint,
        i,
        len;

    for (i = 0, len = dataTemp.length; i < len; i += 1) {
      point = dataTemp[i];
      prevPoint = dataTemp[i - 1] || {};
      nextPoint = dataTemp[i + 1] || {};

      x1 = point.x;
      y1 = point.y;
      x0 = prevPoint.x;
      y0 = prevPoint.y;
      x2 = nextPoint.x;
      y2 = nextPoint.y;

      lastYPos = point.lastYPos;
      lastXPos = point.lastXPos;
      arrLen = curvePath.length;
      lineArrLen = linePath.length;

      if (minimizeTendency) {
        // The new algo to find the spline path
        if (lastYPos !== null) {
          lastObj = tempArr;
          if (i === dataTemp.length - 1) {
            slopePrev = arrS[i - startingIndex - 1];
            anchorX = (x1 + x0) / 2;
            anchorX0 = anchorX;
            anchorY0 = getPointY(anchorX0, slopePrev, x0, y0);

            if (y0 > y1 && anchorY0 < y1 || y0 < y1 && anchorY0 > y1) {
              anchorY0 = y1;
              anchorX0 = getPointX(anchorY0, slopePrev, x0, y0);
            }

            tempArr.push(anchorX0, anchorY0, anchorX, (y1 + y0) / 2, x1, y1);

            curvePath.push(tempArr);
            linePath.push(tempArr);

            isSplineArea && cmrcManager(curvePath, true, startXPos, yBasePos);
            isSplineArea && cmrcManager(linePath, false);
          } else {
            slopePrev = arrS[i - startingIndex - 1];

            // High and Low
            if (y0 > y1 && y2 >= y1 || y0 < y1 && y2 <= y1) {
              slope = 0;
              anchorX = evalX(x0, y0, x1, y1);
              anchorY = y1;

              if (i - startingIndex !== 1) {
                anchorX0 = anchorX;
                anchorY0 = getPointY(anchorX0, slopePrev, x0, y0);

                if (y0 > y1 && anchorY0 < y1 || y0 < y1 && anchorY0 > y1) {
                  anchorY0 = y1;
                  anchorX0 = getPointX(anchorY0, slopePrev, x0, y0);
                }
                tempArr.push(anchorX0, anchorY0, anchorX, anchorY, x1, y1);
              } else {
                tempArr.push((x1 + x0) / 2, (y1 + y0) / 2, anchorX, anchorY, x1, y1);
              }
            } else if (y0 === y1) {
              slope = 0;
              tempArr.push(x0, y0, x1, y1, x1, y1);
              // Rise and decline
            } else if (y0 > y1 && y1 > y2 || y0 < y1 && y1 < y2) {
              slope = getSlope(x0, y0, x2, y2);
              anchorX = evalX(x0, y0, x1, y1);
              anchorY = getPointY(anchorX, slope, x1, y1);

              if (y0 > y1 && anchorY > y0 || y0 < y1 && anchorY < y0) {
                anchorY = y0;
                anchorX = getPointX(anchorY, slope, x1, y1);
              }

              if (i - startingIndex !== 1) {
                anchorX0 = anchorX;
                anchorY0 = getPointY(anchorX0, slopePrev, x0, y0);

                if (y0 > y1 && anchorY0 < y1 || y0 < y1 && anchorY0 > y1) {
                  anchorY0 = y1;
                  anchorX0 = getPointX(anchorY0, slopePrev, x0, y0);
                }
                tempArr.push(anchorX0, anchorY0, anchorX, anchorY, x1, y1);
              } else {
                tempArr.push((x1 + x0) / 2, (y1 + y0) / 2, anchorX, anchorY, x1, y1);
              }
            }
            arrS.push(slope);
          }
        } else if (lastYPos === null && i !== 0) {
          // Raphael Catmull-Rom Curve To fix
          // We can not draw a curve with two datapoints
          // If we have only 2 datapoints, we push the last one again
          lastObj || (lastObj = []);
          if (lastObj[0] === C) {
            curvePath.push(tempArr);
            linePath.push(tempArr);

            isSplineArea && cmrcManager(curvePath, true, startXPos, yBasePos);
            isSplineArea && cmrcManager(linePath, false);
          }

          curvePath.push([M, x1, y1]);
          linePath.push([M, x1, y1]);
          startXPos = x1;
          tempArr = [C];
          startingIndex = i;
          arrS = [null];
        } else {
          // first start
          curvePath.push([M, x1, y1]);
          // line
          linePath.push([M, x1, y1]);
          // store the staring x position
          // this will be nedded to close the line
          startXPos = x1;
          tempArr = [C];
          startingIndex = i;
        }
      } else {
        // Default algo to find the spline path
        if (lastYPos !== null) {
          // This means we have a two consecutive valid points
          // and we will draw a curve.
          if (arrLen >= 2) {
            // This means atleast one command with two values has been inserted.
            // If the last inserted command is not a Catmull-Rom curve command R
            // we have to push one.
            if (curvePath[arrLen - 1][0] === M) {
              curvePath.push([R]);
            }
            // line
            if (linePath[lineArrLen - 1][0] === M) {
              linePath.push([R]);
            }
            // update properties
            arrLen = curvePath.length;
            lineArrLen = linePath.length;
            lastObj = curvePath[arrLen - 1];
            lastArrLength = lastObj.length;
            curvePath[arrLen - 1].push(x1);
            curvePath[arrLen - 1].push(y1);
            //
            linePath[lineArrLen - 1].push(x1);
            linePath[lineArrLen - 1].push(y1);
            // Now for all area charts we need to close path when drawing ends
            // In this case if we have reached the end of data, we close.
            if (i === num - 1) {
              // End of drawing
              // Conncet only if the last command is a curve
              if (lastObj[0] === R) {
                // apply Catmull-Rom-Curve management.
                cmrcManager(curvePath, true, startXPos, yBasePos);
                cmrcManager(linePath, false);
              }
            }
          } else {
            // first start
            curvePath.push([M, lastXPos, lastYPos]);
            curvePath.push([R, x1, y1]);
            // line
            linePath.push([M, lastXPos, lastYPos]);
            linePath.push([R, x1, y1]);
            // store the staring x position
            // this will be nedded to close the line
            startXPos = lastXPos;
          }
        } else if (lastYPos === null && arrLen >= 2) {
          // Raphael Catmull-Rom Curve To fix
          // We can not draw a curve with two datapoints
          // If we have only 2 datapoints, we push the last one again
          lastObj = curvePath[arrLen - 1];
          if (lastObj[0] === R) {
            cmrcManager(curvePath, true, startXPos, yBasePos);
            cmrcManager(linePath, false);
          }

          curvePath.push([M, x1, y1]);
          linePath.push([M, x1, y1]);
          startXPos = x1;
        }
      }
    }

    // If the line is Drawn [R] not closed [!Z] and we have reached the end,
    // We need to close the path with the previous one
    lastObj = curvePath[curvePath.length - 1];
    if (isSplineArea && lastObj) {
      lastArrLength = lastObj.length;
      if (lastObj[lastArrLength - 1] !== Z && (lastObj[0] === R || lastObj[0] === C)) {
        // apply Catmull-Rom-Curve management.
        cmrcManager(curvePath, true, startXPos, yBasePos);
        cmrcManager(linePath, false);
      }
    }

    if (!isSplineArea) {
      curvePath = minimizeTendency ? curvePath : linePath;
      curvePath.length >= 2 && cmrcManager(curvePath, false);
    }

    return {
      closedPath: curvePath,
      openPath: linePath
    };
  };

  // Drawing of splinearea


  MSSplineAreaDataset.prototype.drawPlots = function drawPlots() {
    // retrive requitrd objects
    var dataSet = this,
        conf = dataSet.config,
        chart = dataSet.getFromEnv('chart'),
        JSONData = dataSet.JSONData,
        chartConfig = chart.config,
        datasetIndex = dataSet.index,
        len,
        i,
        num,
        paper = dataSet.getFromEnv('paper'),
        xAxis = dataSet.getFromEnv('xAxis'),
        yAxis = dataSet.getFromEnv('yAxis'),
        setTooltext,
        xPos,
        yPos,
        lastXPos,
        lastYPos = null,
        linePathArr = [],
        dataTemp = [],
        pathObject,
        showTooltip = chartConfig.showtooltip,
        config,
        dataStore = dataSet.components.data,
        dataObj,
        toolText,
        setElement,
        hotElement,
        setLink,
        setValue,
        eventArgs,
        connectNullData = chartConfig.connectnulldata,
        setRolloutAttr,
        setRolloverAttr,
        minimizeTendency = chartConfig.minimizetendency,

    // yBase = yAxis.getAxisBase(),
    previousY,

    // previousYPos,
    plotBorderColor = conf.plotbordercolor,
        plotBorderAlpha = conf.plotborderalpha,
        plotBorderDashStyle = conf.plotBorderDashStyle,
        plotBorderThickness = conf.plotborderthickness,
        container = dataSet.getContainer(),
        pathArr = [],
        splineElement,
        colorArr = conf.fillColor,
        animationObj = chart.get('config', 'animationObj'),
        animation = animationObj.duration,
        animType = animationObj.animType,
        removeDataArr = dataSet.components.removeDataArr || [],
        removeDataArrLen = removeDataArr.length,
        shadowContainer = container && container.shadowGroup,
        shadow = conf.shadow,
        hoverEffects,
        visible = dataSet.getState('visible'),
        imgRef,
        anchorAlpha,
        radius,
        isAnchorVisible,
        anchorShadow,
        anchorProps = {},
        isOnlyLineBorder = !chartConfig.drawfullareaborder,
        polypath,
        pool = dataSet.components.pool || [],
        connector = dataSet.graphics.connector,
        animationManager = dataSet.getFromEnv('animationManager'),
        noOfImages = 0,
        imageElement;
    conf.imagesLoaded = 0;
    if (!dataStore) {
      dataStore = dataSet.components.data;
    }
    len = xAxis.getCategoryLen();
    splineElement = dataSet.graphics.splineElement;
    // create plot elements
    for (i = 0; i < len; i++) {
      dataObj = dataStore[i];
      if (!dataObj) {
        continue;
      }
      config = dataObj && dataObj.config;
      // showValue = config.showValue;
      setValue = config.setValue;
      setLink = config.setLink;
      anchorProps = config.anchorProps;
      anchorShadow = anchorProps.shadow;
      setTooltext = config.setLevelTooltext;
      // setDisplayValue = config.setDisplayValue;
      config && (previousY = setValue >= 0 ? config.previousPositiveY : config.previousNegativeY);
      // label = config.label;
      setElement = dataObj.graphics.element;

      hotElement = dataObj.graphics.hotElement;
      // labelElement = dataObj.graphics.label;
      imageElement = dataObj.graphics.image;
      if (setValue === null) {
        setElement && setElement.hide();
        hotElement && hotElement.hide();
        imageElement && imageElement.hide();
        // labelElement && labelElement.hide();
        if (!connectNullData) {
          lastYPos = null;
          // lastValidValue = false;
        }
      } else {
        // previousYPos = yAxis.getAxisPosition(previousY || yBase);
        yPos = yAxis.getAxisPosition(setValue + (previousY || 0));
        xPos = xAxis.getAxisPosition(i);
        if (visible === false && animation) {
          yPos = yAxis.getPixel(yAxis.getAxisBase());
        }
        // Storing the x Position and y Position in dataObj for future reference
        dataObj._xPos = xPos;
        dataObj._yPos = yPos;

        dataTemp.push({
          x: xPos,
          y: yPos,
          lastXPos: lastXPos,
          lastYPos: lastYPos
        });
        lastXPos = xPos;
        lastYPos = yPos;
        anchorAlpha = anchorProps.anchorAlpha;
        radius = anchorProps.radius;
        isAnchorVisible = radius && anchorAlpha;
        if (!(config.isAnchorsDrawn || conf.drawanchors || isAnchorVisible)) {
          // If no anchor is required the hide anchor
          setElement && !isAnchorVisible && setElement.hide();
          continue;
        }
        hoverEffects = config.hoverEffects;
        if (!showTooltip) {
          toolText = '';
        } else {
          toolText = config.toolText + (setTooltext ? '' : config.toolTipValue);
        }

        config.finalTooltext = toolText;

        eventArgs = config.eventArgs = config.eventArgs || {};

        eventArgs.index = i;
        eventArgs.link = setLink;
        eventArgs.value = setValue;
        eventArgs.displayValue = config.displayValue;
        eventArgs.categoryLabel = xAxis.getLabel(i).label;
        eventArgs.toolText = toolText;
        eventArgs.id = dataSet.userID;
        eventArgs.datasetIndex = datasetIndex || 0;
        eventArgs.datasetName = JSONData.seriesname;
        eventArgs.visible = visible;

        if (hoverEffects.enabled) {
          config.setRolloverAttr = {
            polypath: [hoverEffects.anchorSides || 2, xPos, yPos, hoverEffects.anchorRadius, hoverEffects.startAngle, hoverEffects.dip],
            fill: (0, _lib.toRaphaelColor)({
              color: hoverEffects.anchorColor,
              alpha: hoverEffects.anchorBgAlpha
            }),
            stroke: (0, _lib.toRaphaelColor)({
              color: hoverEffects.anchorBorderColor,
              alpha: hoverEffects.anchorBorderAlpha
            }),
            'stroke-width': hoverEffects.anchorBorderThickness
          };
          config.setRolloutAttr = {
            polypath: [anchorProps.symbol[1] || 2, xPos, yPos, anchorProps.radius, anchorProps.startAngle, 0],
            fill: (0, _lib.toRaphaelColor)({
              color: anchorProps.bgColor,
              alpha: anchorProps.bgAlpha
            }),
            stroke: (0, _lib.toRaphaelColor)({
              color: anchorProps.borderColor,
              alpha: anchorProps.borderAlpha
            }),
            'stroke-width': anchorProps.borderThickness
          };
          setRolloverAttr = config.setRolloverAttr;
          setRolloutAttr = config.setRolloutAttr;
        }

        polypath = [anchorProps.symbol[1] || 2, xPos, yPos, anchorProps.radius, anchorProps.startAngle, 0];
        if (anchorProps.imageUrl) {
          config.anchorImageLoaded = false;
          noOfImages++;
          imgRef = new Image();
          imgRef.onload = dataSet._onAnchorImageLoad(dataSet, i, eventArgs, xPos, yPos);
          imgRef.onerror = dataSet._onErrorSetter(dataSet, i);
          imgRef.src = anchorProps.imageUrl;
        } else {
          imageElement && imageElement.hide();
          if (!setElement) {
            if (pool.element && pool.element.length) {
              setElement = dataObj.graphics.element = pool.element.shift();
            } else {
              setElement = dataObj.graphics.element = paper.polypath(container.plotGroup);
            }
          }
          // Hide any anchor image if there
          imageElement && imageElement.hide();
          animationManager.registerAnimation([{
            animType: animType,
            data: [{
              el: setElement,
              attrs: {
                polypath: polypath,
                fill: (0, _lib.toRaphaelColor)({
                  color: anchorProps.bgColor,
                  alpha: anchorProps.bgAlpha
                }),
                stroke: (0, _lib.toRaphaelColor)({
                  color: anchorProps.borderColor,
                  alpha: anchorProps.borderAlpha
                }),
                'stroke-width': anchorProps.borderThickness,
                'visibility': !anchorProps.radius ? hiddenStr : visible,
                opacity: dataSet.getState('visible') ? 1 : 0
              }
            }]
          }], 'final');
          setElement.show().shadow(anchorShadow, container.anchorShadowGroup).data('anchorRadius', anchorProps.radius).data('anchorHoverRadius', hoverEffects.anchorRadius).data('eventArgs', eventArgs);

          if (hoverEffects.enabled) {
            setElement && setElement.data('anchorRadius', anchorProps.radius).data('anchorHoverRadius', hoverEffects.anchorRadius).data('hoverEnabled', hoverEffects.enabled).data(SETROLLOVERATTR, setRolloverAttr).data(SETROLLOUTATTR, setRolloutAttr);
          }

          config.trackerConfig || (config.trackerConfig = {});

          config.trackerConfig.trackerRadius = mathMax(anchorProps.radius, hoverEffects && hoverEffects.anchorRadius || 0, HTP) + (anchorProps.borderThickness || 0) / 2;
        }
      }
    }
    num = len;
    conf.noOfImages = conf.totalImages = noOfImages;
    if (noOfImages === 0) {
      dataSet.addJob('labelDrawID', dataSet.drawLabel.bind(this), _lib.priorityList.label);
    }

    pathObject = this.getSplinePath(dataTemp, yAxis, num, minimizeTendency);
    pathArr = pathObject.closedPath;
    pathArr = pathArr.join();
    // Drawing Spline Area
    if (!splineElement) {
      splineElement = dataSet.graphics.splineElement = paper.path(container.commonElemsGroup);
    }

    if (pathArr === BLANKSTRING) {
      splineElement.hide();
    } else {
      animationManager.registerAnimation([{
        animType: 'plot',
        data: [{
          el: splineElement,
          attrs: {
            path: pathArr,
            stroke: (0, _lib.toRaphaelColor)({
              color: plotBorderColor,
              alpha: plotBorderAlpha
            }),
            'stroke-width': isOnlyLineBorder ? 0 : plotBorderThickness,
            fill: (0, _lib.toRaphaelColor)(colorArr),
            'stroke-linecap': 'round',
            'stroke-linejoin': plotBorderThickness > MAX_MITER_LINEJOIN ? 'round' : 'miter',
            'stroke-dasharray': plotBorderDashStyle,
            opacity: dataSet.getState('visible') ? 1 : 0
          }
        }]
      }], 'final');
      splineElement.show().shadow(shadow, shadowContainer);
    }
    if (isOnlyLineBorder) {
      if (!connector) {
        connector = dataSet.graphics.connector = paper.path(container.areaGroup);
      }
      animationManager.registerAnimation([{
        animType: 'plot',
        data: [{
          el: connector,
          attrs: {
            path: linePathArr,
            stroke: (0, _lib.toRaphaelColor)({
              color: plotBorderColor,
              alpha: plotBorderAlpha
            }),
            'stroke-width': plotBorderThickness,
            'stroke-linecap': 'round',
            'stroke-linejoin': plotBorderThickness > MAX_MITER_LINEJOIN ? 'round' : 'miter',
            'stroke-dasharray': plotBorderDashStyle,
            opacity: 1
          }
        }]
      }], 'final');
    }

    for (i = 0; i < removeDataArrLen; i++) {
      dataSet._removeDataVisuals(removeDataArr.shift());
    }
  };
  /**
   * Returns the name of the component
   * @return {string} The name of the component, in this case 'column'.
   */


  MSSplineAreaDataset.prototype.getName = function getName() {
    return 'splinearea';
  };

  return MSSplineAreaDataset;
}(_area2['default']);

exports['default'] = MSSplineAreaDataset;
exports._calculateMaxMin = _calculateMaxMin2;

/***/ }),
/* 46 */,
/* 47 */,
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

var dP         = __webpack_require__(38)
  , createDesc = __webpack_require__(75);
module.exports = __webpack_require__(39) ? function(object, key, value){
  return dP.f(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};

/***/ }),
/* 49 */
/***/ (function(module, exports) {

module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys       = __webpack_require__(178)
  , enumBugKeys = __webpack_require__(118);

module.exports = Object.keys || function keys(O){
  return $keys(O, enumBugKeys);
};

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

var store      = __webpack_require__(117)('wks')
  , uid        = __webpack_require__(76)
  , Symbol     = __webpack_require__(32).Symbol
  , USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function(name){
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

var global    = __webpack_require__(65)
  , core      = __webpack_require__(82)
  , hide      = __webpack_require__(127)
  , redefine  = __webpack_require__(345)
  , ctx       = __webpack_require__(189)
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})
    , key, own, out, exp;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if(target)redefine(target, key, out, type & $export.U);
    // export
    if(exports[key] != out)hide(exports, key, exp);
    if(IS_PROTO && expProto[key] != out)expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library` 
module.exports = $export;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

var dP         = __webpack_require__(54)
  , createDesc = __webpack_require__(89);
module.exports = __webpack_require__(55) ? function(object, key, value){
  return dP.f(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

var anObject       = __webpack_require__(86)
  , IE8_DOM_DEFINE = __webpack_require__(200)
  , toPrimitive    = __webpack_require__(135)
  , dP             = Object.defineProperty;

exports.f = __webpack_require__(55) ? Object.defineProperty : function defineProperty(O, P, Attributes){
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if(IE8_DOM_DEFINE)try {
    return dP(O, P, Attributes);
  } catch(e){ /* empty */ }
  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
  if('value' in Attributes)O[P] = Attributes.value;
  return O;
};

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(88)(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

var store      = __webpack_require__(138)('wks')
  , uid        = __webpack_require__(91)
  , Symbol     = __webpack_require__(36).Symbol
  , USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function(name){
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports._postSpaceManagement = exports._feedAxesRawData = exports._createAxes = undefined;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(14);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _cartesian = __webpack_require__(22);

var _cartesian2 = _interopRequireDefault(_cartesian);

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var chartPaletteStr = { // Palette string and 3d chart palette string
  chart2D: {
    bgColor: 'bgColor',
    bgAlpha: 'bgAlpha',
    bgAngle: 'bgAngle',
    bgRatio: 'bgRatio',
    canvasBgColor: 'canvasBgColor',
    canvasBaseColor: 'canvasBaseColor',
    divLineColor: 'divLineColor',
    legendBgColor: 'legendBgColor',
    legendBorderColor: 'legendBorderColor',
    toolTipbgColor: 'toolTipbgColor',
    toolTipBorderColor: 'toolTipBorderColor',
    baseFontColor: 'baseFontColor',
    anchorBgColor: 'anchorBgColor'
  },
  chart3D: {
    bgColor: 'bgColor3D',
    bgAlpha: 'bgAlpha3D',
    bgAngle: 'bgAngle3D',
    bgRatio: 'bgRatio3D',
    canvasBgColor: 'canvasBgColor3D',
    canvasBaseColor: 'canvasBaseColor3D',
    divLineColor: 'divLineColor3D',
    divLineAlpha: 'divLineAlpha3D',
    legendBgColor: 'legendBgColor3D',
    legendBorderColor: 'legendBorderColor3D',
    toolTipbgColor: 'toolTipbgColor3D',
    toolTipBorderColor: 'toolTipBorderColor3D',
    baseFontColor: 'baseFontColor3D',
    anchorBgColor: 'anchorBgColor3D'
  }
},
    _createAxes,
    _feedAxesRawData,
    _postSpaceManagement,
    mathMax = Math.max;

var MSDyBaseCartesian = function (_MSCartesian) {
  _inherits(MSDyBaseCartesian, _MSCartesian);

  function MSDyBaseCartesian() {
    _classCallCheck(this, MSDyBaseCartesian);

    return _possibleConstructorReturn(this, _MSCartesian.apply(this, arguments));
  }

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  MSDyBaseCartesian.getName = function getName() {
    return 'MSDyBaseCartesian';
  };

  MSDyBaseCartesian.prototype._createAxes = function _createAxes() {
    var iapi = this,
        children,
        canvas = iapi.getChildren('canvas')[0],
        zoomObj = {
      zoomable: true,
      pannable: true
    },
        yAxis,
        xAxis;

    // components.yAxis = [];
    // components.xAxis = [];
    (0, _lib.componentFactory)(iapi, _cartesian2['default'], 'xAxis');
    (0, _lib.componentFactory)(iapi, _cartesian2['default'], 'yAxis', 2);
    children = iapi.getChildren();
    xAxis = children.xAxis[0];
    yAxis = children.yAxis;

    canvas.attachAxis(yAxis[0], true, iapi.zoomY ? zoomObj : {});
    canvas.attachAxis(yAxis[1], true, iapi.zoomY ? zoomObj : {});
    canvas.attachAxis(xAxis, false, iapi.zoomX ? zoomObj : {});

    iapi._setCategories();
  };

  MSDyBaseCartesian.prototype._feedAxesRawData = function _feedAxesRawData() {
    var iapi = this,
        config = iapi.config,
        children = iapi.getChildren(),
        colorM = iapi.getFromEnv('color-manager'),
        dataObj = iapi.jsonData,
        chartAttrs = dataObj.chart,
        xAxisConf,
        yAxis1,
        yAxisConf,
        sYAxisConf,
        is3d = iapi.is3d,
        palleteString = is3d ? chartPaletteStr.chart3D : chartPaletteStr.chart2D,
        yAxis,
        primaryAxisOnleft = config.primaryAxisOnleft = (0, _lib.pluckNumber)(chartAttrs.primaryaxisonleft, 1),
        syncAxisLimits = (0, _lib.pluckNumber)(chartAttrs.syncaxislimits, 0),
        xAxis,
        sYAxisTrendlines = [{ line: [] }],
        pYAxisTrendlines = [{ line: [] }],
        trendlinesArr,
        trendlineObj,
        arrLen,
        len,
        i,
        j,
        trendlines = dataObj.trendlines || [];
    xAxisConf = {
      isVertical: false,
      isReverse: false,
      isOpposit: false,
      outCanfontFamily: (0, _lib.pluck)(chartAttrs.outcnvbasefont, chartAttrs.basefont, 'Verdana,sans'),
      outCanfontSize: (0, _lib.pluckFontSize)(chartAttrs.outcnvbasefontsize, chartAttrs.basefontsize, 10),
      outCancolor: (0, _lib.pluck)(chartAttrs.outcnvbasefontcolor, chartAttrs.basefontcolor, colorM.getColor(palleteString.baseFontColor)).replace(/^#? ([a-f0-9]+)/ig, '#$1'),
      axisNamePadding: chartAttrs.xaxisnamepadding,
      axisValuePadding: chartAttrs.labelpadding,
      axisNameFont: chartAttrs.xaxisnamefont,
      axisNameFontSize: chartAttrs.xaxisnamefontsize,
      axisNameFontColor: chartAttrs.xaxisnamefontcolor,
      axisNameFontBold: chartAttrs.xaxisnamefontbold,
      axisNameFontItalic: chartAttrs.xaxisnamefontitalic,
      axisNameBgColor: chartAttrs.xaxisnamebgcolor,
      axisNameBorderColor: chartAttrs.xaxisnamebordercolor,
      axisNameAlpha: chartAttrs.xaxisnamealpha,
      axisNameFontAlpha: chartAttrs.xaxisnamefontalpha,
      axisNameBgAlpha: chartAttrs.xaxisnamebgalpha,
      axisNameBorderAlpha: chartAttrs.xaxisnameborderalpha,
      axisNameBorderPadding: chartAttrs.xaxisnameborderpadding,
      axisNameBorderRadius: chartAttrs.xaxisnameborderradius,
      axisNameBorderThickness: chartAttrs.xaxisnameborderthickness,
      axisNameBorderDashed: chartAttrs.xaxisnameborderdashed,
      axisNameBorderDashLen: chartAttrs.xaxisnameborderdashlen,
      axisNameBorderDashGap: chartAttrs.xaxisnameborderdashgap,
      useEllipsesWhenOverflow: chartAttrs.useellipseswhenoverflow,
      divLineColor: (0, _lib.pluck)(chartAttrs.vdivlinecolor, chartAttrs.divlinecolor, colorM.getColor(palleteString.divLineColor)),
      divLineAlpha: (0, _lib.pluck)(chartAttrs.vdivlinealpha, chartAttrs.divlinealpha, is3d ? colorM.getColor('divLineAlpha3D') : colorM.getColor('divLineAlpha')),
      divLineThickness: (0, _lib.pluckNumber)(chartAttrs.vdivlinethickness, chartAttrs.divlinethickness, 1),
      divLineIsDashed: Boolean((0, _lib.pluckNumber)(chartAttrs.vdivlinedashed, chartAttrs.vdivlineisdashed, chartAttrs.divlinedashed, chartAttrs.divlineisdashed, 0)),
      divLineDashLen: (0, _lib.pluckNumber)(chartAttrs.vdivlinedashlen, chartAttrs.divlinedashlen, 4),
      divLineDashGap: (0, _lib.pluckNumber)(chartAttrs.vdivlinedashgap, chartAttrs.divlinedashgap, 2),
      showAlternateGridColor: (0, _lib.pluckNumber)(chartAttrs.showalternatevgridcolor, 0),
      alternateGridColor: (0, _lib.pluck)(chartAttrs.alternatevgridcolor, colorM.getColor('altVGridColor')),
      alternateGridAlpha: (0, _lib.pluck)(chartAttrs.alternatevgridalpha, colorM.getColor('altVGridAlpha')),
      numDivLines: chartAttrs.numvdivlines,
      maxLabelHeight: chartAttrs.maxlabelheight,
      labelFont: chartAttrs.labelfont,
      labelFontSize: chartAttrs.labelfontsize,
      labelFontColor: chartAttrs.labelfontcolor,
      labelFontAlpha: chartAttrs.labelalpha,
      labelFontBold: chartAttrs.labelfontbold,
      labelFontItalic: chartAttrs.labelfontitalic,
      axisName: chartAttrs.xaxisname,
      axisMinValue: chartAttrs.xaxisminvalue,
      axisMaxValue: chartAttrs.xaxismaxvalue,
      setAdaptiveMin: chartAttrs.setadaptivexmin,
      adjustDiv: chartAttrs.adjustvdiv,
      labelDisplay: chartAttrs.labeldisplay,
      showLabels: chartAttrs.showlabels,
      rotateLabels: chartAttrs.rotatelabels,
      slantLabel: (0, _lib.pluckNumber)(chartAttrs.slantlabels, chartAttrs.slantlabel),
      labelStep: (0, _lib.pluckNumber)(chartAttrs.labelstep, chartAttrs.xaxisvaluesstep),
      showAxisValues: (0, _lib.pluckNumber)(chartAttrs.showxaxisvalues, chartAttrs.showxaxisvalue),
      showLimits: chartAttrs.showvlimits,
      showDivLineValues: (0, _lib.pluckNumber)(chartAttrs.showvdivlinevalues, chartAttrs.showvdivlinevalues),
      // showZeroPlane: chartAttrs.showvzeroplane,
      zeroPlaneColor: chartAttrs.vzeroplanecolor,
      zeroPlaneThickness: (0, _lib.pluckNumber)(chartAttrs.vzeroplanethickness, chartAttrs.vdivlinethickness, 2),
      zeroPlaneAlpha: (0, _lib.pluckNumber)(chartAttrs.vzeroplanealpha, chartAttrs.vdivlinealpha, config.zeroplanealpha),
      showZeroPlaneValue: chartAttrs.showvzeroplanevalue,
      trendlineColor: chartAttrs.trendlinecolor,
      trendlineToolText: chartAttrs.trendlinetooltext,
      trendlineThickness: chartAttrs.trendlinethickness,
      trendlineAlpha: chartAttrs.trendlinealpha,
      showTrendlinesOnTop: chartAttrs.showtrendlinesontop,
      showAxisLine: is3d ? 0 : (0, _lib.pluckNumber)(chartAttrs.showxaxisline, chartAttrs.showaxislines, chartAttrs.drawAxisLines, 0),
      axisLineThickness: (0, _lib.pluckNumber)(chartAttrs.xaxislinethickness, chartAttrs.axislinethickness, 1),
      axisLineAlpha: (0, _lib.pluckNumber)(chartAttrs.xaxislinealpha, chartAttrs.axislinealpha, 100),
      axisLineColor: (0, _lib.pluck)(chartAttrs.xaxislinecolor, chartAttrs.axislinecolor, '#000000')
    };
    yAxisConf = {
      outCanfontFamily: (0, _lib.pluck)(chartAttrs.outcnvbasefont, chartAttrs.basefont, 'Verdana,sans'),
      outCanfontSize: (0, _lib.pluckFontSize)(chartAttrs.outcnvbasefontsize, chartAttrs.basefontsize, 10),
      outCancolor: (0, _lib.pluck)(chartAttrs.outcnvbasefontcolor, chartAttrs.basefontcolor, colorM.getColor(palleteString.baseFontColor)).replace(/^#? ([a-f0-9]+)/ig, '#$1'),
      axisNamePadding: (0, _lib.pluckNumber)(chartAttrs.pyaxisnamepadding, chartAttrs.yaxisnamepadding),
      axisValuePadding: (0, _lib.pluckNumber)(chartAttrs.pyaxisvaluespadding, chartAttrs.yaxisvaluespadding),
      axisNameFont: (0, _lib.pluck)(chartAttrs.pyaxisnamefont, chartAttrs.yaxisnamefont),
      axisNameFontSize: (0, _lib.pluckNumber)(chartAttrs.pyaxisnamefontsize, chartAttrs.yaxisnamefontsize),
      axisNameFontColor: (0, _lib.pluck)(chartAttrs.pyaxisnamefontcolor, chartAttrs.yaxisnamefontcolor),
      axisNameFontBold: (0, _lib.pluckNumber)(chartAttrs.pyaxisnamefontbold, chartAttrs.yaxisnamefontbold),
      axisNameFontItalic: (0, _lib.pluckNumber)(chartAttrs.pyaxisnamefontitalic, chartAttrs.yaxisnamefontitalic),
      axisNameBgColor: (0, _lib.pluck)(chartAttrs.pyaxisnamebgcolor, chartAttrs.yaxisnamebgcolor),
      axisNameBorderColor: (0, _lib.pluck)(chartAttrs.pyaxisnamebordercolor, chartAttrs.yaxisnamebordercolor),
      axisNameAlpha: (0, _lib.pluckNumber)(chartAttrs.pyaxisnamealpha, chartAttrs.yaxisnamealpha),
      axisNameFontAlpha: (0, _lib.pluckNumber)(chartAttrs.pyaxisnamefontalpha, chartAttrs.yaxisnamefontalpha),
      axisNameBgAlpha: (0, _lib.pluckNumber)(chartAttrs.pyaxisnamebgalpha, chartAttrs.yaxisnamebgalpha),
      axisNameBorderAlpha: (0, _lib.pluckNumber)(chartAttrs.pyaxisnameborderalpha, chartAttrs.yaxisnameborderalpha),
      axisNameBorderPadding: (0, _lib.pluckNumber)(chartAttrs.pyaxisnameborderpadding, chartAttrs.yaxisnameborderpadding),
      axisNameBorderRadius: (0, _lib.pluckNumber)(chartAttrs.pyaxisnameborderradius, chartAttrs.yaxisnameborderradius),
      axisNameBorderThickness: (0, _lib.pluckNumber)(chartAttrs.pyaxisnameborderthickness, chartAttrs.yaxisnameborderthickness),
      axisNameBorderDashed: (0, _lib.pluckNumber)(chartAttrs.pyaxisnameborderdashed, chartAttrs.yaxisnameborderdashed),
      axisNameBorderDashLen: (0, _lib.pluckNumber)(chartAttrs.pyaxisnameborderdashlen, chartAttrs.yaxisnameborderdashlen),
      axisNameBorderDashGap: (0, _lib.pluckNumber)(chartAttrs.pyaxisnameborderdashgap, chartAttrs.yaxisnameborderdashgap),
      axisNameWidth: (0, _lib.pluckNumber)(chartAttrs.pyaxisnamewidth, chartAttrs.yaxisnamewidth),
      useEllipsesWhenOverflow: chartAttrs.useellipseswhenoverflow,
      rotateAxisName: (0, _lib.pluckNumber)(chartAttrs.rotateyaxisname, 1),
      axisName: (0, _lib.pluck)(chartAttrs.pyaxisname, chartAttrs.yaxisname),
      divLineColor: (0, _lib.pluck)(chartAttrs.divlinecolor, colorM.getColor(palleteString.divLineColor)),
      divLineAlpha: (0, _lib.pluck)(chartAttrs.divlinealpha, colorM.getColor('divLineAlpha')),
      divLineThickness: (0, _lib.pluckNumber)(chartAttrs.divlinethickness, 1),
      divLineIsDashed: Boolean((0, _lib.pluckNumber)(chartAttrs.divlinedashed, chartAttrs.divlineisdashed, 0)),
      divLineDashLen: (0, _lib.pluckNumber)(chartAttrs.divlinedashlen, 4),
      divLineDashGap: (0, _lib.pluckNumber)(chartAttrs.divlinedashgap, 2),
      showAlternateGridColor: (0, _lib.pluckNumber)(chartAttrs.showalternatehgridcolor, 1),
      alternateGridColor: (0, _lib.pluck)(chartAttrs.alternatehgridcolor, colorM.getColor('altHGridColor')),
      alternateGridAlpha: (0, _lib.pluck)(chartAttrs.alternatehgridalpha, colorM.getColor('altHGridAlpha')),
      numDivLines: chartAttrs.numdivlines,
      axisMinValue: syncAxisLimits ? (0, _lib.pluckNumber)(chartAttrs.syaxisminvalue, chartAttrs.pyaxisminvalue, chartAttrs.yaxisminvalue) : (0, _lib.pluckNumber)(chartAttrs.pyaxisminvalue, chartAttrs.yaxisminvalue),
      axisMaxValue: syncAxisLimits ? (0, _lib.pluckNumber)(chartAttrs.syaxismaxvalue, chartAttrs.pyaxismaxvalue, chartAttrs.yaxismaxvalue) : (0, _lib.pluckNumber)(chartAttrs.pyaxismaxvalue, chartAttrs.yaxismaxvalue),
      setAdaptiveMin: chartAttrs.setadaptiveymin,
      adjustDiv: chartAttrs.adjustdiv,
      labelStep: chartAttrs.yaxisvaluesstep,
      showAxisValues: (0, _lib.pluckNumber)(chartAttrs.showyaxisvalues, chartAttrs.showyaxisvalue),
      showLimits: (0, _lib.pluckNumber)(chartAttrs.showyaxislimits, chartAttrs.showlimits, iapi.showLimits),
      showDivLineValues: (0, _lib.pluckNumber)(chartAttrs.showdivlinevalues, chartAttrs.showdivlinevalue),
      // showZeroPlane: chartAttrs.showzeroplane,
      zeroPlaneColor: chartAttrs.zeroplanecolor,
      zeroPlaneThickness: (0, _lib.pluckNumber)(chartAttrs.zeroplanethickness, chartAttrs.divlinethickness, config.zeroplanethickness, 2),
      zeroPlaneAlpha: (0, _lib.pluckNumber)(chartAttrs.zeroplanealpha, chartAttrs.divlinealpha, config.zeroplanealpha),
      showZeroPlaneValue: chartAttrs.showzeroplanevalue,
      showZeroPlaneOnTop: config.showzeroplaneontop,
      trendlineColor: chartAttrs.trendlinecolor,
      trendlineToolText: chartAttrs.trendlinetooltext,
      trendlineThickness: chartAttrs.trendlinethickness,
      trendlineAlpha: chartAttrs.trendlinealpha,
      showTrendlinesOnTop: chartAttrs.showtrendlinesontop,
      showAxisLine: is3d ? 0 : (0, _lib.pluckNumber)(chartAttrs.showyaxisline, chartAttrs.showaxislines, chartAttrs.drawAxisLines, 0),
      axisLineThickness: (0, _lib.pluckNumber)(chartAttrs.yaxislinethickness, chartAttrs.axislinethickness, 1),
      axisLineAlpha: (0, _lib.pluckNumber)(chartAttrs.yaxislinealpha, chartAttrs.axislinealpha, 100),
      axisLineColor: (0, _lib.pluck)(chartAttrs.yaxislinecolor, chartAttrs.axislinecolor, '#000000')
    };
    sYAxisConf = {
      outCanfontFamily: (0, _lib.pluck)(chartAttrs.outcnvbasefont, chartAttrs.basefont, 'Verdana,sans'),
      outCanfontSize: (0, _lib.pluckFontSize)(chartAttrs.outcnvbasefontsize, chartAttrs.basefontsize, 10),
      outCancolor: (0, _lib.pluck)(chartAttrs.outcnvbasefontcolor, chartAttrs.basefontcolor, colorM.getColor(palleteString.baseFontColor)).replace(/^#? ([a-f0-9]+)/ig, '#$1'),
      axisNamePadding: chartAttrs.yaxisnamepadding,
      axisValuePadding: chartAttrs.yaxisvaluespadding,
      axisNameFont: chartAttrs.syaxisnamefont,
      axisNameFontSize: chartAttrs.syaxisnamefontsize,
      axisNameFontColor: chartAttrs.syaxisnamefontcolor,
      axisNameFontBold: chartAttrs.syaxisnamefontbold,
      axisNameFontItalic: chartAttrs.syaxisnamefontitalic,
      axisNameBgColor: chartAttrs.syaxisnamebgcolor,
      axisNameBorderColor: chartAttrs.syaxisnamebordercolor,
      axisNameAlpha: chartAttrs.syaxisnamealpha,
      axisNameFontAlpha: chartAttrs.syaxisnamefontalpha,
      axisNameBgAlpha: chartAttrs.syaxisnamebgalpha,
      axisNameBorderAlpha: chartAttrs.syaxisnameborderalpha,
      axisNameBorderPadding: chartAttrs.syaxisnameborderpadding,
      axisNameBorderRadius: chartAttrs.syaxisnameborderradius,
      axisNameBorderThickness: chartAttrs.syaxisnameborderthickness,
      axisNameBorderDashed: chartAttrs.syaxisnameborderdashed,
      axisNameBorderDashLen: chartAttrs.syaxisnameborderdashlen,
      axisNameBorderDashGap: chartAttrs.syaxisnameborderdashgap,
      axisNameWidth: chartAttrs.syaxisnamewidth,
      useEllipsesWhenOverflow: chartAttrs.useellipseswhenoverflow,
      rotateAxisName: (0, _lib.pluckNumber)(chartAttrs.rotateyaxisname, 1),
      axisName: chartAttrs.syaxisname,
      divLineColor: (0, _lib.pluck)(chartAttrs.divlinecolor, colorM.getColor(palleteString.divLineColor)),
      divLineAlpha: (0, _lib.pluck)(chartAttrs.divlinealpha, colorM.getColor('divLineAlpha')),
      divLineThickness: (0, _lib.pluckNumber)(chartAttrs.divlinethickness, 1),
      divLineIsDashed: Boolean((0, _lib.pluckNumber)(chartAttrs.divlinedashed, chartAttrs.divlineisdashed, 0)),
      divLineDashLen: (0, _lib.pluckNumber)(chartAttrs.divlinedashlen, 4),
      divLineDashGap: (0, _lib.pluckNumber)(chartAttrs.divlinedashgap, 2),
      showAlternateGridColor: (0, _lib.pluckNumber)(chartAttrs.showalternatehgridcolor, 1),
      alternateGridColor: (0, _lib.pluck)(chartAttrs.alternatehgridcolor, colorM.getColor('altHGridColor')),
      alternateGridAlpha: (0, _lib.pluck)(chartAttrs.alternatehgridalpha, colorM.getColor('altHGridAlpha')),
      numDivLines: chartAttrs.numdivlines,
      // @todo have to change the y axis max and min value afterwards when percentage axis is ready
      axisMinValue: syncAxisLimits ? (0, _lib.pluckNumber)(chartAttrs.syaxisminvalue, chartAttrs.pyaxisminvalue, chartAttrs.yaxisminvalue) : chartAttrs.syaxisminvalue,
      axisMaxValue: syncAxisLimits ? (0, _lib.pluckNumber)(chartAttrs.syaxismaxvalue, chartAttrs.pyaxismaxvalue, chartAttrs.yaxismaxvalue) : chartAttrs.syaxismaxvalue,
      setAdaptiveMin: chartAttrs.setadaptivesymin || chartAttrs.setadaptiveymin,
      adjustDiv: chartAttrs.adjustdiv,
      labelStep: chartAttrs.yaxisvaluesstep,
      showAxisValues: (0, _lib.pluckNumber)(chartAttrs.showsyaxisvalues, chartAttrs.showsyaxisvalue, chartAttrs.showyaxisvalues, chartAttrs.showyaxisvalue),
      showLimits: (0, _lib.pluckNumber)(chartAttrs.showsecondarylimits, chartAttrs.showyaxislimits, chartAttrs.showlimits),
      showDivLineValues: (0, _lib.pluckNumber)(chartAttrs.showdivlinesecondaryvalue, chartAttrs.showyaxisvalues, chartAttrs.showyaxisvalue, 1),
      // showZeroPlane: chartAttrs.showzeroplane,
      zeroPlaneColor: chartAttrs.zeroplanecolor,
      zeroPlaneThickness: (0, _lib.pluckNumber)(chartAttrs.zeroplanethickness, chartAttrs.divlinethickness, 2),
      zeroPlaneAlpha: chartAttrs.zeroplanealpha,
      showZeroPlaneValue: chartAttrs.showzeroplanevalue,
      trendlineColor: chartAttrs.trendlinecolor,
      trendlineToolText: chartAttrs.trendlinetooltext,
      trendlineThickness: chartAttrs.trendlinethickness,
      trendlineAlpha: chartAttrs.trendlinealpha,
      showTrendlinesOnTop: chartAttrs.showtrendlinesontop,
      showAxisLine: is3d ? 0 : (0, _lib.pluckNumber)(chartAttrs.showsyaxisline, chartAttrs.showaxislines, chartAttrs.drawAxisLines, 0),
      axisLineThickness: (0, _lib.pluckNumber)(chartAttrs.syaxislinethickness, chartAttrs.axislinethickness, 1),
      axisLineAlpha: (0, _lib.pluckNumber)(chartAttrs.syaxislinealpha, chartAttrs.axislinealpha, 100),
      axisLineColor: (0, _lib.pluck)(chartAttrs.syaxislinecolor, chartAttrs.axislinecolor, '#000000')
    };
    xAxisConf.vtrendlines = dataObj.vtrendlines;
    for (i = 0, len = trendlines.length; i < len; i++) {
      trendlinesArr = trendlines[i] && trendlines[i].line || [];
      arrLen = trendlinesArr.length;
      for (j = 0; j < arrLen; j++) {
        trendlineObj = trendlinesArr[j] || {};
        // parentyaxis = (trendlineObj.parentyaxis && trendlineObj.parentyaxis.toLowerCase()) || BLANK;
        if (trendlineObj.parentyaxis === 's') {
          sYAxisTrendlines[0].line.push(trendlineObj);
        } else {
          pYAxisTrendlines[0].line.push(trendlineObj);
        }
      }
    }
    yAxisConf.trendlines = pYAxisTrendlines;
    sYAxisConf.trendlines = sYAxisTrendlines;
    yAxis = children.yAxis[0];
    yAxis1 = children.yAxis[1];
    xAxis = children.xAxis[0];
    if (primaryAxisOnleft === 1) {
      yAxisConf.isVertical = true;
      yAxisConf.isReverse = true;
      yAxisConf.isOpposit = false;

      sYAxisConf.isVertical = true;
      sYAxisConf.isReverse = true;
      sYAxisConf.isOpposit = true;
    } else {
      yAxisConf.isVertical = true;
      yAxisConf.isReverse = true;
      yAxisConf.isOpposit = true;

      sYAxisConf.isVertical = true;
      sYAxisConf.isReverse = true;
      sYAxisConf.isOpposit = false;
    }

    yAxis.configure(yAxisConf);
    yAxis1 && yAxis1.configure(sYAxisConf);
    xAxis.configure(xAxisConf, false, false, false);

    // setting the active to false will not draw the trendline and plot lines
    yAxis1 && yAxis1.setAxisConfig({
      isActive: false,
      isPercent: iapi.isPercentage,
      axisIndex: 1,
      uniqueClassName: 1
    });
  };

  MSDyBaseCartesian.prototype._postSpaceManagement = function _postSpaceManagement() {
    var iapi = this,
        config = iapi.config,
        children = iapi.getChildren(),
        yAxisArr = children.yAxis,
        xAxis = children.xAxis && children.xAxis[0],
        yAxis = yAxisArr[0],
        sYAxis = yAxisArr[1],
        legend = children.legend[0],
        xDepth = config.xDepth,
        canvas = children.canvas[0],
        canvasConfig = canvas.config,
        canvasBorderWidth = canvasConfig.canvasBorderWidth,
        canvasPadding = canvasConfig.canvasPadding,
        canvasPaddingLeft = canvasConfig.canvasPaddingLeft,
        canvasPaddingRight = canvasConfig.canvasPaddingRight,
        canvasPaddingTop = canvasConfig.canvasPaddingTop,
        yAxisStartXPos,
        sYAxisStartXPos,
        primaryAxisOnleft = config.primaryAxisOnleft,
        canvasPaddingBottom = canvasConfig.canvasPaddingBottom;

    xAxis && xAxis.setAxisDimention({
      x: config.canvasLeft + (xDepth || 0) + mathMax(canvasPaddingLeft, canvasPadding),
      y: config.canvasBottom + (config.shift || 0) + canvasBorderWidth,
      opposite: config.canvasTop - canvasBorderWidth,
      axisLength: config.canvasWidth - (xDepth || 0) - mathMax(canvasPaddingLeft, canvasPadding) - mathMax(canvasPaddingRight, canvasPadding)
    });
    if (primaryAxisOnleft) {
      config.yAxisStartXPos = config.canvasLeft - canvasBorderWidth;
      config.sYAxisStartXPos = config.canvasRight + canvasBorderWidth;
    } else {
      config.yAxisStartXPos = config.canvasRight + canvasBorderWidth;
      config.sYAxisStartXPos = config.canvasLeft - canvasBorderWidth;
    }
    yAxisStartXPos = config.yAxisStartXPos;
    sYAxisStartXPos = config.sYAxisStartXPos;
    yAxis && yAxis.setAxisDimention({
      x: yAxisStartXPos,
      y: config.canvasTop + canvasPaddingTop,
      opposite: sYAxisStartXPos,
      axisLength: config.canvasHeight - canvasPaddingTop - canvasPaddingBottom
    });

    sYAxis && sYAxis.setAxisDimention({
      x: sYAxisStartXPos,
      y: config.canvasTop + canvasPaddingTop,
      opposite: yAxisStartXPos,
      axisLength: config.canvasHeight - canvasPaddingTop - canvasPaddingBottom
    });

    xAxis && xAxis.shiftLabels(-xDepth, 0);
    legend.postSpaceManager();

    // Setting the number of columns to be displayed based on numdisplaysets.
    iapi.config.realtimeEnabled && iapi._setRealTimeCategories && iapi._setRealTimeCategories();
    // function for adjusting value padding depending upon data and axis labels.
    canvas.setCanvasPadding();
    iapi.setAxisDimention();
  };

  return MSDyBaseCartesian;
}(_fusioncharts2['default']);

exports._createAxes = _createAxes = MSDyBaseCartesian.prototype._createAxes;
exports._feedAxesRawData = _feedAxesRawData = MSDyBaseCartesian.prototype._feedAxesRawData;
exports._postSpaceManagement = _postSpaceManagement = MSDyBaseCartesian.prototype._postSpaceManagement;
exports._createAxes = _createAxes;
exports._feedAxesRawData = _feedAxesRawData;
exports._postSpaceManagement = _postSpaceManagement;
exports['default'] = MSDyBaseCartesian;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(59);

var _fusioncharts2 = __webpack_require__(35);

var _fusioncharts3 = _interopRequireDefault(_fusioncharts2);

var _lib = __webpack_require__(5);

var _eventApi = __webpack_require__(7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var defaultGaugePaletteOptions = (0, _lib.extend2)({}, _lib.defaultGaugePaletteOptions),
    getDataset = function getDataset(component) {
  var datasets = [];
  component.iterateComponents(function (child) {
    if (child.getType() === 'dataset') {
      datasets.push(child);
    }
  });
  return datasets;
};

var GaugeBase = function (_SSCartesian) {
  _inherits(GaugeBase, _SSCartesian);

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  GaugeBase.getName = function getName() {
    return 'GaugeBase';
  };

  function GaugeBase() {
    _classCallCheck(this, GaugeBase);

    var _this = _possibleConstructorReturn(this, _SSCartesian.call(this));

    _this.defaultPaletteOptions = defaultGaugePaletteOptions;
    _this.multiValueGauge = false;
    _this.decimals = 2;
    _this.formatnumberscale = 0;
    _this.drawAnnotations = true;
    _this.useScaleRecursively = true;
    _this.includeColorRangeInLimits = false;
    _this.isWidget = true;
    _this._clearChart = _lib.stubFN;
    _this._createAxes = _this._createAxes || _lib.stubFN;
    _this._feedAxesRawData = _this._feedAxesRawData || _lib.stubFN;
    _this._setCategories = _this._setCategories || _lib.stubFN;
    _this._realTimeConfigure = _fusioncharts._realTimeConfigure;
    _this._getData = _fusioncharts._getData;
    /**
     * This function feeds real-time data to real-time gauges. In single value gauges (LEDs, Bulb, Cylinder,
     * Thermometer) the function takes a numeric value as the parameter. For Angular gauge and Horizontal Linear
     * gauge, this function accepts two parameters - the dial number and the value to update.
     *
     * @group chart-realtime
     * @see FusionCharts#feedData
     * @see FusionCharts#getData
     * @param {string} value
     * @param {string} label
     */
    _this._setData = _fusioncharts._setData;
    /**
     * @group chart-realtime
     * @see FusionCharts#startUpdate
     * @see FusionCharts#restartUpdate
     * @see FusionCharts#isUpdateActive
     * @see FusionCharts#clearChart
     */
    _this._stopUpdate = _fusioncharts._stopUpdate;
    /**
    * @group chart-realtime
    * @see FusionCharts#startUpdate
    * @see FusionCharts#stopUpdate
    * @see FusionCharts#isUpdateActive
    * @see FusionCharts#clearChart
    */
    _this._restartUpdate = _fusioncharts._restartUpdate;
    /**
    * @group chart-realtime
    * @see FusionCharts#startUpdate
    * @see FusionCharts#stopUpdate
    * @see FusionCharts#clearChart
    * @see FusionCharts#restartUpdate
    */
    _this._isUpdateActive = _fusioncharts._isUpdateActive;
    _this.eiMethods = _fusioncharts.eiMethods;
    return _this;
  }

  GaugeBase.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _SSCartesian.prototype.__setDefaultConfig && _SSCartesian.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    config.valuefontbold = 1;
  };
  // Only updates the internal data-structure without updating visuals.


  GaugeBase.prototype.realTimeUpdate = function realTimeUpdate(dataObj) {
    var iapi = this,
        components = iapi.components,
        dataset = components.dataset,
        newDataset = dataObj.dataset,
        newCategory = dataObj.categories && dataObj.categories.category || [],
        realTimeConfig = iapi.config.realTimeConfig = iapi.config.realTimeConfig || (iapi.config.realTimeConfig = {}),
        data,
        length,
        i,
        curDataset;

    if (!iapi.config.cachedArrivedJSON) {
      iapi.config.cachedArrivedJSON = {};
    }

    iapi.config.cachedArrivedJSON = dataObj;

    if (dataset) {
      curDataset = newDataset[0];
      data = curDataset.data;
      for (i = 0, length = data.length; i < length; i++) {
        data[i].label = newCategory[i] && newCategory[i].label;
      }
      // curDataset.data[0].label = newCategory[0].label;
      // dataset[0].updateData(curDataset);
      dataset[0].maxminFlag && (realTimeConfig.maxminFlag = dataset[0].maxminFlag);
    }
  };

  /**
   * Update visuals during real time draw.
   * @param  {boolean} ajaxCall       to decide if the data are fed through ajax or API
   * @param  {string}  stream         raw data that has to be fed to the chart
   * @param  {Object}  prevData       previuosly fed data
   * @param  {string}  url            url for ajax request
   * @param  {number}  ajaxCallLatency ajax call delay
   */


  GaugeBase.prototype.realTimeDraw = function realTimeDraw(ajaxCall, stream, prevData, url, ajaxCallLatency) {
    if (!this.config.cachedArrivedJSON) {
      return;
    }
    var iapi = this,

    // scale = chartChildren.scale && chartChildren.scale[0],
    dataset = getDataset(iapi),

    // sync = realTimeConfig.sync,
    dataObj = iapi.config.cachedArrivedJSON,
        newDataset = dataObj.dataset,
        realTimeConfig = iapi.config.realTimeConfig = iapi.config.realTimeConfig || (iapi.config.realTimeConfig = {}),
        curDataset,
        showRTValue = realTimeConfig.showRTValue,

    // maxminFlag = realTimeConfig.maxminFlag,
    timer,
        eventArgs;

    timer = new Date().getTime();

    // set the state that the realtime update is going to happen
    iapi.state = 'realTimeUpdate';

    // Querying if animation is single step
    iapi.getFromEnv('animationManager').setIsSingleStep();
    // Function to manage during realTime
    iapi.rtManageSpace && iapi._RTmanageSpace();
    if (dataset && dataset.length) {
      curDataset = newDataset[0];
      curDataset.data[0].label = dataObj.categories.category[0].label;
      dataset[0].updateData(curDataset);
      dataset[0].maxminFlag && (realTimeConfig.maxminFlag = dataset[0].maxminFlag);
      dataset[0].asyncDraw();

      iapi.config.cachedArrivedJSON = undefined;

      iapi._preDraw();
      // maxminFlag && scale && scale.asyncDraw();

      showRTValue && iapi._drawRealTimeValue && iapi._drawRealTimeValue();
    }

    iapi._setRTdata && iapi._setRTdata();

    timer = new Date().getTime() - timer;
    eventArgs = {
      data: stream,
      updateObject: realTimeConfig.legacyUpdateObj,
      prevData: prevData,
      source: ajaxCall ? 'XmlHttpRequest' : 'feedData',
      latency: timer
    };

    if (ajaxCall) {
      eventArgs.networkLatency = ajaxCallLatency;
      eventArgs.url = url;
    }
    (0, _eventApi.triggerEvent)('realTimeUpdateComplete', iapi.chartInstance, eventArgs);
  };

  GaugeBase.prototype._setRTmenu = function _setRTmenu() {
    var iapi = this,
        chartMenuTools = iapi.getFromEnv('chartMenuTools'),
        setChartTools = chartMenuTools.set,
        updateChartMenuTools = chartMenuTools.update,
        stopState = false,
        toggle = function toggle() {
      if (stopState) {
        iapi._restartUpdate();
        updateChartMenuTools('Restart Update', 'Stop Update', iapi);
        stopState = false;
      } else {
        iapi._stopUpdate();
        updateChartMenuTools('Stop Update', 'Restart Update', iapi);
        stopState = true;
      }
    };

    setChartTools([{
      'Stop Update': {
        handler: function handler() {
          toggle();
        },
        action: 'click'
      }
    }]);
  };

  return GaugeBase;
}(_fusioncharts3['default']);

exports['default'] = GaugeBase;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports._isUpdateActive = exports._restartUpdate = exports._stopUpdate = exports.eiMethods = exports._setData = exports._getData = exports._realTimeConfigure = undefined;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(14);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _schedular = __webpack_require__(41);

var _schedular2 = _interopRequireDefault(_schedular);

var _lib = __webpack_require__(5);

var _realtimecolumn = __webpack_require__(148);

var _realtimecolumn2 = _interopRequireDefault(_realtimecolumn);

var _column = __webpack_require__(15);

var _column2 = _interopRequireDefault(_column);

var _eventApi = __webpack_require__(7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var NORMALSTRING = 'normal',
    math = Math,
    mathMax = math.max,
    dropHash = _lib.regex.dropHash,
    PXSTRING = 'px',
    convertColor = _lib.graphics.convertColor,
    animationObjStr = _lib.preDefStr.animationObjStr,
    UNDEF = void 0,
    visibleStr = _lib.preDefStr.visibleStr,
    configStr = _lib.preDefStr.configStr,
    getDataset = function getDataset(chart) {
  var canvas = chart.getChildren('canvas')[0],
      vcanvas = canvas.getChildren('vCanvas')[0],
      vcanvasChildren = vcanvas.getChildren(),
      intermediateComponents,
      datasets = [];
  for (var key in vcanvasChildren) {
    if (key === 'dataset') {
      datasets = datasets.concat(vcanvasChildren[key]);
      continue;
    }
    intermediateComponents = vcanvasChildren[key];
    for (var index = 0; index < intermediateComponents.length; index++) {
      if (intermediateComponents[index].getChildren('dataset')) {
        datasets = datasets.concat(intermediateComponents[index].getChildren('dataset'));
      }
    }
  }
  return datasets;
},
    eiMethods = {
  feedData: function feedData() {
    var chartContainer = this,
        chart = chartContainer.apiInstance,
        list = chart.getJobList(),
        callback = arguments[1],
        updateStr,
        output,
        asyncRender = chart.chartInstance.args.asyncRender;
    if (asyncRender || callback) {
      updateStr = arguments[0];
      list.eiMethods.push(_schedular2['default'].addJob(function () {
        output = chart.feedData(updateStr);
        if (typeof callback === 'function') {
          callback(output);
        }
      }, _lib.priorityList.postRender));
    } else {
      return chart.feedData.apply(chart, arguments);
    }
  },

  setData: function setData() {
    var chart = this.apiInstance,
        list = chart.getJobList(),
        asyncRender = chart.chartInstance.args.asyncRender;
    asyncRender ? list.eiMethods.push(_schedular2['default'].addJob(chart._setData, chart, arguments, _lib.priorityList.postRender)) : chart._setData.apply(chart, arguments);
  },

  stopUpdate: function stopUpdate() {
    var chart = this.apiInstance,
        list = chart.getJobList(),
        asyncRender = chart.chartInstance.args.asyncRender;
    asyncRender ? list.eiMethods.push(_schedular2['default'].addJob(chart._stopUpdate, _lib.priorityList.postRender)) : chart._stopUpdate.apply(chart, arguments);
  },

  restartUpdate: function restartUpdate() {
    this.apiInstance._restartUpdate.apply(this.apiInstance, arguments);
  },

  isUpdateActive: function isUpdateActive() {
    return this.apiInstance._isUpdateActive.apply(this.apiInstance, arguments);
  },

  clearChart: function clearChart() {
    var chart = this.apiInstance,
        list = chart.getJobList(),
        asyncRender = chart.chartInstance.args.asyncRender;
    asyncRender ? list.eiMethods.push(_schedular2['default'].addJob(chart._clearChart, _lib.priorityList.postRender)) : chart._clearChart.apply(chart, arguments);
  },

  getData: function getData() {
    return this.apiInstance._getData.apply(this.apiInstance, arguments);
  },

  showLog: function showLog() {
    var msLogger = this.apiInstance.components && this.apiInstance.components.messageLogger;
    return msLogger && msLogger.show && msLogger.show.apply(msLogger, arguments);
  },

  hideLog: function hideLog() {
    var msLogger = this.apiInstance.components && this.apiInstance.components.messageLogger;
    return msLogger && msLogger.hide && msLogger.hide.apply(msLogger, arguments);
  },

  clearLog: function clearLog() {
    var msLogger = this.apiInstance.components && this.apiInstance.components.messageLogger;
    return msLogger && msLogger.clearLog && msLogger.clearLog.apply(msLogger, arguments);
  },

  getDataForId: function getDataForId() {
    return this.apiInstance._getDataForId.apply(this.apiInstance, arguments);
  },

  setDataForId: function setDataForId() {
    return this.apiInstance._setDataForId.apply(this.apiInstance, arguments);
  },

  getDataJSON: function getDataJSON() {
    return this.apiInstance._getDataJSON.apply(this.apiInstance, arguments);
  }
};

function _setData(value, label) {
  var stream = _lib.BLANKSTRING;

  if (value && value.toString || value === _lib.BLANKSTRING || value === 0) {
    stream = 'value=' + value.toString();
  }
  if (label && label.toString || label === _lib.BLANKSTRING) {
    stream = stream + '&label=' + label.toString();
  }
  if (stream) {
    this.feedData(stream);
  }
}
/**
 * This function feeds real-time data to real-time gauges. In single value gauges (LEDs, Bulb, Cylinder,
 * Thermometer) the function takes a numeric value as the parameter. For Angular gauge and Horizontal Linear
 * gauge, this function accepts two parameters - the dial number and the value to update.
 *
 * @group chart-realtime
 * @see FusionCharts#feedData
 * @see FusionCharts#getData
 * @param {string} value
 * @param {string} label
 */

function _getData() {
  var iapi = this,
      components = iapi.components,
      dataset = components.dataset,
      xAxis = components.xAxis && components.xAxis[0] || components.scale,
      length,
      i,
      j,
      store = [],
      maxLength = 0,
      data,
      innerStore;

  if (dataset) {
    length = dataset.length;
    // Finding the dataset with maximum length
    for (i = 0; i < length; i++) {
      maxLength = mathMax(maxLength, dataset[i].components.data.length);
    }

    for (i = 0; i < maxLength; i++) {
      innerStore = store[i] = [];

      innerStore[0] = xAxis.getLabel(i).label;
      for (j = 1; j <= length; j++) {
        data = dataset[j - 1].components.data[i];
        innerStore[j] = data && data.config.setValue;
      }
    }
    return store;
  }
}

function _realTimeConfigure() {
  var iapi = this,
      config = iapi.config,
      animationObj = config.animationObj,
      realTimeConfig = config.realTimeConfig || (config.realTimeConfig = {}),
      refreshInterval,
      realtimeValueFontColor,
      realtimeValueFontSize,
      showRTmenuItem,
      jsonData = iapi.jsonData,
      chartAttrs = jsonData.chart,
      catLen = jsonData.categories && jsonData.categories[0] && jsonData.categories[0].category && jsonData.categories[0].category.length || 0;

  // Parsing the real time attributes
  realTimeConfig.showRTValue = (0, _lib.pluckNumber)(chartAttrs.showrealtimevalue, 1);
  realTimeConfig.dataStreamURL = (0, _lib.parseUnsafeString)(chartAttrs.datastreamurl, _lib.BLANKSTRING);
  realTimeConfig.dataStamp = chartAttrs.datastamp;
  realTimeConfig.useMessageLog = (0, _lib.pluckNumber)(chartAttrs.usemessagelog, 0);
  realTimeConfig.clearInterval = (0, _lib.pluckNumber)(chartAttrs.clearchartinterval, 0);
  realTimeConfig.realtimeValueSeparator = (0, _lib.pluck)(chartAttrs.realtimevaluesep, _lib.COMMASPACE);
  realTimeConfig.refreshInterval = refreshInterval = (0, _lib.pluckNumber)(chartAttrs.refreshinterval, chartAttrs.updateinterval, 2);
  realTimeConfig.updateInterval = iapi.config.updateInterval = (0, _lib.pluckNumber)(chartAttrs.updateinterval, refreshInterval);
  realTimeConfig.realtimeValuePadding = (0, _lib.pluckNumber)(chartAttrs.realtimevaluepadding);
  realTimeConfig.realtimeValueFont = (0, _lib.pluck)(chartAttrs.realtimevaluefont, _lib.BLANKSTRING);
  realTimeConfig.realtimeValueFontBold = (0, _lib.pluck)(chartAttrs.realtimevaluefontbold, 0);
  realTimeConfig.realtimeValueFontColor = realtimeValueFontColor = (0, _lib.pluck)(chartAttrs.realtimevaluefontcolor, _lib.BLANKSTRING);
  realTimeConfig.realtimeValueFontSize = realtimeValueFontSize = (0, _lib.pluckNumber)(chartAttrs.realtimevaluefontsize, _lib.BLANKSTRING);
  realTimeConfig.realTimeValuePadding = (0, _lib.pluckNumber)(chartAttrs.realtimevaluepadding, 5);
  realTimeConfig.fontWeight = (0, _lib.pluckNumber)(chartAttrs.realtimevaluefontbold, 0) ? 'bold' : NORMALSTRING;
  realTimeConfig.numDisplaySets = (0, _lib.pluckNumber)(chartAttrs.numdisplaysets, mathMax(catLen, 15));
  realTimeConfig.refreshInstantly = (0, _lib.pluckNumber)(chartAttrs.refreshinstantly, 0);
  realTimeConfig.showRTmenuItem = showRTmenuItem = (0, _lib.pluckNumber)(chartAttrs.showrtmenuitem, 0);

  // chartAnimation is forced to sync
  realTimeConfig.sync = (0, _lib.pluckNumber)(chartAttrs.sync, refreshInterval > 0.6);

  if (realtimeValueFontColor) {
    realTimeConfig.realtimeValueFontColor = realtimeValueFontColor.replace(dropHash, _lib.HASHSTRING);
  }

  if (realtimeValueFontSize) {
    realTimeConfig.realtimeValueFontSize = realtimeValueFontSize + PXSTRING;
  }

  refreshInterval *= 1000;
  animationObj.duration > refreshInterval && (animationObj.duration = refreshInterval);
  if (showRTmenuItem) {
    iapi._setRTmenu();
  }
}
/**
 * @group chart-realtime
 * @see FusionCharts#startUpdate
 * @see FusionCharts#restartUpdate
 * @see FusionCharts#isUpdateActive
 * @see FusionCharts#clearChart
 */
function _stopUpdate(source) {
  var iapi = this,
      realTimeConfig = iapi.config.realTimeConfig,
      loadData = iapi.config.timers && iapi.config.timers.setTimeout.loadData,
      chartObj = iapi.chartInstance;

  iapi.getChildren('dataStreamer')[0]._stopUpdate();
  // Clearing previously queqed updates of the chart if any ideally when update interval is less than
  // refresh interval.
  loadData && clearTimeout(loadData);

  realTimeConfig.clearIntervalFlag = false;

  /**
   * This event is raised when the real time update of the chart is stopped .
   *
   * @event Fusioncharts#realTimeUpdateStopped
   * @group chart-realtime
   */

  (0, _eventApi.triggerEvent)('dataRestored', chartObj, {
    source: source
  });
}

/**
 * @group chart-realtime
 * @see FusionCharts#startUpdate
 * @see FusionCharts#stopUpdate
 * @see FusionCharts#isUpdateActive
 * @see FusionCharts#clearChart
 */
function _restartUpdate() {
  this.getChildren('dataStreamer')[0]._restartUpdate();
}

/**
 * @group chart-realtime
 * @see FusionCharts#startUpdate
 * @see FusionCharts#stopUpdate
 * @see FusionCharts#clearChart
 * @see FusionCharts#restartUpdate
 */
function _isUpdateActive() {
  var state = this.chartInstance.__state;

  return !state._rtPaused;
}

var RealtimeColumn = function (_MSCartesian) {
  _inherits(RealtimeColumn, _MSCartesian);

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  RealtimeColumn.getName = function getName() {
    return 'RealtimeColumn';
  };

  function RealtimeColumn() {
    _classCallCheck(this, RealtimeColumn);

    var _this = _possibleConstructorReturn(this, _MSCartesian.call(this));

    _this.showRTvalue = true;
    _this.canvasPadding = true;
    _this.isRealTime = true;
    _this.defaultDatasetType = 'realtimecolumn';
    _this.transposeAxis = true;
    _this.rtManageSpace = true;
    _this._realTimeConfigure = _realTimeConfigure;
    _this._getData = _getData;
    _this._setData = _setData;
    _this._stopUpdate = _stopUpdate;
    _this._isUpdateActive = _isUpdateActive;
    _this._restartUpdate = _restartUpdate;
    _this.eiMethods = eiMethods;
    return _this;
  }

  RealtimeColumn.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _MSCartesian.prototype.__setDefaultConfig && _MSCartesian.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    config.enablemousetracking = true;
  };

  // Setting the number of categories to be shown.


  RealtimeColumn.prototype._setRealTimeCategories = function _setRealTimeCategories() {
    var iapi = this,
        xAxis = iapi.getChildren('xAxis')[0],
        tempArr = [],
        realTimeConfig = iapi.config.realTimeConfig,
        clear = realTimeConfig && realTimeConfig.clear,
        categories = clear ? UNDEF : iapi.jsonData.categories && iapi.jsonData.categories[0] && iapi.jsonData.categories[0].category,
        catLen = xAxis.getCategoryLen(),
        numDisplaySets = realTimeConfig.numDisplaySets;

    // Setting category as per numDisplaySets
    catLen = xAxis.getCategoryLen();
    if (catLen < numDisplaySets) {
      tempArr.length = numDisplaySets - catLen;
      categories = categories ? tempArr.concat(categories) : tempArr;
      xAxis.setCategory(categories);
    } else if (catLen > numDisplaySets) {
      categories.splice(numDisplaySets, catLen - numDisplaySets);
      xAxis.setCategory(categories);
    }
  };

  // Spacemanagement for real time value


  RealtimeColumn.prototype._realTimeValuePositioning = function _realTimeValuePositioning(availableHeight) {
    var iapi = this,
        components = iapi.getChildren(),
        smartLabel = iapi.getFromEnv('smartLabel'),
        height,
        space,
        config = iapi.config,
        realTimeConfig = config.realTimeConfig || (config.realTimeConfig = {}),
        padding = realTimeConfig.realTimeValuePadding,
        axisConfig = components.xAxis[0].config,
        style = axisConfig.trend.trendStyle,
        attr = realTimeConfig.style = {
      color: convertColor((0, _lib.pluck)(realTimeConfig.realtimeValueFontColor, style.color), (0, _lib.pluck)(axisConfig.trendlineAlpha, 99)),
      fontFamily: (0, _lib.pluck)(realTimeConfig.realtimeValueFont, style.fontFamily),
      fontSize: (0, _lib.pluck)(realTimeConfig.realtimeValueFontSize, style.fontSize),
      fontWeight: (0, _lib.pluck)(realTimeConfig.fontWeight, style.fontWeight),
      lineHeight: (0, _lib.pluckNumber)(style.lineHeight)
    };

    smartLabel.useEllipsesOnOverflow(config.useEllipsesWhenOverflow);
    smartLabel.setStyle(attr);

    // Setting the height to be left for displaying the value.
    realTimeConfig.height = height = smartLabel.getOriSize(_lib.TESTSTR).height;
    realTimeConfig.canvasBottom = config.canvasBottom;
    space = height + padding;

    if (space > availableHeight) {
      space = availableHeight;
    }
    return {
      bottom: space
    };
  };

  // Drwaing the real time value.


  RealtimeColumn.prototype._drawRealTimeValue = function _drawRealTimeValue() {
    var iapi = this,
        chart = iapi.getFromEnv('chart'),
        config = iapi.config,
        dataset = getDataset(chart),
        paper = iapi.getFromEnv('paper'),
        smartLabel = iapi.getFromEnv('smartLabel'),
        realTimeConfig = config.realTimeConfig,
        realtimeValueSeparator = realTimeConfig.realtimeValueSeparator,
        len = dataset.length,
        displayValue = _lib.BLANKSTRING,
        animationObj = iapi.get(configStr, animationObjStr),
        animObj = animationObj.animObj,
        dummyObj = animationObj.dummyObj,
        animationDuration = animationObj.duration,
        canvasBottom = realTimeConfig.canvasBottom,
        height = realTimeConfig.height,
        canvasLeft = config.canvasLeft,
        canvasRight = config.canvasRight,
        style = realTimeConfig.style || {},
        positionX,
        positionY,
        realTimeValueGraphics = iapi.getGraphicalElement('realTimeValue'),
        chartChildContainer = iapi.getChildContainer(),
        attr,
        parentLayer = chart.getContainer().parentGroup,
        realTimeValueGroup = chartChildContainer.realTimeValueGroup,
        datasetStore,
        drawn,
        prevData,
        dataDisplayValue,
        i;

    if (realTimeConfig.clear && realTimeValueGraphics) {
      realTimeValueGraphics.attr({ text: _lib.BLANKSTRING });
    }

    if (!realTimeValueGroup) {
      realTimeValueGroup = chart.addChildContainer('realTimeValueGroup', paper.group('realTimeValue', parentLayer).insertBefore(chartChildContainer.datalabelsGroup));
    } else {
      for (i = 0; i < len; i++) {
        datasetStore = dataset[i].components.data;
        prevData = datasetStore[datasetStore.length - 1];
        dataDisplayValue = prevData && prevData.config.displayValue;

        displayValue += dataDisplayValue ? dataDisplayValue === UNDEF ? _lib.BLANKSTRING : dataDisplayValue + realtimeValueSeparator : _lib.BLANKSTRING;
      }

      displayValue = displayValue.substring(0, displayValue.length - realtimeValueSeparator.length);
      smartLabel.useEllipsesOnOverflow(config.useEllipsesWhenOverflow);
      smartLabel.setStyle(style);
      positionX = (canvasLeft + canvasRight) / 2;
      positionY = canvasBottom - height / 2;

      attr = {
        x: positionX || 0,
        y: positionY || 0,
        'font-size': style.fontSize,
        'font-weight': style.fontWeight,
        'font-family': style.fontFamily,
        'line-height': style.lineHeight,
        visibility: visibleStr
      };

      if (!realTimeValueGraphics) {
        realTimeValueGraphics = iapi.addGraphicalElement('realTimeValue', paper.text(attr, realTimeValueGroup));
        drawn = true;
      }

      realTimeValueGraphics.attr({
        text: displayValue,
        fill: style.color
      });

      if (realTimeValueGraphics && !drawn) {
        realTimeValueGraphics.show();
        realTimeValueGraphics.animateWith(dummyObj, animObj, attr, animationDuration);
      }
    }
  };

  RealtimeColumn.prototype._hideRealTimeValue = function _hideRealTimeValue() {
    var iapi = this,
        components = iapi.components,
        realTimeValue = components.realTimeValue || (components.realTimeValue = {}),
        graphics = realTimeValue && realTimeValue.graphics;

    graphics && graphics.hide();
  };

  RealtimeColumn.prototype._setRTmenu = function _setRTmenu() {
    var iapi = this,
        chartMenuTools = iapi.getFromEnv('chartMenuTools'),
        setChartTools = chartMenuTools.set,
        updateChartMenuTools = chartMenuTools.update,
        stopState = false,
        toggle = function toggle() {
      if (stopState) {
        iapi._restartUpdate();
        updateChartMenuTools('Restart Update', 'Stop Update', iapi);
        stopState = false;
      } else {
        iapi._stopUpdate();
        updateChartMenuTools('Stop Update', 'Restart Update', iapi);
        stopState = true;
      }
    },
        toolArray = [{
      'Clear Chart': {
        handler: function handler() {
          iapi._clearChart();
        },
        action: 'click'
      }
    }, {
      'Stop Update': {
        handler: function handler() {
          toggle();
        },
        action: 'click'
      }
    }];
    setChartTools(toolArray);
  };

  RealtimeColumn.prototype._getDataJSON = function _getDataJSON() {
    return this.config.realTimeConfig.legacyUpdateObj || {
      values: []
    };
  };

  // Function to copy the original data to a different DS for showing tooltip in RT charts.


  RealtimeColumn.prototype._setRTdata = function _setRTdata() {
    var iapi = this,
        datasets = getDataset(iapi),
        i,
        dataRT,
        dataset,
        removeDataArr,
        removeDataArrLen,
        datasetComponents,
        data,
        dataLen,
        len = datasets.length;

    for (i = len; i--;) {
      dataset = datasets[i];
      datasetComponents = dataset.components;
      removeDataArr = datasetComponents.removeDataArr || [];
      removeDataArrLen = removeDataArr.length;
      data = datasetComponents.data;
      dataLen = data.length;
      dataRT = [].concat(removeDataArr, data.slice(removeDataArrLen, dataLen));
      datasetComponents.dataRT = dataRT;
    }
  };
  /**
   * to get multiseries group class defined
   */


  RealtimeColumn.prototype.getDSGroupdef = function getDSGroupdef() {
    return _column2['default'];
  };
  /**
   * to get Dataset class defined
   */


  RealtimeColumn.prototype.getDSdef = function getDSdef() {
    return _realtimecolumn2['default'];
  };

  return RealtimeColumn;
}(_fusioncharts2['default']);

exports['default'] = RealtimeColumn;
exports._realTimeConfigure = _realTimeConfigure;
exports._getData = _getData;
exports._setData = _setData;
exports.eiMethods = eiMethods;
exports._stopUpdate = _stopUpdate;
exports._restartUpdate = _restartUpdate;
exports._isUpdateActive = _isUpdateActive;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(445);
module.exports = __webpack_require__(66)('Array').map;

/***/ }),
/* 61 */,
/* 62 */,
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(64);
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};

/***/ }),
/* 64 */
/***/ (function(module, exports) {

module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),
/* 65 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(82);
module.exports = function(CONSTRUCTOR){
  var C = core[CONSTRUCTOR];
  return (C.virtual || C.prototype);
};

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.contextMenuSpecAttr = exports.btnSpecAttr = exports.scrollerSpecAttr = undefined;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _lib = __webpack_require__(5);

var _toolBarFactoryHelper = __webpack_require__(25);

var _toolbarFactory = __webpack_require__(416);

var _componentPool = __webpack_require__(422);

var _componentPool2 = _interopRequireDefault(_componentPool);

var _helper = __webpack_require__(26);

var _componentInterface = __webpack_require__(6);

var _componentInterface2 = _interopRequireDefault(_componentInterface);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */

var convertColor = _lib.graphics.convertColor,
    btnSpecAttr = {},
    scrollerSpecAttr = {},
    contextMenuSpecAttr = {},
    componentInstanceCount = 0;
/**
 * Creates Toolbox class
 */

var Toolbox = function (_ComponentInterface) {
  _inherits(Toolbox, _ComponentInterface);

  /**
   * constructor function of Toolbox class
   */
  function Toolbox() {
    _classCallCheck(this, Toolbox);

    var _this = _possibleConstructorReturn(this, _ComponentInterface.call(this));

    _this.onceInitialized = false;
    /*
    * The tool box supports two kind of alignment. ALIGNMENT_HORIZONTAL and ALIGNMENT_VERTICAL.
    * The ALIGNMENT_HORIZONTAL would create a toolbar like
    * --------------------------
    * |    |   |   |   |   |   |
    * --------------------------
    * Where in each rectangular cell one icon is placed.
    * The ALIGNMENT_VERTICAL would rotate it in 90degree
    *
    * For each kind of alignment the toolbox
    * can be placed either in top, right, bottom, left or any combination of these. If two same axis position is
    * given like (POSITION_RIGHT && POSITION_LEFT) then it would position in middle
    */

    _this.ALIGNMENT_HORIZONTAL = parseInt('0', 2);

    _this.ALIGNMENT_VERTICAL = parseInt('1', 2);

    _this.POSITION_TOP = parseInt('00', 2);

    _this.POSITION_RIGHT = parseInt('01', 2);

    _this.POSITION_BOTTOM = parseInt('10', 2);

    _this.POSITION_LEFT = parseInt('11', 2);

    _this.getDefaultConfiguration = function () {
      return btnSpecAttr;
    };
    return _this;
  }

  /**
   * Return the pId/count of instance
   * @return {number} iCount value of instance
   */


  Toolbox.prototype.getICount = function getICount() {
    return this._iCount;
  };

  /**
   * Configure Toolbox
   * @param {Object} options Consists of chart, components, graphics
   */


  Toolbox.prototype.configure = function configure(options) {
    var bPosition,
        bHAlign,

    // hDirection,
    // vDirection,
    bVAlign,
        componentAPI = this,
        chart,
        chartAttrs,
        bSymbolPadding;

    if (!componentAPI.onceInitialized) {
      componentAPI._options = options;
      componentAPI._chart = options.chart;
      componentAPI._iCount = ++componentInstanceCount;
      componentAPI.onceInitialized = true;
    }

    chart = componentAPI._chart;
    chartAttrs = chart.jsonData.chart;

    // Button specific attributes
    btnSpecAttr.scale = (0, _lib.pluckNumber)(chartAttrs.toolbarbuttonscale, 1.15);
    btnSpecAttr.width = (0, _lib.pluckNumber)(chartAttrs.toolbarbuttonwidth, 15);
    btnSpecAttr.height = (0, _lib.pluckNumber)(chartAttrs.toolbarbuttonheight, 15);
    btnSpecAttr.radius = (0, _lib.pluckNumber)(chartAttrs.toolbarbuttonradius, 2);
    btnSpecAttr.spacing = (0, _lib.pluckNumber)(chartAttrs.toolbarbuttonspacing, 5);

    btnSpecAttr.fill = convertColor((0, _lib.pluck)(chartAttrs.toolbarbuttoncolor, 'ffffff'));
    btnSpecAttr.labelFill = convertColor((0, _lib.pluck)(chartAttrs.toolbarlabelcolor, 'cccccc'));
    btnSpecAttr.symbolFill = convertColor((0, _lib.pluck)(chartAttrs.toolbarsymbolcolor, 'ffffff'));
    btnSpecAttr.hoverFill = (0, _lib.pluck)(chartAttrs.toolbarbuttonhovercolor);
    btnSpecAttr.stroke = convertColor((0, _lib.pluck)(chartAttrs.toolbarbuttonbordercolor, 'bbbbbb'));
    btnSpecAttr.symbolStroke = convertColor((0, _lib.pluck)(chartAttrs.toolbarsymbolbordercolor, '9a9a9a'));

    btnSpecAttr.strokeWidth = (0, _lib.pluckNumber)(chartAttrs.toolbarbuttonborderthickness, 1);
    btnSpecAttr.symbolStrokeWidth = (0, _lib.pluckNumber)(chartAttrs.toolbarsymbolborderthickness, 1);
    bSymbolPadding = btnSpecAttr.symbolPadding = (0, _lib.pluckNumber)(chartAttrs.toolbarsymbolpadding, 5);
    btnSpecAttr.symbolHPadding = (0, _lib.pluckNumber)(chartAttrs.toolbarsymbolhpadding, bSymbolPadding);
    btnSpecAttr.symbolVPadding = (0, _lib.pluckNumber)(chartAttrs.toolbarsymbolvpadding, bSymbolPadding);

    bPosition = btnSpecAttr.position = (0, _lib.pluck)(chartAttrs.toolbarposition, 'tr').toLowerCase();
    switch (bPosition) {
      case 'tr':
      case 'rt':
      case 'top right':
      case 'right top':
        bPosition = 'tr';
        break;

      case 'br':
      case 'rb':
      case 'bottom right':
      case 'right bottom':
        bPosition = 'br';
        break;

      case 'tl':
      case 'lt':
      case 'top left':
      case 'left top':
        bPosition = 'tl';
        break;

      case 'bl':
      case 'lb':
      case 'bottom left':
      case 'left bottom':
        bPosition = 'bl';
        break;

      default:
        bPosition = 'tr';
    }
    bHAlign = btnSpecAttr.hAlign = (_lib.BLANKSTRING + chartAttrs.toolbarhalign).toLowerCase() === 'left' ? 'l' : bPosition.charAt(1);
    bVAlign = btnSpecAttr.vAlign = (_lib.BLANKSTRING + chartAttrs.toolbarvalign).toLowerCase() === 'bottom' ? 'b' : bPosition.charAt(0);
    btnSpecAttr.hDirection = (0, _lib.pluckNumber)(chartAttrs.toolbarhdirection, bHAlign === 'r' ? -1 : 1);
    btnSpecAttr.vDirection = (0, _lib.pluckNumber)(chartAttrs.toolbarvdirection, bVAlign === 'b' ? -1 : 1);
    btnSpecAttr.vMargin = (0, _lib.pluckNumber)(chartAttrs.toolbarvmargin, 6);
    btnSpecAttr.hMargin = (0, _lib.pluckNumber)(chartAttrs.toolbarhmargin, 10);
    // btnSpecAttr.x = pluckNumber(chartAttrs.toolbarx, bHAlign === 'l' ? 0: chart.origRenderWidth);
    // btnSpecAttr.y = pluckNumber(chartAttrs.toolbary, bVAlign === 't' ? 0: chart.origRenderHeight);

    if (!chartAttrs.toolbary || !chartAttrs.toolbarx) {
      btnSpecAttr.spaceNotHardCoded = true;
    } else {
      btnSpecAttr.x = (0, _lib.pluckNumber)(chartAttrs.toolbarx);
      btnSpecAttr.y = (0, _lib.pluckNumber)(chartAttrs.toolbary);
      delete btnSpecAttr.spaceNotHardCoded;
    }

    scrollerSpecAttr.color = chartAttrs.scrollcolor && convertColor(chartAttrs.scrollcolor);
    scrollerSpecAttr.padding = (0, _lib.pluckNumber)(chartAttrs.scrollpadding, 0);
    scrollerSpecAttr.height = (0, _lib.pluckNumber)(chartAttrs.scrollheight, 12);
    scrollerSpecAttr.width = (0, _lib.pluckNumber)(chartAttrs.scrollwidth, 12);
    scrollerSpecAttr.displayFlat = (0, _lib.pluckNumber)(chartAttrs.flatscrollbars, 0);
    scrollerSpecAttr.scrollBar3DLighting = (0, _lib.pluckNumber)(chartAttrs.scrollbar3dlighting, 1);
    scrollerSpecAttr.startPercent = Math.min(1, Math.max(0, parseFloat(chartAttrs.scrolltoend) || 0));
    scrollerSpecAttr.showButtons = !!(0, _lib.pluckNumber)(chartAttrs.scrollshowbuttons, 1);
    scrollerSpecAttr.buttonPadding = (0, _lib.pluckNumber)(chartAttrs.scrollbtnpadding, 0);

    contextMenuSpecAttr.baseFontFamily = (0, _lib.pluck)(chartAttrs.basefont, 'Verdana,sans');
    contextMenuSpecAttr.baseFontSize = (0, _lib.pluckNumber)(chartAttrs.basefontsize, 10);
    contextMenuSpecAttr.baseFontColor = (0, _lib.pluck)(chartAttrs.basefontcolor, '595959');
  };

  /**
   * Returns the Factory classes of toolbox
   * @param {string} alignmentType alignment of toolbox (horizontal/vertical)
   * @return {Object} Object consists of Factory classes of toolbox
   */


  Toolbox.prototype.getAPIInstances = function getAPIInstances(alignmentType) {
    var componentAPI = this,
        chart = componentAPI._chart,
        api = {},
        Factory,
        componentPool = componentAPI.componentPool = new _componentPool2['default'](chart, componentAPI._iCount);

    _toolBarFactoryHelper.ToolBarFactoryHelper.setComponentPool(componentPool);
    _toolBarFactoryHelper.ToolBarFactoryHelper.setOptions(componentAPI._options);
    Factory = _toolbarFactory.ToolbarFactory.getAPIInstances();

    switch (alignmentType) {
      case componentAPI.ALIGNMENT_HORIZONTAL:
        // Initialize the horizontal toolbar component
        api.Toolbar = Factory.HorizontalToolbar;
        break;

      case componentAPI.ALIGNMENT_VERTICAL:
        // Initialize the vertical toolbar component
        break;
    }
    api.ComponentGroup = Factory.ComponentGroup;
    api.Symbol = Factory.Symbol;
    api.Scroller = Factory.Scroller;
    api.SymbolWithContext = Factory.SymbolWithContext;
    api.SymbolStore = _helper.SymbolStore;
    api.CheckboxSymbol = Factory.CheckboxSymbol;

    return api;
  };
  /**
   * Hides all the components of Toolbox
   */


  Toolbox.prototype.clean = function clean() {
    var componentAPI = this;
    componentAPI.componentPool.hideRecursive(componentAPI._iCount);
  };

  return Toolbox;
}(_componentInterface2['default']);

exports['default'] = Toolbox;
exports.scrollerSpecAttr = scrollerSpecAttr;
exports.btnSpecAttr = btnSpecAttr;
exports.contextMenuSpecAttr = contextMenuSpecAttr;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.trimData = exports.plotGraphicClick = undefined;

var _iterator = __webpack_require__(9);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(10);

var _symbol2 = _interopRequireDefault(_symbol);

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _typeof = typeof _symbol2['default'] === "function" && typeof _iterator2['default'] === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2['default'] === "function" && obj.constructor === _symbol2['default'] && obj !== _symbol2['default'].prototype ? "symbol" : typeof obj; }; /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */


var _area = __webpack_require__(20);

var _area2 = _interopRequireDefault(_area);

var _eventApi = __webpack_require__(7);

var _lib = __webpack_require__(5);

var _redraphael = __webpack_require__(17);

var _redraphael2 = _interopRequireDefault(_redraphael);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var UNDEF = void 0,
    win = window,
    doc = win.document,
    isVML = _redraphael2['default'].type === 'VML',
    supportsTouch = 'createTouch' in doc,

// The devices which both touch and pointer.
supportsOnlyTouch = supportsTouch && !(win.navigator.maxTouchPoints || win.navigator.msMaxTouchPoints),
    ROLLOVER = 'DataPlotRollOver',
    ROLLOUT = 'DataPlotRollOut',
    EVENTARGS = 'eventArgs',
    TRANSFORMSTR = 't',
    DASH_DEF = 'none',
    convertColor = _lib.graphics.convertColor,
    getDarkColor = _lib.graphics.getDarkColor,
    POINTER = 'pointer',

// SETROLLOVERATTR = 'setRolloverAttr',
// SETROLLOUTATTR = 'setRolloutAttr',
visibleStr = _lib.preDefStr.visibleStr,
    docMode8 = doc.documentMode === 8,
    VISIBLE = docMode8 ? visibleStr : '',
    HIDDEN = 'hidden',
    M = 'M',
    L = 'L',
    dataset = void 0,
    math = Math,
    mathATan2 = math.atan2,
    mathSin = math.sin,
    mathCos = math.cos,
    mathMax = math.max,
    mathMin = math.min,
    mathAbs = math.abs,
    mathCeil = math.ceil,
    mathFloor = math.floor,
    pi = math.PI,
    piBy2 = pi / 2,
    pi2 = 2 * pi,
    pi3By2 = pi + piBy2,
    getLightColor = _lib.graphics.getLightColor,
    legendInteractivity = function legendInteractivity(dataSet, legendItem) {
  var index = legendItem.configuration.index,
      set = dataSet.components.data[index],
      setGraphics = set.graphics;
  plotGraphicClick.call(setGraphics.element);
},

/*
 * Gets the single Fill color.
*/
singleFillColorFn = function singleFillColorFn(color, defaultRadius) {
  var value = defaultRadius ? 1 : UNDEF;
  return (0, _lib.toRaphaelColor)({
    color: (0, _lib.getFirstColor)(color.color, value),
    alpha: (0, _lib.getFirstAlpha)(color.alpha, value)
  });
},

// Function to replace multiple macros in a text
replaceMacros = function replaceMacros(text, macrosArr, valuesArr) {
  var i = macrosArr.length || 0,
      regExpression;
  while (i--) {
    regExpression = new RegExp(macrosArr[i], 'gi');
    text = text.replace(regExpression, valuesArr[i]);
  }
  return text;
},

// // Function to find if a text contains any from a set of macros
// containsMacro = function (text, macrosArr) {
//   var i = macrosArr.length || 0,
//     regExpression,
//     match;
//   while (i--) {
//     regExpression = new RegExp(macrosArr[i], 'gi');
//     match = text.match(regExpression);
//     if (match) {
//       return true;
//     }
//   }
//   return false;
// },
/*
 * Function to get the exact visual position (top, left) of a element
 */
getContainerPosition = function getContainerPosition(el, noscroll) {
  var p = {
    left: 0,
    top: 0
  },
      clientRect;
  // for newer browsers
  if (el.getBoundingClientRect) {
    clientRect = el.getBoundingClientRect();
    p.top = clientRect.top + (win.pageYOffset || doc.scrollTop || 0) - (doc.clientTop || 0);
    p.left = clientRect.left + (win.pageXOffset || doc.scrollLeft || 0) - (doc.clientLeft || 0);
  } else {
    // for very older browsers
    // iterate till the root element of the DOM to get the exact position of the element
    while (el) {
      p.left += el.offsetLeft || 0;
      p.top += el.offsetTop || 0;
      if (el !== doc.body && el !== doc.documentElement && !noscroll) {
        p.left -= el.scrollLeft || 0;
        p.top -= el.scrollTop || 0;
      }
      el = el.offsetParent;
    }
  }
  return p;
},
    getClickArcTangent = function getClickArcTangent(x, y, center, ref, pieYScale) {
  return mathATan2((y - center[1] - ref.top) / pieYScale, x - center[0] - ref.left);
},
    plotDragMove = function plotDragMove(evt) {
  var o = this,
      plotItem = o.data('plotItem'),
      chart = plotItem.chart,
      evtData = evt.data,
      dx = evtData[0],
      dy = evtData[1],
      x = evtData[2],
      y = evtData[3],
      seriesData = plotItem.seriesData,
      datasetConf = dataset.config,
      angle,
      dummyObj = chart.get('config', 'animationObj').dummyObj;

  // Stop dummyobj animation if happening
  dummyObj && dummyObj.stop(UNDEF, true, true);

  if (isNaN(dx) || isNaN(dy) || !datasetConf.enableRotation || seriesData.singletonCase || seriesData.isRightClicked) {
    return;
  }
  angle = getClickArcTangent.call(evt, x, y, seriesData.pieCenter, seriesData.chartPosition, 1);
  if (!seriesData.isRotating) {
    seriesData.dragStartAngle !== angle && (seriesData.isRotating = true);
    /**
     * This event is fired on drag rotation start of pie chart.
     *
     * @event FusionCharts#rotationStart
     * @group chart:pie
     *
     * @param { number} startingAngle - Gives the value of the
     *                 startingAngle of the chart, when the chart
     *                 starts rotating
     */
    (0, _eventApi.triggerEvent)('RotationStart', chart.chartInstance, {
      startingAngle: seriesData._rotationalStartAngle = chart._startingAngle()
    });
  }

  datasetConf.startAngle += angle - seriesData.dragStartAngle;
  seriesData.dragStartAngle = angle;
  seriesData.moveDuration = 0;

  // Check if already there is an initiation for visual updates.
  if (!datasetConf.updateInited) {
    // set the flag to truth value.
    datasetConf.updateInited = true;
    setTimeout(chart._batchRotate || (chart._batchRotate = function () {
      // visually update the chart
      dataset._rotate();
      // turn the flag to falsy after an interval
      datasetConf.updateInited = false;
    }), 50);
  }
},
    plotDragStart = function plotDragStart(evt) {
  var o = this,
      plotItem = o.data('plotItem'),
      chart = plotItem.chart,
      seriesData = plotItem.seriesData,
      datasetConf = dataset.config,
      startingAng = -datasetConf.startAngle,
      angle,
      x = evt.data[0],
      y = evt.data[1];
  seriesData.isRightClicked = !!(!_lib.hasTouch && evt.button !== 0 && evt.button !== 1);

  if (!datasetConf.enableRotation || seriesData.isRightClicked) {
    return;
  }
  seriesData.isRotating = false;
  // Calculate chart's current position. Chart cotainer may be moved mean while
  seriesData.chartPosition = getContainerPosition(chart.getFromEnv('chart-container'));
  angle = getClickArcTangent.call(evt, x, y, seriesData.pieCenter, seriesData.chartPosition, 1);
  seriesData.dragStartAngle = angle;
  seriesData.startingAngleOnDragStart = startingAng;
},
    plotDragEnd = function plotDragEnd(e) {
  var o = this,
      rotaionalEndAngle,
      plotItem = o.data('plotItem'),
      chart = plotItem.chart,
      chartConfig = chart.config,
      seriesData = plotItem.seriesData;
  if (seriesData.isRightClicked) {
    return;
  }

  chartConfig.clicked = true;
  if (!chart.disposed) {
    /* extend2 (chart.logic.chartInstance.jsVars._reflowData,
        reflowUpdate, true); */
    dataset._rotate();
  }

  !seriesData.isRotating && plotGraphicClick.call(plotItem.graphic, e);

  delete chartConfig.clicked;
  if (seriesData.isRotating) {
    /* The events mouseup, dragend and click are raised in order. In order
      * to update the flag isRotating to false post click event, setTimeout
      * called, to take immediate effect, is programmed to update the flag.
      * Thus, the flag gets updated post the series of events, in effect.
      * NB: Click event is subscribed conditionally.
      */
    setTimeout(function () {
      seriesData.isRotating = false;
    }, 0);
    /**
     * This event is fired on drag rotation end of pie chart.
     *
     * @event FusionCharts#rotationEnd
     * @group chart:pie
     *
     * @param { number} changeInAngle - Gives the value by how much
     *                 the chart was rotated
     * @param { number} startingAngle - Gives the value of the
     *                 startingAngle of the chart on rotation end.
     */
    (0, _eventApi.triggerEvent)('RotationEnd', chart.chartInstance, {
      startingAngle: rotaionalEndAngle = chart._startingAngle(),
      changeInAngle: rotaionalEndAngle - seriesData._rotationalStartAngle
    });
  }
  // !chart.isHovered && chart.onPlotHover (o, false);
},
    plotRollOver = function plotRollOver(e) {
  var ele = this,
      plotItem = ele.plotItem || ele.data('plotItem'),
      chart = plotItem.chart,
      centerLabel = chart.getFromEnv('centerLabel'),
      conf = plotItem.seriesData,
      innerDiameter,
      centerLabelText,
      centerLabelConfig;

  if (!conf.isRotating) {
    _lib.plotEventHandler.call(ele, chart, e, ROLLOVER);
    onPlotHover(ele, true);
  }
  conf.isHovered = true;
  innerDiameter = plotItem.innerDiameter;

  if (innerDiameter) {
    (centerLabelConfig = plotItem.centerLabelConfig) && (centerLabelText = centerLabelConfig.label) && centerLabel && centerLabel.draw(centerLabelText, plotItem.center[0], plotItem.center[1], innerDiameter, innerDiameter, centerLabelConfig, false);
  }
},
    onPlotHover = function onPlotHover(plot, hover) {
  var plotItem = plot.data('plotItem'),
      center = plotItem.center,
      rolloverProps = plotItem.rolloverProperties || {},
      color = hover ? rolloverProps.color : plotItem.color,
      borderWidth = hover ? rolloverProps.borderWidth : plotItem.borderWidth,
      borderColor = hover ? rolloverProps.borderColor : plotItem.borderColor;
  if (color) {
    if (hover) {
      color.cx = center[0];
      color.cy = center[1];
      color.r = plotItem.radius;
    }
    rolloverProps.enabled && plotItem.graphic.attr({
      fill: (0, _lib.toRaphaelColor)(color),
      'stroke-width': borderWidth,
      'stroke': borderColor
    });
  }
},
    plotRollOut = function plotRollOut(e) {
  var ele = this,
      plotItem = ele.plotItem || ele.data('plotItem'),
      chart = plotItem.chart,
      centerLabel = chart.getFromEnv('centerLabel'),
      conf = plotItem.seriesData,

  // TODO: enable doughnut center label feature related to enableMultiSlicing
  enableMultiSlicing = true,
      // seriesData.enableMultiSlicing,
  innerDiameter,
      centerLabelConfig,
      centerLabelText;
  if (!conf.isRotating) {
    _lib.plotEventHandler.call(ele, chart, e, ROLLOUT);
    onPlotHover(ele, false);
  }
  conf.isHovered = false;
  innerDiameter = plotItem.innerDiameter;
  if (innerDiameter) {
    (centerLabelConfig = !enableMultiSlicing ? conf.lastCenterLabelConfig : conf.centerLabelConfig) && ((centerLabelText = centerLabelConfig.label) || !centerLabelText) && centerLabel && centerLabel.draw(centerLabelText, plotItem.center[0], plotItem.center[1], innerDiameter, innerDiameter, centerLabelConfig, false);
  }
},
    plotGraphicClick = function plotGraphicClick(evt) {
  var prevTextPos,
      o = this.element || this,
      plotItem = o.plotItem || o.data('plotItem'),
      elData = o.data('eventArgs') || {},
      chart = plotItem.chart,
      index = plotItem.index,
      seriesData = dataset.config,
      enableMultiSlicing = seriesData.enableMultiSlicing,
      set = dataset.components.data[index],
      setGraphics = set.graphics,
      setConfig = set.config,
      doNotSlice = setConfig.doNotSlice,
      atleastOneOtherSliced,
      graphic,
      dataLabel,
      sliced,
      slicedTranslation = setConfig.slicedTranslation,
      transX,
      transY,
      connector,
      connectorPath,
      lastSliceTimeStamp,
      minTimeForNextSlice = 400,
      eventArgs,
      path,
      anim = {
    plot: {
      data: [],
      animType: 'bounce'
    },
    'default': {
      data: []
    },
    initial: {
      data: []
    },
    'final': {
      data: []
    }
  },
      key = '';

  !seriesData.isRotating && _lib.plotEventHandler.call(o, chart, evt);

  if (seriesData.isRotating || seriesData.singletonCase || doNotSlice) {
    return;
  }

  // If 'enableMultiSlicing' is false, sliceInOtherPies is called only once
  // for the clicked pie. From within sliceInOtherPies, 'enableMultiSlicing'
  // is set to true, method plotGraphicClick is called once for each
  // sliced pie and finally, value of 'enableMultiSlicing' is reset to false.
  // Value of multiSliced is always false for plotGraphicClick call from
  // sliceInOtherPies. However, its value may be true or false, by the
  // return value of the sliceInOtherPies.
  atleastOneOtherSliced = !enableMultiSlicing && dataset.sliceInOtherPies(index);

  if ((sliced = setConfig.sliced) && atleastOneOtherSliced) {
    return;
  }

  //
  // In chrome of hybrid touch devices (touch + mouse), slice is getting fired twice for single touch
  // To prevent this cancle slice event within very sort period
  //
  if (supportsTouch && !supportsOnlyTouch) {
    lastSliceTimeStamp = new Date().getTime();
    if (plotItem.lastSliceTimeStamp && lastSliceTimeStamp - plotItem.lastSliceTimeStamp < minTimeForNextSlice) {
      return;
    }

    // store current time stamp
    plotItem.lastSliceTimeStamp = lastSliceTimeStamp;
  }
  graphic = setGraphics.element;
  connector = setGraphics.connector;
  dataLabel = setGraphics.label || setGraphics.dataLabel;
  slicedTranslation = (typeof slicedTranslation === 'undefined' ? 'undefined' : _typeof(slicedTranslation)) === 'object' ? 't' + slicedTranslation : slicedTranslation;
  connectorPath = setConfig.connectorPath;
  transX = (sliced ? -1 : 1) * setConfig.transX;
  transY = (sliced ? -1 : 1) * setConfig.transY;
  eventArgs = graphic.data(EVENTARGS) || graphic.data(EVENTARGS, {});
  /**
   * This event is fired when a pieSlice in pie-chart starts slicing transition.
   *
   * @event FusionCharts#slicingStart
   * @group chart:pie-slice
   *
   * @param { object} data - Contains the values for the following
   *                 attributes borderColor, borderWidth,
   *                 categoryLabel, dashStyle, displayValue,
   *                 hoverEffects (boolean), label, link,
   *                 rolloverProperties (boolean), sliced (boolean),
   *                 toolText, value (value of the sliced object)
   * @param { boolean} slicedState - Tells the state of the slice before
   *                  transition begins. The value is true for
   *                  sliced-out state and false for sliced-in state.
   */
  (0, _eventApi.triggerEvent)('slicingStart', chart.chartInstance, {
    slicedState: sliced,
    dataIndex: 'index' in elData && elData.index,
    data: dataset.getPlotData(index, sliced)
  });

  anim['default'].data.push({
    el: graphic,
    attrs: {
      transform: sliced ? 't0,0' : slicedTranslation
    },
    animType: 'bounce',
    callback: function callback() {
      /**
       * This event is fired when a pieSlice in pie-chart ends slicing transition.
       *
       * @event FusionCharts#slicingEnd
       * @group chart:pie-slice
       *
       * @param { object} data - Contains the values for the following
       *                 attributes borderColor, borderWidth,
       *                 categoryLabel, dashStyle, displayValue,
       *                 hoverEffects (boolean), label, link,
       *                 rolloverProperties (boolean), sliced (boolean),
       *                 toolText, value (value of the sliced object)
       * @param { boolean} slicedState - Tells the state of the slice
       *                  before transition begins. The value is true
       *                  for sliced-out state and false for
       *                  sliced-in state.
       */
      (0, _eventApi.triggerEvent)('slicingEnd', chart.chartInstance, {
        slicedState: sliced,
        dataIndex: 'index' in elData && elData.index,
        data: dataset.getPlotData(index, sliced)
      });
    }
  });

  if (dataLabel && dataLabel.x) {
    if (!(prevTextPos = dataLabel.data('textPos'))) {
      prevTextPos = dataLabel.data('textPos', {
        x: dataLabel.x,
        y: dataLabel.y
      });
    }
    anim['default'].data.push({
      el: dataLabel,
      attrs: {
        x: dataLabel.x + (sliced ? 0 : transX)
      },
      animType: 'bounce'
    });
    prevTextPos.x = dataLabel.x + (sliced ? 0 : transX);
  }

  if (connectorPath) {
    path = connectorPath.slice(0);
    path[1] += transX;
    path[2] += transY;
    path[4] += transX;
    path[6] += transX;
    anim['default'].data.push({
      el: connector,
      attrs: {
        path: path
      },
      animType: 'bounce'
    });
    setConfig.connectorPath = path;
  }
  // updating the slicing information.
  eventArgs.isSliced = sliced = setConfig.sliced = !sliced;

  // TODO: Enable center label feature related to enableMultiSlicing
  // if ((innerDiameter = plotItem.innerDiameter) && !enableMultiSlicing) {
  //  (centerLabelConfig = sliced && plotItem.centerLabelConfig.label ?
  //      plotItem.centerLabelConfig : dataset.centerLabelConfig) &&
  //  (centerLabelText = centerLabelConfig.label) &&
  //  chart.drawDoughnutCenterLabel (centerLabelText, plotItem.center[0], plotItem.center[1],
  //      innerDiameter, innerDiameter, centerLabelConfig, true);
  // }
  // Registering the animations
  for (key in anim) {
    chart.getFromEnv('animationManager').registerAnimation([anim[key]], key);
  }
  return sliced;
},
    sortArrayByPoint = function sortArrayByPoint(a, b) {
  return a.point.value - b.point.value;
},
    sortArrayByAngle = function sortArrayByAngle(a, b) {
  return a.angle - b.angle;
},

// Function that produce the point color
_getPointColor = function _getPointColor(color, alpha, radius3D, defaultRadius) {
  var colorObj, shadowIntensity, shadowColor, highLightIntensity, loLight, hiLight, highLight;
  color = (0, _lib.getFirstColor)(color);
  alpha = (0, _lib.getFirstAlpha)(alpha);
  if (radius3D < 100 && _lib.hasSVG) {
    // radial gradient is not supported in VML
    if (defaultRadius) {
      loLight = getDarkColor(color, mathFloor((85 - 0.2 * (100 - radius3D)) * 100) / 100);

      hiLight = getLightColor(color, mathFloor((100 - 0.5 * radius3D) * 100) / 100);

      colorObj = {
        color: loLight + _lib.COMMASTRING + hiLight + _lib.COMMASTRING + hiLight + _lib.COMMASTRING + loLight,
        alpha: alpha + _lib.COMMASTRING + alpha + _lib.COMMASTRING + alpha + _lib.COMMASTRING + alpha,
        radialGradient: true,
        gradientUnits: 'userSpaceOnUse',
        r: radius3D
      };
    } else {
      shadowIntensity = Math.floor(0.85 * (100 - 0.35 * radius3D) * 100) / 100;
      shadowColor = getDarkColor(color, shadowIntensity);
      highLightIntensity = Math.floor(0.5 * (100 + radius3D) * 100) / 100;
      highLight = getLightColor(color, highLightIntensity);
      colorObj = {
        color: highLight + _lib.COMMASTRING + shadowColor,
        alpha: alpha + _lib.COMMASTRING + alpha,
        ratio: radius3D + ',' + (100 - radius3D),
        radialGradient: true,
        gradientUnits: 'userSpaceOnUse'
      };
    }
  } else {
    colorObj = {
      color: color + _lib.COMMASTRING + color,
      alpha: alpha + _lib.COMMASTRING + alpha,
      ratio: '0,100'
    };
  }

  return colorObj;
},
    alignments = ['start', 'start', 'end', 'end'],
    alignCenter = 'middle',
    ySign = [-1, 1, 1, -1],
    xSign = [1, 1, -1, -1];
/**
 * function to Remove data plots if the number of current data plots/categories
 * is more than the existing ones.
 * @param  {Object} datasetJSON JSON for dataset configurations
 */
function _trimData(datasetJSON) {
  if (!this.JSONData) {
    return;
  }
  var dataSet = this,
      legend = dataSet.getFromEnv('legend'),
      prevData = dataSet.JSONData,
      prevDataLength = prevData.data && prevData.data.length,
      currDataLength = datasetJSON.data && datasetJSON.data.length || 0,
      dataDiff = prevDataLength - currDataLength;
  // Removing data plots if the number of current data plots/categories
  // is more than the existing ones.
  if (dataDiff > 0) {
    legend && legend.emptyItems(prevDataLength - dataDiff);
    dataSet.removeData(currDataLength, dataDiff, false);
  }
}
/**
 * class definition for pie2d dataset chart API
 */

var Pie2DDataset = function (_AreaDataset) {
  _inherits(Pie2DDataset, _AreaDataset);

  /**
   * constructor fn
   */
  function Pie2DDataset() {
    _classCallCheck(this, Pie2DDataset);

    var _this = _possibleConstructorReturn(this, _AreaDataset.call(this));

    _this.type = 'pie2d';
    dataset = _this;
    return _this;
  }
  /**
   * parse defualt configuration of the chart
   */


  Pie2DDataset.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _AreaDataset.prototype.__setDefaultConfig && _AreaDataset.prototype.__setDefaultConfig.call(this);
    this.config.doughnutradius = 0;
  };
  /**
    * Function for parsing all the attributes and value given by the user at chart,dataset and set level.
    * This function is called once from the init() function of the Column class.
    * @param  {Object} datasetJSON JSON for dataset configurations
    * @return {boolean} Indicates whether the configuration was successful or not
    */


  Pie2DDataset.prototype.configure = function configure(datasetJSON) {
    if (!datasetJSON) {
      return false;
    }
    this.trimData(datasetJSON);
    this.JSONData = datasetJSON;
    var dataSet = this,
        chart = dataSet.getFromEnv('chart'),
        chartConfig = chart.config,
        dataLabelStyle = chartConfig.dataLabelStyle,
        conf = dataSet.config,
        JSONData = dataSet.JSONData,
        chartAttr = dataSet.getFromEnv('chart-attrib'),
        is3D = chart.is3D,
        radius3D = void 0,
        use3DLighting = void 0,
        toolTipSepChar = void 0,
        enableMultiSlicing = void 0,
        enableAnimation = void 0;

    // set the default configurations
    dataSet.__setDefaultConfig();
    dataSet.setState('visible', (0, _lib.pluckNumber)(dataSet.JSONData.visible, !Number(dataSet.JSONData.initiallyhidden), 1) === 1);
    (0, _lib.parseConfiguration)({}, dataSet.config, chart && chart.config);

    // reflowData = /*logic.chartInstance.jsVars._reflowData*/ {},
    // reflowDataObj = reflowData.dataObj || (reflowData.dataObj = {}),
    // reflowChartObj = reflowDataObj.chart || (reflowDataObj.chart = {});
    enableAnimation = conf.enableAnimation = (0, _lib.pluckNumber)(chartAttr.animation, chartAttr.defaultanimation, 1);
    conf.animation = !enableAnimation ? false : {
      duration: (0, _lib.pluckNumber)(chartAttr.animationduration, chartAttr.moveduration, 1) * 1000
    };
    conf.transposeAnim = !enableAnimation && !(0, _lib.pluckNumber)(conf.transposeanimation, 1) ? false : {
      duration: (0, _lib.pluckNumber)(chartAttr.transposeanimduration, 0.2) * 1000
    };
    conf.showPlotBorder = (0, _lib.pluckNumber)(chartAttr.showplotborder, 1);
    conf.showHoverEffect = (0, _lib.pluckNumber)(chartAttr.plothovereffect, chartAttr.showhovereffect, UNDEF);
    conf.showTooltip = (0, _lib.pluckNumber)(chartAttr.showtooltip, 1);
    conf.toolText = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(JSONData.plottooltext, chartAttr.plottooltext)));
    // thickness of pie slice border

    enableMultiSlicing = conf.enableMultiSlicing = (0, _lib.pluckNumber)(chartAttr.enablemultislicing, 1);
    // whether to use 3d lighing effect on pie
    use3DLighting = conf.use3DLighting = (0, _lib.pluckNumber)(chartAttr.use3dlighting, 1);
    // radius of the pie 3d lighting effect
    radius3D = conf.radius3D = use3DLighting ? (0, _lib.pluckNumber)(chartAttr.radius3d, 90) : 100;
    // whether to show the zero values on pie
    conf.showZeroPies = (0, _lib.pluckNumber)(chartAttr.showzeropies, 1);
    conf.showPercentInToolTip = (0, _lib.pluckNumber)(chartAttr.showpercentintooltip, 1);
    conf.showLabels = (0, _lib.pluckNumber)(chartAttr.showlabels, 1);
    conf.showValues = (0, _lib.pluckNumber)(JSONData.showvalues, chartAttr.showvalues, 1);
    conf.showPercentValues = (0, _lib.pluckNumber)(chartAttr.showpercentvalues, chartAttr.showpercentagevalues, 0);
    toolTipSepChar = conf.toolTipSepChar = (0, _lib.pluck)(chartAttr.tooltipsepchar, chartAttr.hovercapsepchar, _lib.COMMASPACE);
    conf.labelSepChar = (0, _lib.pluck)(chartAttr.labelsepchar, toolTipSepChar);
    conf.pieBorderColor = (0, _lib.pluck)(chartAttr.plotbordercolor, chartAttr.piebordercolor);
    conf.pieBorderAlpha = (0, _lib.pluckNumber)(chartAttr.plotborderalpha, chartAttr.pieborderalpha);
    conf.pieBorderThickness = conf.showPlotBorder ? (0, _lib.pluckNumber)(chartAttr.plotborderthickness, chartAttr.pieborderthickness, chartConfig.plotborderthickness, 1) : 0;
    // length of the dash
    conf.plotDashLen = (0, _lib.pluckNumber)(chartAttr.plotborderdashlen, 5);
    // distance between dash
    conf.plotDashGap = (0, _lib.pluckNumber)(chartAttr.plotborderdashgap, 4);
    conf.showValueInLegend = (0, _lib.pluckNumber)(chartAttr.showvalueinlegend, 0);
    conf.showLabelInLegend = (0, _lib.pluckNumber)(chartAttr.showlabelinlegend, 1);
    conf.valueBeforeLabelInLegend = (0, _lib.pluckNumber)(chartAttr.valuebeforelabelinlegend, 0);
    conf.showValueAsPercentInLegend = (0, _lib.pluckNumber)(chartAttr.showvalueaspercentinlegend, 1);
    conf.legendSepChar = (0, _lib.pluck)(chartAttr.legendsepchar, ', ');
    conf.showvalues = (0, _lib.pluckNumber)(chartAttr.showvalues, 1);
    conf.chartPosition = (0, _lib.getPosition)(chart.getFromEnv('chart-container'), chart);
    conf.timerThreshold = 30;
    conf.centerLabelConfig = {
      label: (0, _lib.parseUnsafeString)((0, _lib.pluck)(chartAttr.defaultcenterlabel, '')),
      font: (0, _lib.pluck)(chartAttr.centerlabelfont, dataLabelStyle.fontFamily),
      fontSize: (0, _lib.pluckNumber)(chartAttr.centerlabelfontsize, parseInt(dataLabelStyle.fontSize, 10)),

      color: (0, _lib.getFirstColor)((0, _lib.pluck)(chartAttr.centerlabelcolor, chartAttr.valuefontcolor, chartConfig.style.inCanvasStyle.color, '555555')),
      alpha: (0, _lib.pluckNumber)(chartAttr.centerlabelalpha, 100),

      bold: (0, _lib.pluckNumber)(chartAttr.centerlabelbold, dataLabelStyle.fontWeight),
      italic: (0, _lib.pluckNumber)(chartAttr.centerlabelitalic, dataLabelStyle.style),

      bgColor: (0, _lib.pluck)(chartAttr.centerlabelbgcolor, ''),
      bgAlpha: (0, _lib.pluckNumber)(chartAttr.centerlabelbgalpha, 100),

      borderColor: (0, _lib.pluck)(chartAttr.centerlabelbordercolor, dataLabelStyle.borderColor),
      borderAlpha: (0, _lib.pluckNumber)(chartAttr.centerlabelborderalpha, 100),

      borderThickness: (0, _lib.pluckNumber)(chartAttr.centerlabelborderthickness, dataLabelStyle.borderThickness),
      borderRadius: (0, _lib.pluckNumber)(chartAttr.centerlabelborderradius, dataLabelStyle.borderRadius),

      textPadding: (0, _lib.pluckNumber)(chartAttr.centerlabeltextpadding, dataLabelStyle.borderPadding),
      padding: (0, _lib.pluckNumber)(chartAttr.centerlabelpadding, 2),

      bgOval: (0, _lib.pluckNumber)(chartAttr.centerlabelbgoval, 0),
      shadow: (0, _lib.pluckNumber)(chartAttr.showcenterlabelshadow, 0),
      // getFirstColor(pluck(chartAttr.centerlabelhovercolor, chartAttr.centerlabelcolor, '555555')),
      hoverColor: chartAttr.centerlabelhovercolor && (0, _lib.getFirstColor)((0, _lib.pluck)(chartAttr.centerlabelhovercolor)),
      hoverAlpha: (0, _lib.pluckNumber)(chartAttr.centerlabelhoveralpha),

      toolText: (0, _lib.parseUnsafeString)((0, _lib.pluck)(chartAttr.centerlabeltooltext, _lib.BLANKSTRING))
    };

    // radius3d can not be greater than 100 and can not be less than 0
    if (radius3D > 100) {
      radius3D = 100;
    }
    if (radius3D < 0) {
      radius3D = 0;
    }
    // todo need to remove
    conf.showLegend = (0, _lib.pluckNumber)(chartAttr.showlegend, 0);
    conf.reverselegend = !(0, _lib.pluckNumber)(chartAttr.reverselegend, 0);
    // conf.alphaanimation = pluckNumber(chartAttr.alphaanimation, 1);
    // required in 3d
    chart.is3D = is3D;
    conf.pieYScale = (0, _lib.pluckNumber)(chartAttr.pieyscale, 40);
    if (conf.pieYScale < 1) {
      conf.pieYScale = 1;
    }
    // fix for FCXT-296
    if (conf.pieYScale >= 100) {
      conf.pieYScale = 80;
    }
    conf.pieYScale /= 100;

    conf.pieSliceDepth = (0, _lib.pluckNumber)(chartAttr.pieslicedepth, 15);
    if (conf.pieSliceDepth < 1) {
      conf.pieSliceDepth = 1;
    }
    conf.managedPieSliceDepth = conf.pieSliceDepth;

    conf.enableMultiSlicing = !!enableMultiSlicing;

    conf.startAngle = (0, _lib.pluckNumber)(chartAttr.startingangle, 0) * -(pi / 180);
    // HCObj.chart.startingAngle = pluck(dataArr.length > 1 ? FCChartObj.startingangle : 0, 0);
    conf.usePerPointLabelColor = chartAttr.colorlabelsfromplot == _lib.ONESTRING;
    conf.reversePlotOrder = (0, _lib.pluckNumber)(chartAttr.reverseplotorder, 0);
    conf.animateClockWise = (0, _lib.pluckNumber)(chartAttr.animateclockwise, conf.reversePlotOrder);
    conf.showShadow = (0, _lib.pluckNumber)(chartAttr.showshadow, 1);
    conf.singletonCase = JSONData.data.length === 1;
    conf.valueTotal = 0;
    dataSet._setConfigure();
    // add legend items
    dataSet._addLegend();
  };
  /**
   * function to Remove data plots if the number of current data plots/categories
   * is more than the existing ones.
   * @param  {Object} datasetJSON JSON for dataset configurations
   */


  Pie2DDataset.prototype.trimData = function trimData(datasetJSON) {
    _trimData.call(this, datasetJSON);
  };
  /**
   * parse and format display value, tooltext and other texts
   * @param {Object} dataJSON input data json
   * @param {Object} config   config of plot
   */


  Pie2DDataset.prototype._parseDisplayProperties = function _parseDisplayProperties(dataJSON, config) {
    var setTooltext,
        pValue,
        toolText = '',
        TTValue,
        value,
        labelText,
        displayValueText,
        displayValue,
        displayValueArgs,
        showValue,
        dataSet = this,
        chart = dataSet.getFromEnv('chart'),
        numberFormatter = dataSet.getFromEnv('number-formatter'),
        chartAttr = chart.getFromEnv('chart-attrib'),
        conf = dataSet.config,
        dataValue = (0, _lib.pluckNumber)(config.y, numberFormatter.getCleanValue(dataJSON.value, true)),
        totalValue = conf.valueTotal,
        showLabels = conf.showLabels,
        name = (0, _lib.parseUnsafeString)((0, _lib.pluck)(config.seriesName, dataJSON.label, dataJSON.name, _lib.BLANKSTRING)),
        showPercentValues = conf.showPercentValues,
        showPercentInToolTip = conf.showPercentInToolTip,
        labelSepChar = conf.labelSepChar,
        toolTipSepChar = conf.toolTipSepChar,
        showTooltip = conf.showTooltip;
    // Adding label, tooltext, and display value
    setTooltext = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(dataJSON.tooltext, conf.toolText)));
    pValue = config.pValue = numberFormatter.percentValue(dataValue / totalValue * 100);
    value = config.value = numberFormatter.dataLabels(dataValue) || _lib.BLANKSTRING;
    labelText = (0, _lib.pluckNumber)(dataJSON.showlabel, showLabels) === 1 ? name : _lib.BLANKSTRING;
    displayValueText = (showValue = (0, _lib.pluckNumber)(dataJSON.showvalue, conf.showValues)) === 1 ? showPercentValues === 1 ? pValue : value : _lib.BLANKSTRING;
    TTValue = showPercentInToolTip ? pValue : value;
    displayValue = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)(dataJSON.displayvalue));

    // red-1416
    displayValueArgs = (0, _lib.pluck)(displayValue, name + labelSepChar + (showPercentValues ? pValue : value), _lib.BLANKSTRING);

    if (displayValue !== UNDEF && showValue) {
      displayValueText = displayValue;
    } else {
      // create the datalabel str
      if (displayValueText !== _lib.BLANKSTRING && labelText !== _lib.BLANKSTRING) {
        displayValueText = labelText + labelSepChar + displayValueText;
      } else {
        displayValueText = (0, _lib.pluck)(labelText, displayValueText);
      }
    }

    // Create the Tooltext
    if (showTooltip) {
      if (setTooltext !== UNDEF) {
        toolText = (0, _lib.parseTooltext)(setTooltext, [1, 2, 3, 5, 6, 7, 14, 24, 25], {
          formattedValue: value,
          label: name,
          yaxisName: (0, _lib.parseUnsafeString)(chartAttr.yaxisname),
          xaxisName: (0, _lib.parseUnsafeString)(chartAttr.xaxisname),
          percentValue: pValue,
          sum: numberFormatter.dataLabels(totalValue),
          unformattedSum: totalValue
        }, dataJSON, chartAttr);
      } else {
        toolText = name;
        if (toolText != _lib.BLANKSTRING) {
          toolText = toolText + toolTipSepChar + TTValue;
        } else {
          toolText = TTValue;
        }
      }
    }
    config.displayValue = displayValueText;
    config.displayValueArgs = displayValueArgs;
    config.toolText = toolText;
    config.seriesName = name;
    config.categoryLabel = labelText;
  };
  /**
   * function to check whether text style attributes are present in the input json
   * @param {Object} dataJSON - input data json
   * @return {boolean}        - whether text style attributes are present or not
   */


  Pie2DDataset.prototype._isStyled = function _isStyled(dataJSON) {
    var dataSet = this,
        chart = dataSet.getFromEnv('chart'),
        chartConfig = chart.config;

    if (chartConfig.usedataplotcolorforlabels || dataJSON.labelbordercolor || dataJSON.labelbgcolor || dataJSON.labelborderthickness || dataJSON.labelborderalpha || dataJSON.labelalpha || dataJSON.labelfont || dataJSON.labelfontsize || dataJSON.labelfontcolor || dataJSON.labelfontalpha || dataJSON.labelalpha || dataJSON.labelfontbold || dataJSON.labelfontitalic || dataJSON.labelborderpadding || dataJSON.labelborderradius || dataJSON.labelbgalpha || dataJSON.labelborderdashed || dataJSON.labelborderdashlen || dataJSON.labelborderdashgap) {
      return true;
    }
  };
  /**
   * Function for parsing all the attributes and value given by the user at set level.
   * This function is called once from the configure() function of the Column class.
   * @param  {Object} newDataset JSON for dataset configurations for new data only in a case of realtime chart
   * @param  {number} newIndex JSON for dataset configurations for new data only in a case of realtime chart
   */


  Pie2DDataset.prototype._setConfigure = function _setConfigure(newDataset, newIndex) {
    var index,
        name,
        setColor,
        setAlpha,
        borderConfig,
        setPlotBorderColor,
        setPlotBorderAlpha,
        pointShadow,
        displayValue,
        legendText,
        legValue,
        isSliced,
        centerLabelConfig,
        setCenterLabel,
        setBorderDashed,
        pointDashStyle,
        pValue,
        value,
        pluckedHoverColor,
        dataObj,
        tempIndex,
        config,
        dataValue,
        dataConfig,
        dataJSON,
        dataSet = this,
        dataSetComponents = dataSet.components,
        removeDataArr = dataSetComponents.removeDataArr = dataSetComponents.removeDataArr || [],
        chart = dataSet.getFromEnv('chart'),
        chartAttr = chart.jsonData.chart,
        legend = chart.getFromEnv('legend'),
        chartConfig = chart.config,
        conf = dataSet.config,
        JSONData = dataSet.JSONData,
        setDataArr = (newDataset || JSONData).data,
        setDataLen = setDataArr && setDataArr.length,
        showZeroPies = conf.showZeroPies,
        totalValue = conf.valueTotal || 0,
        dataArr = [],

    // dataLabelStyle = parsexAxisStyles({}, {}, chartAttr, chartConfig.dataLabelStyle, setColor),
    plotBorderDash = (0, _lib.pluckNumber)(chartAttr.plotborderdashed, 0),
        dataStore = dataSet.components.data || (dataSet.components.data = []),
        numberFormatter = dataSet.getFromEnv('number-formatter'),
        colorM = dataSet.getFromEnv('color-manager'),
        labelInLeg = conf.labelInLeg,
        valInLeg = conf.valInLeg,
        seriesCenterLabelConfig = conf.centerLabelConfig,
        setBorderWidth = conf.pieBorderThickness,
        reversePlotOrder = conf.reversePlotOrder,
        radius3D = conf.radius3D,
        enableMultiSlicing = conf.enableMultiSlicing,
        lastSlicedid = conf.lastSlicedid || 0,

    // length of the dash
    seriesDashLen = (0, _lib.pluckNumber)(chartAttr.plotBorderDashed, 5),

    // distance between dash
    seriesDashGap = (0, _lib.pluckNumber)(chartAttr.plotborderdashgap, 4),
        valBefore = (0, _lib.pluckNumber)(chartAttr.valuebeforelabelinlegend, 0),
        valAsPerInLeg = (0, _lib.pluckNumber)(chartAttr.showvalueaspercentinlegend, 1),
        nullCount = 0,
        sepChar = (0, _lib.pluck)(chartAttr.legendsepchar, ', ');
    chartConfig.dataLabelStyle = (0, _lib.parsexAxisStyles)({}, {}, chartAttr, chartConfig.dataLabelStyle, setColor);
    /* if (!add && newDataset) {
        totalValue = conf.valueTotal = 0;
    } */
    // Parsing the attributes and values at set level.
    for (index = 0; index < setDataLen; index += 1) {
      /**/
      dataObj = setDataArr[index];
      dataValue = numberFormatter.getCleanValue(dataObj.value, true);

      if (!(dataValue === null || !showZeroPies && dataValue === 0)) {
        /* if (!add && newDataset && newIndex) {
            totalValue = (conf.valueTotal += (dataValue - dataStore[newIndex].config.y));
        } */
        dataArr.push(dataObj);
        totalValue += dataValue;
      } else {
        nullCount += 1;
      }
    }

    !conf.singletonCase && (conf.singletonCase = setDataLen - nullCount === 1);

    if (nullCount && dataStore.length > setDataLen - nullCount) {
      if (legend) {
        legend.emptyItems(dataStore.length - nullCount);
      }
      for (index = dataStore.length - 1; nullCount > 0; index -= 1, nullCount -= 1) {
        if (dataStore[index]) {
          dataObj = dataStore[index];
          dataConfig = dataObj.config;
          removeDataArr.push(dataObj);
          dataConfig.y = null;
          dataObj.legendItemId = UNDEF;
        }
      }
    }
    if (totalValue === 0) {
      dataArr = [];
    }
    conf.valueTotal = totalValue;
    // counts the total number of labels
    conf.dataLabelCounter = 0;
    chartConfig.allPlotSliceEnabled = chartConfig.enableslicing;
    for (index = (setDataLen = dataArr.length) - 1; index >= 0; index -= 1) {
      // individual data obj
      // for further manipulation
      tempIndex = index;
      if (newDataset) {
        dataJSON = dataArr[index];

        if (newIndex !== UNDEF) {
          tempIndex = newIndex + index;
          dataObj = dataStore[tempIndex];
        } else {
          tempIndex = dataStore.length - setDataLen + index;
          dataObj = dataStore[tempIndex];
        }
      } else {
        dataObj = dataStore[index] || (dataStore[index] = {
          graphics: {},
          config: {}
        });
        dataJSON = dataArr[index];
      }
      config = dataObj && dataObj.config;

      if (!config) {
        config = dataStore[tempIndex].config = {};
      }

      if (!dataObj.graphics) {
        dataStore[tempIndex].graphics = {};
      }

      // Taking the value
      // we multiply the value with 1 to convert it to integer
      config.y = dataValue = numberFormatter.getCleanValue(dataJSON.value, true);
      // Label provided with data point
      config.seriesName = name = (0, _lib.parseUnsafeString)((0, _lib.pluck)(dataJSON.label, dataJSON.name, _lib.BLANKSTRING));

      // parsing slice cosmetics attribute supplied in data points
      // Color for each slice
      setColor = (0, _lib.pluck)(dataJSON.color, colorM.getPlotColor(index));

      // Alpha for each slice
      setAlpha = (0, _lib.pluck)(dataJSON.alpha, chartAttr.plotfillalpha, _lib.HUNDREDSTRING);

      borderConfig = config.borderConfig = dataSet._parseBorderConfig(setColor, setAlpha, dataJSON);
      // each slice border color
      setPlotBorderColor = borderConfig.setPlotBorderColor;
      // each slice border alpha
      setPlotBorderAlpha = borderConfig.setPlotBorderAlpha;

      // Used to set alpha of the shadow
      pointShadow = {

        opacity: mathMax(setAlpha, setPlotBorderAlpha) / 100
      };

      // Check if pre-sliced
      isSliced = Boolean((0, _lib.pluckNumber)(dataJSON.issliced, chartAttr.issliced, /* config.sliced, */0));

      if (isSliced) {
        if (!enableMultiSlicing) {
          if (lastSlicedid !== -1) {
            dataStore[dataStore.length - lastSlicedid - 1].sliced = false;
          }
          conf.lastSlicedid = index;
        }
        conf.preSliced = isSliced;
      }

      setBorderDashed = (0, _lib.pluckNumber)(dataJSON.dashed, plotBorderDash);
      pointDashStyle = setBorderDashed ? (0, _lib.getDashStyle)((0, _lib.pluck)(dataJSON.dashlen, seriesDashLen), (0, _lib.pluck)(dataJSON.dashgap, seriesDashGap), setBorderWidth) : DASH_DEF;

      // parse all the toolText and display value related properties.
      dataSet._parseDisplayProperties(dataJSON, config);

      legendText = labelInLeg ? name : _lib.BLANKSTRING;
      if (valInLeg) {
        legValue = valAsPerInLeg ? numberFormatter.legendPercentValue(dataValue / totalValue * 100) : numberFormatter.legendValue(dataValue);
        legendText = valBefore ? legValue + (legendText && sepChar + legendText) : (legendText && legendText + sepChar) + legValue;
      }

      (displayValue = config.displayValue) && (conf.dataLabelCounter += 1);
      value = config.value;
      pValue = config.pValue;
      centerLabelConfig = {
        // if displayValue is UNDEF set as empty string, this defaulting can't be done before
        // because lot of logic is dependent on displayValue being UNDEF
        label: (0, _lib.pluck)((setCenterLabel = dataJSON.centerlabel || chartAttr.centerlabel) && replaceMacros(setCenterLabel, ['\\$value', '\\$percentValue', '\\$displayValue', '\\$label'], [value, pValue, displayValue === UNDEF ? '' : displayValue, name]), ''),
        font: seriesCenterLabelConfig.font,
        fontSize: (0, _lib.pluckNumber)(dataJSON.centerlabelfontsize, seriesCenterLabelConfig.fontSize),
        color: (0, _lib.getFirstColor)((0, _lib.pluck)(dataJSON.centerlabelcolor, seriesCenterLabelConfig.color)),
        alpha: (0, _lib.pluckNumber)(dataJSON.centerlabelalpha, seriesCenterLabelConfig.alpha),
        bold: (0, _lib.pluckNumber)(dataJSON.centerlabelbold, seriesCenterLabelConfig.bold),
        italic: (0, _lib.pluckNumber)(dataJSON.centerlabelitalic, seriesCenterLabelConfig.italic),

        bgColor: (0, _lib.pluck)(dataJSON.centerlabelbgcolor, seriesCenterLabelConfig.bgColor),
        bgAlpha: (0, _lib.pluckNumber)(dataJSON.centerlabelbgalpha, seriesCenterLabelConfig.bgAlpha),

        borderColor: (0, _lib.pluck)(dataJSON.centerlabelbordercolor, seriesCenterLabelConfig.borderColor),
        borderAlpha: (0, _lib.pluckNumber)(dataJSON.centerlabelborderalpha, seriesCenterLabelConfig.borderAlpha),
        borderThickness: seriesCenterLabelConfig.borderThickness,
        borderRadius: seriesCenterLabelConfig.borderRadius,

        textPadding: seriesCenterLabelConfig.textPadding,
        padding: seriesCenterLabelConfig.padding,

        bgOval: seriesCenterLabelConfig.bgOval,
        shadow: seriesCenterLabelConfig.shadow,

        hoverColor: (pluckedHoverColor = (0, _lib.pluck)(dataJSON.centerlabelhovercolor, seriesCenterLabelConfig.hoverColor)) && (0, _lib.getFirstColor)(pluckedHoverColor),
        hoverAlpha: (0, _lib.pluckNumber)(dataJSON.centerlabelhoveralpha, seriesCenterLabelConfig.hoverAlpha),

        toolText: (0, _lib.pluck)(dataJSON.centerlabeltooltext, '')
      };
      // Add style for individual data labels of pie
      // check if there is indivual level cosmetics in the data Object.
      if (dataSet._isStyled(dataJSON)) {
        config.style = (0, _lib.parsexAxisStyles)(dataJSON, {}, chartAttr, chartConfig.dataLabelStyle, setColor);
      } else if (config.style) {
        // if there is a style already existant delete it.
        delete config.style;
      }
      config.showInLegend = legendText !== _lib.BLANKSTRING; // prevent legend item when no label
      config.isVisible = true;
      config.name = legendText;
      // config.legendCosmetics= this.parseLegendOptions(chartAttr, dataJSON),
      config.shadow = pointShadow;
      config.setColor = setColor;
      config.color = _getPointColor(setColor, setAlpha, radius3D, conf.doughnutradius);
      config._3dAlpha = setAlpha;
      config.borderColor = convertColor(setPlotBorderColor, setPlotBorderAlpha);
      config.borderWidth = setBorderWidth;
      config.link = (0, _lib.getValidValue)(dataJSON.link);
      config.sliced = isSliced;
      config.dashStyle = pointDashStyle;
      if (!(config.doNotSlice = (0, _lib.pluck)(dataJSON.enableslicing, chartConfig.enableslicing) != _lib.ONESTRING) && chartConfig.allPlotSliceEnabled === _lib.ZEROSTRING) {
        chartConfig.allPlotSliceEnabled = _lib.ONESTRING;
      }
      dataSet._parseHoverEffectOptions(index);
      config.centerLabelConfig = centerLabelConfig;
      config.radius3D = radius3D;
    }
    if (reversePlotOrder) {
      dataStore && dataStore.reverse();
    }
    // /special conf for pie/doughnut
    conf.dataArr = dataArr;
    // Pass the configuration whether user wants to supress rotation.
    conf.enableRotation = dataStore.length > 1 ? (0, _lib.pluckNumber)(chartAttr.enablerotation, 1) : 0;
  };
  /**
   * parse attributes related to hover effect
   * @param {number} index  -index of data plot
   */


  Pie2DDataset.prototype._parseHoverEffectOptions = function _parseHoverEffectOptions(index) {
    var highlight,
        hoverColor,
        hoverAlpha,
        hoverBorderColor,
        hoverBorderAlpha,
        hoverBorderThickness,
        isHoverColorString,
        highlightColors,
        hColorsLen,
        hColorsLoop,
        dataSet = this,
        chart = dataSet.getFromEnv('chart'),
        chartAttr = chart.jsonData.chart,
        conf = dataSet.config,
        config = dataSet.components.data[index].config,
        JSONData = dataSet.JSONData,
        dataJSON = JSONData.data[index],
        setColor = config.setColor,
        setAlpha = config._3dAlpha,
        radius3D = conf.radius3D,
        borderConfig = config.borderConfig,
        setPlotBorderAlpha = borderConfig.setPlotBorderAlpha,
        setPlotBorderColor = borderConfig.setPlotBorderColor,
        setBorderWidth = conf.setBorderWidth,
        hoverEffect = (0, _lib.pluckNumber)(config.hovereffect, conf.showHoverEffect),
        hoverEffects = config.hoverEffects = {
      enabled: hoverEffect
    };
    // Enable hover effect when any of the hover attributes are explicitly set
    if (hoverEffect === UNDEF) {
      hoverEffect = hoverEffects.enabled = (0, _lib.pluck)(dataJSON.hovercolor, JSONData.hovercolor, chartAttr.plotfillhovercolor, dataJSON.hoveralpha, JSONData.hoveralpha, chartAttr.plotfillhoveralpha, dataJSON.borderhovercolor, JSONData.borderhovercolor, chartAttr.plotborderhovercolor, dataJSON.borderhoveralpha, JSONData.borderhoveralpha, chartAttr.plotborderhoveralpha, chartAttr.plotfillhoveralpha, dataJSON.borderhoverthickness, JSONData.borderhoverthickness, chartAttr.plotborderhoverthickness, UNDEF) !== UNDEF;
    }
    // Parsing the hover effects only if showhovereffect is not 0.
    if (hoverEffect) {
      highlight = (0, _lib.pluckNumber)(dataJSON.highlightonhover, JSONData.highlight, chartAttr.highlight, 1);
      hoverColor = (0, _lib.pluck)(dataJSON.hovercolor, JSONData.hovercolor, chartAttr.plotfillhovercolor);
      if (hoverColor && highlight) {
        highlight = 0;
      }
      hoverColor = (0, _lib.pluck)(hoverColor, setColor);
      hoverAlpha = (0, _lib.pluck)(dataJSON.hoveralpha, JSONData.hoveralpha, chartAttr.plotfillhoveralpha, setAlpha);
      hoverBorderColor = (0, _lib.pluck)(dataJSON.borderhovercolor, JSONData.borderhovercolor, chartAttr.plotborderhovercolor, setPlotBorderColor);
      hoverBorderAlpha = (0, _lib.pluck)(dataJSON.borderhoveralpha, JSONData.borderhoveralpha, chartAttr.plotborderhoveralpha, chartAttr.plotfillhoveralpha, setPlotBorderAlpha);
      hoverBorderThickness = (0, _lib.pluckNumber)(dataJSON.borderhoverthickness, JSONData.borderhoverthickness, chartAttr.plotborderhoverthickness, setBorderWidth);
      hoverColor.replace(/,+?$/, '');
      if (highlight === 1) {
        isHoverColorString = typeof hoverColor === 'string';

        highlightColors = isHoverColorString ? hoverColor.split(/\s{0,},\s{0,}/) : hoverColor.color.split(/\s{0,},\s{0,}/);

        hColorsLen = highlightColors.length;
        for (hColorsLoop = 0; hColorsLoop < hColorsLen; hColorsLoop++) {
          highlightColors[hColorsLoop] = getLightColor(highlightColors[hColorsLoop], 70);
        }

        if (isHoverColorString) {
          hoverColor = highlightColors.join(',');
        } else {
          hoverColor.color = highlightColors.join(',');
        }
      }
      dataSet._setHoverColor(hoverEffects, hoverColor, hoverAlpha, radius3D);
      hoverEffects.borderColor = convertColor(hoverBorderColor, hoverBorderAlpha);
      hoverEffects.borderWidth = hoverBorderThickness;
    } else {
      hoverEffects.enabled = false;
    }
  };
  /**
   * It draws data labels
   * @param {boolean} isRotating state; if pie is rotating or not
   * @param {Array} plotItems    array of datapots
   * @param {Object} plot        config of data plot
   * @param {Object} seriesData  contains pie center center co-ordinates and radius
   * @param {Object} anim        anim object
   */


  Pie2DDataset.prototype.placeDataLabels = function placeDataLabels(isRotating, plotItems, plot, seriesData, anim) {
    var dataSet = this,
        chart = dataSet.getFromEnv('chart'),
        chartConfig = chart.config,
        labelGroup = dataSet.getContainer('label-group'),
        plotOptions = dataSet.config,
        canvasLeft = chartConfig.canvasLeft,
        canvasTop = chartConfig.canvasTop,
        canvasWidth = chartConfig.canvasWidth,
        cx = canvasLeft + chartConfig.canvasWidth * 0.5,
        cy = canvasTop + chartConfig.canvasHeight * 0.5,
        smartLabel = chart.getFromEnv('smartLabel'),
        dataLabelsOptions = plotOptions.dataLabelOptions,
        style = dataLabelsOptions.style,
        lineHeight = (0, _lib.pluckNumber)(mathCeil(parseFloat(style.lineHeight)), 12),
        placeInside = plotItems.length === 1 ? chartConfig.singletonPlaceValue : false,
        skipOverlapLabels = dataLabelsOptions.skipOverlapLabels,
        manageLabelOverflow = dataLabelsOptions.manageLabelOverflow,
        connectorPadding = dataLabelsOptions.connectorPadding,
        distanceOption = dataLabelsOptions.distance,
        remainingHeight,
        seriesCenter = seriesData && seriesData.metrics || [cx, cy, 2 * plotOptions.pieMinRadius, plotOptions.innerSize || 0],
        isSingleStepAnim = chartConfig.isSingleStepAnim,
        centerY = seriesCenter[1],
        centerX = seriesCenter[0],
        radius = seriesCenter[2] * 0.5,

    // divide the points into quarters for anti collision
    quarters = [[], // top right
    [], // bottom right
    [], // bottom left
    [] // top left
    ],
        plotLeft = canvasLeft,
        plotTop = canvasTop,
        plotWidth = canvasWidth,
        dataLabelsRadius = plot.labelsRadius = radius + distanceOption,
        labelFontSize = parseInt(style.fontSize, 10),
        labelHeight = labelFontSize,
        halfLabelHeight = labelHeight / 2,
        xDisplacement = [connectorPadding, connectorPadding, -connectorPadding, -connectorPadding],
        maxLabels = plot.labelsMaxInQuadrant = mathFloor(dataLabelsRadius / labelHeight),
        isSmartLineSlanted = dataLabelsOptions.isSmartLineSlanted,
        innerRadius = seriesCenter[3] / 2,
        align,
        i,
        labelWidth,
        j,
        oriY,
        maxYmayHave,
        spaceRequired,
        length,
        k,
        sliced,
        x1,
        x2,
        x3,
        x4,
        y1,
        y2,
        y3,
        points,
        point,
        angle,
        connector,
        connectorPath,
        excess,
        excessArr,
        labelQuadrantHeight,
        maxQuadrantLabel,
        dataLabel,
        quarter,
        transX,
        transY,
        smartLabelObj,
        slicedTranslation,
        centerDistance,
        sameSideQuadrentLastY = Number.POSITIVE_INFINITY,
        extraLineSpaceComp,
        lPoint,
        pointConfig,
        pointGraphics,
        leftClubbedQuadrent = [],
        rightClubbedQuadrent = [],
        prevTextPos,
        prevConnectorPos,
        paper = dataSet.getFromEnv('paper'),
        _textAttrs,
        _textCss,
        _textAttrsWithXY,
        cloneOb = function cloneOb(ob) {
      var clonedOb = {},
          key = '';
      for (key in ob) {
        clonedOb[key] = ob[key];
      }
      return ob;
    },
        applyAttrFnGen = function applyAttrFnGen(el, attr) {
      return function () {
        el.attr(attr);
      };
    };

    // run parent method
    /** ^
     * Introduced the isRotating argument too to detect
     * whether this is called during rotation.
     */
    smartLabel.useEllipsesOnOverflow(chartConfig.useEllipsesWhenOverflow);
    if (!isRotating) {
      // do not set the style every time
      // Do it for first time
      smartLabel.setStyle(style);
    }

    // arrange points for detection collision
    // Creates an array of quarter containing labels of each
    // quarter if there has only one label the draw it inside
    if (!innerRadius && plotOptions.singletonCase && placeInside) {
      point = plotItems[0];
      if ((_textAttrs = point.config._textAttrs).text) {
        pointGraphics = point.graphics;
        pointConfig = point.config;
        dataLabel = pointGraphics.label;

        point.slicedTranslation = [plotLeft, plotTop];
        _textAttrs['text-anchor'] = alignCenter;
        _textAttrs.x = 0;
        _textAttrs.y = 0;
        _textAttrs.transform = ['t', centerX, centerY];

        if (!dataLabel) {
          dataLabel = pointGraphics.label = paper.text(_textAttrs, _textCss, labelGroup).on('dragstart', plotDragStart).on('dragmove', plotDragMove).on('dragend', plotDragEnd).hover(plotRollOver, plotRollOut);
        } else {
          dataLabel.attr(_textAttrs);
        }

        dataLabel.x = centerX;
        dataLabel.data('textPos', {
          x: centerX,
          y: centerY
        }).data('plotItem', _textAttrs.plotItem).data(EVENTARGS, _textAttrs.eventArgs);

        if (pointConfig.y !== null && pointConfig.y !== UNDEF) {
          dataLabel.show();
        }

        if (pointGraphics.connector) {
          pointGraphics.connector.attr({
            path: []
          });
        }
      }
    } else {
      if (placeInside) {
        centerDistance = innerRadius + (radius - innerRadius) / 2;
        (0, _lib.fcEach)(plotItems, function (point) {
          pointConfig = point.config;
          if ((_textAttrs = pointConfig._textAttrs).text) {
            pointGraphics = point.graphics;
            dataLabel = pointGraphics.label;
            if (pointConfig.y !== null && pointConfig.y !== UNDEF) {
              connector = pointGraphics.connector;
              connector && connector.show();
              dataLabel && dataLabel.show();
            }
            _textAttrs.transform = 't0,0';
            angle = pointConfig.angle;
            y3 = centerY + centerDistance * mathSin(angle);
            // previous implementation adds halfLebelHeight - 2 which makes the
            // label aligned to top instead middle [RED - 1717]
            /* y3 = centerY + (centerDistance *
                mathSin (angle)) + halfLabelHeight - 2; */
            x3 = centerX + centerDistance * mathCos(angle);
            _textAttrs._x = x3;
            _textAttrs._y = y3;
            if (point.sliced) {
              slicedTranslation = point.slicedTranslation;
              transX = slicedTranslation[0] - plotLeft;
              transY = slicedTranslation[1] - plotTop;
              x3 = x3 + transX;
              y3 = y3 + transY;
            }

            _textAttrs['text-anchor'] = alignCenter;
            _textAttrs.x = 0;
            _textAttrs.y = 0;
            _textAttrs.transform = ['t', x3, y3];

            if (!dataLabel) {
              dataLabel = pointGraphics.label = paper.text(_textAttrs, _textCss, labelGroup).on('dragstart', plotDragStart).on('dragmove', plotDragMove).on('dragend', plotDragEnd).hover(plotRollOver, plotRollOut);
            } else {
              dataLabel.attr(_textAttrs);
            }
            dataLabel.x = _textAttrs._x;
            // storing original x value
            // to use while slicing in (IE Issue original
            //  x get changed form animate)
            dataLabel.x = _textAttrs._x;
            dataLabel.y = _textAttrs._y;

            dataLabel.data('plotItem', _textAttrs.plotItem).data(EVENTARGS, _textAttrs.eventArgs);

            if (_textAttrs.visibility === VISIBLE) {
              dataLabel.show();
            }
          }
        });
      } else {
        // outside
        for (i = plotItems.length - 1; i >= 0; i--) {
          point = plotItems[i];
          pointConfig = point.config;
          _textAttrs = pointConfig._textAttrs || {};
          if (!(_textAttrs.text = pointConfig.displayValue)) {
            continue;
          }
          pointGraphics = point.graphics;
          if (pointConfig.y !== null && pointConfig.y !== UNDEF) {
            dataLabel = pointGraphics.label;
            connector = pointGraphics.connector;
            connector && connector.show();
            dataLabel && dataLabel.show();
          }
          _textAttrs.text = pointConfig.displayValue;
          _textAttrs.transform = 't0,0';
          angle = pointConfig.angle % pi2;

          if (angle < 0) {
            angle = pi2 + angle;
          }
          // Calculate bottom right quarter labels
          if (angle >= 0 && angle < piBy2) {
            quarter = 1;
          } else
            // Calculate bottom left quarter labels
            if (angle < pi) {
              quarter = 2;
            } else
              // Calculate top left quarter labels
              if (angle < pi3By2) {
                quarter = 3;
              } else {
                // Calculate top right quarter labels
                quarter = 0;
              }
          // Now put labels according to each quarter
          quarters[quarter].push({
            point: point,
            angle: angle
          });
        }
        i = k = 4;
        // if excess then remove the low value slice first
        while (i--) {
          if (skipOverlapLabels) {
            // Find labels can fit into the quarters or not
            excess = quarters[i].length - maxLabels;
            if (excess > 0) {
              // sort by point.value
              quarters[i].sort(sortArrayByPoint);
              // remove extra data form the array
              // which labels can not be fitted into
              // the quarters
              excessArr = quarters[i].splice(0, excess);
              // hide all removed labels
              for (j = 0, length = excessArr.length; j < length; j += 1) {
                point = excessArr[j].point;
                _textAttrs = point.config._textAttrs;
                pointGraphics = point.graphics;
                if (pointGraphics.label) {
                  pointGraphics.label.attr('visibility', HIDDEN);
                }
                if (pointGraphics.connector) {
                  pointGraphics.connector.attr({
                    visibility: HIDDEN
                  });
                }
              }
            }
          }
          // now we sort the data labels by its label angle
          quarters[i].sort(sortArrayByAngle);
        }

        maxQuadrantLabel = mathMax(quarters[0].length, quarters[1].length, quarters[2].length, quarters[3].length);
        labelQuadrantHeight = mathMax(mathMin(maxQuadrantLabel, maxLabels) * labelHeight, dataLabelsRadius + labelHeight);

        // Club the first and second quadrent as they appear in the right side of the
        // chart and club the other two. Clubbing here means merge all the points together
        // so that marginal quadrent case are handled like one point at first quadrent and
        // second point at another quadrent but placed closely.
        rightClubbedQuadrent = quarters[0].concat(quarters[1]);
        leftClubbedQuadrent = quarters[2].concat(quarters[3]);

        for (i = rightClubbedQuadrent.length - 1; i >= 0; i--) {
          lPoint = rightClubbedQuadrent[i].point.config;
          // Clear if any previous values are stored
          delete lPoint.clearance;
          delete lPoint.clearanceShift;
          oriY = mathAbs(labelQuadrantHeight * mathSin(lPoint.angle));
          if (Math.abs(sameSideQuadrentLastY - oriY) < lineHeight * 2) {
            lPoint.clearance = 0;
            rightClubbedQuadrent[i + 1].point.clearanceShift = lineHeight / 2;
          }
          sameSideQuadrentLastY = oriY;
        }

        sameSideQuadrentLastY = Number.POSITIVE_INFINITY;

        for (i = 0, length = leftClubbedQuadrent.length; i < length; i++) {
          lPoint = leftClubbedQuadrent[i].point.config;
          // Clear if any previous values are stored
          delete lPoint.clearance;
          delete lPoint.clearanceShift;
          oriY = mathAbs(labelQuadrantHeight * mathSin(lPoint.angle));
          if (Math.abs(sameSideQuadrentLastY - oriY) < lineHeight * 2) {
            lPoint.clearance = 0;
            leftClubbedQuadrent[i - 1].point.clearanceShift = lineHeight / 2;
          }
          sameSideQuadrentLastY = oriY;
        }

        // reverse 1st and 3rd quardent points
        quarters[1].reverse();
        quarters[3].reverse();

        while (k--) {
          points = quarters[k];
          length = points.length;

          if (!skipOverlapLabels) {
            if (length > maxLabels) {
              labelHeight = labelQuadrantHeight / length;
            } else {
              labelHeight = labelFontSize;
            }
            halfLabelHeight = labelHeight / 2;
          }

          // 1st pass
          // place all labels at 1st quarter

          // calculate the total available space to put labels
          spaceRequired = length * labelHeight;
          // calculate the remaining height
          remainingHeight = labelQuadrantHeight;
          // place all child point
          for (i = 0; i < length; i += 1, spaceRequired -= labelHeight) {
            // Get the y position of the label (radius
            // where data label is to draw)
            oriY = mathAbs(labelQuadrantHeight * mathSin(points[i].angle));

            if (remainingHeight < oriY) {
              oriY = remainingHeight;
            } else if (oriY < spaceRequired) {
              oriY = spaceRequired;
            }

            remainingHeight = (points[i].oriY = oriY) - labelHeight;
          }

          // 2nd pass (reverse)
          align = alignments[k];
          // place all labels at 1st quarter
          maxYmayHave = labelQuadrantHeight - (length - 1) * labelHeight;
          remainingHeight = 0;

          // place all child point
          for (i = points.length - 1; i >= 0; i -= 1, maxYmayHave += labelHeight) {
            point = points[i].point;
            angle = points[i].angle;
            pointConfig = point.config;
            _textAttrs = pointConfig._textAttrs || {};
            if (!_textAttrs.text) {
              continue;
            }
            _textCss = pointConfig._textCss;
            pointGraphics = point.graphics;
            sliced = pointConfig.sliced;
            dataLabel = pointGraphics.label;

            oriY = mathAbs(labelQuadrantHeight * mathSin(angle));

            if (oriY < remainingHeight) {
              oriY = remainingHeight;
            } else if (oriY > maxYmayHave) {
              oriY = maxYmayHave;
            }

            remainingHeight = oriY + labelHeight;

            // If the there is a label down underneath or
            // bordered put elipses else wrap the word.
            extraLineSpaceComp = pointConfig.clearance === UNDEF ? mathCeil((0, _lib.pluckNumber)(parseFloat(pointConfig.style.border), 12), 12) * 2 : mathCeil((0, _lib.pluckNumber)(parseFloat(pointConfig.style.border), pointConfig.clearance)) * 2;

            y1 = (oriY + points[i].oriY) / 2;
            x1 = centerX + xSign[k] * dataLabelsRadius * mathCos(math.asin(y1 / labelQuadrantHeight));
            y1 *= ySign[k];
            y1 += centerY;

            y2 = centerY + radius * mathSin(angle);
            x2 = centerX + radius * mathCos(angle);

            // Relation: centerX <= connectorStartX <= connectorEndX
            // (for right half and vice versa for left half)
            (k < 2 && x1 < x2 || k > 1 && x1 > x2) && (x1 = x2);

            x3 = x1 + xDisplacement[k];
            y3 = y1 - halfLabelHeight - 2;
            x4 = x3 + xDisplacement[k];

            _textAttrs._x = x4;

            if (manageLabelOverflow) {
              labelWidth = k > 1 ? x4 - chartConfig.canvasLeft : chartConfig.canvasLeft + plotWidth - x4;
              smartLabel.setStyle(pointConfig.style);
              lineHeight = (0, _lib.pluckNumber)(mathCeil(parseFloat(pointConfig.style.lineHeight)), 12) + extraLineSpaceComp;
              smartLabelObj = smartLabel.getSmartText(pointConfig.displayValue, labelWidth, lineHeight);

              if (pointConfig.clearance === UNDEF && smartLabelObj.height > labelHeight) {
                y1 += labelHeight;
              }

              _textAttrs.text = smartLabelObj.text;
              // _textAttrs.title = smartLabelObj.tooltext || '';

              _textAttrs.tooltip = smartLabelObj.tooltext;

              /* dataLabel.attr ( {
                  text: smartLabelObj.text
                  //title: (smartLabelObj.tooltext || '')
              })
              .tooltip (smartLabelObj.tooltext); */
            }
            _textAttrs._y = y3;

            if (sliced) {
              transX = pointConfig.transX;
              transY = pointConfig.transY;
              x3 = x3 + transX;
              x1 = x1 + transX;
              x2 = x2 + transX;
              y2 = y2 + transY;
              x4 = x4 + transX;
            }

            _textAttrs['text-anchor'] = align;
            _textAttrs.vAlign = 'middle';

            _textAttrs.x = x4;
            _textAttrs.y = y1;

            prevTextPos = dataLabel && dataLabel.data('textPos');

            if (prevTextPos) {
              if (isSingleStepAnim && anim) {
                _textAttrsWithXY = cloneOb(_textAttrs);
                _textAttrsWithXY.x = prevTextPos.x;
                _textAttrsWithXY.y = prevTextPos.y;
                anim.plot.data.push({
                  el: dataLabel,
                  attrs: _textAttrsWithXY,
                  callback: applyAttrFnGen(dataLabel, _textAttrs)
                });
              } else {
                dataLabel.attr({
                  x: prevTextPos.x,
                  y: prevTextPos.y
                }).attr(_textAttrs);
              }
            } else {
              // for the initial rendering.
              dataLabel = pointGraphics.label = paper.text(_textAttrs, _textCss, labelGroup).on('dragstart', plotDragStart).on('dragmove', plotDragMove).on('dragend', plotDragEnd).hover(plotRollOver, plotRollOut);
            }

            dataLabel.x = _textAttrs._x;
            dataLabel._x = _textAttrs._x;
            dataLabel.y = _textAttrs._y;

            if (_textAttrs.tooltip) {
              dataLabel.tooltip(_textAttrs.tooltip);
              delete _textAttrs.tooltip;
            }
            if (_textAttrs.visibility === VISIBLE) {
              dataLabel.show();
            }
            dataLabel.data('textPos', {
              x: x4,
              y: y1
            }).data('plotItem', _textAttrs.plotItem).data(EVENTARGS, _textAttrs.eventArgs);
            // draw the connector
            if (connector = pointGraphics.connector) {
              pointConfig.connectorPath = connectorPath = [M, x2, y2, // base
              L,
              // first break, next to the label
              isSmartLineSlanted ? x1 : x2, y1, x3, y1 // end of the string at the label
              ];
              prevConnectorPos = connector.data('connectorPath');
              if (prevConnectorPos) {
                if (!chartConfig.clicked) {
                  if (isSingleStepAnim && anim) {
                    anim.plot.data.push({
                      el: connector,
                      attrs: {
                        path: connectorPath
                      }
                    });
                  } else {
                    connector.attr({
                      path: connectorPath
                    });
                  }
                }
              } else {
                connector.attr({
                  path: connectorPath
                });
              }
              connector.data('connectorPath', {
                path: connectorPath
              });
            }
          }
        }
      }
    }
  };
  /**
   * set hover effect depending on the 3D lighting mode
   * @param {Object} hoverEffects conatins hover effects
   * @param {string} hoverColor color string
   * @param {number} hoverAlpha color alpha
   * @param {boolean} radius3D  if 3D Lighting Mode is on
   */


  Pie2DDataset.prototype._setHoverColor = function _setHoverColor(hoverEffects, hoverColor, hoverAlpha, radius3D) {
    var dataSet = this;
    if (radius3D) {
      hoverEffects.color = _getPointColor(hoverColor, hoverAlpha, radius3D, dataSet.config.doughnutradius);
    } else {
      hoverEffects.color = hoverColor;
      hoverEffects.alpha = hoverAlpha;
    }
  };
  /**
   * Function to an existing data of a dataset.
   * @param {Object} dataObj data JSON
   * @param {integer} index The data index whoch needs to be updated
   * @param {boolean} draw  Indicates whether the chart should redraw itself or not
   */


  Pie2DDataset.prototype.updateData = function updateData() {
    var dataSet = this,
        conf = dataSet.config,
        dataStore = dataSet.components.data;
    conf.valueTotal -= dataStore[arguments[1]].config.y;
    _AreaDataset.prototype.updateData.call(this, arguments);
  };
  /**
   * function to rotate pie slices
   */


  Pie2DDataset.prototype._rotate = function _rotate() {
    var _ringPath,
        _rotateAttrs,
        dataSet = this,
        chart = dataSet.getFromEnv('chart'),
        conf = dataSet.config,
        plotData = dataSet.components.data,
        chartConfig = chart.config,
        piePlotOptions = conf.piePlotOptions,
        startAngle = (conf.startAngle || 0) % pi2,
        slicedOffset = conf.slicingDistance,
        valueTotal = conf.valueTotal,
        factor = pi2 / valueTotal,
        cx = chartConfig.canvasLeft + chartConfig.canvasWidth * 0.5,
        cy = chartConfig.canvasTop + chartConfig.canvasHeight * 0.5,
        r = conf.pieMinRadius,
        r2 = (piePlotOptions.innerSize || 0) * 0.5,
        val,
        angle,
        angle1,
        angle2,
        setConfig,
        setGraphics,
        i;

    angle1 = angle2 = startAngle;
    for (i = 0; i < plotData.length; i += 1) {
      setConfig = plotData[i].config;
      setGraphics = plotData[i].graphics;
      val = setConfig.y;

      if (val === null || val === UNDEF) {
        continue;
      }

      // plotItem = plotItems[i];

      angle2 = angle1;
      // This conditional assignment of value 2 * pi is to by-pass a
      // computational error inherent to any computer system, which
      // happens here for certain values in singleton cases.
      angle1 -= !conf.singletonCase ? val * factor : pi2;
      angle = (angle1 + angle2) * 0.5;

      setConfig.angle = angle;
      setConfig.transX = mathCos(angle) * slicedOffset;
      setConfig.transY = mathSin(angle) * slicedOffset;

      setConfig.slicedTranslation = TRANSFORMSTR + mathCos(angle) * slicedOffset + _lib.COMMASTRING + mathSin(angle) * slicedOffset;

      if (!(_rotateAttrs = setConfig._rotateAttrs)) {
        _rotateAttrs = setConfig._rotateAttrs = {
          ringpath: [],
          transform: _lib.BLANKSTRING
        };
      }
      _ringPath = _rotateAttrs.ringpath;
      _ringPath[0] = cx;
      _ringPath[1] = cy;
      _ringPath[2] = r;
      _ringPath[3] = r2;
      _ringPath[4] = angle1;
      _ringPath[5] = angle2;
      _rotateAttrs.transform = setConfig.sliced ? setConfig.slicedTranslation : _lib.BLANKSTRING;
      setGraphics.element.attr(_rotateAttrs);
    }
    dataSet.placeDataLabels(true, plotData, conf);
  };
  /**
   * function to fetch radius and slice offset
   * @return {Object} contains radius and slice offset
   */


  Pie2DDataset.prototype._parsePiePlotOptions = function _parsePiePlotOptions() {
    var dataSet = this,
        conf = dataSet.config;
    return {
      size: conf.pieMinRadius,
      slicedOffset: conf.slicingDistance
    };
  };
  /**
   * function to fetch data label style as object
   * @return {Object} contains data label style
   */


  Pie2DDataset.prototype._parseDataLabelOptions = function _parseDataLabelOptions() {
    return {
      style: this.getFromEnv('chart').config.dataLabelStyle
    };
  };
  /**
   * Function to register datasets in the internal data store of legend class.
   */


  Pie2DDataset.prototype._addLegend = function _addLegend() {
    var i,
        config,
        dataObj,
        dataSet = this,
        legend = dataSet.getFromEnv('legend'),
        dataStore = dataSet.components.data;
    for (i = 0; i < dataStore.length; i += 1) {
      dataObj = dataStore[i];
      config = dataObj.config;
      if (config.y !== null) {
        dataObj.legendItemId = legend.addItems(dataSet, legendInteractivity, {
          index: i,
          fillColor: (0, _lib.toRaphaelColor)(config.setColor),
          strokeColor: (0, _lib.toRaphaelColor)(config.borderColor),
          type: dataSet.type,
          label: config.seriesName,
          enabled: (0, _lib.pluckNumber)(config.includeInLegend, 1),
          legendItemId: dataObj.legendItemId
        });
      }
    }
  };
  /**
   * fetches data plot from data store
   * @param {number} id           - index of data plot which is to be fetched
   * @param {boolean} slicedState - sliced or not
   * @return {Object}             - data plot
   */


  Pie2DDataset.prototype.getPlotData = function getPlotData(id, slicedState) {
    var dataset = this,
        data = dataset.components.data[id].config,
        userData = dataset.config.userData || (dataset.config.userData = []),
        plotData,
        value,
        prop;

    if (!userData[id]) {
      plotData = userData[id] = {};
      for (prop in data) {
        _typeof(value = data[prop]) !== 'object' && typeof value !== 'function' && prop.indexOf('_') !== 0 && (plotData[prop] = value);
      }
      plotData.value = plotData.y;
      plotData.categoryLabel = plotData.label = plotData.seriesName;

      delete plotData.y;
      delete plotData.total;
      delete plotData.doNotSlice;
      delete plotData.name;
      delete plotData.seriesName;
      delete plotData.centerAngle;
      delete plotData.showInLegend;
      delete plotData.angle;
      delete plotData.endAngle;
      delete plotData.isVisible;
      delete plotData.setColor;
      delete plotData.slicedTranslation;
      delete plotData.startAngle;
      delete plotData.transX;
      delete plotData.transY;
      delete plotData.pValue;
    } else {
      plotData = userData[id];
    }

    plotData.sliced = slicedState;
    return plotData;
  };
  /**
   * parse border cosmetics
   * @param {string} setColor color hex
   * @param {string} setAlpha aplha value
   * @param {Object} dataJSON data Object
   * @return {Object}         contains plot border color and alpha
   */


  Pie2DDataset.prototype._parseBorderConfig = function _parseBorderConfig(setColor, setAlpha, dataJSON) {
    var dataSet = this,
        conf = dataSet.config,
        pieBorderColor = conf.pieBorderColor,
        chart = dataSet.getFromEnv('chart'),
        chartAttr = chart.jsonData.chart,

    // each slice border color
    setPlotBorderColor = (0, _lib.pluck)(dataJSON.bordercolor, pieBorderColor),

    // each slice border alpha
    setPlotBorderAlpha = (0, _lib.pluck)(dataJSON.borderalpha, chartAttr.plotborderalpha, chartAttr.pieborderalpha);

    setPlotBorderColor = (0, _lib.pluck)(setPlotBorderColor, getLightColor(setColor, 25)).split(_lib.COMMASTRING)[0];
    setPlotBorderAlpha = chartAttr.showplotborder == _lib.ZEROSTRING ? _lib.ZEROSTRING : (0, _lib.pluck)(setPlotBorderAlpha, setAlpha, '80');
    return {
      setPlotBorderColor: setPlotBorderColor,
      setPlotBorderAlpha: setPlotBorderAlpha
    };
  };
  /**
   * Function to hide the graphics elements
   */


  Pie2DDataset.prototype.hideElements = function hideElements() {
    var elem = this,
        chart = elem.data && elem.data('plotItem').chart,
        dataSet = chart.getChildren('dataset') && chart.getChildren('dataset')[0],
        i = 0,
        shadowArr = elem._ && elem._.shadows || [];

    if (dataSet) {
      elem.hide();
      for (; i < shadowArr.length; i += 1) {
        shadowArr[i].hide();
      }
    }
  };
  // hideFn (graphic, type) {
  //   return function () {
  //     graphic[type].hide();
  //   };
  // }
  /**
   * function to create group for dataset
   */


  Pie2DDataset.prototype._createContainer = function _createContainer() {
    var dataSet = this,
        paper = dataSet.getFromEnv('paper'),
        dsType = dataset.type,
        parentContainer = void 0,
        pieGroups = void 0,
        piePlotGroups = void 0,
        pieLabelGroups = void 0,
        groupName = dataset.groupName,
        parent = dataset.getLinkedParent(),
        group = groupName || dataset.dsGroup || dsType;

    !parent.getChildContainer(group + 'Group') && (group = 'default');
    parentContainer = parent.getChildContainer('datalabelsGroup');

    pieGroups = dataSet.getContainer('pie-groups') || dataset.addContainer('pie-groups', paper.group('pie', parentContainer).trackTooltip(true));

    piePlotGroups = dataSet.getContainer('pie-plot-groups') || dataset.addContainer('pie-plot-groups', paper.group('pie-plot', pieGroups));

    pieLabelGroups = dataSet.getContainer('pie-label-groups') || dataset.addContainer('pie-label-groups', paper.group('pie-label', pieGroups));

    dataSet.getContainer('plot-group') || dataset.addContainer('plot-group', paper.group('plots', piePlotGroups));

    dataSet.getContainer('plot-shadow-group') || dataset.addContainer('plot-shadow-group', paper.group('plot-shadows', piePlotGroups).toBack());

    dataSet.getContainer('label-group') || dataset.addContainer('label-group', paper.group('labels', pieLabelGroups).trackTooltip(true));

    dataSet.getContainer('connector-shadow-group') || dataset.addContainer('connector-shadow-group', paper.group('connector-shadows', pieLabelGroups));

    dataSet.getContainer('anchor-shadow-group') || dataset.addContainer('anchor-shadow-group', paper.group('anchor-shadows', pieLabelGroups));
  };
  /**
   * Function for drawing 2D pie
   * This function is called every time for each dataset when they are initially drawn or shown/hidden from
   */


  Pie2DDataset.prototype.draw = function draw() {
    // retrive requitrd objects
    var j,
        singleFillColor,
        dataSet = this,
        chart = dataSet.getFromEnv('chart'),
        chartConfig = chart.config,
        dataLabelStyle = chartConfig.dataLabelStyle,
        conf = dataSet.config,
        showShadow = conf.showShadow,
        i,
        alphaanimation = chartConfig.alphaanimation,
        paper = dataSet.getFromEnv('paper'),
        dataSetComponents = dataSet.components,
        dataStore = dataSetComponents.data,
        removeDataArr = dataSetComponents.removeDataArr = dataSetComponents.removeDataArr || [],
        dataObj,
        toolText,
        setElement,
        setLink,
        eventArgs,
        isSingleStepAnim = chartConfig.isSingleStepAnim,
        style = chartConfig.style,
        pool = dataSet.pool,
        visible = dataSet.getState('visible'),
        plotGroup,
        plotShadow,
        labelGroup,
        connectorShadowGroup,
        anchorShadowGroup,
        angle1,
        angle2,
        setGraphics,
        set,
        val,
        displayValue,
        sliced,
        isHot,
        color,
        angle,
        plotItem,
        dataLabel,
        connectorWidth,
        plotData = dataSetComponents.data || [],
        dataLength = plotData.length,
        canvasWidth = chartConfig.canvasWidth,
        canvasHeight = chartConfig.canvasHeight,
        cx = chartConfig.canvasLeft + canvasWidth * 0.5,
        cy = chartConfig.canvasTop + canvasHeight * 0.5,

    // Fetching previous center points and
    // other data if required
    previousData = conf.previousData,
        valueTotal,
        factor,
        callBackCalled = false,
        animationObj = chart.get('config', 'animationObj'),
        animationDuration = animationObj.duration || 0,
        animStartFN = function animStartFN() {
      if (!callBackCalled) {
        callBackCalled = true;
        labelGroup.show();
      }
    },
        restoreColor = function restoreColor() {
      var i, dataObj;

      if (singleFillColor) {
        for (i = 0; i < dataLength; i += 1) {
          // set original color
          dataObj = plotData[i];
          dataObj.graphics.element && dataObj.graphics.element.attr({
            fill: (0, _lib.toRaphaelColor)(dataObj.config.color)
          });
        }
      }
    },
        isDimensionModified = function () {
      var pieCenter = conf.pieCenter || [],
          piePlotOptions = conf.piePlotOptions || [],
          oldDimensions = {
        cx: pieCenter[0],
        cy: pieCenter[1],
        r: piePlotOptions.size,
        r2: (conf.innerSize || 0) * 0.5
      },
          tolerance = 5;

      return function (newDimesion) {
        var prop,
            flag = false;
        for (prop in newDimesion) {
          if (mathAbs(newDimesion[prop] - oldDimensions[prop]) > tolerance) {
            flag = true;
            break;
          }
        }
        return flag;
      };
    }(),
        transposeAnimCallBack = function transposeAnimCallBack() {
      if (!callBackCalled) {
        restoreColor();
      }
    },
        enableRotation = !!conf.enableRotation,
        piePlotOptions = conf.piePlotOptions = dataSet._parsePiePlotOptions(),
        colorLabelFromPoint = false,
        textDirection = chartConfig.textDirection,
        dataLabelOptions = conf.dataLabelOptions,
        slicedOffset = piePlotOptions.slicedOffset,
        connector,
        r = piePlotOptions.size,
        r2 = (conf.innerSize || 0) * 0.5,
        startAngle = (conf.startAngle || 0) % pi2,

    // plotAnimFN = ATTRFN,
    plotAnimCallBack,
        initialAngle,
        isTranspose,
        endAngle = startAngle - pi2,
        animateClockWise = conf.animateClockWise,
        _textAttrs,
        _textCss,
        isNewEl,
        anim = {
      plot: {
        data: [],
        animType: 'linear'
      },
      initial: {
        data: []
      },
      final: {
        data: []
      }
    },
        placeDataLabels = function placeDataLabels() {
      dataSet.placeDataLabels(false, dataStore, conf, null, anim);
    },
        key = '',
        setElAttr,
        initialConfig = {},
        showFn = function showFn() {
      this.attr({
        opacity: 1
      });
    };

    if (!dataSet.getContainer('pie-groups')) {
      dataSet._createContainer();
    }
    plotGroup = dataSet.getContainer('plot-group');
    plotShadow = dataSet.getContainer('plot-shadow-group');
    labelGroup = dataSet.getContainer('label-group');
    connectorShadowGroup = dataSet.getContainer('connector-shadow-group');
    anchorShadowGroup = dataSet.getContainer('anchor-shadow-group');

    if (!dataSet.drawn) {
      if (animationDuration) {
        // plotAnimFN = ANIMATEFN;
        plotAnimCallBack = animStartFN;
        labelGroup.hide();
      }
    } else {
      isTranspose = true;
      if (animationDuration) {
        plotAnimCallBack = transposeAnimCallBack;
      }
      // Todo remove this
      singleFillColor = isDimensionModified({
        cx: cx,
        cy: cy,
        r: r,
        r2: r2
      }) && false;
    }

    labelGroup.css(dataLabelStyle);

    // hide all groups if dataset is not visible.
    if (!visible) {
      plotGroup.hide();
      plotShadow.hide();
      labelGroup.hide();
      connectorShadowGroup.hide();
      anchorShadowGroup.hide();
    }

    removeDataArr.length && dataSet.remove(anim);

    valueTotal = conf.valueTotal;
    factor = pi2 / valueTotal;

    // chart._addCSSDefinition('.fusioncharts-datalabels .fusioncharts-label', style);
    // Log the chart position for calculating mouse xy.
    conf.pieCenter = [cx, cy];

    angle1 = startAngle;
    angle2 = startAngle;
    for (i = 0; i < dataLength; i += 1) {
      dataObj = plotData[i];
      setGraphics = dataObj.graphics;
      set = dataObj.config;
      if (!(_textAttrs = set._textAttrs)) {
        _textAttrs = set._textAttrs = {};
      }
      val = set.y;
      displayValue = set.displayValue;
      sliced = set.sliced;
      toolText = set.toolText;
      setLink = !!set.link;
      style = set.style;
      isHot = setLink || enableRotation || !set.doNotSlice;

      if (val === null || val === UNDEF || set.isVisible === false) {
        continue;
      }

      color = set.color;
      color.r = r;
      color.cx = cx;
      color.cy = cy;

      angle2 = angle1;
      // This conditional assignment of value 2 * pi is to by-pass a
      // computational error inherent to any computer system, which
      // happens here for certain values in singleton cases.
      angle1 -= !conf.singletonCase ? val * factor : pi2;

      angle = (angle1 + angle2) * 0.5;

      setElement = setGraphics.element;
      dataLabel = setGraphics.label;
      connector = setGraphics.connector;

      // create the element if not available.
      if (!setElement) {
        isNewEl = true;
        if (pool && pool.element.length) {
          setElement = setGraphics.element = pool.element.splice(0, 1)[0].show();
        } else {
          setElement = setGraphics.element = paper.ringpath(plotGroup).attr({
            'stroke-linejoin': 'round',
            ishot: isHot
          }).on('dragstart', plotDragStart).on('dragmove', plotDragMove).on('dragend', plotDragEnd).hover(plotRollOver, plotRollOut);
        }
        if (isTranspose) {
          if (i < dataLength) {
            initialAngle = UNDEF;
            for (j = i + 1; j < dataLength && initialAngle === UNDEF; j += 1) {
              initialAngle = plotData[j].config.endAngle;
            }
          }
          if (initialAngle === UNDEF) {
            initialAngle = endAngle;
          }
        } else {
          initialAngle = animateClockWise ? endAngle : startAngle;
        }
        if (!dataSet.drawn) {
          setElement.attr({
            ringpath: alphaanimation ? [cx, cy, r, r2, angle1, angle2] : [cx, cy, r2, r2, angle1, angle2]
          });
        } else {
          setElement.attr({
            ringpath: [previousData.cx, previousData.cy, previousData.r, previousData.r2, initialAngle, initialAngle]
          });
        }
      } else {
        isNewEl = false;
      }
      if (displayValue !== UNDEF) {
        // If data label cosmetics exists.
        if (style) {
          if (!(_textCss = set._textCss)) {
            _textCss = set._textCss = {};
          }
          _textCss.fontFamily = style.fontFamily;
          _textCss.fontSize = style.fontSize;
          _textCss.lineHeight = style.lineHeight;
          _textCss.fontWeight = style.fontWeight;
          _textCss.fontStyle = style.fontStyle;
        } else if (set._textCss) {
          /* If there was a perviously applied cosmetics for a data Object, need to remove the already
          applied css. */
          dataLabel && dataLabel.removeCSS();
          delete set._textCss;
          _textCss = UNDEF;
        }
        set.style = style || (style = dataLabelStyle);
        _textAttrs.text = displayValue;
        _textAttrs.fill = (colorLabelFromPoint ? (0, _lib.toRaphaelColor)(set.color) : style.color) || '#000000';
        _textAttrs['text-bound'] = [style.backgroundColor, style.borderColor, style.borderThickness, style.borderPadding, style.borderRadius, style.borderDash];
        _textAttrs.direction = textDirection;
        _textAttrs.lineHeight = style.lineHeight;

        if (!dataLabel) {
          if (pool && pool.label && pool.label.length) {
            dataLabel = setGraphics.label = pool.label.splice(0, 1)[0];
          } else {
            _textAttrs.ishot = isHot;
          }
        } else {
          if (_textCss) {
            dataLabel.css(_textCss);
            delete _textCss.fontFamily;
            delete _textCss.fontSize;
            delete _textCss.lineHeight;
            delete _textCss.fontWeight;
            delete _textCss.fontStyle;
            _textCss = UNDEF;
          }

          delete _textAttrs.ishot;
        }

        if (!isSingleStepAnim) {
          dataLabel && anim.initial.data.push({
            el: dataLabel,
            attrs: {
              opacity: 0
            }
          });
          dataLabel && anim['final'].data.push({
            el: dataLabel,
            attrs: {
              opacity: 1
            }
          });
        }

        if (dataLabelOptions.distance > 0 && (connectorWidth = dataLabelOptions.connectorWidth) && dataLabelOptions.enableSmartLabels) {
          if (!connector) {
            if (pool && pool.connector.length) {
              connector = setGraphics.connector = pool.connector.splice(0, 1)[0];
            } else {
              connector = setGraphics.connector = paper.path('M 0 0 L 0 0', labelGroup).attr({
                visibility: VISIBLE,
                ishot: true
              }).on('dragstart', plotDragStart).on('dragmove', plotDragMove).on('dragend', plotDragEnd).hover(plotRollOver, plotRollOut);
            }
          }

          connector.attr({
            'stroke-width': connectorWidth,
            stroke: dataLabelOptions.connectorColor || '#606060'
          }).show();
          if (!isSingleStepAnim) {
            connector && anim.initial.data.push({
              el: connector,
              attrs: {
                opacity: 0
              }
            });
            connector && anim['final'].data.push({
              el: connector,
              attrs: {
                opacity: 1
              }
            });
          }
        } else {
          connector && anim.plot.data.push({
            el: connector,
            attrs: {
              opacity: 0
            }
          });
        }
      } else {
        // hide the label
        _textAttrs.visibility = HIDDEN;
        dataLabel && anim.plot.data.push({
          el: dataLabel,
          attrs: {
            opacity: 0
          }
        });
        connector && anim.plot.data.push({
          el: connector,
          attrs: {
            opacity: 0
          }
        });
      }

      plotItem = set.plotItem = {
        chart: chart,
        index: i, // @todo check requirement
        seriesData: conf,
        value: val,
        angle: set.angle = angle,
        angle1: set.startAngle = angle1,
        angle2: set.endAngle = angle2,
        slicedX: mathCos(angle) * slicedOffset,
        slicedY: mathSin(angle) * slicedOffset,
        sliced: sliced,
        labelText: displayValue,
        toolText: toolText,
        name: set.name,
        link: set.link,
        percentage: valueTotal ? val * valueTotal / 100 : 0,
        originalIndex: dataLength - i - 1,
        style: set.style,
        color: (0, _lib.toRaphaelColor)(set.color),
        borderColor: set.borderColor,
        borderWidth: set.borderWidth,
        rolloverProperties: set.hoverEffects,
        radius: r,
        center: [cx, cy],
        innerDiameter: 2 * r2,
        centerLabelConfig: set.centerLabelConfig,
        graphic: setElement,
        isVisible: set.isVisible,
        label: dataLabel,
        connector: connector,
        transX: set.transX = mathCos(angle) * slicedOffset,
        transY: set.transY = mathSin(angle) * slicedOffset,
        slicedTranslation: set.slicedTranslation = 't' + mathCos(angle) * slicedOffset + ',' + mathSin(angle) * slicedOffset
      };

      eventArgs = {
        index: conf.reversePlotOrder ? dataLength - 1 - i : i,
        link: set.link,
        value: set.y,
        displayValue: set.displayValueArgs,
        categoryLabel: set.categoryLabel,
        isSliced: sliced,
        toolText: toolText
      };

      if (!dataSet.drawn) {
        if (alphaanimation) {
          plotGroup.attr({
            opacity: 0
          });
          anim.plot.data.push({
            el: plotGroup,
            attrs: {
              opacity: 1
            },
            callback: plotAnimCallBack
          });
        } else {
          setElement.attr({ opacity: 0 });
          initialConfig = _lib.animHelperFN.animByWeight(animateClockWise ? dataLength - i - 1 : i, dataLength, 0.5);
          initialConfig.hookFn = showFn;
          anim.plot.data.push({
            el: setElement,
            attrs: {
              ringpath: [cx, cy, r, r2, angle1, angle2]
            },
            animConfig: [initialConfig],
            animType: 'easeInOutQuad',
            callback: plotAnimCallBack
          });
        }
      } else {
        anim.plot.data.push({
          el: setElement,
          attrs: {
            ringpath: [cx, cy, r, r2, angle1, angle2]
          },
          callback: plotAnimCallBack
        });
      }

      if (!isSingleStepAnim) {
        labelGroup && anim.initial.data.push({
          el: labelGroup,
          attrs: {
            opacity: 0
          }
        });
        labelGroup && anim['final'].data.push({
          el: labelGroup,
          attrs: {
            opacity: 1
          },
          animConfig: [{
            hookFn: placeDataLabels
          }]
        });
      } else {
        placeDataLabels();
      }

      setElAttr = {
        'stroke-width': set.borderWidth,
        'stroke': set.borderColor,
        fill: isVML || isTranspose && singleFillColor ? singleFillColorFn(set.color, conf.doughnutradius) : (0, _lib.toRaphaelColor)(set.color),
        'stroke-dasharray': set.dashStyle,
        redrawDataLabels: startAngle,
        cursor: setLink ? POINTER : ''
      };

      if (!isNewEl) {
        anim.plot.data.push({
          el: setElement,
          attrs: setElAttr
        });
      } else {
        setElement.attr(setElAttr);
      }
      if (!isSingleStepAnim) {
        // close slicing on animation start
        anim.initial.data.push({
          el: setElement,
          attrs: {
            transform: ''
          }
        });
      }
      // In case issliced is on for new element
      anim['final'].data.push({
        el: setElement,
        attrs: {
          transform: plotItem.sliced ? plotItem.slicedTranslation : ''
        }
      });

      setElement.show().shadow(showShadow && set.shadow, plotShadow).tooltip(toolText).data('plotItem', plotItem).data('dataset', this).data(EVENTARGS, eventArgs);

      _textAttrs.plotItem = plotItem;
      _textAttrs[EVENTARGS] = eventArgs;

      connector && connector.data('plotItem', plotItem).data(EVENTARGS, eventArgs);
    }

    if (!animationDuration) {
      restoreColor();
      animStartFN();
    }
    // Registering the animations
    for (key in anim) {
      dataSet.getFromEnv('animationManager').registerAnimation([anim[key]], key);
    }
    // Marking dataSet drawn
    dataSet.drawn = true;
    conf.previousData = {
      cx: cx,
      cy: cy,
      r: r,
      r2: r2
    };
  };
  /**
   * function to slice in other sliced out slices which are not clicked
   * @param {number} mainPieId  index of clicked sliced
   * @return {boolean}          true when at least one other pie is sliced
   */


  Pie2DDataset.prototype.sliceInOtherPies = function sliceInOtherPies(mainPieId) {
    var dataset = this,
        plotItems = dataset.components.data,
        i = plotItems.length,
        numSliced = 0,
        plot;

    dataset.enableMultiSlicing = true;

    while (i--) {
      i !== mainPieId && (plot = plotItems[i]).config.sliced && ++numSliced && plotGraphicClick.call(plot.graphics);
    }

    dataset.enableMultiSlicing = false;
    // Returns true when at least one other pie is sliced
    return !!numSliced;
  };
  /**
   * Function to remove a data from a dataset
   * @param {Object} anim     - object reference of animation manager argument
   *                            consist of elements and their configuration
   */


  Pie2DDataset.prototype.remove = function remove(anim) {
    // todo: if we remove a data at a specified index, make animation proper for that.
    var dataSet = this,
        chart = dataSet.getFromEnv('chart'),
        chartConfig = chart.config,
        components = dataSet.components,
        removeDataArr = components.removeDataArr || [],
        pool = dataSet.pool = dataSet.pool = {},
        len = removeDataArr.length,
        conf = dataSet.config,
        removeData,

    // pieCenter = conf.pieCenter,
    ele,
        canvasWidth = chartConfig.canvasWidth,
        canvasHeight = chartConfig.canvasHeight,
        cx = chartConfig.canvasLeft + canvasWidth * 0.5,
        cy = chartConfig.canvasTop + canvasHeight * 0.5,
        hideFn = dataSet.hideElements,
        graphics,
        r = conf.pieMinRadius,
        r2 = (conf.innerSize || 0) * 0.5,
        i,
        startAngle = conf.startAngle,

    // plotItem,
    endAngle = startAngle - pi2;
    for (i = 0; i < len; i++) {
      removeData = removeDataArr[0];
      graphics = removeData.graphics;
      for (ele in graphics) {
        // element will just change ringpath
        if (ele === 'element') {
          anim.plot.data.push({
            el: graphics[ele],
            attrs: {
              ringpath: [cx, cy, r, r2, endAngle, endAngle + 0.01]
            },
            callback: hideFn
          });
          anim.initial.data.push({
            el: graphics[ele],
            attrs: {
              // In case element is sliced it will translate to center
              transform: ''
            },
            animType: 'bounce'
          });
          // other elements will fadeout
        } else {
          anim.initial.data.push({
            el: graphics[ele],
            attrs: {
              opacity: 0
            },
            callback: hideFn
          });
        }
        if (!pool[ele]) {
          pool[ele] = [];
        }
        // hide the elements when updated to lower number of visual count of elements.
        pool[ele].push(graphics[ele]);
      }
      removeDataArr.splice(0, 1);
    }
  };
  /**
   * function to get eventarg for this dataset
   * @return {Object}   arguement object for event
   */


  Pie2DDataset.prototype.getEventArgs = function getEventArgs() {
    var dataset = this,
        index = dataset.getJSONIndex(),
        set = dataset.components.data[index],
        config = set.config || {},
        eventArgs;

    eventArgs = {
      datasetName: config.seriesName,
      datasetIndex: index,
      id: config.userID,
      visible: config.isVisible,
      label: config.seriesName,
      value: config.value,
      percentValue: config.pValue,
      tooltext: config.toolText,
      link: config.link,
      sliced: config.sliced
    };
    return eventArgs;
  };

  return Pie2DDataset;
}(_area2['default']);

exports['default'] = Pie2DDataset;
exports.plotGraphicClick = plotGraphicClick;
exports.trimData = _trimData;
//

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports._createDatasets = undefined;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(12);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _column = __webpack_require__(8);

var _column2 = _interopRequireDefault(_column);

var _area = __webpack_require__(20);

var _area2 = _interopRequireDefault(_area);

var _line = __webpack_require__(11);

var _line2 = _interopRequireDefault(_line);

var _column3 = __webpack_require__(15);

var _column4 = _interopRequireDefault(_column3);

var _fusioncharts3 = __webpack_require__(96);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }
// import { pluck, componentFactory } from '../../renderer-javascript/components/lib';


var UNDEFINED;

var MSCombi2D = function (_AreaBase) {
  _inherits(MSCombi2D, _AreaBase);

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  MSCombi2D.getName = function getName() {
    return 'MSCombi2D';
  };

  function MSCombi2D() {
    _classCallCheck(this, MSCombi2D);

    var _this = _possibleConstructorReturn(this, _AreaBase.call(this));

    _this.friendlyName = 'Multi-series Combination Chart';
    _this.defaultDatasetType = 'column';
    return _this;
  }

  MSCombi2D.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _AreaBase.prototype.__setDefaultConfig && _AreaBase.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    config.enablemousetracking = true;
  };
  /**
   * function to  create dataset, groupmaneger.
   * assign dataset to group manager.
   **/


  MSCombi2D.prototype._createDatasets = function _createDatasets() {
    _fusioncharts3._createDatasets.call(this);
  };
  /**
   * This method return the dataset definations for this charts
   * @param  {string} name type of dataset class
   * @return {Object}      dataset class
   */


  MSCombi2D.prototype.getDSdef = function getDSdef(name) {
    return name === 'area' ? _area2['default'] : name === 'line' ? _line2['default'] : _column2['default'];
  };
  /**
   * This method return the dataset-group definations for this charts
   * @param  {string} name is type of dataset group
   * @return {Object} <dataset group class>     dataset group class
   */


  MSCombi2D.prototype.getDSGroupdef = function getDSGroupdef(name) {
    return name === 'column' ? _column4['default'] : UNDEFINED;
  };
  /**
   * function to return dataset type applicable for this chart
   * @param   {string}  name  dataset type
   * @return  {string}        dataset type applicable for this chart
   */


  MSCombi2D.prototype.getDSType = function getDSType(name) {
    return name && name.toLowerCase() === 'area' ? 'area' : name && name.toLowerCase() === 'line' ? 'line' : 'column';
  };

  return MSCombi2D;
}(_fusioncharts2['default']);

exports['default'] = MSCombi2D;
exports._createDatasets = _fusioncharts3._createDatasets;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _line = __webpack_require__(11);

var _line2 = _interopRequireDefault(_line);

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var UNDEF,
    COMMA = ',',
    NONE = 'none',
    getDarkColor = _lib.graphics.getDarkColor,
    COMMASTRING = ',',
    PLOTGRADIENTCOLOR = 'plotGradientColor',
    SHOWSHADOW = 'showShadow',
    math = Math,
    mathPow = math.pow,
    getLightColor = _lib.graphics.getLightColor,

// Function that produce the point color
getPointColor = function getPointColor(color, alpha) {
  var colorObj, innerColor, outerColor;
  color = (0, _lib.getFirstColor)(color);
  alpha = (0, _lib.getFirstAlpha)(alpha);
  innerColor = getLightColor(color, 70);
  outerColor = getDarkColor(color, 50);
  colorObj = {
    FCcolor: {
      gradientUnits: 'objectBoundingBox',
      cx: 0.4,
      cy: 0.4,
      r: '100%',
      color: innerColor + COMMASTRING + outerColor,
      alpha: alpha + COMMASTRING + alpha,
      ratio: _lib.BGRATIOSTRING,
      radialGradient: true
    }
  };
  return colorObj;
},

/*
* valueX, valueY are the compontents of the setlevel data.
* pointObj - Object to store the regression configuration specific to that dataset.
*/
pointValueWatcher = function pointValueWatcher(valueX, valueY, pointObj) {
  var obj = pointObj.obj || (pointObj.obj = {}),
      objX = pointObj.objX || (pointObj.objX = {}),
      itemValueX,
      itemValueY;
  // update the max and min calculations.
  if (valueY !== null) {
    obj.max = obj.max > valueY ? obj.max : valueY;
    obj.min = obj.min < valueY ? obj.min : valueY;
  }
  if (valueX !== null) {
    objX.max = objX.max > valueX ? objX.max : valueX;
    objX.min = objX.min < valueX ? objX.min : valueX;
  }
  // code for regression line
  if (pointObj.isRegression) {
    itemValueX = valueX || 0;
    itemValueY = valueY || 0;
    // Calculating the summation of X.
    pointObj.sumX += itemValueX;
    // Calculating the summation of Y.
    pointObj.sumY += itemValueY;
    // Calculating the summation of XY.
    pointObj.sumXY += itemValueX * itemValueY;
    // Calculating the summation of X²
    pointObj.sumXsqure += mathPow(itemValueX, 2);
    // Push all the x values
    pointObj.xValues.push(itemValueX);
    // Calculating the summation of Y²
    pointObj.sumYsqure += mathPow(itemValueY, 2);
    // Push all the y values
    pointObj.yValues.push(itemValueY);
  }
},

/*
 * Sorting order callback.
*/
sortFN = function sortFN(a, b) {
  return a - b;
},

/*
 * @return a line series made from the regression Object.
*/
getRegressionLineSeries = function getRegressionLineSeries(regressionObj, showYOnX, dataLength) {
  var data,
      xMin,
      xMax,
      yMin,
      yMax,
      slopeB,
      firstY,
      secondY,
      firstX,
      secondX,
      sumXY = regressionObj.sumXY,
      sumX = regressionObj.sumX,
      sumY = regressionObj.sumY,
      xValues = regressionObj.xValues,
      sumXsqure = regressionObj.sumXsqure,
      yValues = regressionObj.yValues,
      sumYsqure = regressionObj.sumYsqure;
  if (showYOnX) {
    // Short the array
    xValues.sort(sortFN);
    // Store X minimum and maximum no
    xMin = xValues[0];
    xMax = xValues[xValues.length - 1];

    slopeB = (dataLength * sumXY - sumX * sumY) / (dataLength * sumXsqure - mathPow(sumX, 2));
    firstY = !(isNaN(slopeB) || !isFinite(slopeB)) ? slopeB * (xMin - sumX / dataLength) + sumY / dataLength : sumY / dataLength;
    secondY = !(isNaN(slopeB) || !isFinite(slopeB)) ? slopeB * (xMax - sumX / dataLength) + sumY / dataLength : sumY / dataLength;

    data = [{
      x: xMin,
      y: firstY
    }, {
      x: xMax,
      y: secondY
    }];
  } else {
    // Short the array
    yValues.sort(sortFN);
    // Store Y minimum and maximum no
    yMin = yValues[0];
    yMax = yValues[yValues.length - 1];

    slopeB = (dataLength * sumXY - sumX * sumY) / (dataLength * sumYsqure - mathPow(sumY, 2));
    firstX = !isNaN(slopeB) ? slopeB * (yMin - sumY / dataLength) + sumX / dataLength : sumX / dataLength;
    secondX = !isNaN(slopeB) ? slopeB * (yMax - sumY / dataLength) + sumX / dataLength : sumX / dataLength;

    data = [{
      x: firstX,
      y: yMin
    }, {
      x: secondX,
      y: yMax
    }];
  }
  return data;
},
    hidingPosition = function hidingPosition() {
  return function () {
    return {
      polypath: [[2, 0, 0, 0, 0, 0]],
      text: ''
    };
  };
};

var ScatterDataset = function (_LineDataset) {
  _inherits(ScatterDataset, _LineDataset);

  function ScatterDataset() {
    _classCallCheck(this, ScatterDataset);

    var _this = _possibleConstructorReturn(this, _LineDataset.call(this));

    _this.type = 'scatter';
    return _this;
  }

  /**
   * Returns the name of this component
   *
   * @return {string} The name of this component
   */


  ScatterDataset.prototype.getName = function getName() {
    return 'scatter';
  };

  /*
   * Parses all the attributes for dataset level and set level
   * Called from init function of scatter class
   */


  ScatterDataset.prototype.configureAttributes = function configureAttributes(datasetJSON) {
    if (!datasetJSON) {
      return false;
    }
    this.trimData(datasetJSON);
    this.JSONData = datasetJSON;
    var plotBorderDash,
        parentYAxis,
        enableAnimation,
        defaultShadow,
        dataSet = this,
        chart = dataSet.getFromEnv('chart'),
        conf = dataSet.config,
        JSONData = dataSet.JSONData,
        areaAlpha = chart.areaAlpha,

    // chart level JSON format
    chartAttr = chart.jsonData.chart,
        colorM = dataSet.getFromEnv('color-manager'),
        showplotborder = (0, _lib.pluckNumber)(JSONData.showplotborder, chartAttr.showplotborder || 1),
        plotFillColor = colorM.getPlotColor(dataSet.index),
        usePlotGradientColor,
        lineDashed = conf.lineDashed = (0, _lib.pluckNumber)(JSONData.linedashed, JSONData.dashed, chartAttr.linedashed, 0),
        isLineSet = dataSet.isLineSet;
    conf.plotColor = plotFillColor;
    defaultShadow = (0, _lib.pluckNumber)(chart.defaultPlotShadow, colorM.getColor(SHOWSHADOW));
    conf.xAxisLabelMode = (0, _lib.pluck)(chartAttr.xaxislabelmode, 'categories');
    conf.toolTipSepChar = (0, _lib.pluck)(chartAttr.tooltipsepchar, ', ');

    conf.defaultValuePadding = {
      left: 0,
      right: 0
    };
    // Functional attributes configuration
    // ParentYAxis is always 1 for lineset
    if (isLineSet) {
      conf.parentYAxis = parentYAxis = 1;
    } else {
      conf.parentYAxis = parentYAxis = (0, _lib.pluck)(JSONData.parentyaxis && JSONData.parentyaxis.toLowerCase(), 'p') === 's' ? 1 : 0;
    }

    dataSet.yAxis = dataSet.getFromEnv('yAxis')[parentYAxis];
    conf.connectNullData = (0, _lib.pluckNumber)(chartAttr.connectnulldata, 0);

    conf.includeInLegend = (0, _lib.pluckNumber)(JSONData.includeinlegend, 1);
    // Animation related attributes configuration
    conf.enableAnimation = enableAnimation = (0, _lib.pluckNumber)(chartAttr.animation, chartAttr.defaultanimation, 1);
    conf.animation = !enableAnimation ? false : {
      duration: (0, _lib.pluckNumber)(chartAttr.animationduration, 1) * 1000
    };
    conf.transposeanimation = (0, _lib.pluckNumber)(chartAttr.transposeanimation, enableAnimation);
    conf.transposeanimduration = (0, _lib.pluckNumber)(chartAttr.transposeanimduration, 0.2) * 1000;

    // Value related configurations
    conf.showValues = (0, _lib.pluckNumber)(JSONData.showvalues, chartAttr.showvalues);
    conf.valuePadding = (0, _lib.pluckNumber)(chartAttr.valuepadding, 2);
    conf.valuePosition = (0, _lib.pluck)(JSONData.valueposition, chartAttr.valueposition, 'auto');

    // Tooltip related attributes
    conf.showTooltip = (0, _lib.pluckNumber)(chartAttr.showtooltip, 1);
    conf.seriesNameInTooltip = (0, _lib.pluckNumber)(chartAttr.seriesnameintooltip, 1);
    // Regression Line cosmetics
    conf.showRegressionLine = (0, _lib.pluckNumber)(JSONData.showregressionline, chartAttr.showregressionline, 0);
    // Data Plot cosmetics attributes configuration parsing
    conf.plotFillColor = conf.plotfillcolor = (0, _lib.pluck)(JSONData.color, chartAttr.plotfillcolor, plotFillColor);
    conf.plotFillAngle = conf.plotFillAngle = (0, _lib.pluck)(chartAttr.plotfillangle, 270);
    conf.plotFillAlpha = conf.plotfillalpha = (0, _lib.pluck)(JSONData.alpha, chartAttr.plotfillalpha, areaAlpha, '70');
    usePlotGradientColor = (0, _lib.pluckNumber)(chartAttr.useplotgradientcolor, 1);
    conf.plotGradientColor = conf.plotgradientcolor = usePlotGradientColor !== 0 ? (0, _lib.getDefinedColor)(chartAttr.plotgradientcolor, colorM.getColor(PLOTGRADIENTCOLOR)) : '';
    conf.fillColor = conf.fillcolor = {
      color: conf.plotfillcolor + (conf.plotgradientcolor ? COMMA + conf.plotgradientcolor : _lib.BLANKSTRING),
      alpha: conf.plotfillalpha,
      angle: conf.plotFillAngle
    };

    conf.plotBorderAlpha = conf.plotborderalpha = showplotborder ? (0, _lib.pluck)(JSONData.plotborderalpha, chartAttr.plotborderalpha, JSONData.alpha, '95') : 0;
    conf.plotBorderColor = conf.plotbordercolor = (0, _lib.pluck)(JSONData.plotbordercolor, chartAttr.plotbordercolor, chartAttr.areabordercolor, '666666');
    conf.dashed = plotBorderDash = (0, _lib.pluckNumber)(JSONData.dashed, chartAttr.plotborderdashed);
    conf.plotBorderDashLen = conf.plotborderdashlen = (0, _lib.pluck)(JSONData.plotborderdashlen, chartAttr.plotborderdashlen, 5);
    conf.plotBorderDashGap = conf.plotborderdashgap = (0, _lib.pluck)(JSONData.plotborderdashgap, chartAttr.plotborderdashgap, 4);
    conf.plotBorderThickness = conf.plotborderthickness = (0, _lib.pluckNumber)(JSONData.plotborderthickness, chartAttr.plotborderthickness, 1);
    conf.plotBorderDashStyle = conf.plotborderdashstyle = plotBorderDash ? (0, _lib.getDashStyle)(conf.plotborderdashlen, conf.plotborderdashgap) : 'none';

    conf.showHoverEffect = conf.showhovereffect = (0, _lib.pluckNumber)(chartAttr.plothovereffect, chartAttr.anchorhovereffect, chartAttr.showhovereffect, UNDEF);

    conf.rotateValues = (0, _lib.pluckNumber)(chartAttr.rotatevalues) ? 270 : 0;
    // Line configuration attributes parsing
    conf.drawLine = (0, _lib.pluckNumber)(JSONData.drawline, chartAttr.drawlines, 0);
    conf.lineThickness = conf.linethickness = (0, _lib.pluckNumber)(JSONData.linethickness, chartAttr.linethickness, 2);
    conf.lineDashLen = conf.linedashlen = (0, _lib.pluckNumber)(JSONData.linedashlen, chartAttr.linedashlen, 5);
    conf.lineDashGap = conf.linedashgap = (0, _lib.pluckNumber)(JSONData.linedashgap, chartAttr.linedashgap, 4);
    conf.lineAlpha = conf.linealpha = (0, _lib.pluckNumber)(JSONData.linealpha, chartAttr.linealpha, JSONData.alpha, _lib.HUNDREDSTRING);
    conf.lineColor = conf.linecolor = (0, _lib.pluck)(JSONData.linecolor, chartAttr.linecolor, JSONData.color, conf.plotColor);
    conf.lineDashStyle = conf.linedashstyle = (0, _lib.getDashStyle)(conf.linedashlen, conf.linedashgap);
    conf.lineDashStyle = conf.linedashstyle = lineDashed ? conf.linedashstyle : NONE;
    // todo remove if not applicable in scatter chart.
    conf.shadow = {
      opacity: (0, _lib.pluckNumber)(chartAttr.showshadow, defaultShadow) ? conf.linealpha / 100 : 0
    };
    // Anchor cosmetics attributes in dataset level
    // Whether to draw the Anchors or not.
    conf.drawanchors = (0, _lib.pluckNumber)(JSONData.drawanchors, JSONData.showanchors, chartAttr.drawanchors, chartAttr.showanchors);
    conf.anchorbgcolor = (0, _lib.getFirstColor)((0, _lib.pluck)(JSONData.anchorbgcolor, chartAttr.anchorbgcolor, colorM.getColor('anchorBgColor')));
    conf.anchorbordercolor = (0, _lib.getFirstColor)((0, _lib.pluck)(JSONData.anchorbordercolor, JSONData.color, chartAttr.anchorbordercolor, conf.linecolor));
    conf.anchorradius = (0, _lib.pluckNumber)(JSONData.anchorradius, chartAttr.anchorradius, 3);
    conf.anchoralpha = (0, _lib.pluck)(JSONData.anchoralpha, JSONData.alpha, chartAttr.anchoralpha, _lib.HUNDREDSTRING);
    conf.anchorbgalpha = (0, _lib.pluck)(JSONData.anchorbgalpha, JSONData.alpha, chartAttr.anchorbgalpha, _lib.HUNDREDSTRING);
    conf.anchorborderthickness = (0, _lib.pluck)(JSONData.anchorborderthickness, chartAttr.anchorborderthickness, 1);
    // We first look into dataset then chart obj and then default value.
    conf.anchorsides = (0, _lib.pluckNumber)(JSONData.anchorsides, chartAttr.anchorsides, dataSet.index + 3);

    // Anchor image cosmetics attributes
    conf.anchorimageurl = (0, _lib.pluck)(JSONData.anchorimageurl, chartAttr.anchorimageurl);
    conf.anchorimagealpha = (0, _lib.pluckNumber)(JSONData.anchorimagealpha, chartAttr.anchorimagealpha, 100);
    conf.anchorimagescale = (0, _lib.pluckNumber)(JSONData.anchorimagescale, chartAttr.anchorimagescale, 100);
    conf.anchorimagepadding = (0, _lib.pluckNumber)(JSONData.anchorimagepadding, chartAttr.anchorimagepadding, 1);
    conf.anchorstartangle = (0, _lib.pluckNumber)(JSONData.anchorstartangle, chartAttr.anchorstartangle, 90);
    conf.anchorshadow = (0, _lib.pluckNumber)(JSONData.anchorshadow, chartAttr.anchorshadow, 0);

    conf.plotToolText = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(JSONData.plottooltext, chartAttr.plottooltext)));
    // if there is a valid dataset array provided.
    if (conf.showRegressionLine) {
      // regression object used in XY chart
      // Create here to avoid checking always
      conf.regressionObj = {
        isRegression: true,
        sumX: 0,
        sumY: 0,
        sumXY: 0,
        sumXsqure: 0,
        sumYsqure: 0,
        xValues: [],
        yValues: []
      };
      conf.showYOnX = (0, _lib.pluckNumber)(JSONData.showyonx, chartAttr.showyonx, 1);
      // Regression Line cosmetics.
      conf.regressionLineColor = (0, _lib.getFirstColor)((0, _lib.pluck)(JSONData.regressionlinecolor, chartAttr.regressionlinecolor, conf.anchorbordercolor));
      conf.regressionLineThickness = (0, _lib.pluckNumber)(JSONData.regressionlinethickness, chartAttr.regressionlinethickness, conf.anchorborderthickness);
      conf.regressionLineAlpha = (0, _lib.getFirstAlpha)((0, _lib.pluckNumber)(JSONData.regressionlinealpha, chartAttr.regressionlinealpha, conf.anchoralpha));
      conf.regLineColor = (0, _lib.toRaphaelColor)({
        color: conf.regressionLineColor,
        alpha: conf.regressionLineAlpha
      });
    }
    if (conf.seriesNameInTooltip) {
      conf.seriesname = (0, _lib.getFirstValue)(JSONData && JSONData.seriesname);
    }
    dataSet.setState('visible', (0, _lib.pluckNumber)(JSONData.visible, !Number(JSONData.initiallyhidden), 1) === 1);
    dataSet._setConfigure();
    chart.hasLegend !== false && dataSet._addLegend();
  };

  /**
   * Sets the configurations for the set level attributes.
   */


  ScatterDataset.prototype._setConfigure = function _setConfigure() {
    var i,
        config,
        dataObj,
        setData,
        setValue,
        toolText,
        toolTipValue,
        macroIndices,
        parserConfig,
        formatedVal,
        formatedValX,
        setDisplayValue,
        infMin = -Infinity,
        infMax = +Infinity,
        yMax = infMin,
        yMin = infMax,
        xMin = infMax,
        xMax = infMin,
        dataSet = this,
        dataStore = dataSet.components.data || (dataSet.components.data = []),
        chart = dataSet.getFromEnv('chart'),
        conf = dataSet.config,
        JSONData = dataSet.JSONData,

    // chart level JSON format
    chartAttr = chart.jsonData.chart,
        setDataArr = JSONData.data || [],
        dataSetLen = setDataArr.length,
        numberFormatter = dataSet.getFromEnv('number-formatter'),
        yAxisName = (0, _lib.parseUnsafeString)(chartAttr.yaxisname),
        xAxisName = (0, _lib.parseUnsafeString)(chartAttr.xaxisname),
        lineDashed = conf.lineDashed,
        lineDashStyle = conf.linedashstyle,
        parentYAxis = conf.parentYAxis,
        tooltipSepChar = conf.toolTipSepChar,
        seriesname = conf.seriesname;

    conf.imageCount = 0;
    // Iterate through all set level data
    for (i = 0; i < dataSetLen; i += 1) {
      setData = setDataArr[i];
      dataObj = dataStore[i] || (dataStore[i] = {});
      config = dataObj.config || (dataObj.config = {});
      // The set data is given: {x: <Number>, y : <Number>}
      config.setValue = setValue = {
        x: numberFormatter.getCleanValue(setData.x),
        y: numberFormatter.getCleanValue(setData.y)
      };
      if (setValue.x !== null && setValue.y !== null) {
        if (setValue.x > xMax) {
          xMax = setValue.x;
          conf.rightMostData = dataObj;
        }
        if (setValue.x < xMin) {
          xMin = setValue.x;
          conf.leftMostData = dataObj;
        }
        if (setValue.y > yMax) {
          yMax = setValue.y;
          conf.topMostData = dataObj;
        }
        if (setValue.y < yMin) {
          yMin = setValue.y;
          conf.bottomMostData = dataObj;
        }
      }
      // update the regression calulations.
      conf.showRegressionLine && pointValueWatcher(setValue.x, setValue.y, conf.regressionObj);

      config._x = setValue.x;
      config._y = setValue.y;

      config.setLink = (0, _lib.pluck)(setData.link);
      // Parsing the anchor properties for set level
      config.anchorProps = this._parseAnchorProperties(i);

      config.showValue = (0, _lib.pluckNumber)(setData.showvalue, conf.showValues);
      // Dashed, color and alpha configuration in set level is only for line chart
      config.dashed = (0, _lib.pluckNumber)(setData.dashed, lineDashed);
      config.color = (0, _lib.pluck)(setData.color, conf.linecolor);
      config.alpha = (0, _lib.pluck)(setData.alpha, conf.linealpha);

      config.dashStyle = config.dashed ? lineDashStyle : 'none';
      config.toolTipValue = toolTipValue = numberFormatter.dataLabels(setValue.y, parentYAxis);
      config.setDisplayValue = setDisplayValue = (0, _lib.parseUnsafeString)(setData.displayvalue);
      formatedVal = config.formatedVal = (0, _lib.pluck)(setData.toolTipValue, numberFormatter.dataLabels(setValue.y, parentYAxis));
      formatedValX = numberFormatter.xAxis(setValue.x);
      config.displayValue = (0, _lib.pluck)(setDisplayValue, toolTipValue);
      config.setTooltext = (0, _lib.getValidValue)((0, _lib.parseUnsafeString)((0, _lib.pluck)(setData.tooltext, conf.plotToolText)));
      // Initial tooltext parsing
      if (!conf.showTooltip) {
        toolText = false;
      } else if (config.setTooltext !== UNDEF) {
        macroIndices = [4, 5, 6, 7, 8, 9, 10, 11];
        parserConfig = {
          yaxisName: yAxisName,
          xaxisName: xAxisName,
          yDataValue: formatedVal,
          xDataValue: formatedValX
        };
        toolText = (0, _lib.parseTooltext)(config.setTooltext, macroIndices, parserConfig, setData, chartAttr, JSONData);
      } else {
        // determine the default tooltext then.
        if (formatedVal === null) {
          toolText = false;
        } else {
          toolText = seriesname ? seriesname + tooltipSepChar : _lib.BLANKSTRING;
          toolText += setValue.x ? formatedValX + tooltipSepChar : _lib.BLANKSTRING;
          toolText += toolTipValue;
        }
      }

      config.toolText = toolText;
      if (!dataObj) {
        dataObj = dataStore[i] = {
          graphics: {}
        };
      } else if (!dataObj.graphics) {
        dataStore[i].graphics = {};
      }
      // parse the hover cosmetics.
      config.hoverEffects = this._parseHoverEffectOptions(dataObj);
      config.anchorProps.isAnchorHoverRadius = config.hoverEffects.anchorRadius;
    }
    conf.xMax = xMax;
    conf.xMin = xMin;
    conf.yMin = yMin;
    conf.yMax = yMax;
    // augment the regression line to be a line series.
    if (conf.showRegressionLine) {
      // get a line series.
      conf.regressionData = getRegressionLineSeries(conf.regressionObj, conf.showYOnX, dataSetLen);
    }
    dataSet.ErrorValueConfigure && dataSet.ErrorValueConfigure();
  };
  /*
  * Animate common element
  */


  ScatterDataset.prototype.animateCommonElements = function animateCommonElements(lineOb, anim) {
    var dataset = this,
        chart = dataset.getFromEnv('chart'),
        paper = dataset.getFromEnv('paper'),

    // containers = dataset.graphics.containers,
    key = '',
        fullPath,
        item,
        j = 0,
        jj = 0,
        visible = dataset.getState('visible'),
        hasRegressionLine = dataset.config.showRegressionLine,
        regressionOb = dataset.regressionOb,
        isSingleStepAnim = chart.config.isSingleStepAnim,
        animCb = function animCb(animItem) {
      this.attr({
        path: fullPath
      });
      animItem.el.attr(animItem.attr);
    },
        drawLine = dataset.config.drawLine;
    // Iterating over line storing Object
    for (key in lineOb) {
      item = lineOb[key];
      if (item.used) {
        // generate path and old path
        fullPath = [];
        for (j = 0, jj = item.path.length; j < jj; ++j) {
          fullPath = fullPath.concat(item.path[j].getPathArr());
        }
        // create line if doesnt exist
        if (!item.el) {
          item.el = paper.path({
            path: fullPath,
            opacity: 0
          }, dataset.getContainer('commonElemsGroup'));
        }
        // stopping previous animation
        item.el.stop();
        if (!isSingleStepAnim) {
          anim.initial.data.push({
            el: item.el,
            attrs: {
              opacity: 0
            },
            callback: animCb.bind(item.el, item)
          });
          // Fade In if visible
          visible && drawLine && anim['final'].data.push({
            el: item.el,
            attrs: {
              opacity: 1
            }
          });
        } else {
          anim.plot.data.push({
            el: item.el,
            attrs: {
              path: fullPath
            }
          });
        }
      } else {
        // Remove the element
        anim['final'].data.push({
          el: item.el,
          type: 'fadeOut'
        });
        delete lineOb[key];
      }
      // Mark for next event that
      // this element was before
      item.old = true;
      item.used = false;
      item.prevPath = item.path;
      item.attrs = UNDEF;
      item.path = UNDEF;
    }

    // regression line animation
    if (hasRegressionLine && visible) {
      regressionOb.el = regressionOb.el || paper.path(dataset.getContainer('areaGroup'));
      if (chart.state === 'initial') {
        regressionOb.el.attr(regressionOb.attr);
        regressionOb.el.hide();
      }
      regressionOb.el.attr('visibility') !== 'hidden' && anim.initial.data.push({
        el: regressionOb.el,
        type: 'fadeOut'
      });
      anim['final'].data.push({
        el: regressionOb.el,
        type: 'fadeIn'
      });
    } else if (regressionOb.el) {
      anim.initial.data.push({
        el: regressionOb.el,
        type: 'fadeOut'
      });
    }
  };
  /*
   * Using kdtree algo for searching
  */


  ScatterDataset.prototype._getHoveredPlot = function _getHoveredPlot(x, y) {
    var res = this.dataTree.getNeighbour({
      x: x,
      y: y
    }, true);
    // searching neighbour from Kdtree with basic search flag on
    if (res) {
      return {
        pointIndex: res.index || res.i,
        hovered: true,
        pointObj: res.data
      };
    }
  };
  /**
   * Helper function to create a RedRaphael group.
   * @param  {String} groupName                Name of the group to be created.
   * @param  {Paper} paper                     A RedRaphael paper element.
   * @param  {Element} parentContainer         The parent container in which the group will be appended.
   * @return {Element}                         The group that was created.
   */
  // createGroup (groupName, paper, parentContainer) {
  //   return paper.group(groupName, parentContainer);
  // }

  // Draw and update the graphics elements of plots

  ScatterDataset.prototype.animatePlots = function animatePlots(anim) {
    var dataset = this,
        chart = dataset.getFromEnv('chart'),
        chartConfig = chart.config,
        isSingleStepAnim = chartConfig.isSingleStepAnim,
        dsComponents = dataset.components,
        dataStore = dsComponents.data,
        animStore = dsComponents.animAttrs,
        dsLen = dataStore.length,

    // JSONData = dataset.JSONData,
    // setDataArr = JSONData.data || {},
    animObj,
        elemPolypath,
        animState,
        animAttrs,
        animElem,
        i,
        ii;

    for (i = 0, ii = dsLen; i < ii; i += 1) {
      // setData = setDataArr[i];
      // dataObj = dataStore[i];
      animObj = animStore[i];

      animState = animObj.state;
      animAttrs = animObj.attrs;
      animElem = animObj.elem;

      if (isSingleStepAnim) {
        anim.plot.data.push({
          el: animElem,
          attrs: animAttrs,
          animType: 'easeOut'
        });
      } else {
        if (animState === 'initial') {
          elemPolypath = animAttrs.polypath.slice();
          elemPolypath[2] = chartConfig.canvasBottom;
          animElem.attr({
            polypath: elemPolypath,
            opacity: 0,
            'fill-opacity': 0,
            'stroke-opacity': 0
          });
          anim.plot.data.push({
            el: animElem,
            attrs: animAttrs,
            animType: 'easeOut',
            animConfig: [{
              start: 0,
              end: 1,
              syncWith: 'plot'
            }]
          });
        } else if (animState === 'update') {
          anim.plot.data.push({
            el: animElem,
            attrs: animAttrs,
            animType: 'easeOut',
            animConfig: [{
              start: 0,
              end: 1,
              syncWith: 'plot'
            }]
          });
        } else if (animState === 'hide') {
          elemPolypath = animElem.attr('polypath').slice();
          elemPolypath[2] = chartConfig.canvasBottom;
          anim.plot.data.push({
            el: animElem,
            attrs: {
              'polypath': elemPolypath,
              'opacity': 0,
              'stroke-opacity': 0,
              'fill-opacity': 0
            },
            animType: 'easeOut',
            animConfig: [{
              start: 0,
              end: 1,
              syncWith: 'plot'
            }]
          });
        } else {
          animElem.attr(animAttrs);
        }
      }
    }
    dataset.setupHoverTracker();
  };

  /*
   * Called from groupmanager for each dataset when it is initially drawn or drawn on legend interaction
   */


  ScatterDataset.prototype.removeElements = function removeElements() {
    var dataSet = this,
        components = dataSet.components,
        removeDataArr = components.removeDataArr,
        pool = components.pool || (components.pool = {
      element: [],
      hotElement: [],
      label: []
    }),
        chart = dataSet.getFromEnv('chart'),
        animationManager = dataSet.getFromEnv('animationManager'),
        removeData,
        maxminFlag = dataSet.maxminFlag,
        ele,
        graphics,
        i,
        attr,
        chartConfig = chart.config,
        paper = dataSet.getFromEnv('paper'),
        rotateValues = chartConfig.rotatevalues,
        clear = chartConfig.realTimeConfig && chartConfig.realTimeConfig.clear,
        position = hidingPosition(),
        _pos = function _pos(data) {
      return position(data);
    },
        animCallBack = function animCallBack() {
      this.hide();
    },
        removedAnimElems = [],
        removedElemPolypath;

    for (i = removeDataArr.length - 1; i >= 0; i--) {
      removeData = removeDataArr[i];
      removeDataArr.splice(i, 1);
      // In case of non existing data plot continue;
      if (!removeData || !removeData.graphics) {
        continue;
      }

      graphics = removeData.graphics;
      for (ele in graphics) {
        if (ele === 'label' && dataSet.startPosition === UNDEF && dataSet.endPosition === UNDEF) {
          graphics[ele].hide();
        }
        attr = _pos(removeData);
        if (ele === 'label') {
          attr.transform = paper.getSuggestiveRotation(rotateValues, attr.x, attr.y);
        }
        clear && graphics[ele].hide();
        removedElemPolypath = graphics[ele].attr('polypath').slice();
        removedElemPolypath[2] = chartConfig.canvasBottom;

        removedAnimElems.push({
          el: graphics[ele],
          attrs: {
            polypath: removedElemPolypath,
            opacity: 0,
            'fill-opacity': 0,
            'stroke-opacity': 0
          },
          callback: animCallBack,
          animType: 'easeIn',
          animConfig: [{
            start: 0,
            end: 1,
            syncWith: 'middle'
          }]
        });
      }
      animationManager.registerAnimation([{
        data: removedAnimElems,
        animType: 'easeIn',
        animConfig: [{
          start: 0,
          end: 1,
          syncWith: 'middle'
        }]
      }], 'plot');

      // Storing the graphic elements for reuse.
      removeData.graphics.element && (pool.element = pool.element.concat(removeData.graphics.element));
      removeData.graphics.hotElement && (pool.hotElement = pool.hotElement.concat(removeData.graphics.hotElement));
      removeData.graphics.label && (pool.label = pool.label.concat(removeData.graphics.label));
    }
    components.pool = pool;
    maxminFlag && dataSet.setMaxMin();
  };

  ScatterDataset.prototype.getDataLimits = function getDataLimits() {
    var dataset = this,
        conf = dataset.config,
        chart = dataset.getFromEnv('chart'),
        chartConfig = chart.config,
        max = conf.yMax,
        min = conf.yMin,
        xMax = conf.xMax,
        xMin = conf.xMin,
        infMin = -Infinity,
        infMax = +Infinity,
        transposeAxis = chartConfig.transposeAxis;
    if (dataset.getState('visible') === false && transposeAxis) {
      max = infMin;
      min = infMax;
      xMax = infMin;
      xMin = infMax;
    }
    return {
      max: max,
      min: min,
      xMax: xMax,
      xMin: xMin
    };
  };

  ScatterDataset.prototype.getAxisValuePadding = function getAxisValuePadding() {
    return this.config.defaultValuePadding;
  };

  // Function to register datasets in the internal data store of legend class.


  ScatterDataset.prototype._addLegend = function _addLegend() {
    var symbolColor,
        mFillColor,
        mLineColor,
        dataset = this,
        chart = dataset.getFromEnv('chart'),
        conf = dataset.config,
        legend = chart.getChildren('legend')[0],
        drawAnchors = (0, _lib.pluckNumber)(conf.drawanchors, 1),
        marker = {
      fillColor: getPointColor(conf.anchorbgcolor, _lib.HUNDREDSTRING),
      lineColor: {
        FCcolor: {
          color: conf.anchorbordercolor,
          alpha: conf.anchoralpha
        }
      },
      lineWidth: conf.anchorborderthickness
    },
        item3dlighting = legend.config.symbol3DLighting;

    if (item3dlighting) {
      if (marker.fillcolor && marker.fillcolor.FCcolor) {
        symbolColor = (0, _lib.extend2)({}, marker.fillcolor);
        symbolColor.FCcolor.alpha = '100';
      } else {
        symbolColor = (0, _lib.pluck)(marker.fillColor);
      }
    } else {
      symbolColor = {
        FCcolor: {
          color: (0, _lib.pluck)((mFillColor = marker.fillColor) && (mFillColor.FCcolor && mFillColor.FCcolor.color.split(COMMA)[0] || mFillColor)),
          angle: 0,
          ratio: '0',
          alpha: '100'
        }
      };
    }

    dataset.legendItemId = legend.addItems(dataset, dataset.legendInteractivity, {
      enabled: conf.includeInLegend,
      type: dataset.type,
      drawLine: (0, _lib.pluck)(conf.drawLine, true),
      fillColor: (0, _lib.toRaphaelColor)(symbolColor),
      strokeColor: (0, _lib.toRaphaelColor)((0, _lib.pluck)((mLineColor = marker.lineColor) && (mLineColor.FCcolor && mLineColor.FCcolor.color.split(COMMA)[0] || mLineColor))),
      rawFillColor: conf.anchorbgcolor,
      rawStrokeColor: conf.anchorbordercolor,
      anchorSide: drawAnchors ? conf.anchorsides : 0,
      strokeWidth: conf.anchorborderthickness,
      label: (0, _lib.getFirstValue)(dataset.JSONData.seriesname)
    });
  };

  ScatterDataset.prototype.getDSGroupdef = function getDSGroupdef() {
    return UNDEF;
  };

  return ScatterDataset;
}(_line2['default']);

exports['default'] = ScatterDataset;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _lib = __webpack_require__(5);

var _stringsLib = __webpack_require__(234);

var _componentInterface = __webpack_require__(6);

var _componentInterface2 = _interopRequireDefault(_componentInterface);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var sortColorFN = (0, _lib.getComparatorFN)(true, 'minvalue'),
    UNDEF = void 0;

// Class for managing gradient color range

var ColorGradient = function (_ComponentInterface) {
  _inherits(ColorGradient, _ComponentInterface);

  function ColorGradient() {
    _classCallCheck(this, ColorGradient);

    return _possibleConstructorReturn(this, _ComponentInterface.apply(this, arguments));
  }

  ColorGradient.prototype.configure = function configure(colorRange) {
    var cm = this,
        oldColorArr = cm.colorArr,
        colorManager = cm.getFromEnv('color-manager'),
        numberFormatter = cm.getFromEnv('number-formatter'),
        colorArr = colorRange && (0, _lib.extend2)({}, colorRange).color,
        defuPaletteOptions = colorManager.getColor('paletteColors'),
        defaultObj,
        colorObj,
        colorObjNext,
        i,
        l,
        temp,
        newColorRange,
        j,
        newMin,
        nextIndex;

    // removing due to defaultAsigned retaining false after update
    delete cm.defaultAsigned;

    if (!(defuPaletteOptions instanceof Array)) {
      defuPaletteOptions = colorManager.getPlotColor(0);
    }
    if (colorArr && colorArr.length > 0) {
      l = colorArr.length - 1;
      // validate all color object
      // remove invalid obj
      for (i = l; i >= 0; i -= 1) {
        colorObj = colorArr[i];
        if (colorObj) {
          colorObj.minvalue = numberFormatter.getCleanValue(colorObj.minvalue);
          colorObj.maxvalue = numberFormatter.getCleanValue(colorObj.maxvalue);

          // for not specified min/max value
          if (colorObj.minvalue === null) {
            if (colorObj.maxvalue !== null) {
              colorObj.minvalue = colorObj.maxvalue;
            } else if (i !== l) {
              // remove invalid color range
              colorArr.splice(i, 1);
            }
          }

          if (colorObj.label !== UNDEF) {
            colorObj.label = (0, _lib.parseUnsafeString)(colorObj.label);
          }

          if (colorObj.name !== UNDEF) {
            colorObj.name = (0, _lib.parseUnsafeString)(colorObj.name);
          }

          if (colorObj.maxvalue !== null) {
            if (colorObj.minvalue > colorObj.maxvalue) {
              // alter the value
              temp = colorObj.minvalue;
              colorObj.minvalue = colorObj.maxvalue;
              colorObj.maxvalue = temp;
            }
          }
        }
      }
      // now sort colors
      colorArr.sort(sortColorFN);

      // Put the default Color if color not given in color Obj
      if (!colorArr[0].code) {
        colorArr[0].code = defuPaletteOptions[0];
      }
      // Put the default Alpha if Alpha not given in color Obj
      if ((0, _lib.getValidValue)(colorArr[0].alpha) === UNDEF) {
        colorArr[0].alpha = _stringsLib.HUNDREDSTRING;
      }
      // now devide overlaping color ranges
      for (i = 0, l = colorArr.length - 1; i < l; i += 1) {
        nextIndex = i + 1;
        colorObj = colorArr[i];
        colorObjNext = colorArr[nextIndex];
        // Put the default Color if color not given in color Obj
        if (!colorObjNext.code) {
          colorObjNext.code = defuPaletteOptions[nextIndex];
        }
        // Put the default Alpha if Alpha not given in color Obj
        if ((0, _lib.getValidValue)(colorObjNext.alpha) === UNDEF) {
          colorObjNext.alpha = _stringsLib.HUNDREDSTRING;
        }
        // if maxColor is null
        if (colorObj.maxvalue === null) {
          colorObj.maxvalue = colorObjNext.minvalue;
        }

        if (colorObj.maxvalue > colorObjNext.minvalue) {
          if (colorObj.maxvalue > colorObjNext.maxvalue) {
            newColorRange = (0, _lib.extend2)(colorObj);
            newColorRange.maxvalue = colorObj.maxvalue;
            newMin = newColorRange.minvalue = colorObjNext.maxvalue;
            // insert newColorRange into proper position
            j = i + 2;
            while (j < l && colorArr[j].minvalue < newMin) {
              j += 1;
            }
            colorArr.splice(j, 0, newColorRange);
            l += 1; // legth increased
          }
          colorObj.maxvalue = colorObjNext.minvalue;
        }
      }
      // if last color has null maxvalue
      colorObj = colorArr[i];
      // if maxColor is null
      if (colorObj.maxvalue === null) {
        colorObj.maxvalue = colorObj.minvalue;
      }
    }

    if (!(colorArr && colorArr.length || oldColorArr && oldColorArr.length)) {
      if (!defaultObj) {
        defaultObj = {
          code: 'CCCCCC',
          alpha: '100',
          bordercolor: '000000',
          borderalpha: '100'
        };
      }
      colorArr = [defaultObj];
      cm.defaultAsigned = true;
    }

    cm.colorArr = colorArr || oldColorArr;
  };

  ColorGradient.prototype.getColorObj = function getColorObj(value) {
    var colorArr = this.colorArr,
        i = 0,
        l = colorArr.length,
        colorObj,
        nextColorObj,
        returnedObj = {};
    for (; i < l; i += 1) {
      returnedObj.index = i;
      colorObj = colorArr[i];
      nextColorObj = colorArr[i + 1];
      if (value < colorObj.minvalue) {
        returnedObj.nextObj = colorObj;
        return returnedObj;
      }
      if (value >= colorObj.minvalue && value <= colorObj.maxvalue) {
        returnedObj.colorObj = colorObj;
        if (nextColorObj && value == nextColorObj.minvalue) {
          // at the border of two color point
          returnedObj.nextObj = nextColorObj;
          returnedObj.isOnMeetPoint = true;
        }
        return returnedObj;
      }
      returnedObj.prevObj = colorObj;
    }
    returnedObj.index = i - 1;
    return returnedObj;
  };

  ColorGradient.prototype.getColorRangeArr = function getColorRangeArr(minValue, maxValue) {
    var temp,
        colorArr = this.colorArr,
        i,
        l,
        minColorObj,
        lastMaxValue,
        maxColorObj,
        returnArr = [],
        colorObj,
        lastColorObj;
    if (!this.defaultAsigned) {
      if (minValue > maxValue) {
        // Swap
        temp = minValue;
        minValue = maxValue;
        maxValue = temp;
      }
      if (minValue < maxValue) {
        minColorObj = this.getColorObj(minValue);
        maxColorObj = this.getColorObj(maxValue);
        if (minColorObj && maxColorObj) {
          lastMaxValue = minValue;
          i = minColorObj.index;
          l = maxColorObj.index;
          for (; i <= l; i += 1) {
            colorObj = (0, _lib.extend2)({}, colorArr[i]);
            if (colorObj.minvalue !== lastMaxValue) {
              colorObj.minvalue = lastMaxValue;
            }
            returnArr.push(colorObj);
            lastColorObj = colorObj;
            lastMaxValue = colorObj.maxvalue;
          }
          lastColorObj.maxvalue = maxValue;
        }
      }
    }
    return returnArr;
  };

  return ColorGradient;
}(_componentInterface2['default']);

exports['default'] = ColorGradient;

/***/ }),
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */
/***/ (function(module, exports) {

module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};

/***/ }),
/* 76 */
/***/ (function(module, exports) {

var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

/***/ }),
/* 77 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(309), __esModule: true };

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

exports.__esModule = true;
exports.getDep = exports._global = undefined;

var _iterator = __webpack_require__(9);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(10);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2['default'] === "function" && typeof _iterator2['default'] === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2['default'] === "function" && obj.constructor === _symbol2['default'] && obj !== _symbol2['default'].prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                                                                                         * FusionCharts Core Framework
                                                                                                                                                                                                                                                                                                                                         * This module contains the basic routines required by subsequent modules to
                                                                                                                                                                                                                                                                                                                                         * extend/scale or add functionality to the FusionCharts object.
                                                                                                                                                                                                                                                                                                                                         * @private
                                                                                                                                                                                                                                                                                                                                         *
                                                                                                                                                                                                                                                                                                                                         * @module fusioncharts.constructor
                                                                                                                                                                                                                                                                                                                                         */
// eslint-disable-next-line
/*?
 // metascript to get access to package.json
 var package = JSON.parse(require('fs').readFileSync('./package.json')),
     packageVersion = '\'' + package.version.split(/[.\-]/).join('\', \'') + '\''; // convert version string to array
 */

// import modifyEnv from '../dependency-manager';
// import addEventAPI from '../events/events';
// import enableDebugging from '../debugger/debugger';
// import rendererLib from '../../mantle/renderer/renderer-lib';
// import rendererInterface from '../../mantle/renderer-javascript/renderer-javascript-interface';
// import runtime from '../runtime/runtime';

// import { addNumberFormatter } from '../../mantle/renderer-javascript/components/numberformatter';
// import { dataStreamerListener } from '../../mantle/renderer-javascript/components/datastreamer';

var _updater = __webpack_require__(313);

var _updater2 = _interopRequireDefault(_updater);

var _apiChartattributes = __webpack_require__(315);

var _apiChartattributes2 = _interopRequireDefault(_apiChartattributes);

var _runtime = __webpack_require__(316);

var _runtime2 = _interopRequireDefault(_runtime);

var _rendererJavascriptInterface = __webpack_require__(317);

var _rendererJavascriptInterface2 = _interopRequireDefault(_rendererJavascriptInterface);

var _rendererLib = __webpack_require__(126);

var _rendererLib2 = _interopRequireDefault(_rendererLib);

var _renderer = __webpack_require__(318);

var _renderer2 = _interopRequireDefault(_renderer);

var _debugger = __webpack_require__(320);

var _debugger2 = _interopRequireDefault(_debugger);

var _eventApi = __webpack_require__(7);

var _events = __webpack_require__(321);

var _dependencyManager = __webpack_require__(80);

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var win = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : null,
    _FUSIONCHARTS,
    UNDEF,
    doc = win.document,
    nav = win.navigator,


// The _global variable would store all private methods and properties
// available to each module.
_global = {
  window: win
},


/**
 * ~var {Object} modules For maintaining module information.
 */
modules = _global.modules = {},
    interpreters = _global.interpreters = {},
    isIE = /msie/i.test(nav.userAgent) && !win.opera,
    hasLoaded = /loaded|complete/,
    mapLegacyDiscovered = false,
    // flag to keep track of legacy map script
notifyLibraryInit = function notifyLibraryInit() {
  // function to notify init of library
  var wasReady = _global.ready;
  _global.ready = true;
  if (_eventApi.triggerEvent) {
    _global.readyNotified = true;
    /**
     * This event is fired when the FusionCharts library is ready to be used. By the time this event is
     * raised the browser's `DOM` is ready to be interacted with, which corresponds to the
     * `DOMContentLoaded` event of browsers. In older browsers, where `DOMContentLoaded` is not fired, the
     * `ready` event corresponds to the `load` event of the page. In case FusionCharts library is included
     * in the page when the `DOMContentLoaded` event is already fired (i.e. script is loaded asyncronously
     * using AJAX or by using script deferring methods,) the `ready` event is still fired to ensure
     * integrity of all the listeners.
     *
     * In many ways the nature of this event is similar to `jQuery(document).ready` of jQuery library and
     * `Ext.onReady` function of ExtJS library. One should interact with the FusionCharts framework (i.e.
     * create new charts, set options, etc) only after this event has been fired. This event also helps you
     * to neatly write your codes in separate script files and in page `<head>` thus keeping scripts from
     * being part of your page `<body>`.
     *
     * An alternate (and shorthand) to subscribing the `ready` event is to use the
     * {@link FusionCharts.ready} function. One advantage that {@link FusionCharts.ready} function has over
     * this `ready` event is that the `ready` event is fired only once during the life-cycle of a page while
     * functions passed  to the {@link FusionCharts.ready} function is executed even when attached after the
     * `ready` event has been fired.
     *
     * > This is a framework level event and as such can be only listened via
     * > {@link FusionCharts.addEventLsitener} on the `FusionCharts` class alone. It will not be fired if
     * > subscribed from individual chart instances.
     *
     * @event FusionCharts.ready
     * @group framework
     * @since  3.4.0
     *
     * @param {array} version - The FusionCharts framework version is returned in form of an array. This is
     * equivalent to the array {@link FusionCharts.version}
     * @param {boolean} now - This indicates whether this event was fired at the instant of
     * `window.ondomcontentloaded` event (or `window.onload` of older browsers) or whether the window was
     * already loaded and this event is fired just to maintain integrity.
     *
     * @example
     * <html>
     * <head>
     * <script type="text/javascript" src="/fusioncharts/js/fusioncharts.js"></script>
     * <script type="text/javascript">
     * // Render a chart within a chart container `div` element.
     * FusionCharts.addEventListener('ready', function () {
     *     var chart = new FusionCharts({
     *         type: 'column2d',
     *         renderAt: 'chart-container-div',
     *         dataFormat: 'json',
     *         dataSource: {
     *             chart: {
     *                 caption: "Quarterly sales summary",
     *                 numberPrefix: "$"
     *             }
     *             data: [
     *                 { label: "Q1", value: "213345"},
     *                 { label: "Q2", value: "192672"},
     *                 { label: "Q3", value: "201238"},
     *                 { label: "Q4", value: "209881"},
     *             ]
     *         }
     *     });
     *     // Since we are in the `ready` block, the `chart-container-div`
     *     // element should be available by now.
     *     chart.render();
     * });
     * </script>
     * <body>
     *     <div id="chart-container-div">Chart loads here...</div>
     * </body>
     * </html>
     */
    (0, _eventApi.triggerEvent)('ready', _FUSIONCHARTS, {
      version: _FUSIONCHARTS.version,
      now: !wasReady
    });
  }
  _global.readyNow = !wasReady;
},


// recursive function that copies one object into another.
merge = function merge(obj1, obj2) {
  var item,
      str,
      objectToStringFn = Object.prototype.toString;
  // check whether obj2 is an array
  // if array then iterate through it's index
  //* *** MOOTOOLS precution
  if (obj2 instanceof Array) {
    for (item = 0; item < obj2.length; item += 1) {
      if (_typeof(obj2[item]) !== 'object') {
        obj1[item] = obj2[item];
      } else {
        if (_typeof(obj1[item]) !== 'object') {
          obj1[item] = obj2[item] instanceof Array ? [] : {};
        }
        merge(obj1[item], obj2[item]);
      }
    }
  } else {
    for (item in obj2) {
      if (_typeof(obj2[item]) === 'object') {
        str = objectToStringFn.call(obj2[item]);
        if (str === '[object Object]') {
          if (_typeof(obj1[item]) !== 'object') {
            obj1[item] = {};
          }
          merge(obj1[item], obj2[item]);
        } else if (str === '[object Array]') {
          if (!(obj1[item] instanceof Array)) {
            obj1[item] = [];
          }
          merge(obj1[item], obj2[item]);
        } else {
          obj1[item] = obj2[item];
        }
      } else {
        obj1[item] = obj2[item];
      }
    }
  }
  return obj1;
},


/**
 * This method, when added to the prototype of an object,
 * allows shallow or deep extension of the object with another
 * object.
 * @param {Object}  sink   The object to be extended into
 * @param {Object}  source The object to be extended from
 * @param {Object}  proto  The reference object
 * @param {boolean} deep   Whether to copy deeply or not
 *
 * @return {Object} Returns a new object extended form the given object
 */
extend = _global.extend = function (sink, source, proto, deep) {
  var item;
  // When 'proto' is marked as true, the methods and properties
  // of source is not added to the prototype of the sink.
  if (proto && sink.prototype) {
    sink = sink.prototype;
  }

  // If deep extend is specified, then we use the deep copy function
  // 'merge'
  if (deep === true) {
    merge(sink, source);
  } else {
    // Copy all methods and properties of the object passed in parameter
    // to the object to which this function is attached.
    for (item in source) {
      sink[item] = source[item];
    }
  }

  return sink;
};

// Function that auto-generates a unique id.
_global.uniqueId = function () {
  return 'chartobject-' + (_global.uniqueId.lastId += 1);
};
_global.uniqueId.lastId = 0;

// Define the policy to create default parameters for the swfObject.
// Values are in format [sourceOption, defaultValue]
// This helps in building the initial FusionCharts object when new instances
// are created from user parameters.
_global.policies = {

  /**
   * Contains all the customizable options that are used by the library internally and has nothing to do with
   * renderer attributes, vars or parameters.
   * @memberOf FusionCharts
   * @type {Object}
   * @private
   * @enum
   */
  options: {
    chartTypeSourcePath: ['typeSourcePath', ''],
    /** @ignore **/
    product: ['product', 'v3'],
    /**
     * Default insert mode of adding a FusionCharts to a container
     */
    insertMode: ['insertMode', 'replace'],
    safeMode: ['safeMode', true],
    /**
     * Default parameters for overlay button
     */
    overlayButton: ['overlayButton', UNDEF],

    containerBackgroundColor: ['containerBackgroundColor', '#ffffff'],
    containerBackgroundOpacity: ['containerBackgroundOpacity', 1],
    containerClassName: ['containerClassName', 'fusioncharts-container'],

    /**
     * In case you want to set a default chartType for all new instances of FusionCharts
     */
    chartType: ['type', UNDEF],

    /**
     * Default styling for chart messages
     */
    baseChartMessageFont: ['baseChartMessageFont', 'Verdana,sans'],
    baseChartMessageFontSize: ['baseChartMessageFontSize', '10'],
    baseChartMessageColor: ['baseChartMessageColor', '#666666'],

    /**
     * Default position for chart messages image
     */
    baseChartMessageImageHAlign: ['baseChartMessageImageHAlign', 'middle'],
    baseChartMessageImageVAlign: ['baseChartMessageImageVAlign', 'middle'],
    baseChartMessageImageAlpha: ['baseChartMessageImageAlpha', 100],
    baseChartMessageImageScale: ['baseChartMessageImageScale', 100],

    /**
     * Default message for chart (data related)
     */
    dataLoadStartMessage: ['dataLoadStartMessage', 'Retrieving data. Please wait.'],
    dataLoadErrorMessage: ['dataLoadErrorMessage', 'Error in loading data.'],
    dataInvalidMessage: ['dataInvalidMessage', 'Invalid data.'],
    dataEmptyMessage: ['dataEmptyMessage', 'No data to display.'],

    /**
     * Default message for chart (chart related)
     */
    typeNotSupportedMessage: ['typeNotSupportedMessage', 'Chart type not supported.'],
    browserNotSupportedMessage: ['browserNotSupportedMessage', 'This browser is not supported.'],
    loadMessage: ['loadMessage', 'Loading chart. Please wait.'],
    renderErrorMessage: ['renderErrorMessage', 'Unable to render chart.'],

    // Allow FusionCharts to accept parameter to specify where to render the
    // chart.
    containerElementId: ['renderAt', UNDEF],
    renderer: ['renderer', UNDEF],
    containerElementType: ['containerElementType', UNDEF],

    // Add visibility tracking default config
    visibilityTrackingInterval: 300
  },
  /**
   * ~var {Object} attributes Contains configurations pertaining to the
   * host (browser) environment.
   */
  attributes: {
    lang: ['lang', 'EN'],
    id: ['id', UNDEF]
  },

  /**
   * ~var {array} width configuration for width of the chart.
   * ~var {array} height configuration for height of the chart.
   * ~var {array} src specifies chart swf url
   */
  width: ['width', '400'],
  height: ['height', '300'],
  src: ['swfUrl', '']
};

// Specifies the order in which the parameters of the new
// FusionCharts objects are interpreted and converted to options object.
interpreters.stat = ['swfUrl', 'id', 'width', 'height', 'debugMode', 'registerWithJS', 'backgroundColor', 'scaleMode', 'lang', 'detectFlashVersion', 'autoInstallRedirect'];

/**
 * Allows the core to process an arguments object based on a set of policies
 * and construct an object out of it that is mapped exactly as respective
 * parameter policy defines. In other words, it uses an object and
 * creates another object or updates another object with values from the
 * original arguments object in a particular hierarchy and name that a set
 * of rules (policies) define.
 */
_global.parsePolicies = function (obj, policies, options) {
  var prop, policy, value;

  // Iterate through the data policy and correspondingly create the
  // three stacks of parameters, attributes and flashVars
  for (policy in policies) {
    // Set just the policy object in case of single-level policy.
    if (_global.policies[policy] instanceof Array) {
      value = options[policies[policy][0]];
      obj[policy] = value === UNDEF ? policies[policy][1] : value;
    } else {
      // Define objects that would hold parameters for swfobject. Also
      // populate with variables from the parameters
      if (_typeof(obj[policy]) !== 'object') {
        obj[policy] = {};
      }

      // Set every sub-object for two-level policy
      for (prop in policies[policy]) {
        value = options[policies[policy][prop][0]];
        obj[policy][prop] = value === UNDEF ? policies[policy][prop][1] : value;
      }
    }
  }
};

/**
 * Parse commands (command interpretor) based on a specified interpreter
 * structure
 */
_global.parseCommands = function (obj, interpreter, args) {
  var i, l;

  if (typeof interpreter === 'string') {
    interpreter = interpreters[interpreter] || [];
  }

  // Iterate through the arguments template and add the keys to the
  // options object while fetching corresponding values from arguments
  // array.
  for (i = 0, l = interpreter.length; i < l; i++) {
    obj[interpreter[i]] = args[i];
  }

  return obj;
};

/**
 * Different types of extension registrations
 */
_global.registrars = {
  'module': function module() {
    return _FUSIONCHARTS.apply(_FUSIONCHARTS, arguments);
  }
};

/**
 * Create new instances of charts, gauges and maps using this function.
 *
 * The preferred way to draw charts, gauges and maps using FusionCharts is to pass the chart configurations and data
 * to this constructor and call `render()` on the returned instance. You can provide all the properties, data and
 * event bindings of charts through the parameters passed to this function.
 *
 * You can call methods of the {@link FusionCharts} class on the returned instance. For all practical purposes, this
 * is the first step to creating a chart, gauges and maps using FusionCharts.
 *
 * __Accessing existing charts using `FusionCharts()` constructor:__
 *
 * The `FusionCharts` function has a dual behavior - other than creating new charts, it can also be used to access
 * already created charts. This is done by dropping the `new` operator and passing only the chart `id` as a
 * parameter. For example, `var salesChart = FusionCharts('sales-chart');` will return the instance of the chart
 * with the `id` "sales-chart". The previous code snippet is equivalent to
 * `var salesChart = FusionCharts.items['sales-chart'];`. Refer to {@link FusionCharts.items} to know more.
 *
 * @class
 * @global
 *
 * @param {Object} options - While creating a new instance of FusionCharts, you can pass
 * an `options` object with all configuration parameters for that instance. All configurations passed through this
 * object are referred to as "construction parameters". Through these parameters, you can customize the look and
 * feel of a chart, pass data to the chart, configure its dimensions and bind to events.
 *
 * Each of this object's properties correspond to a configuration option.
 *
 * @param {!string} [options.type] - Provide the name of the chart type to be rendered. Full list of charts is
 * available at {@tutorial setup-list-of-charts}.
 *
 * This parameter controls what chart will be rendered. The data passed to the chart has to be compatible with the
 * chart type specified here.
 *
 * Alternatively, you can also call {@link FusionCharts#chartType} on the chart instance to provide the chart type.
 *
 * @param {!string} [options.id] - This name is used to refer to the current instance after the
 * chart has been created. The chart instance is available under this name in {@link FusionCharts.items}. If no `id`
 * is provided, FusionCharts automatically generates an `id` for each chart.
 *
 * @param {numeric|percent} [options.width="400"] - Set the width in pixels or percent such as `640` or
 * `'50%'`. If width is in pixels, there is no need to provide the `px` unit suffix. You can call
 * {@link FusionCharts#resizeTo} function on the chart instance to set the width later on.
 *
 * @param {numeric|percent} [options.height="300"] - Set the height in pixels or percent such as `640` or
 * `'50%'`. If height is in pixels, there is no need to provide the `px` unit suffix. You can call
 * {@link FusionCharts#resizeTo} function on the chart instance to set the height later on.
 *
 * @param {string|DOMElement} [options.renderAt] - A chart needs reference to a DOM element on the page where
 * it will be rendered. You can provide the HTML ID of the element as a string to this option, or you can pass a
 * reference of the DOMElement itself where the chart needs to be rendered.
 *
 * For example, if you have a DOMElement like `<div class='chart-1' id='chart-container'></div>`, you can provide
 * the value of the `div`'s `id` attribute to this option as a string. Alternatively, you can pass direct reference
 * to the DOMElement like: `renderAt: document.getElementByClassName("chart-1")`.
 *
 * Instead of providing the DOMElement here, it can also be passed as the first parameter to the
 * {@link FusionCharts.render} function. Setting the DOMElement in {@link FusionCharts.render} function overrides
 * the value set here.
 *
 * @param {FusionCharts~dataFormats} [options.dataFormat] - This is the name of the format of data passed to the
 * `dataSource` option below. Currently, FusionCharts accepts only JSON and XML data. The value for this option is
 * one of the formats specified in {@link FusionCharts~dataFormats}.
 *
 * @param {string|object} [options.dataSource] - Provide the source of data and configuration of the chart.
 * FusionCharts accepts data in the formats specified in {@link FusionCharts~dataFormats}.
 *
 * This is the preferred way to set data and configuration of the chart. The data and configuration can also be
 * updated or set using the functions {@link FusionCharts#setChartData} and {@link FusionCharts#setChartDataUrl}.
 *
 * @param {Object} [options.events] - You can bind multiple events to this particular chart instance through
 * this option. You need to pass an object to this option, where each key is an event name fired by FusionCharts and
 * value for that key is a callback in the format of {@link FusionCharts~eventListener}.
 *
 * To bind multiple charts to the same event, you need to use {@link FusionCharts#addEventListener} function
 * instead.
 *
 * @param {Object} [options.link] - Provide LinkedCharts configuration. See {@link FusionCharts#configureLink}
 * for details.
 *
 * @param {boolean} [options.showDataLoadingMessage=false] - FusionCharts shows a message while it is retrieving
 * data from a `url` provided as `dataSource`. While displaying the message the chart is grayed out and interaction
 * on it is blocked. This can be prevented by setting this option to `false`.
 *
 * @param {boolean} [options.showChartLoadingMessage=true] - Shows `Loading chart...` message in `renderAt`
 * container if the chart needs to load additional resource/JS files. This can be turned off by setting this option
 * to `false`.
 *
 * @param {string} [options.baseChartMessageFont='Verdana'] - Allows to set the common custom font face for all
 * chart messages.
 *
 * @param {string} [options.baseChartMessageFontSize='10'] - Allows to set the common custom font size for all
 * chart messages.
 *
 * @param {hexcolor} [options.baseChartMessageColor='#666666'] - Allows to set the common custom font color for
 * all chart messages.
 *
 * @param {string} [options.baseChartMessageImageHAlign='middle'] - Allows to set the common custom horizontal
 * alignment for all image as chart messages.
 *
 * @param {string} [options.baseChartMessageImageVAlign='middle'] - Allows to set the common custom vertical
 * alignment for all image as chart messages.
 *
 * @param {string} [options.baseChartMessageImageAlpha='100'] - Allows to set the common custom alpha
 * for all image as chart messages.
 *
 * @param {string} [options.baseChartMessageImageScale='100'] - Allows to set the common custom scaling
 * for all image as chart messages.
 *
 * @param {string} [options.dataLoadStartMessage='Retrieving data. Please wait.'] - Allows to set the message to
 * be displayed before the chart data begins loading. Additional properties like the font face, size, and color can
 * be set by suffixing the property name with the corresponding message key, e.g. dataLoadStartMessageFont,
 * dataLoadStartMessageFontSize, dataLoadStartMessageColor. If message keys are not specified, base cosmetics are
 * used.
 *
 * @param {string} [options.dataLoadErrorMessage='Error in loading data.'] - Allows to set the message to be
 * displayed when there is an error loading the chart data. Additional properties like the font face, size, and
 * color can be set by suffixing the property name with the corresponding message key, e.g.
 * dataLoadStartMessageFont, dataLoadStartMessageFontSize, dataLoadStartMessageColor. If message keys are not
 * specified, base cosmetics are used.
 *
 * @param {string} [options.dataInvalidMessage='Invalid data.'] - Allows to set the message to be displayed when
 * the data loaded for the chart is invalid. Additional properties like the font face, size, and color can be
 * set by suffixing the property name with the corresponding message key, e.g. dataLoadStartMessageFont,
 * dataLoadStartMessageFontSize, dataLoadStartMessageColor. If message keys are not specified, base cosmetics are
 * used.
 *
 * @param {string} [options.dataEmptyMessage='No data to display.'] - Allows to set the message to be displayed if
 * data loaded for the chart is empty. Additional properties like the font face, size, and color can be
 * set by suffixing the property name with the corresponding message key, e.g. dataLoadStartMessageFont,
 * dataLoadStartMessageFontSize, dataLoadStartMessageColor. If message keys are not specified, base cosmetics are
 * used.
 *
 * @param {string} [options.typeNotSupportedMessage='Chart type not supported.'] - Allows to set the message to be
 * displayed if specified chart type is not supported. Additional properties like the font face, size, and color
 * can be set by suffixing the property name with the corresponding message key, e.g. dataLoadStartMessageFont,
 * dataLoadStartMessageFontSize, dataLoadStartMessageColor. If message keys are not specified, base cosmetics are
 * used.
 *
 * @param {string} [options.loadMessage='Loading chart. Please wait.'] - Allows to set the message to be displayed
 * when the chart begins to load. Additional properties like the font face, size, and color can be set by
 * suffixing the property name with the corresponding message key, e.g. dataLoadStartMessageFont,
 * dataLoadStartMessageFontSize, dataLoadStartMessageColor. If message keys are not specified, base cosmetics are
 * used.
 *
 * @param {string} [options.renderErrorMessage='Unable to render chart.'] - Allows to set the message to be
 * displayed if there was an error while rendering the chart. Additional properties like the font face, size, and
 * color can be set by suffixing the property name with the corresponding message key, e.g.
 * dataLoadStartMessageFont, dataLoadStartMessageFontSize, dataLoadStartMessageColor. If message keys are not
 * specified, base cosmetics are used.
 *
 * @param {hexcolor} [options.containerBackgroundColor="#ffffff"] - Sets the background color of the chart's
 * container HTML DOM element. It is not same as `bgColor` chart attribute. To see this background color, a chart's
 * own background alpha must be set to `0` by setting `bgAlpha` attribute to `"0"` in chart attributes.
 *
 * @param {opacity} [options.containerBackgroundOpacity=1] - Sets the opacity of the container element. Useful
 * if the chart has underlying HTML elements or background image that needs to be made visible. If opacity is
 * reduced, you need to configure the chart itself to be transparent by setting the `bgAlpha` chart attribute.
 *
 * @param {string} [options.containerClassName] - Sets the CSS class that will be set on the container DOM element
 * of the rendered chart. Default is `fusioncharts-container`.
 *
 * @example
 * <html>
 * <head>
 * <script type="text/javascript" src="js/fusioncharts.js"></script>
 * <script type="text/javascript">
 * FusionCharts.ready(function () {
 *     // Create a new instance of FusionCharts for rendering inside an HTML
 *     // `&lt;div&gt;` element with id `my-chart-container`.
 *     var myChart = new FusionCharts({
 *         type: 'column2d',
 *         renderAt: 'chart-container',
 *
 *         dataFormat: 'json',
 *         dataSource: {
 *             chart: {
 *                 caption: "Harry's SuperMart",
 *                 subCaption: "Top 5 stores in last month by revenue",
 *             },
 *             data:[{
 *                 label: "Bakersfield Central",
 *                 value: "880000"
 *             },
 *             {
 *                 label: "Garden Groove harbour",
 *                 value: "730000"
 *             },
 *             {
 *                 label: "Los Angeles Topanga",
 *                 value: "590000"
 *             },
 *             {
 *                 label: "Compton-Rancho Dom",
 *                 value: "520000"
 *             },
 *             {
 *                 label: "Daly City Serramonte",
 *                 value: "330000"
 *             }]
 *         }
 *     });
 *
 *     // Render the chart.
 *     myChart.render();
 * });
 * </script>
 * <body>
 *     <div id="chart-container">FusionCharts will load here...</div>
 * </body>
 * </html>
 */
_FUSIONCHARTS = function FUSIONCHARTS(options) {
  // This point onwards, we must check whether this is being used as a
  // constructor or not
  if (!(this instanceof _FUSIONCHARTS)) {
    // Allow private communication with modules. In case FusionCharts is
    // not called as constructor and it is passed an array that is marked
    // to do private communication, then share the _global variable.
    if (arguments.length === 1 && options instanceof Array && options[0] === 'private') {
      // Prevent overwriting and duplicate execution of modules.
      if (modules[options[1]]) {
        return UNDEF;
      }
      modules[options[1]] = {};

      // Check for module-specific information
      if (options[3] instanceof Array) {
        _FUSIONCHARTS.version[options[1]] = options[3];
      }

      // Execute module function
      if (typeof options[2] === 'function') {
        return options[2].call(_global, modules[options[1]]);
      } else {
        return _global;
      }
    }

    // Allow using FusionCharts object to directly access its new items
    if (arguments.length === 1 && typeof options === 'string') {
      return _FUSIONCHARTS.items[options];
    }
    /**
     * This error occurs when the `FusionCharts` constructor is called without the `new` keyword and also
     * without passing a reference chart id as the parameter. In case you are rendering a new chart, ensure you
     * do a `new FusionCharts({});` or in case you are using the constructor as a getter, ensure you pass the
     * chart Id (string) as first parameter.
     *
     * @typedef {RuntimeException} Error-25081840
     * @memberOf FusionCharts.debugger
     * @group debugger-error
     */
    _eventApi.raiseError && (0, _eventApi.raiseError)(this, '25081840', 'run', '', new SyntaxError('Use the "new" keyword while creating a new FusionCharts object'));
  }

  // Define a variable for iterative key in various loops and the
  // object variable that stores the options.
  var opts = {};

  if (!this) {
    return;
  }

  /**
   * @var {Object} __state maintains internal state related information.
   * @private
   */
  this.__state = {};

  // Check whether linear arguments are sent and convert it to object.
  if (arguments.length === 1 && _typeof(arguments[0]) === 'object') {
    // If the above condition matches, then we can safely assume that
    // the first parameter is the options object.
    opts = arguments[0];
  } else {
    // Parse command interpreter policies
    _global.parseCommands(opts, interpreters.stat, arguments);
  }

  // Incorporate the trailing object parameter as object-style
  // parameter input overrides.
  if (arguments.length > 1 && _typeof(arguments[arguments.length - 1]) === 'object') {
    delete opts[interpreters.stat[arguments.length - 1]];
    _global.extend(opts, arguments[arguments.length - 1]);
  }

  // Set autogenerated chart-id in case one is not specified
  this.id = typeof opts.id === 'undefined' ? this.id = _global.uniqueId() : opts.id;

  // Set dimension passed by user and subsequently validate the options.
  // - Remove trailing 'px'
  this.args = opts;

  // If an item is created with same id, the previous item is disposed.
  if (_FUSIONCHARTS.items[this.id] instanceof _FUSIONCHARTS) {
    /**
     * This error occurs when a new chart is created (instantiated) with the an `id` that has been already
     * assigned to an existing chart. Change the chart Id or dispose the other chart with the duplicate id.
     *
     * @typedef {ParameterException} Error-06091847
     * @memberOf FusionCharts.debugger
     * @group debugger-error
     */
    _global.raiseWarning(this, '06091847', 'param', '', new Error('A FusionCharts object with the specified id \"' + this.id + '\" already exists. Renaming it to ' + (this.id = _global.uniqueId())));
  }

  // Parse _global policies.
  _global.parsePolicies(this, _global.policies, opts);

  // Copy chart id to attributes
  this.attributes.id = this.id;

  // Set initial dimension of charts
  this.resizeTo && this.resizeTo(opts.width, opts.height, true);

  // Set initial chart type of charts
  this.chartType && this.chartType(opts.type || opts.swfUrl, true);

  /**
   * Whenever a new instance of {@link FusionCharts} is created (as in `new FusionCharts(...)`, this pre
   * initialization event is raised. This event triggers a number of modules that needs to be setup on every
   * instance of FusionCharts. One can listen to this event perform actions that, on similar grounds, requires
   * to be setup upn initialization of each chart.
   *
   * Since this event is fired upon instantiating a new FusionCharts object, it is virtually impossible to listen
   * to this event by adding event listener to that individual chart. That is because, by the time one's event
   * listener is attached using {@link FusionCharts#addEventListener} on the subsequent lines post doing `new
   * FusionCharts(...)`, this event would have been already fired. Thus, the alternate ways to listen to this
   * event are:
   *
   * 1. Listen to FusionCharts global events using {@link FusionCharts.addEventListener} before even creating a
   *    new instance. (The required instance can be identified by the `id` of the chart using
   *    `eventObject.sender.id`.)
   *
   * 2. Pass the event listener as the FusionCharts constructor parameter itself.
   *
   * @event FusionCharts.beforeInitialize
   * @group chart
   *
   * @example
   * // Listening using global events
   * FusionCharts.addEventListener('beforeInitialize', function (opts) {
   *     // Prints id of the chart being rendered
   *     console.log("Chart with id " + opts.sender.id + " is about to be initialized.");
   *  });
   *
   * // Pass event listener in the FusionCharts constructor
   * var mychart = new FusionCharts({
   *     "type": "column2d",
   *     "dataFormat": "json",
   *     "dataSource": {
   *          ...
   *     },
   *     // Attach event handlers
   *     "events": {
   *         // Attach to beforeInitialize
   *         "beforeInitialize": function () {
   *             console.log("Initializing mychart...");
   *         }
   *     }
   * });
   *
   * @param {numeric|percent} height - Height of the chart in pixels or percentage.
   * @param {numeric|percent} width - Width of the chart in pixels or percentage.
   */
  (0, _eventApi.triggerEvent)('beforeInitialize', this, opts);

  // Add this object to the repository of objects within core object.
  _FUSIONCHARTS.items[this.id] = this;

  // Create alias for defaultOptions
  _FUSIONCHARTS.defaultOptions = _FUSIONCHARTS.options;

  /**
   * Once a new instance of {@link FusionCharts} is created and is ready to be operated upon, this `initialized`
   * event is fired. Note that initialization does not indicate that the chart has been rendered. It denotes that
   * the JavaScript object instance of FusionCharts is created (as in `new FusionCharts(...)` done) and is now
   * ready to be operated upon (like data being passed onto it, it being rendered, etc.)
   *
   * @event FusionCharts.initialized
   * @group chart
   *
   * @param {numeric|percent} height - height of the chart in pixels or percentage .
   * @param {numeric|percent} width - width of the chart in pixels or percentage .
   *
   * @example
   * // Listening using global events
   * FusionCharts.addEventListener('initialized', function (opts) {
   *     // Prints id of the chart that has initialized
   *     console.log("Chart with id " + opts.sender.id + " has been initialized.");
   *  });
   *
   * // Pass event listener in the FusionCharts constructor
   * var mychart = new FusionCharts({
   *     "type": "column2d",
   *     "dataFormat": "json",
   *     "dataSource": {
   *          ...
   *     },
   *     // Attach event handlers
   *     "events": {
   *         // Attach to beforeInitialize
   *         "initialized": function () {
   *             console.log("Initialized mychart...");
   *         }
   *     }
   * });
   */
  (0, _eventApi.triggerEvent)('initialized', this, opts);

  return this;
};

// Set FusionCharts as the primary core.
_global.core = _FUSIONCHARTS;

// Make the core extensible and reset the constructor of the object
// for maintaining correct prototype chain.
_FUSIONCHARTS.prototype = {};
// Reset constructor.
_FUSIONCHARTS.prototype.constructor = _FUSIONCHARTS;

_global.extend(_FUSIONCHARTS, /** @lends FusionCharts */{
  id: 'FusionCharts',

  /**
   * Specifies the framework version of {@link FusionCharts}. In the format
   * `[major, minor, revision, nature, build]`
   * @type {array}
   */
  version: _lib.PROJECT_VERSION.split(/[\.\-]/g),

  /**
   * The reference to every new instance of FusionCharts is maintained in this object with the chart `ID` as the
   * key. Upon {@link FusionCharts#dispose} of the instance, the key is removed from this. One can iterate through
   * all instances of {@link FusionCharts} using this object.
   *
   * A short-hand approach to accessing a single chart by its `id` is to use {@link FusionCharts} function itself
   * but without the `new` operator and by passing the chart id as the first parameter.
   * @type {Object}
   *
   * @group framework
   *
   * @example
   * // Assuming a page has many instances of {@link FusionCharts}, but
   * // none of them are rendered, we are going to iterate through all and
   * // render them.
   * for (var item in FusionCharts.items) {
   *     FusionCharts.items[item].render();
   * }
   *
   * @example
   * // Alternate method to access the charts using FusionCharts function to retrieve the chart from its id.
   * for (var item in FusionCharts.items) {
   *     FusionCharts(item).render();
   * }
   */
  items: {},

  // Add an object to store options
  options: {
    html5ScriptNameSuffix: '.js',
    html5ScriptNamePrefix: 'fusioncharts.'
  },

  /**
   * The function returns the `DOMElement` that is created inside chart container by FusionCharts. The returned
   * element is the same as accessing the {@link FusionCharts#ref} property. Note that this is the `<span>`
   * element created by FusionCharts to render the chart. It is not the container element that was specified
   * during rendering the chart as the `renderAt` parameter.
   *
   * @param {string} id - The ID of the chart, whose `DOMElement` is to be referenced.
   *
   * @group framework
   * @since 3.1.1
   * @deprecated 3.2.0 - This method has been deprecated as direct access to `DOMElement` of the chart has become
   * redundant. {@link FusionCharts#ref} property can be used in the rare case where such access to the
   * `DOMElement` of a chart is required.
   *
   * @return {DOMElement}
   *
   * @example
   * // Iterate on all charts rendered on a page and move them to a common location
   * var sidebar = document.getElementById('sidebar-html-div'), // assuming that your common container is this
   *     chart;
   *
   * for (chart in FusionCharts.items) {
   *     sidebar.appendChild(FusionCharts.getObjectReference(chart).parentNode);
   * }
   *
   * // The above can be done without using this deprecated getObjectReference method.
   * for (chart in FusionCharts.items) {
   *     chart = FusionCharts.items[chart];
   *     chart.ref && sidebar.appendChild(chart.ref.parentNode);
   * }
   */
  getObjectReference: function getObjectReference(id) {
    return _FUSIONCHARTS.items[id].ref;
  },

  /**
   * Extend FusionCharts functionalities by adding modules and other items.
   * @private
   *
   * @param {string} what - The type of extension that can be done. The possible values can be `"module"`,
   * `"theme"`, etc.
   * @param {...*} args - Depending upon what you want to register, supply the relevant registration items.
   */
  register: function register(what) {
    return _global.registrars[what = what && what.toString && what.toString().toLowerCase()] && _global.registrars[what].apply(_FUSIONCHARTS, Array.prototype.slice.call(arguments, 1));
  },

  /**
   * Get the definations of previously registered components
   * @private
   *
   * @param {string} what - The type of extension that can be done. The possible values can be `"component"`,
   * `"theme"`, etc.
   * @param {...*} args - Depending upon what you want to retirvr, supply the relevant names of sub-items.
   * @todo change the defination of get so that user can't do registration using this
   */
  get: function get(what) {
    return _global.registrars[what = what && what.toString && what.toString().toLowerCase()] && _global.registrars[what].apply(_FUSIONCHARTS, Array.prototype.slice.call(arguments, 1));
  },

  _getGlobal: function _getGlobal() {
    return _global;
  }

});

// // Expose the core to the _global scope.
// win.FusionCharts = _global.core;
// /* @if ENV=='test' */
// /* jshint ignore:start */
// FusionCharts = win.FusionCharts;
// /* jshint ignore:end */
// /* @endif */

// FusionCharts = _global.core;

// Check whether legacy FusionMaps already exists at this point in execution
// time. If yes, then we need to perform routines to assimilate it.
if (win.FusionMaps && win.FusionMaps.legacy) {
  _FUSIONCHARTS(['private', 'modules.core.geo', win.FusionMaps.legacy, win.FusionMaps.version]);
  mapLegacyDiscovered = true;
}
// If FusionMaps legacy was not discovered, we give it another shot after
// the page has loaded.
if (!(hasLoaded.test(doc.readyState) || doc.loaded)) {
  (function () {
    var _timer, script, done;

    function init() {
      /* jshint noarg: false */
      // quit if this function has already been called
      if (done) {
        return;
      }

      // flag this function so we don't do the same thing twice
      done = true;

      // kill the timer
      if (_timer) {
        clearTimeout(_timer);
      }

      if (!mapLegacyDiscovered) {
        if (win.FusionMaps && win.FusionMaps.legacy) {
          _FUSIONCHARTS(['private', 'modules.core.geo', win.FusionMaps.legacy, win.FusionMaps.version]);
        }
        win.FusionMaps = _FUSIONCHARTS;
      }

      // Notify that library is ready for consumption.
      setTimeout(notifyLibraryInit, 1);
    }

    function checkInit() {
      if (hasLoaded.test(doc.readyState)) {
        init(); // call the onload handler
      } else {
        _timer = setTimeout(checkInit, 10);
      }
    }

    if (doc.addEventListener) {
      doc.addEventListener('DOMContentLoaded', init, false);
    } else if (doc.attachEvent) {
      win.attachEvent('onLoad', init);
    }

    if (isIE) {
      try {
        if (win.location.protocol === 'https:') {
          doc.write('<script id="__ie_onload_fusioncharts" defer="defer" src="//:"><\/script>');
        } else {
          doc.write('<script id="__ie_onload_fusioncharts" defer="defer" ' + 'src="javascript:void(0)"><\/script>');
        }
        script = doc.getElementById('__ie_onload_fusioncharts');
        script.onreadystatechange = function () {
          if (this.readyState === 'complete') {
            init(); // call the onload handler
          }
        };
      } catch (e) {
        throw e;
      }
    }

    if (/WebKit/i.test(nav.userAgent)) {
      // sniff
      _timer = setTimeout(checkInit, 10);
    }

    win.onload = function (callback) {
      return function () {
        init();
        callback && callback.call && callback.call(win);
      };
    }(win.onload);
  })();
} else {
  // already marking it ready means that notifier will let know that page
  // has already been loaded.
  _global.ready = true;
  setTimeout(notifyLibraryInit, 1);
}

var fileStore = {};

// add the dependency setter method
_FUSIONCHARTS.addDep = _dependencyManager.addDep;
// Add the dependency seter method
_FUSIONCHARTS.getDep = _dependencyManager.getDep;

/**
 * Function to mark a file that has been added to the fusioncharts core
 * @param {string} name filename
 */
_FUSIONCHARTS.addFile = function (name) {
  fileStore[name] = true;
};

/**
 * Function to get a file that has been added to the fusioncharts core
 * @param {string} name filename
 * @return {boolean} if file has been added
 */

_FUSIONCHARTS.getFile = function (name) {
  return fileStore[name];
};

/**
 * Bind callbacks to events fired throughout FusionCharts. This method can be used to listen to events across
 * all FusionCharts instances on a page.
 *
 * An event listener is used to execute custom functions when an event is fired. FusionCharts fires events at
 * all stages of creating, updating, rendering or removing a chart. This function lets you tap into any of these
 * events and provide your own functions which will be called when those events are triggered.
 *
 * An alternative to this function is to use {@link FusionCharts#addEventListener} method on a chart instance to
 * bind to an event fired by a specific chart.
 *
 * @param {string|array} type - The event name to listen to. The event name is not case sensitive. In case you
 * want to register an event to multiple events in the same registration call, provide them as an array of event
 * names.
 * @param {FusionCharts~eventListener} listener - Pass the function that is to be executed when the event is
 * fired. Upon an event, the listeners for that event are executed sequentially with arguments that are specific
 * to that event. See {@link FusionCharts~eventListener} for more details on the arguments.
 *
 * @group event-handling:add
 * @example
 * // Show a message when a number of charts have been rendered on a page.
 * FusionCharts.ready(function {
 *     var counter = 0,
 *         threshold = 3;
 *
 *     FusionCharts.addEventListener("rendered", function (eventObject) {
 *         counter++;
 *         if (counter > threshold) {
 *             alert("More than " + threshold + "charts rendered!");
 *         }
 *     });
 * });
 */
_FUSIONCHARTS.addEventListener = function (type, listener) {
  return (0, _eventApi.addListener)(type, listener);
};
/**
 * Removes an event that was originally added using {@link FusionCharts.addEventListener}.
 * @param {string} type - The event name whose listener needs to be removed/detached.
 * @param {function} listener - The listener function that needs to be removed.
 *
 * @group event-handling:remove
 */
_FUSIONCHARTS.removeEventListener = function (type, listener) {
  return (0, _eventApi.removeListener)(type, listener);
};
/**
 * This function allows to register callback functions to be executed when FusionCharts library is ready to be
 * used. In general, the framework is ready after `DOMContentLoaded` browser event has been fired and all the
 * initial dependent files/modules are available. One can attach multiple callbacks by calling this function any
 * number of time.
 *
 * The callback function is executed even when attached after FusionCharts is already ready! Thus, it is
 * recommended that all entry-point and initialization codes are written within this block. This also helps in
 * neatly organizing all codes within a script file or the page `<head>` and as such contextually separating
 * code from HTML blocks.
 *
 * @param {FusionCharts~readyCallback} readyCallback - Pass a function that would be executed as callback when
 * FusionCharts framework is ready.
 * @param {*} [args={@link FusionCharts}] - Argument to be passed on to the callback function.
 * @param {function} [context={@link FusionCharts}] - In the situation where the function passed via `fn`
 * parameter needs to be executed in a different scope than the default {@link FusionCharts} scope, pass the
 * appropriate class object here.
 *
 * @example
 * // Render a chart within a chart container `div` element.
 * FusionCharts.ready(function (FusionCharts) {
 *     var chart = new FusionCharts({
 *         type: "column2d",
 *         renderAt: "chart-container-div",
 *         dataSource: "my-chart-data.json",
 *         dataFormat: "jsonurl"
 *     });
 *     // Since we are in the `ready` block, the `chart-container-div`
 *     // element should be available by now.
 *     chart.render();
 * });
 */
_FUSIONCHARTS.ready = function (readyCallback, args, context) {
  // Check if core is already ready or not. If not ready then we need  to attach the function to the ready
  // event listener.
  if (_global.ready) {
    // If it is already ready, we do not need to check for readiness subsequently as this state cannot ever
    // rollback. Thus we redefine the function for performant consumption post readiness.
    _FUSIONCHARTS.ready = function (callback, readyContext) {
      typeof callback === 'function' && setTimeout(function () {
        /**
         * The function passed as ready callback is executed when FusionCharts library is ready. Use
         * {@link FusionCharts.ready} to request executing of your callback function.
         * @callback FusionCharts~callback
         * @param {FusionCharts|*} args - By default, the parameter passed to the callback function is
         * the FusionCharts library class unless specified otherwise in the `args` parameter of
         * {@link FusionCharts.ready}
         */
        callback.call(readyContext || _FUSIONCHARTS, args || _FUSIONCHARTS);
      }, 0);
    };
    _FUSIONCHARTS.ready(readyCallback, context);
  } else if (typeof readyCallback === 'function') {
    _FUSIONCHARTS.addEventListener('ready', function () {
      _FUSIONCHARTS.ready(readyCallback, args, context);
    });
  }

  return this;
};

_FUSIONCHARTS.on = _FUSIONCHARTS.addEventListener; // alias

/**
 * Listen to events fired by an individual chart. For more information on the available events, refer to the
 * events section.
 *
 * @param {string|string[]} type - The event name that needs to be listened to. The event name is not case
 * sensitive. In case you want to register an event to multiple events in the same registration call, provide
 * them as an array of event names.
 * @param {FusionCharts~eventListener} listener - Pass the function that is to be executed when the event is
 * fired. Upon an event, the listeners for that event are executed sequentially with arguments that are
 * specific to that event. See {@link FusionCharts~eventListener} for more details on the arguments.
 *
 * @group event-handling:add
 */
_FUSIONCHARTS.prototype.addEventListener = function (type, listener) {
  return (0, _eventApi.addListener)(type, listener, this);
};
/**
 * Removes an event that was originally added using {@link FusionCharts#addEventListener}.
 * @param {string} type - The event name whose listener needs to be removed/detached.
 * @param {function} listener - The listener function that needs to be removed.
 *
 * @group event-handling:remove
 */
_FUSIONCHARTS.prototype.removeEventListener = function (type, listener) {
  return (0, _eventApi.removeListener)(type, listener, this);
};

_FUSIONCHARTS.prototype.on = _FUSIONCHARTS.prototype.addEventListener; // alias

// Add ability to parse events sent via core constructor.
_global.policies.options.events = ['events', {}];

(0, _eventApi.addListener)('beforeInitialize', function (e) {
  var chart = e.sender,
      events = chart.options.events,
      key;
  if (events) {
    for (key in events) {
      if (typeof events[key] === 'function') {
        chart.addEventListener(key, events[key]);
      }
    }
  }
});

// Raise library initialization event, if not already done.

if (_global.ready && !_global.readyNotified) {
  _global.readyNotified = true;
  /**
   * @fires FusionCharts#ready
   */
  _global.raiseEvent('ready', {
    version: _global.FUSIONCHARTS.version,
    now: _global.readyNow
  });
}

_global.raiseError = _eventApi.raiseError;

extend(_FUSIONCHARTS, _debugger2['default'], false);

_global.legacyEventList = {};
_global.raiseEventWithLegacy = _events.raiseEventWithLegacy;
_global.raiseEventGroup = _events.raiseEventGroup;

// modifyEnv(_global.core);
// addEventAPI(_global);
// enableDebugging(_global);
// addNumberFormatter(_global);
(0, _runtime2['default'])(_global);
// rendererLib(_global);
(0, _renderer2['default'])(_global);
(0, _rendererJavascriptInterface2['default'])(_global);
(0, _rendererLib2['default'])(_global);
(0, _updater2['default'])(_global);
// addChartAttrApis(_global);
extend(_FUSIONCHARTS, _apiChartattributes2['default']);
// dataStreamerListener(_global);

// In any case, we expose the latest core. If legacy overrides it on page
// load, that would be handled
// return _global.core;

// }(_window));

exports._global = _global;
exports.getDep = _dependencyManager.getDep;
exports['default'] = _FUSIONCHARTS;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)))

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.getDepsByType = exports.getDep = exports.addDep = undefined;

var _eventApi = __webpack_require__(7);

var typeStore = {},
    depStore = {};

/**
 * Given an extension, returns the name of the extension
 * @param {Object} extension The extension object
 * @return {string} The name of the extension
*/
function getExtensionName(extension) {
  var name = extension.getName && extension.getName() || extension.name;
  if (typeof name === 'undefined') {
    (0, _eventApi.raiseError)({ id: 'Extension' }, '90211', 'extension', 'Name', new Error('A FusionCharts extension must have a getName API or a name property.'));
  }
  return name && name.toLowerCase();
}

/**
 * Given an extension, returns the name of the extension
 * @param {Object} extension The extension object
 * @return {string} The type of the extension
*/
function getExtensionType(extension) {
  var type = extension.getType && extension.getType() || extension.type;

  return type && type.toLowerCase();
}

/**
 * Defines a store of the given type in the typeStore
 *
 * @param {string} type The type of the store to be created
 */
function defineDepType(type) {
  if (typeof type === 'string') {
    typeStore[type] = {};
  }
}

/**
 * Adds a module as a dependency to FusionCharts. The dependency MUST provide a name property or a
 * getName function on itself.
 *
 * @param {Function} dep The dependency to be added
 */
function addDep(dep) {
  var extensionName = void 0,
      pluggableComponent = void 0,
      extensionType = void 0,
      requiresFusionCharts = void 0;

  if (dep.extension) {
    pluggableComponent = dep.extension;
  } else {
    pluggableComponent = dep;
  }

  extensionName = getExtensionName(dep);
  extensionType = getExtensionType(dep);

  requiresFusionCharts = dep.requiresFusionCharts;

  if (extensionType) {
    !typeStore[extensionType] && defineDepType(extensionType);
    typeStore[extensionType][extensionName] = pluggableComponent;
  } else if (extensionName) {
    depStore[extensionName] = pluggableComponent;
  }

  requiresFusionCharts && pluggableComponent(this);
}

/**
 * Finds a dependency from the store. If a type is provided, it returns a dependency of that type,
 * else it returns the first dependency t finds by the given name,
 *
 * @param {string} name The name of the dependency to fetch
 * @param {string} [type] The type of the dependency
 * @return {Function} The found dependency
 */
function getDep(name, type) {
  var dependency = void 0;

  name = name && name.toLowerCase();

  // If type is already specified, find the dependency of the specified type from the type store
  // and return it
  if (type && typeStore[type]) {
    return typeStore[type][name];
  }

  // If type is not specified, try to find the dependency amongst all registered dependency types
  for (var key in typeStore) {
    if (typeStore.hasOwnProperty(key)) {
      dependency = typeStore[key][name];
      if (dependency) {
        return dependency;
      }
    }
  }

  // If the dependency was not found in the type store, it must be in the depStore. If it is not
  // present in the dep store either, return undefined since the dependency could not be found.
  return depStore[name];
}

/**
 * Given a type, returns all dependencies of the specified type. Else, returns all dependencies of
 * all types.
 *
 * @param {string} [type] The type of dependencies which will be returned.
 * @returns {Object} All dependencies found.
 */
function getDepsByType() {
  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

  return type === '' ? typeStore : typeStore[type];
}

exports.addDep = addDep;
exports.getDep = getDep;
exports.getDepsByType = getDepsByType;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(338);
module.exports = __webpack_require__(66)('Array').forEach;

/***/ }),
/* 82 */
/***/ (function(module, exports) {

var core = module.exports = {version: '2.4.0'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ }),
/* 83 */
/***/ (function(module, exports) {

module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx      = __webpack_require__(189)
  , IObject  = __webpack_require__(348)
  , toObject = __webpack_require__(191)
  , toLength = __webpack_require__(192)
  , asc      = __webpack_require__(350);
module.exports = function(TYPE, $create){
  var IS_MAP        = TYPE == 1
    , IS_FILTER     = TYPE == 2
    , IS_SOME       = TYPE == 3
    , IS_EVERY      = TYPE == 4
    , IS_FIND_INDEX = TYPE == 6
    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
    , create        = $create || asc;
  return function($this, callbackfn, that){
    var O      = toObject($this)
      , self   = IObject(O)
      , f      = ctx(callbackfn, that, 3)
      , length = toLength(self.length)
      , index  = 0
      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
      , val, res;
    for(;length > index; index++)if(NO_HOLES || index in self){
      val = self[index];
      res = f(val, index, O);
      if(TYPE){
        if(IS_MAP)result[index] = res;            // map
        else if(res)switch(TYPE){
          case 3: return true;                    // some
          case 5: return val;                     // find
          case 6: return index;                   // findIndex
          case 2: result.push(val);               // filter
        } else if(IS_EVERY)return false;          // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

exports.__esModule = true;

var _iterator = __webpack_require__(197);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(206);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2["default"] === "function" && typeof _iterator2["default"] === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2["default"] === "function" && obj.constructor === _symbol2["default"] && obj !== _symbol2["default"].prototype ? "symbol" : typeof obj; }; /**!
                                                                                                                                                                                                                                                                                                                                         * RedRaphael 1.0.0 - JavaScript Vector Library
                                                                                                                                                                                                                                                                                                                                         * Copyright (c) 2012-2013 FusionCharts, Inc. <http://www.fusioncharts.com>
                                                                                                                                                                                                                                                                                                                                         *
                                                                                                                                                                                                                                                                                                                                         * Raphael 2.1.0
                                                                                                                                                                                                                                                                                                                                         * Copyright (c) 2008-2012 Dmitry Baranovskiy <http://raphaeljs.com>
                                                                                                                                                                                                                                                                                                                                         * Copyright © 2008-2012 Sencha Labs <http://sencha.com>
                                                                                                                                                                                                                                                                                                                                         *
                                                                                                                                                                                                                                                                                                                                         * Licensed under the MIT license.
                                                                                                                                                                                                                                                                                                                                         */

var _eve = __webpack_require__(392);

var _eve2 = _interopRequireDefault(_eve);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _win = typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : null;

/*\
 * Raphael
 [ method ]
 **
 * Creates a canvas object on which to draw.
 * You must do this first, as all future calls to drawing methods
 * from this instance will be bound to this canvas.
 > Parameters
 **
 - container (HTMLElement|string) DOM element or its ID which is going to be a parent for drawing surface
 - width (number)
 - height (number)
 - callback (function) #optional callback function which is going to be executed in the context of newly created paper
 * or
 - x (number)
 - y (number)
 - width (number)
 - height (number)
 - callback (function) #optional callback function which is going to be executed in the context of newly created paper
 * or
 - all (array) (first 3 or 4 elements in the array are equal to [containerID, width, height] or [x, y, width, height]. The rest are element descriptions in format {type: type, <attributes>}). See @Paper.add.
 - callback (function) #optional callback function which is going to be executed in the context of newly created paper
 * or
 - onReadyCallback (function) function that is going to be called on DOM ready event. You can also subscribe to this event via Eve’s “DOMLoad” event. In this case method returns `undefined`.
 = (object) @Paper
 > Usage
 | // Each of the following examples create a canvas
 | // that is 320px wide by 200px high.
 | // Canvas is created at the viewport’s 10,50 coordinate.
 | var paper = Raphael(10, 50, 320, 200);
 | // Canvas is created at the top left corner of the #notepad element
 | // (or its top right corner in dir="rtl" elements)
 | var paper = Raphael(document.getElementById("notepad"), 320, 200);
 | // Same as above
 | var paper = Raphael("notepad", 320, 200);
 | // Image dump
 | var set = Raphael(["notepad", 320, 200, {
 |     type: "rect",
 |     x: 10,
 |     y: 10,
 |     width: 25,
 |     height: 25,
 |     stroke: "#f00"
 | }, {
 |     type: "text",
 |     x: 30,
 |     y: 40,
 |     text: "Dump"
 | }]);
\*/
function R(first) {
    var args, f;

    // Code commented as resources will now be referenced using relative URLs.
    // @todo Remove once we have ascertained that there are no issues in any environment.
    // if (R._url) { // Reinitialize URLs to be safe from pop state event
    //     R._url = (R._g && R._g.win || _window).location.href.replace(/#.*?$/, "");
    // }
    // If the URL is undefined only then initialize the URL with blank in order to support
    // both relative as well as absolute URLs
    // @todo Need to track the URL change and modify the URL for the gradient and other elements dynamically.
    if (R._url === undefined) {
        R._url = "";
    }

    if (R.is(first, "function")) {
        return loaded ? first() : _eve2["default"].on("raphael.DOMload", first);
    } else if (R.is(first, array)) {
        return R._engine.create[apply](R, first.splice(0, 3 + R.is(first[0], nu))).add(first);
    } else {
        args = Array.prototype.slice.call(arguments, 0);
        if (R.is(args[args.length - 1], "function")) {
            f = args.pop();
            return loaded ? f.call(R._engine.create[apply](R, args)) : _eve2["default"].on("raphael.DOMload", function () {
                f.call(R._engine.create[apply](R, args));
            });
        } else {
            return R._engine.create[apply](R, arguments);
        }
    }
}

R.upgrade = "1.0.0";
R.version = "2.1.0";
R.eve = _eve2["default"];
// RedRaphael = R;

var loaded,
    undef,
    E = "",
    S = " ",
    UNIT_INTERVAL = 40,
    proto = "prototype",
    has = "hasOwnProperty",
    appendChild = "appendChild",
    apply = "apply",
    concat = "concat",
    nu = "number",
    string = "string",
    array = "array",
    object = "object",
    finite = "finite",
    toString = "toString",
    fillString = "fill",
    push = "push",
    setAttribute = "setAttribute",
    split = "split",
    none = "none",
    black = "#000",
    OBJECTSTRING = "object",
    arrayToStr = "[object Array]",
    objectToStr = "[object Object]",
    arraySlice = Array.prototype.slice,
    arraySplice = Array.prototype.splice,
    arrayShift = Array.prototype.shift,
    arrayPop = Array.prototype.pop,
    hasPrototypeBug = function () {
    var a = function a() {};
    return a.hasOwnProperty("prototype");
}(),
    g = {
    doc: _win.document,
    win: _win
},
    oldRaphael = {
    was: Object.prototype[has].call(g.win, "Raphael"),
    is: g.win.Raphael
},
    doc = g.doc,
    win = g.win,
    supportsTouch = R.supportsTouch = "createTouch" in doc,


// The devices which both touch and pointer.
supportsOnlyTouch = R.supportsOnlyTouch = supportsTouch && !(win.navigator.maxTouchPoints || win.navigator.msMaxTouchPoints),
    CustomAttributes = function CustomAttributes() {
    /*\
     * Raphael.ca
     [ property (object) ]
     **
     * Shortcut for @Raphael.customAttributes
    \*/
    /*\
     * Raphael.customAttributes
     [ property (object) ]
     **
     * If you have a set of attributes that you would like to represent
     * as a function of some number across all papers you can do it
     * easily with custom attributes:
     > Usage
     | Raphael.customAttributes.hue = function (num) {
     |     num = num % 1;
     |     return {fill: "hsb(" + num + ", 0.75, 1)"};
     | };
     | // Custom attribute “hue” will change fill
     | // to be given hue with fixed saturation and brightness.
     | // Now you can use it like this:
     | var c = paper.circle(10, 10, 10).attr({hue: .45});
     | // or even like this:
     | c.animate({hue: 1}, 1e3);
     |
     | // You could also create custom attribute
     | // with multiple parameters:
     | Raphael.customAttributes.hsb = function (h, s, b) {
     |     return {fill: "hsb(" + [h, s, b].join(",") + ")"};
     | };
     | c.attr({hsb: "0.5 .8 1"});
     | c.animate({hsb: [1, 0, 0.5]}, 1e3);
    \*/
},
    pluck = function pluck(checkWith) {
    var i = 1,
        ii = arguments.length;
    for (; i < ii; ++i) {
        if (arguments[i] !== checkWith) {
            return arguments[i];
        }
    }
},
    caproto = R.ca = R.customAttributes = CustomAttributes.prototype,
    Paper = function Paper() {
    /*\
     * Paper.ca
     [ property (object) ]
     **
     * Shortcut for @Paper.customAttributes
    \*/
    /*\
     * Paper.customAttributes
     [ property (object) ]
     **
     * If you have a set of attributes that you would like to represent
     * as a function of some number you can do it easily with custom attributes:
     > Usage
     | paper.customAttributes.hue = function (num) {
     |     num = num % 1;
     |     return {fill: "hsb(" + num + ", 0.75, 1)"};
     | };
     | // Custom attribute “hue” will change fill
     | // to be given hue with fixed saturation and brightness.
     | // Now you can use it like this:
     | var c = paper.circle(10, 10, 10).attr({hue: .45});
     | // or even like this:
     | c.animate({hue: 1}, 1e3);
     |
     | // You could also create custom attribute
     | // with multiple parameters:
     | paper.customAttributes.hsb = function (h, s, b) {
     |     return {fill: "hsb(" + [h, s, b].join(",") + ")"};
     | };
     | c.attr({hsb: "0.5 .8 1"});
     | c.animate({hsb: [1, 0, 0.5]}, 1e3);
    \*/
    this.ca = this.customAttributes = new CustomAttributes();
    this._CustomAttributes = function () {};
    this._CustomAttributes.prototype = this.ca;
    this._elementsById = {};
    this.id = R._oid++;
    (0, _eve2["default"])('raphael.new', this);
},


/*\
 * Raphael.fn
 [ property (object) ]
 **
 * You can add your own method to the canvas. For example if you want to draw a pie chart,
 * you can create your own pie chart function and ship it as a Raphaël plugin. To do this
 * you need to extend the `Raphael.fn` object. You should modify the `fn` object before a
 * Raphaël instance is created, otherwise it will take no effect. Please note that the
 * ability for namespaced plugins was removed in Raphael 2.0. It is up to the plugin to
 * ensure any namespacing ensures proper context.
 > Usage
 | Raphael.fn.arrow = function (x1, y1, x2, y2, size) {
 |     return this.path( ... );
 | };
 | // or create namespace
 | Raphael.fn.mystuff = {
 |     arrow: function () {…},
 |     star: function () {…},
 |     // etc…
 | };
 | var paper = Raphael(10, 10, 630, 480);
 | // then use it
 | paper.arrow(10, 10, 30, 30, 5).attr({fill: "#f00"});
 | paper.mystuff.arrow();
 | paper.mystuff.star();
\*/
paperproto = R.fn = Paper.prototype = R.prototype,
    elements = {
    circle: 1,
    rect: 1,
    path: 1,
    ellipse: 1,
    text: 1,
    image: 1,
    group: 1
},

// Add new dragstart, dragmove and dragend events in order to support touch drag in both touch and hybrid devices
events = "click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel dragstart dragmove dragend"[split](S),
    touchMap = R._touchMap = {
    mousedown: "touchstart",
    mousemove: "touchmove",
    mouseup: "touchend"
},
    dragEventMap = R._dragEventMap = {
    dragstart: "mousedown",
    dragmove: "mousemove",
    dragend: "mouseup"
},
    Str = String,
    toFloat = win.parseFloat,
    toInt = win.parseInt,
    math = Math,
    mmax = math.max,
    mmin = math.min,
    abs = math.abs,
    pow = math.pow,
    mathCos = math.cos,
    mathSin = math.sin,
    mathSqrt = math.sqrt,
    round = math.round,
    PI = math.PI,
    deg2rad = PI / 180,
    rad2deg = 180 / PI,
    lowerCase = Str.prototype.toLowerCase,
    upperCase = Str.prototype.toUpperCase,
    objectToString = Object.prototype.toString,
    paper = {},
    separator = /[, ]+/,
    formatrg = /\{(\d+)\}/g,
    ISURL = R._ISURL = /^url\(['"]?([^\)]+?)['"]?\)$/i,
    colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i,
    bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
    whitespace = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]/g,
    commaSpaces = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/,
    p2s = /,?([achlmqrstvxz]),?/gi,
    pathCommand = /([achlmrqstvz])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig,
    tCommand = /([rstm])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig,
    pathValues = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/ig,
    radial_gradient = R._radial_gradient = /^x?r(?:\(([^\)]*?)\))?/,
    isnan = {
    "NaN": 1,
    "Infinity": 1,
    "-Infinity": 1
},
    hsrg = {
    hs: 1,
    rg: 1
},
    availableAttrs = R._availableAttrs = {
    "arrow-end": none,
    "arrow-start": none,
    blur: 0,
    "clip-rect": "0 0 1e9 1e9",
    "clip-path": E,
    cursor: "default",
    cx: 0,
    cy: 0,
    fill: "#fff",
    "fill-opacity": 1,
    font: '10px "Arial"',
    "font-family": '"Arial"',
    "font-size": "10",
    "font-style": "normal",
    "font-weight": 400,
    gradient: 0,
    height: 0,
    href: "about:blank",
    "letter-spacing": 0,
    "line-height": 12,
    "vertical-align": "middle",
    opacity: 1,
    path: "M0,0",
    r: 0,
    rx: 0,
    ry: 0,
    src: E,
    stroke: "#000",
    "stroke-dasharray": E,
    "stroke-linecap": "butt",
    "stroke-linejoin": "butt",
    "stroke-miterlimit": 0,
    "stroke-opacity": 1,
    "stroke-width": 1,
    target: "_blank",
    "text-anchor": "middle",
    "visibility": E,
    title: E,
    transform: E,
    rotation: 0,
    width: 0,
    x: 0,
    y: 0,
    alpha: nu
},
    availableAnimAttrs = R._availableAnimAttrs = {
    blur: nu,
    "clip-rect": "csv",
    "clip-path": "path",
    cx: nu,
    cy: nu,
    fill: "colour",
    "fill-opacity": nu,
    "font-size": nu,
    height: nu,
    opacity: nu,
    path: "path",
    r: nu,
    rx: nu,
    ry: nu,
    stroke: "colour",
    "stroke-opacity": nu,
    "stroke-width": nu,
    transform: "transform",
    width: nu,
    x: nu,
    y: nu,
    // Required for pie 3d
    "color": "colour",
    "borderColor": "colour",
    "borderWidth": nu,
    alpha: nu
},
    eldata = {},
    sortByKey = function sortByKey(a, b) {
    return a.key - b.key;
},
    sortByNumber = function sortByNumber(a, b) {
    return toFloat(a) - toFloat(b);
},
    fun = function fun() {},
    pipe = function pipe(x) {
    return x;
},
    rectPath = R._rectPath = function (x, y, w, h, r) {
    if (r) {
        return [["M", x + r, y], ["l", w - r * 2, 0], ["a", r, r, 0, 0, 1, r, r], ["l", 0, h - r * 2], ["a", r, r, 0, 0, 1, -r, r], ["l", r * 2 - w, 0], ["a", r, r, 0, 0, 1, -r, -r], ["l", 0, r * 2 - h], ["a", r, r, 0, 0, 1, r, -r], ["z"]];
    }
    return [["M", x, y], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]];
},
    ellipsePath = function ellipsePath(x, y, rx, ry) {
    if (ry == null) {
        ry = rx;
    }
    return [["M", x, y], ["m", 0, -ry], ["a", rx, ry, 0, 1, 1, 0, 2 * ry], ["a", rx, ry, 0, 1, 1, 0, -2 * ry], ["z"]];
},
    getPath = R._getPath = {
    group: function group() {
        return false;
    },
    path: function path(el) {
        return el.attr("path");
    },
    circle: function circle(el) {
        var a = el.attrs;
        return ellipsePath(a.cx, a.cy, a.r);
    },
    ellipse: function ellipse(el) {
        var a = el.attrs;
        return ellipsePath(a.cx, a.cy, a.rx, a.ry);
    },
    rect: function rect(el) {
        var a = el.attrs;
        return rectPath(a.x, a.y, a.width, a.height, a.r);
    },
    image: function image(el) {
        var a = el.attrs;
        return rectPath(a.x, a.y, a.width, a.height);
    },
    text: function text(el) {
        var bbox = el._getBBox();
        return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
    }
},


/*\
 * Raphael.mapPath
 [ method ]
 **
 * Transform the path string with given matrix.
 > Parameters
 - path (string) path string
 - matrix (object) see @Matrix
 = (string) transformed path string
\*/
mapPath = R.mapPath = function (path, matrix) {
    if (!matrix) {
        return path;
    }
    var x, y, i, j, ii, jj, pathi;

    path = path2curve(path);
    for (i = 0, ii = path.length; i < ii; i++) {
        pathi = path[i];
        for (j = 1, jj = pathi.length; j < jj; j += 2) {
            x = matrix.x(pathi[j], pathi[j + 1]);
            y = matrix.y(pathi[j], pathi[j + 1]);
            pathi[j] = x;
            pathi[j + 1] = y;
        }
    }
    return path;
},


/*\
 * Raphael.pick
 [ method ]
 **
 * Returns the first truthy argument.
\*/
pick = R.pick = function () {
    for (var arg, i = 0, ii = arguments.length; i < ii; i += 1) {
        arg = arguments[i];
        if (!arg && arg !== false && arg !== 0) {
            continue;
        }
        return arg;
    }
    return undef;
},
    lastArgIfGroup = R._lastArgIfGroup = function (args, clear) {
    var last = args.length - 1,
        arg = args[last];

    if (arg && arg.constructor === R.el.constructor && arg.type === 'group') {
        if (clear) {
            args[last] = undefined;
            delete args[last];
            arraySplice.call(args, last, 1);
        }
        return arg;
    }
},
    serializeArgs = R._serializeArgs = function (args) {
    var arg0 = args[0],
        pathString,
        attrs,
        i,
        ii;

    if (R.is(arg0, 'object') && !R.is(arg0, 'array') && arg0.type !== 'group') {

        attrs = arg0;

        if (arg0.path) {
            pathString = arg0.path;
            pathString && !R.is(pathString, string) && !R.is(pathString[0], array) && (pathString += E);
        }

        for (i = 1, ii = arguments.length; i < ii; i += 2) {
            if (!attrs[arguments[i]]) {
                attrs[arguments[i]] = arguments[i + 1];
            }
        }
    } else {
        attrs = {};
        for (i = 1, ii = arguments.length; i < ii; i += 2) {
            attrs[arguments[i]] = args[(i - 1) / 2] || arguments[i + 1];
        }
    }
    return attrs;
},
    merge = R.merge = function (obj1, obj2, skipUndef, tgtArr, srcArr) {
    var item, srcVal, tgtVal, str, cRef;
    //check whether obj2 is an array
    //if array then iterate through it's index
    //**** MOOTOOLS precution

    if (!srcArr) {
        tgtArr = [obj1];
        srcArr = [obj2];
    } else {
        tgtArr.push(obj1);
        srcArr.push(obj2);
    }

    if (obj2 instanceof Array) {
        for (item = 0; item < obj2.length; item += 1) {
            try {
                srcVal = obj1[item];
                tgtVal = obj2[item];
            } catch (e) {
                continue;
            }

            if ((typeof tgtVal === "undefined" ? "undefined" : _typeof(tgtVal)) !== OBJECTSTRING) {
                if (!(skipUndef && tgtVal === undefined)) {
                    obj1[item] = tgtVal;
                }
            } else {
                if (srcVal === null || (typeof srcVal === "undefined" ? "undefined" : _typeof(srcVal)) !== OBJECTSTRING) {
                    srcVal = obj1[item] = tgtVal instanceof Array ? [] : {};
                }
                cRef = checkCyclicRef(tgtVal, srcArr);
                if (cRef !== -1) {
                    srcVal = obj1[item] = tgtArr[cRef];
                } else {
                    merge(srcVal, tgtVal, skipUndef, tgtArr, srcArr);
                }
            }
        }
    } else {
        for (item in obj2) {
            try {
                srcVal = obj1[item];
                tgtVal = obj2[item];
            } catch (e) {
                continue;
            }

            if (tgtVal !== null && (typeof tgtVal === "undefined" ? "undefined" : _typeof(tgtVal)) === OBJECTSTRING) {
                // Fix for issue BUG: FWXT-602
                // IE < 9 Object.prototype.toString.call(null) gives
                // "[object Object]" instead of "[object Null]"
                // that's why null value becomes Object in IE < 9
                str = objectToString.call(tgtVal);
                if (str === objectToStr) {
                    if (srcVal === null || (typeof srcVal === "undefined" ? "undefined" : _typeof(srcVal)) !== OBJECTSTRING) {
                        srcVal = obj1[item] = {};
                    }
                    cRef = checkCyclicRef(tgtVal, srcArr);
                    if (cRef !== -1) {
                        srcVal = obj1[item] = tgtArr[cRef];
                    } else {
                        merge(srcVal, tgtVal, skipUndef, tgtArr, srcArr);
                    }
                } else if (str === arrayToStr) {
                    if (srcVal === null || !(srcVal instanceof Array)) {
                        srcVal = obj1[item] = [];
                    }
                    cRef = checkCyclicRef(tgtVal, srcArr);
                    if (cRef !== -1) {
                        srcVal = obj1[item] = tgtArr[cRef];
                    } else {
                        merge(srcVal, tgtVal, skipUndef, tgtArr, srcArr);
                    }
                } else {
                    obj1[item] = tgtVal;
                }
            } else {
                obj1[item] = tgtVal;
            }
        }
    }
    return obj1;
},
    extend = R.extend = function (obj1, obj2, skipUndef) {
    if ((typeof obj1 === "undefined" ? "undefined" : _typeof(obj1)) !== OBJECTSTRING && (typeof obj2 === "undefined" ? "undefined" : _typeof(obj2)) !== OBJECTSTRING) {
        //if none of the arguments are object then return back
        return null;
    }

    if ((typeof obj2 === "undefined" ? "undefined" : _typeof(obj2)) !== OBJECTSTRING || obj2 === null) {
        return obj1;
    }

    if ((typeof obj1 === "undefined" ? "undefined" : _typeof(obj1)) !== OBJECTSTRING) {
        obj1 = obj2 instanceof Array ? [] : {};
    }
    merge(obj1, obj2, skipUndef);
    return obj1;
},


/*\
 * Raphael.is
 [ method ]
 **
 * Handfull replacement for `typeof` operator.
 > Parameters
 - o (…) any object or primitive
 - type (string) name of the type, i.e. “string”, “function”, “number”, etc.
 = (boolean) is given value is of given type
\*/
is = R.is = function (o, type) {
    type = lowerCase.call(type);

    if (type == finite) {
        return !isnan[has](+o);
    }
    if (type == array) {
        return o instanceof Array;
    }
    if (type === 'object' && (o === undef || o === null)) {
        return false;
    }
    return type == "null" && o === null || type == (typeof o === "undefined" ? "undefined" : _typeof(o)) && o !== null || type == object && o === Object(o) || type == "array" && Array.isArray && Array.isArray(o) || objectToString.call(o).slice(8, -1).toLowerCase() == type;
},

/*\
  * Raphael.createUUID
  [ method ]
  **
  * Returns RFC4122, version 4 ID
 \*/
createUUID = R.createUUID = function (uuidRegEx, uuidReplacer) {
    return function () {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(uuidRegEx, uuidReplacer).toUpperCase();
    };
}(/[xy]/g, function (c) {
    var r = math.random() * 16 | 0,
        v = c == "x" ? r : r & 3 | 8;
    return v.toString(16);
}),


/*\
  * Raphael.getElementID
  [ method ]
  **
  * Add 'rr-' prefix before created IDs
 \*/
getElementID = R.getElementID = function (id) {
    return "rr-" + id;
},


/*\
  * Raphael.clone
  [ method ]
  **
  * Returns a recursively cloned version of an object.
 \*/
clone = R.clone = hasPrototypeBug ? function (obj) {
    if (Object(obj) !== obj) {
        return obj;
    }
    var res = new obj.constructor();
    for (var key in obj) {
        if (key !== "prototype" && obj[has](key)) {
            res[key] = clone(obj[key]);
        }
    }return res;
} : function (obj) {
    if (Object(obj) !== obj) {
        return obj;
    }
    var res = new obj.constructor();
    for (var key in obj) {
        if (obj[has](key)) {
            res[key] = clone(obj[key]);
        }
    }return res;
},
    Node = _win.Node;
//Adding pollyfill for IE11
if (Node && !Node.prototype.contains) {
    Node.prototype.contains = function (el) {
        while (el = el.parentNode) {
            if (el === this) return true;
        }
        return false;
    };
};

R._g = g;

// PriorityQueue Function Declaration
function PriorityQueue(comparator) {
    this._comparator = comparator;
    this._elements = [];
}

PriorityQueue.prototype.isEmpty = function () {
    return this.size() === 0;
};

PriorityQueue.prototype.peek = function () {
    if (this.isEmpty()) return null;

    return this._elements[0];
};

PriorityQueue.prototype.deq = function () {
    var first = this.peek();
    var last = this._elements.pop();
    var size = this.size();

    if (size === 0) return first;

    this._elements[0] = last;
    var current = 0;

    while (current < size) {
        var largest = current;
        var left = 2 * current + 1;
        var right = 2 * current + 2;

        if (left < size && this._compare(left, largest) >= 0) {
            largest = left;
        }

        if (right < size && this._compare(right, largest) >= 0) {
            largest = right;
        }

        if (largest === current) break;

        this._swap(largest, current);
        current = largest;
    }

    return first;
};

PriorityQueue.prototype.enq = function (element) {
    var size = this._elements.push(element);
    var current = size - 1;

    while (current > 0) {
        var parent = Math.floor((current - 1) / 2);

        if (this._compare(current, parent) <= 0) break;

        this._swap(parent, current);
        current = parent;
    }

    return size;
};

PriorityQueue.prototype.size = function () {
    return this._elements.length;
};

PriorityQueue.prototype._compare = function (a, b) {
    return this._comparator(this._elements[a], this._elements[b]);
};

PriorityQueue.prototype._swap = function (a, b) {
    var aux = this._elements[a];
    this._elements[a] = this._elements[b];
    this._elements[b] = aux;
};

/*\
 * Raphael.type
 [ property (string) ]
 **
 * Can be “SVG”, “VML” or empty, depending on browser support.
\*/
R.type = win.ENABLE_RED_CANVAS && (win.CanvasRenderingContext2D || doc.createElement('canvas').getContext) ? "CANVAS" : win.SVGAngle || doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1") ? "SVG" : "VML";

if (R.type == "VML") {
    var d = doc.createElement("div"),
        b;

    d.innerHTML = '<v:shape adj="1"/>';
    b = d.firstChild;
    b.style.behavior = "url(#default#VML)";
    if (!(b && _typeof(b.adj) == object)) {
        R.type = E;
        // return (R.type = E);
    }
    d = null;
}

/*\
 * Raphael.svg
 [ property (boolean) ]
 **
 * `true` if browser supports SVG.
\*/
/*\
 * Raphael.vml
 [ property (boolean) ]
 **
 * `true` if browser supports VML.
\*/
R.svg = !((R.vml = R.type == "VML") || (R.canvas = R.type == "CANVAS"));

R._Paper = Paper;
R._id = 0;
R._oid = 0;

/*\
 * Raphael.angle
 [ method ]
 **
 * Returns angle between two or three points
 > Parameters
 - x1 (number) x coord of first point
 - y1 (number) y coord of first point
 - x2 (number) x coord of second point
 - y2 (number) y coord of second point
 - x3 (number) #optional x coord of third point
 - y3 (number) #optional y coord of third point
 = (number) angle in degrees.
\*/
R.angle = function (x1, y1, x2, y2, x3, y3) {
    if (x3 == null) {
        var x = x1 - x2,
            y = y1 - y2;
        if (!x && !y) {
            return 0;
        }
        return (180 + math.atan2(-y, -x) * rad2deg + 360) % 360;
    } else {
        return R.angle(x1, y1, x3, y3) - R.angle(x2, y2, x3, y3);
    }
};

/*\
 * Raphael.rad
 [ method ]
 **
 * Transform angle to radians
 > Parameters
 - deg (number) angle in degrees
 = (number) angle in radians.
\*/
R.rad = function (deg) {
    return deg % 360 * deg2rad;
};

/*\
 * Raphael.deg
 [ method ]
 **
 * Transform angle to degrees
 > Parameters
 - deg (number) angle in radians
 = (number) angle in degrees.
\*/
R.deg = function (rad) {
    return rad * rad2deg % 360;
};

/*\
 * Raphael.snapTo
 [ method ]
 **
 * Snaps given value to given grid.
 > Parameters
 - values (array|number) given array of values or step of the grid
 - value (number) value to adjust
 - tolerance (number) #optional tolerance for snapping. Default is `10`.
 = (number) adjusted value.
\*/
R.snapTo = function (values, value, tolerance) {
    var rem, i;

    if (!is(tolerance, finite)) {
        tolerance = 10;
    }

    if (is(values, array)) {
        i = values.length;
        while (i--) {
            if (abs(values[i] - value) <= tolerance) {
                return values[i];
            }
        }
    } else {
        values = +values;
        rem = value % values;

        if (rem < tolerance) {
            return value - rem;
        }
        if (rem > values - tolerance) {
            return value - rem + values;
        }
    }
    return value;
};

/*\
 * Raphael.setWindow
 [ method ]
 **
 * Used when you need to draw in `&lt;iframe>`. Switched window to the iframe one.
 > Parameters
 - newwin (window) new window object
\*/
R.setWindow = function (newwin) {
    (0, _eve2["default"])("raphael.setWindow", R, g.win, newwin);
    win = g.win = newwin;
    doc = g.doc = g.win.document;
    if (R._engine.initWin) {
        R._engine.initWin(g.win);
    }
};

var _toHex = function toHex(color) {
    if (R.vml) {
        // http://dean.edwards.name/weblog/2009/10/convert-any-colour-value-to-hex-in-msie/
        var trim = /^\s+|\s+$/g;
        var bod;
        try {
            var docum = new ActiveXObject("htmlfile");
            docum.write("<body>");
            docum.close();
            bod = docum.body;
        } catch (e) {
            bod = createPopup().document.body;
        }
        var range = bod.createTextRange();
        _toHex = cacher(function (color) {
            try {
                bod.style.color = Str(color).replace(trim, E);
                var value = range.queryCommandValue("ForeColor");
                value = (value & 255) << 16 | value & 65280 | (value & 16711680) >>> 16;
                return "#" + ("000000" + value.toString(16)).slice(-6);
            } catch (e) {
                return none;
            }
        });
    } else {
        var i = g.doc.createElement("i");
        i.title = "Rapha\xebl Colour Picker";
        i.style.display = none;
        g.doc.body.appendChild(i);
        _toHex = cacher(function (color) {
            i.style.color = color;
            return g.doc.defaultView.getComputedStyle(i, E).getPropertyValue("color");
        });
    }
    return _toHex(color);
},
    hsbtoString = function hsbtoString() {
    return "hsb(" + [this.h, this.s, this.b] + ")";
},
    hsltoString = function hsltoString() {
    return "hsl(" + [this.h, this.s, this.l] + ")";
},
    rgbtoString = function rgbtoString() {
    return this.hex;
},
    prepareRGB = function prepareRGB(r, g, b) {
    if (g == null && is(r, object) && "r" in r && "g" in r && "b" in r) {
        b = r.b;
        g = r.g;
        r = r.r;
    }
    if (g == null && is(r, string)) {
        var clr = R.getRGB(r);
        r = clr.r;
        g = clr.g;
        b = clr.b;
    }
    if (r > 1 || g > 1 || b > 1) {
        r /= 255;
        g /= 255;
        b /= 255;
    }

    return [r, g, b];
},
    packageRGB = function packageRGB(r, g, b, o) {
    var rgb = {
        r: r *= 255,
        g: g *= 255,
        b: b *= 255,
        hex: R.rgb(r, g, b),
        toString: rgbtoString
    };
    is(o, "finite") && (rgb.opacity = o);
    return rgb;
};

/*\
 * Raphael.color
 [ method ]
 **
 * Parses the color string and returns object with all values for the given color.
 > Parameters
 - clr (string) color string in one of the supported formats (see @Raphael.getRGB)
 = (object) Combined RGB & HSB object in format:
 o {
 o     r (number) red,
 o     g (number) green,
 o     b (number) blue,
 o     hex (string) color in HTML/CSS format: #••••••,
 o     error (boolean) `true` if string can’t be parsed,
 o     h (number) hue,
 o     s (number) saturation,
 o     v (number) value (brightness),
 o     l (number) lightness
 o }
\*/
R.color = function (clr) {
    var rgb;
    if (R.is(clr, object) && "h" in clr && "s" in clr && "b" in clr) {
        rgb = R.hsb2rgb(clr);
        clr.r = rgb.r;
        clr.g = rgb.g;
        clr.b = rgb.b;
        clr.hex = rgb.hex;
    } else if (R.is(clr, object) && "h" in clr && "s" in clr && "l" in clr) {
        rgb = R.hsl2rgb(clr);
        clr.r = rgb.r;
        clr.g = rgb.g;
        clr.b = rgb.b;
        clr.hex = rgb.hex;
    } else {
        if (R.is(clr, "string")) {
            clr = R.getRGB(clr);
        }
        if (R.is(clr, object) && "r" in clr && "g" in clr && "b" in clr) {
            rgb = R.rgb2hsl(clr);
            clr.h = rgb.h;
            clr.s = rgb.s;
            clr.l = rgb.l;
            rgb = R.rgb2hsb(clr);
            clr.v = rgb.b;
        } else {
            clr = {
                hex: none
            };
            clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;
        }
    }
    clr.toString = rgbtoString;
    return clr;
};

/*\
 * Raphael.hsb2rgb
 [ method ]
 **
 * Converts HSB values to RGB object.
 > Parameters
 - h (number) hue
 - s (number) saturation
 - v (number) value or brightness
 = (object) RGB object in format:
 o {
 o     r (number) red,
 o     g (number) green,
 o     b (number) blue,
 o     hex (string) color in HTML/CSS format: #••••••
 o }
\*/
R.hsb2rgb = function (h, s, v, o) {
    if (this.is(h, object) && "h" in h && "s" in h && "b" in h) {
        v = h.b;
        s = h.s;
        h = h.h;
        o = h.o;
    }
    h *= 360;
    var R, G, B, X, C;
    h = h % 360 / 60;
    C = v * s;
    X = C * (1 - abs(h % 2 - 1));
    R = G = B = v - C;

    h = ~~h;
    R += [C, X, 0, 0, X, C][h];
    G += [X, C, C, X, 0, 0][h];
    B += [0, 0, X, C, C, X][h];
    return packageRGB(R, G, B, o);
};

/*\
 * Raphael.hsl2rgb
 [ method ]
 **
 * Converts HSL values to RGB object.
 > Parameters
 - h (number) hue
 - s (number) saturation
 - l (number) luminosity
 = (object) RGB object in format:
 o {
 o     r (number) red,
 o     g (number) green,
 o     b (number) blue,
 o     hex (string) color in HTML/CSS format: #••••••
 o }
\*/
R.hsl2rgb = function (h, s, l, o) {
    if (this.is(h, object) && "h" in h && "s" in h && "l" in h) {
        l = h.l;
        s = h.s;
        h = h.h;
    }
    if (h > 1 || s > 1 || l > 1) {
        h /= 360;
        s /= 100;
        l /= 100;
    }
    h *= 360;
    var R, G, B, X, C;
    h = h % 360 / 60;
    C = 2 * s * (l < .5 ? l : 1 - l);
    X = C * (1 - abs(h % 2 - 1));
    R = G = B = l - C / 2;

    h = ~~h;
    R += [C, X, 0, 0, X, C][h];
    G += [X, C, C, X, 0, 0][h];
    B += [0, 0, X, C, C, X][h];
    return packageRGB(R, G, B, o);
};

/*\
 * Raphael.rgb2hsb
 [ method ]
 **
 * Converts RGB values to HSB object.
 > Parameters
 - r (number) red
 - g (number) green
 - b (number) blue
 = (object) HSB object in format:
 o {
 o     h (number) hue
 o     s (number) saturation
 o     b (number) brightness
 o }
\*/
R.rgb2hsb = function (r, g, b) {
    b = prepareRGB(r, g, b);
    r = b[0];
    g = b[1];
    b = b[2];

    var H, S, V, C;
    V = mmax(r, g, b);
    C = V - mmin(r, g, b);
    H = C == 0 ? null : V == r ? (g - b) / C : V == g ? (b - r) / C + 2 : (r - g) / C + 4;
    H = (H + 360) % 6 * 60 / 360;
    S = C == 0 ? 0 : C / V;
    return {
        h: H,
        s: S,
        b: V,
        toString: hsbtoString
    };
};

/*\
 * Raphael.rgb2hsl
 [ method ]
 **
 * Converts RGB values to HSL object.
 > Parameters
 - r (number) red
 - g (number) green
 - b (number) blue
 = (object) HSL object in format:
 o {
 o     h (number) hue
 o     s (number) saturation
 o     l (number) luminosity
 o }
\*/
R.rgb2hsl = function (r, g, b) {
    b = prepareRGB(r, g, b);
    r = b[0];
    g = b[1];
    b = b[2];

    var H, S, L, M, m, C;
    M = mmax(r, g, b);
    m = mmin(r, g, b);
    C = M - m;
    H = C == 0 ? null : M == r ? (g - b) / C : M == g ? (b - r) / C + 2 : (r - g) / C + 4;
    H = (H + 360) % 6 * 60 / 360;
    L = (M + m) / 2;
    S = C == 0 ? 0 : L < .5 ? C / (2 * L) : C / (2 - 2 * L);
    return {
        h: H,
        s: S,
        l: L,
        toString: hsltoString
    };
};

R._path2string = function () {
    return this.join(",").replace(p2s, "$1");
};

function repush(array, item) {
    for (var i = 0, ii = array.length; i < ii; i++) {
        if (array[i] === item) {
            return array.push(array.splice(i, 1)[0]);
        }
    }
}

var cacher = R._cacher = function (f, scope, postprocessor) {
    function cachedfunction() {
        var arg = arraySlice.call(arguments, 0),
            args = arg.join("\u2400"),
            cache = cachedfunction.cache = cachedfunction.cache || {},
            count = cachedfunction.count = cachedfunction.count || [];
        if (cache[has](args)) {
            repush(count, args);
            return postprocessor ? postprocessor(cache[args]) : cache[args];
        }
        count.length >= 1e3 && delete cache[count.shift()];
        count.push(args);
        cache[args] = f[apply](scope, arg);
        return postprocessor ? postprocessor(cache[args]) : cache[args];
    }
    return cachedfunction;
};

var preload = R._preload = function (src, f) {
    var img = doc.createElement("img");
    img.style.cssText = "position:absolute;left:-9999em;top:-9999em";
    img.onload = function () {
        f.call(this);
        this.onload = null;
        doc.body.removeChild(this);
    };
    img.onerror = function () {
        doc.body.removeChild(this);
    };
    doc.body.appendChild(img);
    img.src = src;
};

function clrToString() {
    return this.hex;
}

/*\
 * Raphael.getRGB
 [ method ]
 **
 * Parses colour string as RGB object
 > Parameters
 - colour (string) colour string in one of formats:
 # <ul>
 #     <li>Colour name (“<code>red</code>”, “<code>green</code>”, “<code>cornflowerblue</code>”, etc)</li>
 #     <li>#••• — shortened HTML colour: (“<code>#000</code>”, “<code>#fc0</code>”, etc)</li>
 #     <li>#•••••• — full length HTML colour: (“<code>#000000</code>”, “<code>#bd2300</code>”)</li>
 #     <li>rgb(•••, •••, •••) — red, green and blue channels’ values: (“<code>rgb(200,&nbsp;100,&nbsp;0)</code>”)</li>
 #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (“<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>”)</li>
 #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (“<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>”)</li>
 #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>
 #     <li>hsl(•••, •••, •••) — same as hsb</li>
 #     <li>hsl(•••%, •••%, •••%) — same as hsb</li>
 # </ul>
 = (object) RGB object in format:
 o {
 o     r (number) red,
 o     g (number) green,
 o     b (number) blue
 o     hex (string) color in HTML/CSS format: #••••••,
 o     error (boolean) true if string can’t be parsed
 o }
\*/
R.getRGB = cacher(function (colour) {
    var opacity, res, red, green, blue, t, values, rgb;

    colour && is(colour, 'object') && "opacity" in colour && (opacity = colour.opacity);
    if (!colour || !!((colour = Str(colour)).indexOf("-") + 1)) {
        return {
            r: -1,
            g: -1,
            b: -1,
            hex: none,
            error: 1,
            toString: clrToString
        };
    }
    if (colour == none) {
        return {
            r: -1,
            g: -1,
            b: -1,
            hex: none,
            toString: clrToString
        };
    }
    !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() === "#") && (colour = _toHex(colour));

    if (rgb = colour.match(colourRegExp)) {
        if (rgb[2]) {
            blue = toInt(rgb[2].substring(5), 16);
            green = toInt(rgb[2].substring(3, 5), 16);
            red = toInt(rgb[2].substring(1, 3), 16);
        }
        if (rgb[3]) {
            blue = toInt((t = rgb[3].charAt(3)) + t, 16);
            green = toInt((t = rgb[3].charAt(2)) + t, 16);
            red = toInt((t = rgb[3].charAt(1)) + t, 16);
        }
        if (rgb[4]) {
            values = rgb[4][split](commaSpaces);
            red = toFloat(values[0]);
            values[0].slice(-1) == "%" && (red *= 2.55);
            green = toFloat(values[1]);
            values[1].slice(-1) == "%" && (green *= 2.55);
            blue = toFloat(values[2]);
            values[2].slice(-1) == "%" && (blue *= 2.55);
            rgb[1].toLowerCase().slice(0, 4) == "rgba" && (opacity = toFloat(values[3]));
            values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
        }
        if (rgb[5]) {
            values = rgb[5][split](commaSpaces);
            red = toFloat(values[0]);
            values[0].slice(-1) == "%" && (red *= 2.55);
            green = toFloat(values[1]);
            values[1].slice(-1) == "%" && (green *= 2.55);
            blue = toFloat(values[2]);
            values[2].slice(-1) == "%" && (blue *= 2.55);
            (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
            rgb[1].toLowerCase().slice(0, 4) == "hsba" && (opacity = toFloat(values[3]));
            values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
            return R.hsb2rgb(red, green, blue, opacity);
        }
        if (rgb[6]) {
            values = rgb[6][split](commaSpaces);
            red = toFloat(values[0]);
            values[0].slice(-1) == "%" && (red *= 2.55);
            green = toFloat(values[1]);
            values[1].slice(-1) == "%" && (green *= 2.55);
            blue = toFloat(values[2]);
            values[2].slice(-1) == "%" && (blue *= 2.55);
            (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
            rgb[1].toLowerCase().slice(0, 4) == "hsla" && (opacity = toFloat(values[3]));
            values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
            return R.hsl2rgb(red, green, blue, opacity);
        }
        rgb = {
            r: red,
            g: green,
            b: blue,
            toString: clrToString
        };
        rgb.hex = "#" + (16777216 | blue | green << 8 | red << 16).toString(16).slice(1);
        R.is(opacity, "finite") && (rgb.opacity = opacity);
        return rgb;
    }
    return {
        r: -1,
        g: -1,
        b: -1,
        hex: none,
        error: 1,
        toString: clrToString
    };
}, R);

R.tintshade = cacher(function (colour, percent) {
    var rgb = R.getRGB(colour),
        tint,
        offset = 255;

    percent < 0 && (percent *= -1, offset = 0);
    percent > 1 && (percent = 1);

    tint = percent === 0 ? rgb : {
        r: offset - (offset - rgb.r) * percent,
        g: offset - (offset - rgb.g) * percent,
        b: offset - (offset - rgb.b) * percent,
        toString: clrToString
    };
    tint.hex = R.rgb(tint.r, tint.g, tint.b);
    rgb.error && (tint.error = rgb.error);

    if ("opacity" in rgb) {
        tint.rgba = 'rgba(' + [tint.r, tint.g, tint.b, rgb.opacity].join(',') + ')';
        tint.opacity = rgb.opacity;
    } else {
        tint.rgba = 'rgb(' + [tint.r, tint.g, tint.b].join(',') + ')';
    }
    return tint;
}, R);

/*\
 * Raphael.hsb
 [ method ]
 **
 * Converts HSB values to hex representation of the colour.
 > Parameters
 - h (number) hue
 - s (number) saturation
 - b (number) value or brightness
 = (string) hex representation of the colour.
\*/
R.hsb = cacher(function (h, s, b) {
    return R.hsb2rgb(h, s, b).hex;
});

/*\
 * Raphael.hsl
 [ method ]
 **
 * Converts HSL values to hex representation of the colour.
 > Parameters
 - h (number) hue
 - s (number) saturation
 - l (number) luminosity
 = (string) hex representation of the colour.
\*/
R.hsl = cacher(function (h, s, l) {
    return R.hsl2rgb(h, s, l).hex;
});

/*\
 * Raphael.rgb
 [ method ]
 **
 * Converts RGB values to hex representation of the colour.
 > Parameters
 - r (number) red
 - g (number) green
 - b (number) blue
 = (string) hex representation of the colour.
\*/
R.rgb = cacher(function (r, g, b) {
    return "#" + (16777216 | b | g << 8 | r << 16).toString(16).slice(1);
});

/*\
 * Raphael.getColor
 [ method ]
 **
 * On each call returns next colour in the spectrum. To reset it back to red call @Raphael.getColor.reset
 > Parameters
 - value (number) #optional brightness, default is `0.75`
 = (string) hex representation of the colour.
\*/
R.getColor = function (value) {
    var start = this.getColor.start = this.getColor.start || {
        h: 0,
        s: 1,
        b: value || .75
    },
        rgb = this.hsb2rgb(start.h, start.s, start.b);
    start.h += .075;
    if (start.h > 1) {
        start.h = 0;
        start.s -= .2;
        start.s <= 0 && (this.getColor.start = {
            h: 0,
            s: 1,
            b: start.b
        });
    }
    return rgb.hex;
};

/*\
 * Raphael.getColor.reset
 [ method ]
 **
 * Resets spectrum position for @Raphael.getColor back to red.
\*/
R.getColor.reset = function () {
    delete this.start;
};

// http://schepers.cc/getting-to-the-point
function catmullRom2bezier(crp, z) {
    var d = [];
    for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
        var p = [{
            x: +crp[i - 2],
            y: +crp[i - 1]
        }, {
            x: +crp[i],
            y: +crp[i + 1]
        }, {
            x: +crp[i + 2],
            y: +crp[i + 3]
        }, {
            x: +crp[i + 4],
            y: +crp[i + 5]
        }];
        if (z) {
            if (!i) {
                p[0] = {
                    x: +crp[iLen - 2],
                    y: +crp[iLen - 1]
                };
            } else if (iLen - 4 == i) {
                p[3] = {
                    x: +crp[0],
                    y: +crp[1]
                };
            } else if (iLen - 2 == i) {
                p[2] = {
                    x: +crp[0],
                    y: +crp[1]
                };
                p[3] = {
                    x: +crp[2],
                    y: +crp[3]
                };
            }
        } else {
            if (iLen - 4 == i) {
                p[3] = p[2];
            } else if (!i) {
                p[0] = {
                    x: +crp[i],
                    y: +crp[i + 1]
                };
            }
        }
        d.push(["C", (-p[0].x + 6 * p[1].x + p[2].x) / 6, (-p[0].y + 6 * p[1].y + p[2].y) / 6, (p[1].x + 6 * p[2].x - p[3].x) / 6, (p[1].y + 6 * p[2].y - p[3].y) / 6, p[2].x, p[2].y]);
    }

    return d;
}

/*\
 * Raphael.parsePathString
 [ method ]
 **
 * Utility method
 **
 * Parses given path string into an array of arrays of path segments.
 > Parameters
 - pathString (string|array) path string or array of segments (in the last case it will be returned straight away)
 = (array) array of segments.
\*/
R.parsePathString = function (pathString) {
    if (!pathString) {
        return null;
    }
    var pth = paths(pathString);
    if (pth.arr) {
        return pathClone(pth.arr);
    }

    var paramCounts = {
        a: 7,
        c: 6,
        h: 1,
        l: 2,
        m: 2,
        r: 4,
        q: 4,
        s: 4,
        t: 2,
        v: 1,
        z: 0
    },
        data = [];
    if (R.is(pathString, array) && R.is(pathString[0], array)) {
        // rough assumption
        data = pathClone(pathString);
    }
    if (!data.length) {
        Str(pathString).replace(pathCommand, function (a, b, c) {
            var params = [],
                name = b.toLowerCase();
            c.replace(pathValues, function (a, b) {
                b && params.push(+b);
            });
            if (name == "m" && params.length > 2) {
                data.push([b][concat](params.splice(0, 2)));
                name = "l";
                b = b == "m" ? "l" : "L";
            }
            if (name == "r") {
                data.push([b][concat](params));
            } else while (params.length >= paramCounts[name]) {
                data.push([b][concat](params.splice(0, paramCounts[name])));
                if (!paramCounts[name]) {
                    break;
                }
            }
        });
    }
    data.toString = R._path2string;
    pth.arr = pathClone(data);
    return data;
};

/*\
 * Raphael.parseTransformString
 [ method ]
 **
 * Utility method
 **
 * Parses given path string into an array of transformations.
 > Parameters
 - TString (string|array) transform string or array of transformations (in the last case it will be returned straight away)
 = (array) array of transformations.
\*/
R.parseTransformString = cacher(function (TString) {
    if (!TString) {
        return null;
    }
    var paramCounts = {
        r: 3,
        s: 4,
        t: 2,
        m: 6
    },
        data = [];
    if (R.is(TString, array) && R.is(TString[0], array)) {
        // rough assumption
        data = pathClone(TString);
    }
    if (!data.length) {
        Str(TString).replace(tCommand, function (a, b, c) {
            var params = [],
                name = lowerCase.call(b);
            c.replace(pathValues, function (a, b) {
                b && params.push(+b);
            });
            data.push([b][concat](params));
        });
    }
    data.toString = R._path2string;
    return data;
});
// PATHS
var paths = function paths(ps) {
    var p = paths.ps = paths.ps || {};
    if (p[ps]) {
        p[ps].sleep = 100;
    } else {
        p[ps] = {
            sleep: 100
        };
    }
    setTimeout(function () {
        for (var key in p) {
            if (p[has](key) && key != ps) {
                p[key].sleep--;
                !p[key].sleep && delete p[key];
            }
        }
    });
    return p[ps];
};

/*\
 * Raphael.findDotsAtSegment
 [ method ]
 **
 * Utility method
 **
 * Find dot coordinates on the given cubic bezier curve at the given t.
 > Parameters
 - p1x (number) x of the first point of the curve
 - p1y (number) y of the first point of the curve
 - c1x (number) x of the first anchor of the curve
 - c1y (number) y of the first anchor of the curve
 - c2x (number) x of the second anchor of the curve
 - c2y (number) y of the second anchor of the curve
 - p2x (number) x of the second point of the curve
 - p2y (number) y of the second point of the curve
 - t (number) position on the curve (0..1)
 = (object) point information in format:
 o {
 o     x: (number) x coordinate of the point
 o     y: (number) y coordinate of the point
 o     m: {
 o         x: (number) x coordinate of the left anchor
 o         y: (number) y coordinate of the left anchor
 o     }
 o     n: {
 o         x: (number) x coordinate of the right anchor
 o         y: (number) y coordinate of the right anchor
 o     }
 o     start: {
 o         x: (number) x coordinate of the start of the curve
 o         y: (number) y coordinate of the start of the curve
 o     }
 o     end: {
 o         x: (number) x coordinate of the end of the curve
 o         y: (number) y coordinate of the end of the curve
 o     }
 o     alpha: (number) angle of the curve derivative at the point
 o }
\*/
R.findDotsAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
    var t1 = 1 - t,
        t13 = pow(t1, 3),
        t12 = pow(t1, 2),
        t2 = t * t,
        t3 = t2 * t,
        x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,
        y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,
        mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),
        my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),
        nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),
        ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),
        ax = t1 * p1x + t * c1x,
        ay = t1 * p1y + t * c1y,
        cx = t1 * c2x + t * p2x,
        cy = t1 * c2y + t * p2y,
        alpha = 90 - math.atan2(mx - nx, my - ny) * 180 / PI;
    (mx > nx || my < ny) && (alpha += 180);
    return {
        x: x,
        y: y,
        m: {
            x: mx,
            y: my
        },
        n: {
            x: nx,
            y: ny
        },
        start: {
            x: ax,
            y: ay
        },
        end: {
            x: cx,
            y: cy
        },
        alpha: alpha
    };
};

/*\
 * Raphael.bezierBBox
 [ method ]
 **
 * Utility method
 **
 * Return bounding box of a given cubic bezier curve
 > Parameters
 - p1x (number) x of the first point of the curve
 - p1y (number) y of the first point of the curve
 - c1x (number) x of the first anchor of the curve
 - c1y (number) y of the first anchor of the curve
 - c2x (number) x of the second anchor of the curve
 - c2y (number) y of the second anchor of the curve
 - p2x (number) x of the second point of the curve
 - p2y (number) y of the second point of the curve
 * or
 - bez (array) array of six points for bezier curve
 = (object) point information in format:
 o {
 o     min: {
 o         x: (number) x coordinate of the left point
 o         y: (number) y coordinate of the top point
 o     }
 o     max: {
 o         x: (number) x coordinate of the right point
 o         y: (number) y coordinate of the bottom point
 o     }
 o }
\*/
R.bezierBBox = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
    if (!R.is(p1x, "array")) {
        p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
    }
    var bbox = curveDim.apply(null, p1x);
    return {
        x: bbox.min.x,
        y: bbox.min.y,
        x2: bbox.max.x,
        y2: bbox.max.y,
        width: bbox.max.x - bbox.min.x,
        height: bbox.max.y - bbox.min.y
    };
};

/*\
 * Raphael.isPointInsideBBox
 [ method ]
 **
 * Utility method
 **
 * Returns `true` if given point is inside bounding boxes.
 > Parameters
 - bbox (string) bounding box
 - x (string) x coordinate of the point
 - y (string) y coordinate of the point
 = (boolean) `true` if point inside
\*/
R.isPointInsideBBox = function (bbox, x, y) {
    return x >= bbox.x && x <= bbox.x2 && y >= bbox.y && y <= bbox.y2;
};

/*\
 * Raphael.isBBoxIntersect
 [ method ]
 **
 * Utility method
 **
 * Returns `true` if two bounding boxes intersect
 > Parameters
 - bbox1 (string) first bounding box
 - bbox2 (string) second bounding box
 = (boolean) `true` if they intersect
\*/
R.isBBoxIntersect = function (bbox1, bbox2) {
    var i = R.isPointInsideBBox;
    return i(bbox2, bbox1.x, bbox1.y) || i(bbox2, bbox1.x2, bbox1.y) || i(bbox2, bbox1.x, bbox1.y2) || i(bbox2, bbox1.x2, bbox1.y2) || i(bbox1, bbox2.x, bbox2.y) || i(bbox1, bbox2.x2, bbox2.y) || i(bbox1, bbox2.x, bbox2.y2) || i(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
};

function base3(t, p1, p2, p3, p4) {
    var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,
        t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
    return t * t2 - 3 * p1 + 3 * p2;
}

function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
    if (z == null) {
        z = 1;
    }
    z = z > 1 ? 1 : z < 0 ? 0 : z;
    var z2 = z / 2,
        n = 12,
        Tvalues = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816],
        Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472],
        sum = 0;
    for (var i = 0; i < n; i++) {
        var ct = z2 * Tvalues[i] + z2,
            xbase = base3(ct, x1, x2, x3, x4),
            ybase = base3(ct, y1, y2, y3, y4),
            comb = xbase * xbase + ybase * ybase;
        sum += Cvalues[i] * mathSqrt(comb);
    }
    return z2 * sum;
}

function getTatLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {
    if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {
        return;
    }
    var t = 1,
        step = t / 2,
        t2 = t - step,
        l,
        e = .01;
    l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
    while (abs(l - ll) > e) {
        step /= 2;
        t2 += (l < ll ? 1 : -1) * step;
        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
    }
    return t2;
}

function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
    if (mmax(x1, x2) < mmin(x3, x4) || mmin(x1, x2) > mmax(x3, x4) || mmax(y1, y2) < mmin(y3, y4) || mmin(y1, y2) > mmax(y3, y4)) {
        return;
    }
    var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
        ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
        denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

    if (!denominator) {
        return;
    }
    var px = nx / denominator,
        py = ny / denominator,
        px2 = +px.toFixed(2),
        py2 = +py.toFixed(2);
    if (px2 < +mmin(x1, x2).toFixed(2) || px2 > +mmax(x1, x2).toFixed(2) || px2 < +mmin(x3, x4).toFixed(2) || px2 > +mmax(x3, x4).toFixed(2) || py2 < +mmin(y1, y2).toFixed(2) || py2 > +mmax(y1, y2).toFixed(2) || py2 < +mmin(y3, y4).toFixed(2) || py2 > +mmax(y3, y4).toFixed(2)) {
        return;
    }
    return {
        x: px,
        y: py
    };
}

function inter(bez1, bez2) {
    return interHelper(bez1, bez2);
}

function interCount(bez1, bez2) {
    return interHelper(bez1, bez2, 1);
}

function interHelper(bez1, bez2, justCount) {
    var bbox1 = R.bezierBBox(bez1),
        bbox2 = R.bezierBBox(bez2);

    if (!R.isBBoxIntersect(bbox1, bbox2)) {
        return justCount ? 0 : [];
    }
    var l1 = bezlen.apply(0, bez1),
        l2 = bezlen.apply(0, bez2),
        n1 = mmax(~~(l1 / 5), 1),
        n2 = mmax(~~(l2 / 5), 1),
        dots1 = [],
        dots2 = [],
        xy = {},
        res = justCount ? 0 : [];

    for (var i = 0; i < n1 + 1; i++) {
        var p = R.findDotsAtSegment.apply(R, bez1.concat(i / n1));
        dots1.push({
            x: p.x,
            y: p.y,
            t: i / n1
        });
    }
    for (i = 0; i < n2 + 1; i++) {
        p = R.findDotsAtSegment.apply(R, bez2.concat(i / n2));
        dots2.push({
            x: p.x,
            y: p.y,
            t: i / n2
        });
    }
    for (i = 0; i < n1; i++) {
        for (var j = 0; j < n2; j++) {
            var di = dots1[i],
                di1 = dots1[i + 1],
                dj = dots2[j],
                dj1 = dots2[j + 1],
                ci = abs(di1.x - di.x) < .001 ? "y" : "x",
                cj = abs(dj1.x - dj.x) < .001 ? "y" : "x",
                is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
            if (is) {
                if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {
                    continue;
                }
                xy[is.x.toFixed(4)] = is.y.toFixed(4);
                var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),
                    t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
                if (t1 >= 0 && t1 <= 1.001 && t2 >= 0 && t2 <= 1.001) {
                    if (justCount) {
                        res++;
                    } else {
                        res.push({
                            x: is.x,
                            y: is.y,
                            t1: mmin(t1, 1),
                            t2: mmin(t2, 1)
                        });
                    }
                }
            }
        }
    }
    return res;
}

/*\
 * Raphael.pathIntersection
 [ method ]
 **
 * Utility method
 **
 * Finds intersections of two paths
 > Parameters
 - path1 (string) path string
 - path2 (string) path string
 = (array) dots of intersection
 o [
 o     {
 o         x: (number) x coordinate of the point
 o         y: (number) y coordinate of the point
 o         t1: (number) t value for segment of path1
 o         t2: (number) t value for segment of path2
 o         segment1: (number) order number for segment of path1
 o         segment2: (number) order number for segment of path2
 o         bez1: (array) eight coordinates representing beziér curve for the segment of path1
 o         bez2: (array) eight coordinates representing beziér curve for the segment of path2
 o     }
 o ]
\*/
R.pathIntersection = function (path1, path2) {
    return interPathHelper(path1, path2);
};
R.pathIntersectionNumber = function (path1, path2) {
    return interPathHelper(path1, path2, 1);
};
function interPathHelper(path1, path2, justCount) {
    path1 = R._path2curve(path1);
    path2 = R._path2curve(path2);
    var x1,
        y1,
        x2,
        y2,
        x1m,
        y1m,
        x2m,
        y2m,
        bez1,
        bez2,
        res = justCount ? 0 : [];
    for (var i = 0, ii = path1.length; i < ii; i++) {
        var pi = path1[i];
        if (pi[0] == "M") {
            x1 = x1m = pi[1];
            y1 = y1m = pi[2];
        } else {
            if (pi[0] == "C") {
                bez1 = [x1, y1].concat(pi.slice(1));
                x1 = bez1[6];
                y1 = bez1[7];
            } else {
                bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
                x1 = x1m;
                y1 = y1m;
            }
            for (var j = 0, jj = path2.length; j < jj; j++) {
                var pj = path2[j];
                if (pj[0] == "M") {
                    x2 = x2m = pj[1];
                    y2 = y2m = pj[2];
                } else {
                    if (pj[0] == "C") {
                        bez2 = [x2, y2].concat(pj.slice(1));
                        x2 = bez2[6];
                        y2 = bez2[7];
                    } else {
                        bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
                        x2 = x2m;
                        y2 = y2m;
                    }
                    var intr = interHelper(bez1, bez2, justCount);
                    if (justCount) {
                        res += intr;
                    } else {
                        for (var k = 0, kk = intr.length; k < kk; k++) {
                            intr[k].segment1 = i;
                            intr[k].segment2 = j;
                            intr[k].bez1 = bez1;
                            intr[k].bez2 = bez2;
                        }
                        res = res.concat(intr);
                    }
                }
            }
        }
    }
    return res;
}

/*\
 * Raphael.isPointInsidePath
 [ method ]
 **
 * Utility method
 **
 * Returns `true` if given point is inside a given closed path.
 > Parameters
 - path (string) path string
 - x (number) x of the point
 - y (number) y of the point
 = (boolean) true, if point is inside the path
\*/
R.isPointInsidePath = function (path, x, y) {
    var bbox = R.pathBBox(path);
    return R.isPointInsideBBox(bbox, x, y) && (interPathHelper(path, [["M", x, y], ["H", bbox.x2 + 10]], 1) % 2 == 1 || interPathHelper(path, [["M", x, y], ["V", bbox.y2 + 10]], 1) % 2 == 1);
};
R._removedFactory = function (methodname) {
    return function () {
        (0, _eve2["default"])("raphael.log", null, "Rapha\xEBl: you are calling to method \u201C" + methodname + "\u201D of removed object", methodname);
    };
};

/*\
 * Raphael.pathBBox
 [ method ]
 **
 * Utility method
 **
 * Return bounding box of a given path
 > Parameters
 - path (string) path string
 = (object) bounding box
 o {
 o     x: (number) x coordinate of the left top point of the box
 o     y: (number) y coordinate of the left top point of the box
 o     x2: (number) x coordinate of the right bottom point of the box
 o     y2: (number) y coordinate of the right bottom point of the box
 o     width: (number) width of the box
 o     height: (number) height of the box
 o     cx: (number) x coordinate of the center of the box
 o     cy: (number) y coordinate of the center of the box
 o }
\*/
var pathDimensions = R.pathBBox = function (path) {
    var pth = paths(path);
    if (!path) {
        return {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            x2: 0,
            y2: 0
        };
    }
    path = path2curve(path);
    var x = 0,
        y = 0,
        X = [],
        Y = [],
        p;
    for (var i = 0, ii = path.length; i < ii; i++) {
        p = path[i];
        if (p[0] == "M") {
            x = p[1];
            y = p[2];
            X.push(x);
            Y.push(y);
        } else {
            var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
            X = X[concat](dim.min.x, dim.max.x);
            Y = Y[concat](dim.min.y, dim.max.y);
            x = p[5];
            y = p[6];
        }
    }
    var xmin = mmin[apply](0, X),
        ymin = mmin[apply](0, Y),
        xmax = mmax[apply](0, X),
        ymax = mmax[apply](0, Y),
        bb = {
        x: xmin,
        y: ymin,
        x2: xmax,
        y2: ymax,
        width: xmax - xmin,
        height: ymax - ymin
    };
    pth.bbox = clone(bb);
    return bb;
},
    pathClone = function pathClone(pathArray) {
    var res = clone(pathArray);
    res.toString = R._path2string;
    return res;
},
    pathToRelative = R._pathToRelative = function (pathArray) {
    var pth = paths(pathArray);
    if (pth.rel) {
        return pathClone(pth.rel);
    }
    if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) {
        // rough assumption
        pathArray = R.parsePathString(pathArray);
    }
    var res = [],
        x = 0,
        y = 0,
        mx = 0,
        my = 0,
        start = 0;
    if (pathArray[0][0] == "M") {
        x = pathArray[0][1];
        y = pathArray[0][2];
        mx = x;
        my = y;
        start++;
        res.push(["M", x, y]);
    }
    for (var i = start, ii = pathArray.length; i < ii; i++) {
        var r = res[i] = [],
            pa = pathArray[i];
        if (pa[0] != lowerCase.call(pa[0])) {
            r[0] = lowerCase.call(pa[0]);
            switch (r[0]) {
                case "a":
                    r[1] = pa[1];
                    r[2] = pa[2];
                    r[3] = pa[3];
                    r[4] = pa[4];
                    r[5] = pa[5];
                    r[6] = +(pa[6] - x).toFixed(3);
                    r[7] = +(pa[7] - y).toFixed(3);
                    break;
                case "v":
                    r[1] = +(pa[1] - y).toFixed(3);
                    break;
                case "m":
                    mx = pa[1];
                    my = pa[2];
                default:
                    for (var j = 1, jj = pa.length; j < jj; j++) {
                        r[j] = +(pa[j] - (j % 2 ? x : y)).toFixed(3);
                    }
            }
        } else {
            r = res[i] = [];
            if (pa[0] == "m") {
                mx = pa[1] + x;
                my = pa[2] + y;
            }
            for (var k = 0, kk = pa.length; k < kk; k++) {
                res[i][k] = pa[k];
            }
        }
        var len = res[i].length;
        switch (res[i][0]) {
            case "z":
                x = mx;
                y = my;
                break;
            case "h":
                x += +res[i][len - 1];
                break;
            case "v":
                y += +res[i][len - 1];
                break;
            default:
                x += +res[i][len - 2];
                y += +res[i][len - 1];
        }
    }
    res.toString = R._path2string;
    pth.rel = pathClone(res);
    return res;
},
    pathToAbsolute = R._pathToAbsolute = function (pathArray) {
    var pth = paths(pathArray),
        res;
    if (pth.abs) {
        return pathClone(pth.abs);
    }
    if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) {
        // rough assumption
        pathArray = R.parsePathString(pathArray);
    }
    if (!pathArray || !pathArray.length) {
        res = [["M", 0, 0]];
        res.toString = R._path2string;
        return res;
    }
    var x = 0,
        y = 0,
        mx = 0,
        my = 0,
        start = 0;
    res = [];
    if (pathArray[0][0] == "M") {
        x = +pathArray[0][1];
        y = +pathArray[0][2];
        mx = x;
        my = y;
        start++;
        res[0] = ["M", x, y];
    }
    var crz = pathArray.length == 3 && pathArray[0][0] == "M" && pathArray[1][0].toUpperCase() == "R" && pathArray[2][0].toUpperCase() == "Z";
    for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
        res.push(r = []);
        pa = pathArray[i];
        if (pa[0] != upperCase.call(pa[0])) {
            r[0] = upperCase.call(pa[0]);
            switch (r[0]) {
                case "A":
                    r[1] = pa[1];
                    r[2] = pa[2];
                    r[3] = pa[3];
                    r[4] = pa[4];
                    r[5] = pa[5];
                    r[6] = +(pa[6] + x);
                    r[7] = +(pa[7] + y);
                    break;
                case "V":
                    r[1] = +pa[1] + y;
                    break;
                case "H":
                    r[1] = +pa[1] + x;
                    break;
                case "R":
                    var dots = [x, y][concat](pa.slice(1));
                    for (var j = 2, jj = dots.length; j < jj; j++) {
                        dots[j] = +dots[j] + x;
                        dots[++j] = +dots[j] + y;
                    }
                    res.pop();
                    res = res[concat](catmullRom2bezier(dots, crz));
                    break;
                case "M":
                    mx = +pa[1] + x;
                    my = +pa[2] + y;
                default:
                    for (j = 1, jj = pa.length; j < jj; j++) {
                        r[j] = +pa[j] + (j % 2 ? x : y);
                    }
            }
        } else if (pa[0] == "R") {
            dots = [x, y][concat](pa.slice(1));
            res.pop();
            res = res[concat](catmullRom2bezier(dots, crz));
            r = ["R"][concat](pa.slice(-2));
        } else {
            for (var k = 0, kk = pa.length; k < kk; k++) {
                r[k] = pa[k];
            }
        }
        switch (r[0]) {
            case "Z":
                x = mx;
                y = my;
                break;
            case "H":
                x = r[1];
                break;
            case "V":
                y = r[1];
                break;
            case "M":
                mx = r[r.length - 2];
                my = r[r.length - 1];
            default:
                x = r[r.length - 2];
                y = r[r.length - 1];
        }
    }
    res.toString = R._path2string;
    pth.abs = pathClone(res);
    return res;
},
    l2c = function l2c(x1, y1, x2, y2) {
    return [x1, y1, x2, y2, x2, y2];
},
    q2c = function q2c(x1, y1, ax, ay, x2, y2) {
    var _13 = 1 / 3,
        _23 = 2 / 3;
    return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];
},
    a2c = function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
    // for more information of where this math came from visit:
    // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
    var _120 = PI * 120 / 180,
        rad = deg2rad * (+angle || 0),
        res = [],
        xy,
        rotate = cacher(function (x, y, rad) {
        var X = x * mathCos(rad) - y * mathSin(rad),
            Y = x * mathSin(rad) + y * mathCos(rad);
        return {
            x: X,
            y: Y
        };
    });
    if (!recursive) {
        xy = rotate(x1, y1, -rad);
        x1 = xy.x;
        y1 = xy.y;
        xy = rotate(x2, y2, -rad);
        x2 = xy.x;
        y2 = xy.y;
        var cos = mathCos(deg2rad * angle),
            sin = mathSin(deg2rad * angle),
            x = (x1 - x2) / 2,
            y = (y1 - y2) / 2;
        var h = x * x / (rx * rx) + y * y / (ry * ry);
        if (h > 1) {
            h = mathSqrt(h);
            rx = h * rx;
            ry = h * ry;
        }
        var rx2 = rx * rx,
            ry2 = ry * ry,
            k = (large_arc_flag == sweep_flag ? -1 : 1) * mathSqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
            cx = k * rx * y / ry + (x1 + x2) / 2,
            cy = k * -ry * x / rx + (y1 + y2) / 2,
            f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
            f2 = math.asin(((y2 - cy) / ry).toFixed(9));

        f1 = x1 < cx ? PI - f1 : f1;
        f2 = x2 < cx ? PI - f2 : f2;
        f1 < 0 && (f1 = PI * 2 + f1);
        f2 < 0 && (f2 = PI * 2 + f2);
        if (sweep_flag && f1 > f2) {
            f1 = f1 - PI * 2;
        }
        if (!sweep_flag && f2 > f1) {
            f2 = f2 - PI * 2;
        }
    } else {
        f1 = recursive[0];
        f2 = recursive[1];
        cx = recursive[2];
        cy = recursive[3];
    }
    var df = f2 - f1;
    if (abs(df) > _120) {
        var f2old = f2,
            x2old = x2,
            y2old = y2;
        f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
        x2 = cx + rx * mathCos(f2);
        y2 = cy + ry * mathSin(f2);
        res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
    }
    df = f2 - f1;
    var c1 = mathCos(f1),
        s1 = mathSin(f1),
        c2 = mathCos(f2),
        s2 = mathSin(f2),
        t = math.tan(df / 4),
        hx = 4 / 3 * rx * t,
        hy = 4 / 3 * ry * t,
        m1 = [x1, y1],
        m2 = [x1 + hx * s1, y1 - hy * c1],
        m3 = [x2 + hx * s2, y2 - hy * c2],
        m4 = [x2, y2];
    m2[0] = 2 * m1[0] - m2[0];
    m2[1] = 2 * m1[1] - m2[1];
    if (recursive) {
        return [m2, m3, m4][concat](res);
    } else {
        res = [m2, m3, m4][concat](res).join()[split](",");
        var newres = [];
        for (var i = 0, ii = res.length; i < ii; i++) {
            newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
        }
        return newres;
    }
},
    findDotAtSegment = function findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
    var t1 = 1 - t;
    return {
        x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
        y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y
    };
},
    curveDim = cacher(function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
    var a = c2x - 2 * c1x + p1x - (p2x - 2 * c2x + c1x),
        b = 2 * (c1x - p1x) - 2 * (c2x - c1x),
        c = p1x - c1x,
        t1 = (-b + mathSqrt(b * b - 4 * a * c)) / 2 / a,
        t2 = (-b - mathSqrt(b * b - 4 * a * c)) / 2 / a,
        y = [p1y, p2y],
        x = [p1x, p2x],
        dot;
    abs(t1) > "1e12" && (t1 = .5);
    abs(t2) > "1e12" && (t2 = .5);
    if (t1 > 0 && t1 < 1) {
        dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
        x.push(dot.x);
        y.push(dot.y);
    }
    if (t2 > 0 && t2 < 1) {
        dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
        x.push(dot.x);
        y.push(dot.y);
    }
    a = c2y - 2 * c1y + p1y - (p2y - 2 * c2y + c1y);
    b = 2 * (c1y - p1y) - 2 * (c2y - c1y);
    c = p1y - c1y;
    t1 = (-b + mathSqrt(b * b - 4 * a * c)) / 2 / a;
    t2 = (-b - mathSqrt(b * b - 4 * a * c)) / 2 / a;
    abs(t1) > "1e12" && (t1 = .5);
    abs(t2) > "1e12" && (t2 = .5);
    if (t1 > 0 && t1 < 1) {
        dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
        x.push(dot.x);
        y.push(dot.y);
    }
    if (t2 > 0 && t2 < 1) {
        dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
        x.push(dot.x);
        y.push(dot.y);
    }
    return {
        min: {
            x: mmin[apply](0, x),
            y: mmin[apply](0, y)
        },
        max: {
            x: mmax[apply](0, x),
            y: mmax[apply](0, y)
        }
    };
}),
    path2curve = R._path2curve = cacher(function (path, path2) {
    var pth = !path2 && paths(path);
    if (!path2 && pth.curve) {
        return pathClone(pth.curve);
    }
    var p = pathToAbsolute(path),
        p2 = path2 && pathToAbsolute(path2),
        attrs = {
        x: 0,
        y: 0,
        bx: 0,
        by: 0,
        X: 0,
        Y: 0,
        qx: null,
        qy: null
    },
        attrs2 = {
        x: 0,
        y: 0,
        bx: 0,
        by: 0,
        X: 0,
        Y: 0,
        qx: null,
        qy: null
    },
        processPath = function processPath(path, d) {
        var nx, ny;
        if (!path) {
            return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
        }
        !(path[0] in {
            T: 1,
            Q: 1
        }) && (d.qx = d.qy = null);
        switch (path[0]) {
            case "M":
                d.X = path[1];
                d.Y = path[2];
                break;
            case "A":
                path = ["C"][concat](a2c[apply](0, [d.x, d.y][concat](path.slice(1))));
                break;
            case "S":
                nx = d.x + (d.x - (d.bx || d.x));
                ny = d.y + (d.y - (d.by || d.y));
                path = ["C", nx, ny][concat](path.slice(1));
                break;
            case "T":
                d.qx = d.x + (d.x - (d.qx || d.x));
                d.qy = d.y + (d.y - (d.qy || d.y));
                path = ["C"][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                break;
            case "Q":
                d.qx = path[1];
                d.qy = path[2];
                path = ["C"][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
                break;
            case "L":
                path = ["C"][concat](l2c(d.x, d.y, path[1], path[2]));
                break;
            case "H":
                path = ["C"][concat](l2c(d.x, d.y, path[1], d.y));
                break;
            case "V":
                path = ["C"][concat](l2c(d.x, d.y, d.x, path[1]));
                break;
            case "Z":
                path = ["C"][concat](l2c(d.x, d.y, d.X, d.Y));
                break;
        }
        return path;
    },
        fixArc = function fixArc(pp, i) {
        if (pp[i].length > 7) {
            pp[i].shift();
            var pi = pp[i];
            while (pi.length) {
                pp.splice(i++, 0, ["C"][concat](pi.splice(0, 6)));
            }
            pp.splice(i, 1);
            ii = mmax(p.length, p2 && p2.length || 0);
        }
    },
        fixM = function fixM(path1, path2, a1, a2, i) {
        if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M" && !i) {
            path2.splice(i, 0, ["M", a2.x, a2.y]);
            a1.bx = 0;
            a1.by = 0;
            a1.x = path1[i][1];
            a1.y = path1[i][2];
            ii = mmax(p.length, p2 && p2.length || 0);
        }
    };
    for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {
        p[i] = processPath(p[i], attrs);
        fixArc(p, i);
        p2 && (p2[i] = processPath(p2[i], attrs2));
        p2 && fixArc(p2, i);
        fixM(p, p2, attrs, attrs2, i);
        fixM(p2, p, attrs2, attrs, i);
        var seg = p[i],
            seg2 = p2 && p2[i],
            seglen = seg.length,
            seg2len = p2 && seg2.length;
        attrs.x = seg[seglen - 2];
        attrs.y = seg[seglen - 1];
        attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
        attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
        attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
        attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
        attrs2.x = p2 && seg2[seg2len - 2];
        attrs2.y = p2 && seg2[seg2len - 1];
    }
    if (!p2) {
        pth.curve = pathClone(p);
    }
    return p2 ? [p, p2] : p;
}, null, pathClone),
    parseDots = R._parseDots = cacher(function (gradient) {
    var dots = [];
    for (var i = 0, ii = gradient.length; i < ii; i++) {
        var dot = {},
            par = gradient[i].match(/^([^:]*):?([\d\.]*)/);
        dot.color = R.getRGB(par[1]);
        if (dot.color.error) {
            return null;
        }
        //store opacity information
        dot.opacity = dot.color.opacity;
        dot.color = dot.color.hex;
        par[2] && (dot.offset = par[2] + "%");
        dots.push(dot);
    }
    for (i = 1, ii = dots.length - 1; i < ii; i++) {
        if (!dots[i].offset) {
            var start = toFloat(dots[i - 1].offset || 0),
                end = 0;
            for (var j = i + 1; j < ii; j++) {
                if (dots[j].offset) {
                    end = dots[j].offset;
                    break;
                }
            }
            if (!end) {
                end = 100;
                j = ii;
            }
            end = toFloat(end);
            var d = (end - start) / (j - i + 1);
            for (; i < j; i++) {
                start += d;
                dots[i].offset = start + "%";
            }
        }
    }
    return dots;
}),
    tear = R._tear = function (el, paper) {
    el == paper.top && (paper.top = el.prev);
    el == paper.bottom && (paper.bottom = el.next);
    el.next && (el.next.prev = el.prev);
    el.prev && (el.prev.next = el.next);
},
    tofront = R._tofront = function (el, paper) {
    if (paper.top === el) {
        return false;
    }
    tear(el, paper);
    el.next = null;
    el.prev = paper.top;
    paper.top.next = el;
    paper.top = el;
    return true;
},
    toback = R._toback = function (el, paper) {
    if (paper.bottom === el) {
        return false;
    }
    tear(el, paper);
    el.next = paper.bottom;
    el.prev = null;
    paper.bottom.prev = el;
    paper.bottom = el;
    return true;
},
    insertafter = R._insertafter = function (el, el2, paper, paper2) {
    tear(el, paper);
    el.parent = paper2;
    el2 === paper2.top && (paper2.top = el);
    el2.next && (el2.next.prev = el);
    el.next = el2.next;
    el.prev = el2;
    el2.next = el;
},
    insertbefore = R._insertbefore = function (el, el2, paper, paper2) {
    tear(el, paper);
    el.parent = paper2;
    el2 === paper2.bottom && (paper2.bottom = el);
    el2.prev && (el2.prev.next = el);
    el.prev = el2.prev;
    el2.prev = el;
    el.next = el2;
},


/*\
 * Raphael.toMatrix
 [ method ]
 **
 * Utility method
 **
 * Returns matrix of transformations applied to a given path
 > Parameters
 - path (string) path string
 - transform (string|array) transformation string
 = (object) @Matrix
\*/
toMatrix = R.toMatrix = function (path, transform) {
    var bb = pathDimensions(path),
        el = {
        _: {
            transform: E
        },
        getBBox: function getBBox() {
            return bb;
        }
    };
    extractTransform(el, transform);
    return el.matrix;
},


/*\
 * Raphael.transformPath
 [ method ]
 **
 * Utility method
 **
 * Returns path transformed by a given transformation
 > Parameters
 - path (string) path string
 - transform (string|array) transformation string
 = (string) path
\*/
transformPath = R.transformPath = function (path, transform) {
    return mapPath(path, toMatrix(path, transform));
},
    extractTransform = R._extractTransform = function (el, tstr) {
    if (tstr == null) {
        return el._.transform;
    }
    tstr = Str(tstr).replace(/\.{3}|\u2026/g, el._.transform || E);
    var tdata = R.parseTransformString(tstr),
        deg = 0,
        dx = 0,
        dy = 0,
        sx = 1,
        sy = 1,
        _ = el._,
        m = new Matrix();
    _.transform = tdata || [];
    if (tdata) {
        for (var i = 0, ii = tdata.length; i < ii; i++) {
            var t = tdata[i],
                tlen = t.length,
                command = Str(t[0]).toLowerCase(),
                absolute = t[0] != command,
                inver = absolute ? m.invert() : 0,
                x1,
                y1,
                x2,
                y2,
                bb;
            if (command == "t" && tlen == 3) {
                if (absolute) {
                    x1 = inver.x(0, 0);
                    y1 = inver.y(0, 0);
                    x2 = inver.x(t[1], t[2]);
                    y2 = inver.y(t[1], t[2]);
                    m.translate(x2 - x1, y2 - y1);
                } else {
                    m.translate(t[1], t[2]);
                }
            } else if (command == "r") {
                if (tlen == 2) {
                    bb = _.bb || (_.bb = el.getBBox(1));
                    m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                    deg += t[1];
                } else if (tlen == 4) {
                    if (absolute) {
                        x2 = inver.x(t[2], t[3]);
                        y2 = inver.y(t[2], t[3]);
                        m.rotate(t[1], x2, y2);
                    } else {
                        m.rotate(t[1], t[2], t[3]);
                    }
                    deg += t[1];
                }
            } else if (command == "s") {
                if (tlen == 2 || tlen == 3) {
                    bb = _.bb || (_.bb = el.getBBox(1));
                    m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                    sx *= t[1];
                    sy *= t[tlen - 1];
                } else if (tlen == 5) {
                    if (absolute) {
                        x2 = inver.x(t[3], t[4]);
                        y2 = inver.y(t[3], t[4]);
                        m.scale(t[1], t[2], x2, y2);
                    } else {
                        m.scale(t[1], t[2], t[3], t[4]);
                    }
                    sx *= t[1];
                    sy *= t[2];
                }
            } else if (command == "m" && tlen == 7) {
                m.add(t[1], t[2], t[3], t[4], t[5], t[6]);
            }
            _.dirtyT = 1;
            el.matrix = m;
        }
    }

    /*\
     * Element.matrix
     [ property (object) ]
     **
     * Keeps @Matrix object, which represents element transformation
    \*/
    el.matrix = m;

    _.sx = sx;
    _.sy = sy;
    _.deg = deg;
    _.dx = dx = m.e;
    _.dy = dy = m.f;

    if (sx == 1 && sy == 1 && !deg && _.bbox) {
        _.bbox.x += +dx;
        _.bbox.y += +dy;
    } else {
        _.dirtyT = 1;
    }
},
    getEmpty = function getEmpty(item) {
    var l = item[0];
    switch (l.toLowerCase()) {
        case "t":
            return [l, 0, 0];
        case "m":
            return [l, 1, 0, 0, 1, 0, 0];
        case "r":
            if (item.length == 4) {
                return [l, 0, item[2], item[3]];
            } else {
                return [l, 0];
            }
        case "s":
            if (item.length == 5) {
                return [l, 1, 1, item[3], item[4]];
            } else if (item.length == 3) {
                return [l, 1, 1];
            } else {
                return [l, 1];
            }
    }
},
    equaliseTransform = R._equaliseTransform = function (t1, t2) {
    t2 = Str(t2).replace(/\.{3}|\u2026/g, t1);
    t1 = R.parseTransformString(t1) || [];
    t2 = R.parseTransformString(t2) || [];
    var maxlength = mmax(t1.length, t2.length),
        from = [],
        to = [],
        i = 0,
        j,
        jj,
        tt1,
        tt2;
    for (; i < maxlength; i++) {
        tt1 = t1[i] || getEmpty(t2[i]);
        tt2 = t2[i] || getEmpty(tt1);
        if (tt1[0] != tt2[0] || tt1[0].toLowerCase() == "r" && (tt1[2] != tt2[2] || tt1[3] != tt2[3]) || tt1[0].toLowerCase() == "s" && (tt1[3] != tt2[3] || tt1[4] != tt2[4])) {
            return;
        }
        from[i] = [];
        to[i] = [];
        for (j = 0, jj = mmax(tt1.length, tt2.length); j < jj; j++) {
            j in tt1 && (from[i][j] = tt1[j]);
            j in tt2 && (to[i][j] = tt2[j]);
        }
    }
    return {
        from: from,
        to: to
    };
};
R._getContainer = function (x, y, w, h) {
    var container;
    container = h == null && !R.is(x, object) ? g.doc.getElementById(x) : x;
    if (container == null) {
        return;
    }
    if (container.tagName) {
        if (y == null) {
            return {
                container: container,
                width: container.style.pixelWidth || container.offsetWidth,
                height: container.style.pixelHeight || container.offsetHeight
            };
        } else {
            return {
                container: container,
                width: y,
                height: w
            };
        }
    }
    return {
        container: 1,
        x: x,
        y: y,
        width: w,
        height: h
    };
};

/*\
 * Raphael.pathToRelative
 [ method ]
 **
 * Utility method
 **
 * Converts path to relative form
 > Parameters
 - pathString (string|array) path string or array of segments
 = (array) array of segments.
\*/
R.pathToRelative = pathToRelative;
R._engine = {};

/*\
 * Raphael.path2curve
 [ method ]
 **
 * Utility method
 **
 * Converts path to a new path where all segments are cubic bezier curves.
 > Parameters
 - pathString (string|array) path string or array of segments
 = (array) array of segments.
\*/
R.path2curve = path2curve;

/*\
 * Raphael.matrix
 [ method ]
 **
 * Utility method
 **
 * Returns matrix based on given parameters.
 > Parameters
 - a (number)
 - b (number)
 - c (number)
 - d (number)
 - e (number)
 - f (number)
 = (object) @Matrix
\*/
R.matrix = function (a, b, c, d, e, f) {
    return new Matrix(a, b, c, d, e, f);
};

function Matrix(a, b, c, d, e, f) {
    if (a != null) {
        this.a = +a;
        this.b = +b;
        this.c = +c;
        this.d = +d;
        this.e = +e;
        this.f = +f;
    } else {
        this.a = 1;
        this.b = 0;
        this.c = 0;
        this.d = 1;
        this.e = 0;
        this.f = 0;
    }
}
(function (matrixproto) {

    /*\
     * Matrix.add
     [ method ]
     **
     * Adds given matrix to existing one.
     > Parameters
     - a (number)
     - b (number)
     - c (number)
     - d (number)
     - e (number)
     - f (number)
     or
     - matrix (object) @Matrix
    \*/
    matrixproto.add = function (a, b, c, d, e, f) {
        var out = [[], [], []],
            m = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],
            matrix = [[a, c, e], [b, d, f], [0, 0, 1]],
            x,
            y,
            z,
            res;

        if (a && a instanceof Matrix) {
            matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]];
        }

        for (x = 0; x < 3; x++) {
            for (y = 0; y < 3; y++) {
                res = 0;
                for (z = 0; z < 3; z++) {
                    res += m[x][z] * matrix[z][y];
                }
                out[x][y] = res;
            }
        }
        this.a = out[0][0];
        this.b = out[1][0];
        this.c = out[0][1];
        this.d = out[1][1];
        this.e = out[0][2];
        this.f = out[1][2];
    };

    /*\
     * Matrix.invert
     [ method ]
     **
     * Returns inverted version of the matrix
     = (object) @Matrix
    \*/
    matrixproto.invert = function () {
        var me = this,
            x = me.a * me.d - me.b * me.c;
        return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);
    };

    /*\
     * Matrix.clone
     [ method ]
     **
     * Returns copy of the matrix
     = (object) @Matrix
    \*/
    matrixproto.clone = function () {
        return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
    };

    /*\
     * Matrix.translate
     [ method ]
     **
     * Translate the matrix
     > Parameters
     - x (number)
     - y (number)
    \*/
    matrixproto.translate = function (x, y) {
        this.add(1, 0, 0, 1, x, y);
    };

    /*\
     * Matrix.scale
     [ method ]
     **
     * Scales the matrix
     > Parameters
     - x (number)
     - y (number) #optional
     - cx (number) #optional
     - cy (number) #optional
    \*/
    matrixproto.scale = function (x, y, cx, cy) {
        y == null && (y = x);
        (cx || cy) && this.add(1, 0, 0, 1, cx, cy);
        this.add(x, 0, 0, y, 0, 0);
        (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);
    };

    /*\
     * Matrix.rotate
     [ method ]
     **
     * Rotates the matrix
     > Parameters
     - a (number)
     - x (number)
     - y (number)
    \*/
    matrixproto.rotate = function (a, x, y) {
        a = R.rad(a);
        x = x || 0;
        y = y || 0;
        var cos = +mathCos(a).toFixed(9),
            sin = +mathSin(a).toFixed(9);
        this.add(cos, sin, -sin, cos, x, y);
        this.add(1, 0, 0, 1, -x, -y);
    };

    /*\
     * Matrix.x
     [ method ]
     **
     * Return x coordinate for given point after transformation described by the matrix. See also @Matrix.y
     > Parameters
     - x (number)
     - y (number)
     = (number) x
    \*/
    matrixproto.x = function (x, y) {
        return x * this.a + y * this.c + this.e;
    };

    /*\
     * Matrix.y
     [ method ]
     **
     * Return y coordinate for given point after transformation described by the matrix. See also @Matrix.x
     > Parameters
     - x (number)
     - y (number)
     = (number) y
    \*/
    matrixproto.y = function (x, y) {
        return x * this.b + y * this.d + this.f;
    };
    matrixproto.get = function (i) {
        return +this[Str.fromCharCode(97 + i)].toFixed(4);
    };
    matrixproto.toString = function () {
        return R.svg ? "matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")" : [this.get(0), this.get(2), this.get(1), this.get(3), 0, 0].join();
    };
    matrixproto.toMatrixString = function () {
        return "matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")";
    };
    matrixproto.toFilter = function () {
        return "progid:DXImageTransform.Microsoft.Matrix(M11=" + this.get(0) + ", M12=" + this.get(2) + ", M21=" + this.get(1) + ", M22=" + this.get(3) + ", Dx=" + this.get(4) + ", Dy=" + this.get(5) + ", sizingmethod='auto expand')";
    };
    matrixproto.offset = function () {
        return [this.e.toFixed(4), this.f.toFixed(4)];
    };
    function norm(a) {
        return a[0] * a[0] + a[1] * a[1];
    }
    function normalize(a) {
        var mag = mathSqrt(norm(a));
        a[0] && (a[0] /= mag);
        a[1] && (a[1] /= mag);
    }

    /*\
     * Matrix.split
     [ method ]
     **
     * Splits matrix into primitive transformations
     = (object) in format:
     o dx (number) translation by x
     o dy (number) translation by y
     o scalex (number) scale by x
     o scaley (number) scale by y
     o shear (number) shear
     o rotate (number) rotation in deg
     o isSimple (boolean) could it be represented via simple transformations
    \*/
    matrixproto.split = function () {
        var out = {};
        // translation
        out.dx = this.e;
        out.dy = this.f;

        // scale and shear
        var row = [[this.a, this.c], [this.b, this.d]];
        out.scalex = mathSqrt(norm(row[0]));
        normalize(row[0]);

        out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];
        row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];

        out.scaley = mathSqrt(norm(row[1]));
        normalize(row[1]);
        out.shear /= out.scaley;

        // rotation
        var sin = -row[0][1],
            cos = row[1][1];
        if (cos < 0) {
            out.rotate = R.deg(math.acos(cos));
            if (sin < 0) {
                out.rotate = 360 - out.rotate;
            }
        } else {
            out.rotate = R.deg(math.asin(sin));
        }

        out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);
        out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;
        out.noRotation = !+out.shear.toFixed(9) && !out.rotate;
        return out;
    };

    /*\
     * Matrix.toTransformString
     [ method ]
     **
     * Return transform string that represents given matrix
     = (string) transform string
    \*/
    matrixproto.toTransformString = function (shorter) {
        var s = shorter || this[split]();
        if (s.isSimple) {
            s.scalex = +s.scalex.toFixed(4);
            s.scaley = +s.scaley.toFixed(4);
            s.rotate = +s.rotate.toFixed(4);
            return (s.dx || s.dy ? "t" + [s.dx, s.dy] : E) + (s.scalex != 1 || s.scaley != 1 ? "s" + [s.scalex, s.scaley, 0, 0] : E) + (s.rotate ? "r" + [s.rotate, 0, 0] : E);
        } else {
            return "m" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];
        }
    };
})(Matrix.prototype);

// WebKit rendering bug workaround method
var navigator = win.navigator,
    version = navigator.userAgent.match(/Version\/(.*?)\s/) || navigator.userAgent.match(/Chrome\/(\d+)/);

if (navigator.vendor == "Apple Computer, Inc." && (version && version[1] < 4 || navigator.platform.slice(0, 2) == "iP") || navigator.vendor == "Google Inc." && version && version[1] < 8) {

    /*\
     * Paper.safari
     [ method ]
     **
     * There is an inconvenient rendering bug in Safari (WebKit):
     * sometimes the rendering should be forced.
     * This method should help with dealing with this bug.
    \*/
    paperproto.safari = function () {
        var rect = this.rect(-99, -99, this.width + 99, this.height + 99).attr({
            stroke: "none"
        });
        setTimeout(function () {
            rect.remove();
        });
        return true;
    };
} else {
    paperproto.safari = fun;
}

var preventDefault = function preventDefault() {
    this.returnValue = false;
},
    preventTouch = function preventTouch() {
    return this.originalEvent.preventDefault();
},
    stopPropagation = function stopPropagation() {
    this.cancelBubble = true;
},
    stopTouch = function stopTouch() {
    return this.originalEvent.stopPropagation();
},
    addEvent = R.addEvent = function () {
    if (g.doc.addEventListener) {
        return function (obj, type, fn, element) {
            var realName = supportsOnlyTouch && touchMap[type] || type,
                f;

            touchMap[dragEventMap[type]] && (realName = touchMap[dragEventMap[type]]);

            f = function f(e) {
                var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                    scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
                    target;
                if (supportsTouch && touchMap[has](supportsOnlyTouch ? type : dragEventMap[type])) {
                    for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {
                        target = e.targetTouches[i].target;
                        if (target == obj || target.nodeName == 'tspan' && target.parentNode == obj) {
                            var olde = e;
                            e = e.targetTouches[i];
                            e.originalEvent = olde;
                            e.preventDefault = preventTouch;
                            e.stopPropagation = stopTouch;
                            break;
                        }
                    }
                }
                return fn.call(element, e, e.clientX + scrollX, e.clientY + scrollY);
            };
            obj.addEventListener(realName, f, false);
            return function () {
                obj.removeEventListener(realName, f, false);
                return true;
            };
        };
    } else if (g.doc.attachEvent) {
        return function (obj, type, fn, element) {
            var f = function f(e) {
                e = e || g.win.event;
                var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                    scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
                    x = e.clientX + scrollX,
                    y = e.clientY + scrollY;
                e.preventDefault = e.preventDefault || preventDefault;
                e.stopPropagation = e.stopPropagation || stopPropagation;
                return fn.call(element, e, x, y);
            };
            obj.attachEvent("on" + type, f);
            var detacher = function detacher() {
                obj.detachEvent("on" + type, f);
                return true;
            };
            return detacher;
        };
    }
}(),
    drag = [],
    dragMove = function dragMove(e) {
    var x = e.clientX,
        y = e.clientY,
        scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
        scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
        dragi,
        data,
        dummyEve = {},
        key,
        j = drag.length;

    while (j--) {
        dragi = drag[j];
        if (supportsTouch && e.type === 'touchmove') {
            var i = e.touches.length,
                touch;
            while (i--) {
                touch = e.touches[i];
                if (touch.identifier == dragi.el._drag.id) {
                    x = touch.clientX;
                    y = touch.clientY;
                    (e.originalEvent ? e.originalEvent : e).preventDefault();
                    break;
                }
            }
        } else {
            e.preventDefault();
        }

        if (dragi.el.removed) {
            continue;
        }

        var node = R._engine.getNode(dragi.el),
            o,
            next = node.nextSibling,
            parent = node.parentNode,
            display = node.style.display;

        g.win.opera && parent.removeChild(node);

        node.style.display = "none";
        o = dragi.el.paper.getElementByPoint(x, y);
        node.style.display = display;
        g.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));
        o && (0, _eve2["default"])("raphael.drag.over." + dragi.el.id, dragi.el, o);
        x += scrollX;
        y += scrollY;
        for (key in e) {
            if (typeof e[key] === 'function') {
                dummyEve[key] = e[key].bind(e);
            } else {
                dummyEve[key] = e[key];
            }
        }
        data = dummyEve.data = [x - dragi.el._drag.x, y - dragi.el._drag.y, x, y];
        (0, _eve2["default"])("raphael.drag.move." + dragi.el.id, dragi.move_scope || dragi.el, dummyEve, data);
    }
},
    dragUp = function dragUp(e) {
    R.undragmove(dragMove).undragend(dragUp);
    R.unmousemove(dragMove).unmouseup(dragUp);
    var i = drag.length,
        dragi;

    while (i--) {
        dragi = drag[i];
        dragi.el._drag = {};
        (0, _eve2["default"])("raphael.drag.end." + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
    }
    drag = [];
},


/*\
 * Raphael.el
 [ property (object) ]
 **
 * You can add your own method to elements. This is usefull when you want to hack default functionality or
 * want to wrap some common transformation or attributes in one method. In difference to canvas methods,
 * you can redefine element method at any time. Expending element methods wouldn’t affect set.
 > Usage
 | Raphael.el.red = function () {
 |     this.attr({fill: "#f00"});
 | };
 | // then use it
 | paper.circle(100, 100, 20).red();
\*/
elproto = R.el = {};

/*\
 * Element.click
 [ method ]
 **
 * Adds event handler for click for the element.
 > Parameters
 - handler (function) handler for the event
 = (object) @Element
\*/
/*\
 * Element.unclick
 [ method ]
 **
 * Removes event handler for click for the element.
 > Parameters
 - handler (function) handler for the event
 = (object) @Element
\*/

/*\
 * Element.dblclick
 [ method ]
 **
 * Adds event handler for double click for the element.
 > Parameters
 - handler (function) handler for the event
 = (object) @Element
\*/
/*\
 * Element.undblclick
 [ method ]
 **
 * Removes event handler for double click for the element.
 > Parameters
 - handler (function) handler for the event
 = (object) @Element
\*/

/*\
 * Element.mousedown
 [ method ]
 **
 * Adds event handler for mousedown for the element.
 > Parameters
 - handler (function) handler for the event
 = (object) @Element
\*/
/*\
 * Element.unmousedown
 [ method ]
 **
 * Removes event handler for mousedown for the element.
 > Parameters
 - handler (function) handler for the event
 = (object) @Element
\*/

/*\
 * Element.mousemove
 [ method ]
 **
 * Adds event handler for mousemove for the element.
 > Parameters
 - handler (function) handler for the event
 = (object) @Element
\*/
/*\
 * Element.unmousemove
 [ method ]
 **
 * Removes event handler for mousemove for the element.
 > Parameters
 - handler (function) handler for the event
 = (object) @Element
\*/

/*\
 * Element.mouseout
 [ method ]
 **
 * Adds event handler for mouseout for the element.
 > Parameters
 - handler (function) handler for the event
 = (object) @Element
\*/
/*\
 * Element.unmouseout
 [ method ]
 **
 * Removes event handler for mouseout for the element.
 > Parameters
 - handler (function) handler for the event
 = (object) @Element
\*/

/*\
 * Element.mouseover
 [ method ]
 **
 * Adds event handler for mouseover for the element.
 > Parameters
 - handler (function) handler for the event
 = (object) @Element
\*/
/*\
 * Element.unmouseover
 [ method ]
 **
 * Removes event handler for mouseover for the element.
 > Parameters
 - handler (function) handler for the event
 = (object) @Element
\*/

/*\
 * Element.mouseup
 [ method ]
 **
 * Adds event handler for mouseup for the element.
 > Parameters
 - handler (function) handler for the event
 = (object) @Element
\*/
/*\
 * Element.unmouseup
 [ method ]
 **
 * Removes event handler for mouseup for the element.
 > Parameters
 - handler (function) handler for the event
 = (object) @Element
\*/

/*\
 * Element.touchstart
 [ method ]
 **
 * Adds event handler for touchstart for the element.
 > Parameters
 - handler (function) handler for the event
 = (object) @Element
\*/
/*\
 * Element.untouchstart
 [ method ]
 **
 * Removes event handler for touchstart for the element.
 > Parameters
 - handler (function) handler for the event
 = (object) @Element
\*/

/*\
 * Element.touchmove
 [ method ]
 **
 * Adds event handler for touchmove for the element.
 > Parameters
 - handler (function) handler for the event
 = (object) @Element
\*/
/*\
 * Element.untouchmove
 [ method ]
 **
 * Removes event handler for touchmove for the element.
 > Parameters
 - handler (function) handler for the event
 = (object) @Element
\*/

/*\
 * Element.touchend
 [ method ]
 **
 * Adds event handler for touchend for the element.
 > Parameters
 - handler (function) handler for the event
 = (object) @Element
\*/
/*\
 * Element.untouchend
 [ method ]
 **
 * Removes event handler for touchend for the element.
 > Parameters
 - handler (function) handler for the event
 = (object) @Element
\*/

/*\
 * Element.touchcancel
 [ method ]
 **
 * Adds event handler for touchcancel for the element.
 > Parameters
 - handler (function) handler for the event
 = (object) @Element
\*/
/*\
 * Element.untouchcancel
 [ method ]
 **
 * Removes event handler for touchcancel for the element.
 > Parameters
 - handler (function) handler for the event
 = (object) @Element
\*/
for (var i = events.length; i--;) {
    (function (eventName) {
        R[eventName] = elproto[eventName] = function (fn, scope) {
            if (R.is(fn, "function")) {
                this.events = this.events || [];
                this.events.push({
                    name: eventName,
                    f: fn,
                    unbind: addEvent(this.shape || this.node || g.doc, eventName, fn, scope || this)
                });
            }
            return this;
        };
        R["un" + eventName] = elproto["un" + eventName] = function (fn) {
            var events = this.events || [],
                l = events.length;
            while (l--) {
                if (events[l].name == eventName && events[l].f == fn) {
                    events[l].unbind();
                    events.splice(l, 1);
                    !events.length && delete this.events;
                    return this;
                }
            }return this;
        };
    })(events[i]);
}

/*\
 * Element.data
 [ method ]
 **
 * Adds or retrieves given value asociated with given key.
 **
 * See also @Element.removeData
 > Parameters
 - key (string) key to store data
 - value (any) #optional value to store
 = (object) @Element
 * or, if value is not specified:
 = (any) value
 > Usage
 | for (var i = 0, i < 5, i++) {
 |     paper.circle(10 + 15 * i, 10, 10)
 |          .attr({fill: "#000"})
 |          .data("i", i)
 |          .click(function () {
 |             alert(this.data("i"));
 |          });
 | }
\*/
elproto.data = function (key, value) {
    var data = eldata[this.id] = eldata[this.id] || {};
    if (arguments.length == 1) {
        if (R.is(key, object)) {
            for (var i in key) {
                if (key[has](i)) {
                    this.data(i, key[i]);
                }
            }return this;
        }
        (0, _eve2["default"])("raphael.data.get." + this.id, this, data[key], key);
        return data[key];
    }
    data[key] = value;
    (0, _eve2["default"])("raphael.data.set." + this.id, this, value, key);
    return this;
};

/*\
 * Element.removeData
 [ method ]
 **
 * Removes value associated with an element by given key.
 * If key is not provided, removes all the data of the element.
 > Parameters
 - key (string) #optional key
 = (object) @Element
\*/
elproto.removeData = function (key) {
    if (key == null) {
        delete eldata[this.id];
    } else {
        eldata[this.id] && delete eldata[this.id][key];
    }
    return this;
};

/*\
* Element.getData
[ method ]
**
* Retrieves the element data
= (object) data
\*/
elproto.getData = function () {
    return clone(eldata[this.id] || {});
};

var downables = [],
    mouseDown = function mouseDown() {
    this.untrack = addEvent(g.doc, 'mouseup', mouseUp, this);
},
    mouseUp = function mouseUp() {
    this.untrack();
    this.untrack = null;
    return this.fn && this.fn.apply(this.scope || this.el, arguments);
};
elproto.mouseup = function (fn, scope, track) {
    if (!track) {
        return R.mouseup.apply(this, arguments);
    }
    downables.push(track = {
        el: this,
        fn: fn,
        scope: scope
    });
    track.unbind = addEvent(this.shape || this.node || g.doc, 'mousedown', mouseDown, track);

    return this;
};

elproto.unmouseup = function (fn) {
    var i = downables.length,
        undowned;
    while (i--) {
        if (downables[i].el === this && downables[i].fn === fn) {
            undowned = downables[i];
            undowned.unbind();
            undowned.untrack && undowned.untrack();
            downables.splice(i, 1);
        }
    }
    return undowned ? this : R.unmouseup.apply(this, arguments);
};

/*\
 * Element.hover
 [ method ]
 **
 * Adds event handlers for hover for the element.
 > Parameters
 - f_in (function) handler for hover in
 - f_out (function) handler for hover out
 - icontext (object) #optional context for hover in handler
 - ocontext (object) #optional context for hover out handler
 = (object) @Element
\*/
elproto.hover = function (f_in, f_out, scope_in, scope_out) {
    return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
};

/*\
 * Element.unhover
 [ method ]
 **
 * Removes event handlers for hover for the element.
 > Parameters
 - f_in (function) handler for hover in
 - f_out (function) handler for hover out
 = (object) @Element
\*/
elproto.unhover = function (f_in, f_out) {
    return this.unmouseover(f_in).unmouseout(f_out);
};
var draggable = [];

/*\
 * Element.drag
 [ method ]
 **
 * Adds event handlers for drag of the element.
 > Parameters
 - onmove (function) handler for moving
 - onstart (function) handler for drag start
 - onend (function) handler for drag end
 - mcontext (object) #optional context for moving handler
 - scontext (object) #optional context for drag start handler
 - econtext (object) #optional context for drag end handler
 * Additionaly following `drag` events will be triggered: `drag.start.<id>` on start,
 * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element will be dragged over another element
 * `drag.over.<id>` will be fired as well.
 *
 * Start event and start handler will be called in specified context or in context of the element with following parameters:
 o x (number) x position of the mouse
 o y (number) y position of the mouse
 o event (object) DOM event object
 * Move event and move handler will be called in specified context or in context of the element with following parameters:
 o dx (number) shift by x from the start point
 o dy (number) shift by y from the start point
 o x (number) x position of the mouse
 o y (number) y position of the mouse
 o event (object) DOM event object
 * End event and end handler will be called in specified context or in context of the element with following parameters:
 o event (object) DOM event object
 = (object) @Element
\*/
elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {
    function start(e) {
        var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
            scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
            key,
            dummyEve = {},
            data;

        this._drag.x = e.clientX + scrollX;
        this._drag.y = e.clientY + scrollY;
        this._drag.id = e.identifier;

        // Add the drag events for the browsers that doesn't fire mouse event on touch and drag
        if (supportsTouch && !supportsOnlyTouch) {
            !drag.length && R.dragmove(dragMove).dragend(dragUp);
        }
        !drag.length && R.mousemove(dragMove).mouseup(dragUp);

        drag = [{
            el: this,
            move_scope: move_scope,
            start_scope: start_scope,
            end_scope: end_scope
        }];
        for (key in e) {
            if (typeof e[key] === 'function') {
                dummyEve[key] = e[key].bind(e);
            } else {
                dummyEve[key] = e[key];
            }
        }
        data = dummyEve.data = [e.clientX + scrollX, e.clientY + scrollY];
        onstart && onstart.call(start_scope || move_scope || this, dummyEve, data);
        // onstart && eve.on("raphael.drag.start." + this.id, onstart);
        onmove && _eve2["default"].on("raphael.drag.move." + this.id, onmove);
        onend && _eve2["default"].on("raphael.drag.end." + this.id, onend);
        // onstart && eve("raphael.drag.start." + this.id, start_scope || move_scope || this, e.clientX + scrollX, e.clientY + scrollY, e);
    }
    this._drag = {};
    draggable.push({
        el: this,
        start: start,
        onstart: onstart,
        onmove: onmove,
        onend: onend
    });
    // Add the drag events for the browsers that doesn't fire mouse event on touch and drag
    if (supportsTouch && !supportsOnlyTouch) {
        this.dragstart(start);
    }
    this.mousedown(start);

    return this;
};

/*\
 * Element.onDragOver
 [ method ]
 **
 * Shortcut for assigning event handler for `drag.over.<id>` event, where id is id of the element (see @Element.id).
 > Parameters
 - f (function) handler for event, first argument would be the element you are dragging over
\*/
elproto.onDragOver = function (f) {
    f ? _eve2["default"].on("raphael.drag.over." + this.id, f) : _eve2["default"].unbind("raphael.drag.over." + this.id);
};

/*\
 * Element.undrag
 [ method ]
 **
 * Removes all drag event handlers from given element.
\*/
elproto.undrag = function () {
    var i = draggable.length;
    while (i--) {
        if (draggable[i].el == this) {
            this.unmousedown(draggable[i].start);
            draggable.splice(i, 1);
            _eve2["default"].unbind("raphael.drag.*." + this.id);
        }
    }

    !draggable.length && R.unmousemove(dragMove).unmouseup(dragUp);
    delete this._drag;
};

/*\
 * Element.undragmove
 [ method ]
 **
 * Removes all dragmove event handlers from given element.
\*/
elproto.undragmove = function () {
    var i = draggable.length;
    while (i--) {
        if (draggable[i].el == this && draggable[i].onmove) {
            this.unmousedown(draggable[i].start);
            draggable.splice(i, 1);
            _eve2["default"].unbind("raphael.drag.move." + this.id);
        }
    }

    !draggable.length && R.unmousemove(dragMove).unmouseup(dragUp);
};

/*\
 * Element.undragend
 [ method ]
 **
 * Removes all dragend event handlers from given element.
\*/
elproto.undragend = function () {
    var i = draggable.length;
    while (i--) {
        if (draggable[i].el == this && draggable[i].onend) {
            this.unmousedown(draggable[i].start);
            draggable.splice(i, 1);
            _eve2["default"].unbind("raphael.drag.end." + this.id);
        }
    }

    !draggable.length && R.unmousemove(dragMove).unmouseup(dragUp);
};

/*\
 * Element.undragstart
 [ method ]
 **
 * Removes all dragstart event handlers from given element.
\*/
elproto.undragstart = function () {
    var i = draggable.length;
    while (i--) {
        if (draggable[i].el == this && draggable[i].onstart) {
            this.unmousedown(draggable[i].start);
            draggable.splice(i, 1);
            _eve2["default"].unbind("raphael.drag.start." + this.id);
            this._dragstart = false;
        }
    }

    !draggable.length && R.unmousemove(dragMove).unmouseup(dragUp);
};

elproto.follow = function (el, callback, stalk) {
    if (el.removed || el.constructor !== R.el.constructor) {
        return this;
    }
    el.followers.push({
        el: this,
        stalk: stalk = { before: 'insertBefore', after: 'insertAfter' }[stalk],
        cb: callback
    });

    stalk && this[stalk](el);
    return this;
};

elproto.unfollow = function (el) {
    if (el.removed || el.constructor !== R.el.constructor) {
        return this;
    }
    for (var i = 0, ii = el.followers.length; i < ii; i++) {
        if (el.followers[i].el === this) {
            el.followers.splice(i, 1);
            break;
        }
    }
    return this;
};

/*\
 * Paper.hide
 [ method ]
 **
 * Hides a paper
 **
 > Usage
 | paper.hide();
\*/
paperproto.hide = function () {
    var paper = this;
    paper.canvas.style.visibility = "hidden";
    return paper;
};

/*\
 * Paper.show
 [ method ]
 **
 * Shows a hidden paper
 **
 > Usage
 | paper.show();
\*/
paperproto.show = function () {
    var paper = this;
    paper.canvas.style.visibility = E;
    return paper;
};

/*\
 * Paper.group
 [ method ]
 **
 * Creates a group
 **
 > Parameters
 **
 - id (number) id of the group
 = (object) Raphaël element object with type “group”
 **
 > Usage
 | var g = paper.group();
\*/
paperproto.group = function () {
    // id
    var paper = this,
        args = arguments,
        group = lastArgIfGroup(args, true),
        out = R._engine.group(paper, args[0], group);
    return paper.__set__ && paper.__set__.push(out), paper._elementsById[out.id] = out;
};

/*\
 * Paper.circle
 [ method ]
 **
 * Draws a circle.
 **
 > Parameters
 **
 - x (number) x coordinate of the centre
 - y (number) y coordinate of the centre
 - r (number) radius
 = (object) Raphaël element object with type “circle”
 **
 > Usage
 | var c = paper.circle(50, 50, 40);
\*/
paperproto.circle = function () {
    // x, y, r
    var paper = this,
        args = arguments,
        group = lastArgIfGroup(args, true),
        attrs = serializeArgs(args, "cx", 0, "cy", 0, "r", 0, "fill", none, "stroke", black),
        out = R._engine.circle(paper, attrs, group);

    return paper.__set__ && paper.__set__.push(out), paper._elementsById[out.id] = out;
};

/*\
 * Paper.rect
 [ method ]
 *
 * Draws a rectangle.
 **
 > Parameters
 **
 - x (number) x coordinate of the top left corner
 - y (number) y coordinate of the top left corner
 - width (number) width
 - height (number) height
 - r (number) #optional radius for rounded corners, default is 0
 = (object) Raphaël element object with type “rect”
 **
 > Usage
 | // regular rectangle
 | var c = paper.rect(10, 10, 50, 50);
 | // rectangle with rounded corners
 | var c = paper.rect(40, 40, 50, 50, 10);
\*/
paperproto.rect = function () {
    var paper = this,
        args = arguments,
        group = lastArgIfGroup(args, true),
        attrs = serializeArgs(args, "x", 0, "y", 0, "width", 0, "height", 0, "r", 0, "fill", none, "stroke", black),
        out = R._engine.rect(paper, attrs, group);

    return paper.__set__ && paper.__set__.push(out), paper._elementsById[out.id] = out;
};

/*\
 * Paper.ellipse
 [ method ]
 **
 * Draws an ellipse.
 **
 > Parameters
 **
 - x (number) x coordinate of the centre
 - y (number) y coordinate of the centre
 - rx (number) horizontal radius
 - ry (number) vertical radius
 = (object) Raphaël element object with type “ellipse”
 **
 > Usage
 | var c = paper.ellipse(50, 50, 40, 20);
\*/
paperproto.ellipse = function () {
    var paper = this,
        args = arguments,
        group = lastArgIfGroup(args, true),
        attrs = serializeArgs(args, "x", 0, "y", 0, "rx", 0, "ry", 0, "fill", none, "stroke", black),
        out = R._engine.ellipse(this, attrs, group);

    return paper.__set__ && paper.__set__.push(out), paper._elementsById[out.id] = out;
};

/*\
 * Paper.path
 [ method ]
 **
 * Creates a path element by given path data string.
 > Parameters
 - pathString (string) #optional path string in SVG format.
 * Path string consists of one-letter commands, followed by comma seprarated arguments in numercal form. Example:
 | "M10,20L30,40"
 * Here we can see two commands: “M”, with arguments `(10, 20)` and “L” with arguments `(30, 40)`. Upper case letter mean command is absolute, lower case—relative.
 *
 # <p>Here is short list of commands available, for more details see <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a path's data attribute's format are described in the SVG specification.">SVG path string format</a>.</p>
 # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>
 # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>
 # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>
 # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>
 # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>
 # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>
 # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>
 # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>
 # <tr><td>Q</td><td>quadratic Bézier curveto</td><td>(x1 y1 x y)+</td></tr>
 # <tr><td>T</td><td>smooth quadratic Bézier curveto</td><td>(x y)+</td></tr>
 # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>
 # <tr><td>R</td><td><a href="http://en.wikipedia.org/wiki/Catmull–Rom_spline#Catmull.E2.80.93Rom_spline">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>
 * * “Catmull-Rom curveto” is a not standard SVG command and added in 2.0 to make life easier.
 * Note: there is a special case when path consist of just three commands: “M10,10R…z”. In this case path will smoothly connects to its beginning.
 > Usage
 | var c = paper.path("M10 10L90 90");
 | // draw a diagonal line:
 | // move to 10,10, line to 90,90
 * For example of path strings, check out these icons: http://raphaeljs.com/icons/
\*/
paperproto.path = function () {
    var paper = this,
        args = arguments,
        group = lastArgIfGroup(args, true),
        paperConfig = paper.config,
        capStyle = paperConfig && paperConfig["stroke-linecap"] || "butt",
        attrs = serializeArgs(args, "path", E, "fill", none, "stroke", black, "stroke-linecap", capStyle),
        out = R._engine.path(paper, attrs, group);
    return paper.__set__ && paper.__set__.push(out), paper._elementsById[out.id] = out;
};

/*\
 * Paper.image
 [ method ]
 **
 * Embeds an image into the surface.
 **
 > Parameters
 **
 - src (string) URI of the source image
 - x (number) x coordinate position
 - y (number) y coordinate position
 - width (number) width of the image
 - height (number) height of the image
 = (object) Raphaël element object with type “image”
 **
 > Usage
 | var c = paper.image("apple.png", 10, 10, 80, 80);
\*/
paperproto.image = function () {
    var paper = this,
        args = arguments,
        group = lastArgIfGroup(args, true),
        attrs = serializeArgs(args, "src", "", "x", 0, "y", 0, "width", 0, "height", 0),
        out = R._engine.image(paper, attrs, group);
    return paper.__set__ && paper.__set__.push(out), paper._elementsById[out.id] = out;
};

/*\
 * Paper.text
 [ method ]
 **
 * Draws a text string. If you need line breaks, put “\n” in the string.
 **
 > Parameters
 **
 - x (number) x coordinate position
 - y (number) y coordinate position
 - text (string) The text string to draw
 = (object) Raphaël element object with type “text”
 **
 > Usage
 | var t = paper.text(50, 50, "Raphaël\nkicks\nbutt!");
\*/
paperproto.text = function () {
    var paper = this,
        args = arguments,
        group = lastArgIfGroup(args, true),
        attrs = serializeArgs(args, "x", 0, "y", 0, "text", E, "stroke", none, "fill", black, "text-anchor", "middle", "vertical-align", "middle"),
        out = R._engine.text(paper, attrs, group, args[1]);
    return paper.__set__ && paper.__set__.push(out), paper._elementsById[out.id] = out;
};

/*\
 * Paper.set
 [ method ]
 **
 * Creates array-like object to keep and operate several elements at once.
 * Warning: it doesn’t create any elements for itself in the page, it just groups existing elements.
 * Sets act as pseudo elements — all methods available to an element can be used on a set.
 = (object) array-like object that represents set of elements
 **
 > Usage
 | var st = paper.set();
 | st.push(
 |     paper.circle(10, 10, 5),
 |     paper.circle(30, 10, 5)
 | );
 | st.attr({fill: "red"}); // changes the fill of both circles
\*/
paperproto.set = function (itemsArray) {
    !R.is(itemsArray, "array") && (itemsArray = arraySplice.call(arguments, 0, arguments.length));
    var out = new Set(itemsArray);
    this.__set__ && this.__set__.push(out);
    return out;
};

/*\
 * Paper.setConfig
 [ method ]
 **
 * If you need to store any configuration in paper, call this method
 **
 > Parameters
 **
 - key (String) key name of the key-value pair
 - value (String or number) value of the key-value pair
\*/
paperproto.setConfig = function (key, value) {
    var paper = this;

    if (key !== undefined && value !== undefined) {

        paper.config = paper.config || {};
        paper.config[key] = value;
    }
    return paper.config;
};

/*\
 * Paper.setStart
 [ method ]
 **
 * Creates @Paper.set. All elements that will be created after calling this method and before calling
 * @Paper.setFinish will be added to the set.
 **
 > Usage
 | paper.setStart();
 | paper.circle(10, 10, 5),
 | paper.circle(30, 10, 5)
 | var st = paper.setFinish();
 | st.attr({fill: "red"}); // changes the fill of both circles
\*/
paperproto.setStart = function (set) {
    this.__set__ = set || this.set();
};

/*\
 * Paper.setFinish
 [ method ]
 **
 * See @Paper.setStart. This method finishes catching and returns resulting set.
 **
 = (object) set
\*/
paperproto.setFinish = function (set) {
    var out = this.__set__;
    delete this.__set__;
    return out;
};

/*\
 * Paper.setSize
 [ method ]
 **
 * If you need to change dimensions of the canvas call this method
 **
 > Parameters
 **
 - width (number) new width of the canvas
 - height (number) new height of the canvas
\*/
paperproto.setSize = function (width, height) {
    return R._engine.setSize.call(this, width, height);
};

/*\
 * paper.setDimension
 [ method ]
 **
 * If you need to change dimensions of the canvas call this method
 **
 > Parameters
 **
 - paramsObj (Object or number)
    - paramsObj (Object)
    **
    > Properties of paramsObj
    - width (number) new width of the canvas
    - height (number) new height of the canvas
    **
    - paramsObj (number) new width of the canvas
    **
 - height (number) new height of the canvas
\*/
paperproto.setDimension = function (paramsObj, height) {
    var paper = this,
        width;
    // Check if the first argument is an object or not
    if ((typeof paramsObj === "undefined" ? "undefined" : _typeof(paramsObj)) === 'object') {
        width = paramsObj.width;
        height = paramsObj.height;
        paper.setSize(paramsObj.width, paramsObj.height);
    } else {
        width = paramsObj;
        paper.setSize(width, height);
    }
};

paperproto.attr = function (name) {
    var element = this;
    if (name == null) {
        return {
            width: element.width,
            height: element.height
        };
    }
    if (R.is(name, "string")) {
        return element[name];
    }

    element.setDimension(name);
    return element;
};

paperproto.status = function (anim, value) {
    return elproto.status.call(this, anim, value);
};

// Works exactly as paper.animateWith()
paperproto.animateWith = function (el, anim, params, ms, easing, callback, configObject) {
    return elproto.animateWith.call(this, el, anim, params, ms, easing, callback, configObject);
};

/*\
 * Paper.animate
 [ method ]
 **
 * If you need to animate dimensions of the canvas call this method
 **
 > Parameters
 **
 - paramsObj (Object)
    > Properties of paramsObj
    **
    - width (number) new width of the canvas
    - height (number) new height of the canvas
 - duration (number) time stretch in milliseconds to complete animation
 - effect (String) animation style
 - callback (function reference) method which will execute at end of animation
\*/
paperproto.animate = function (params, ms, easing, callback) {
    return elproto.animate.call(this, params, ms, easing, callback);
};

/*\
 * Paper.setViewBox
 [ method ]
 **
 * Sets the view box of the paper. Practically it gives you ability to zoom and pan whole paper surface by
 * specifying new boundaries.
 **
 > Parameters
 **
 - x (number) new x position, default is `0`
 - y (number) new y position, default is `0`
 - w (number) new width of the canvas
 - h (number) new height of the canvas
 - fit (boolean) `true` if you want graphics to fit into new boundary box
\*/
paperproto.setViewBox = function (x, y, w, h, fit) {
    return R._engine.setViewBox.call(this, x, y, w, h, fit);
};

/*\
 * Paper.top
 [ property ]
 **
 * Points to the topmost element on the paper
\*/
/*\
 * Paper.bottom
 [ property ]
 **
 * Points to the bottom element on the paper
\*/
paperproto.top = paperproto.bottom = null;

/*\
 * Paper.raphael
 [ property ]
 **
 * Points to the @Raphael object/function
\*/
paperproto.raphael = R;

var getOffset = function getOffset(elem) {
    var box = elem.getBoundingClientRect(),
        doc = elem.ownerDocument,
        body = doc.body,
        docElem = doc.documentElement,
        clientTop = docElem.clientTop || body.clientTop || 0,
        clientLeft = docElem.clientLeft || body.clientLeft || 0,
        top = box.top + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop) - clientTop,
        left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;
    return {
        y: top,
        x: left
    };
};

/*\
 * Paper.getElementByPoint
 [ method ]
 **
 * Returns you topmost element under given point.
 **
 = (object) Raphaël element object
 > Parameters
 **
 - x (number) x coordinate from the top left corner of the window
 - y (number) y coordinate from the top left corner of the window
 > Usage
 | paper.getElementByPoint(mouseX, mouseY).attr({stroke: "#f00"});
\*/
paperproto.getElementByPoint = function (x, y) {
    var paper = this,
        svg = paper.canvas,
        target = g.doc.elementFromPoint(x, y);
    if (g.win.opera && target.tagName == "svg") {
        var so = getOffset(svg),
            sr = svg.createSVGRect();
        sr.x = x - so.x;
        sr.y = y - so.y;
        sr.width = sr.height = 1;
        var hits = svg.getIntersectionList(sr, null);
        if (hits.length) {
            target = hits[hits.length - 1];
        }
    }
    if (!target) {
        return null;
    }
    while (target.parentNode && target != svg.parentNode && !target.raphael) {
        target = target.parentNode;
    }
    target == paper.canvas.parentNode && (target = svg);
    target = target && target.raphael ? paper.getById(target.raphaelid) : null;
    return target;
};

/*\
 * Paper.getElementsByBBox
 [ method ]
 **
 * Returns set of elements that have an intersecting bounding box
 **
 > Parameters
 **
 - bbox (object) bbox to check with
 = (object) @Set
 \*/
paperproto.getElementsByBBox = function (bbox) {
    var set = this.set();
    this.forEach(function (el) {
        if (R.isBBoxIntersect(el.getBBox(), bbox)) {
            set.push(el);
        }
    });
    return set;
};

paperproto.getById = function (id) {
    return this._elementsById[id] || null;
};

/*\
 * Paper.forEach
 [ method ]
 **
 * Executes given function for each element on the paper
 *
 * If callback function returns `false` it will stop loop running.
 **
 > Parameters
 **
 - callback (function) function to run
 - thisArg (object) context object for the callback
 = (object) Paper object
 > Usage
 | paper.forEach(function (el) {
 |     el.attr({ stroke: "blue" });
 | });
\*/
paperproto.forEach = function (callback, thisArg) {
    var bot = this.bottom;
    while (bot) {
        if (callback.call(thisArg, bot) === false) {
            return this;
        }
        bot = bot.next;
    }
    return this;
};

/*\
 * Paper.getElementsByPoint
 [ method ]
 **
 * Returns set of elements that have common point inside
 **
 > Parameters
 **
 - x (number) x coordinate of the point
 - y (number) y coordinate of the point
 = (object) @Set
\*/
paperproto.getElementsByPoint = function (x, y) {
    var set = this.set();
    this.forEach(function (el) {
        if (el.isPointInside(x, y)) {
            set.push(el);
        }
    });
    return set;
};
function x_y() {
    return this.x + S + this.y;
};
function x_y_w_h() {
    return this.x + S + this.y + S + this.width + " \xd7 " + this.height;
};

/*\
 * Element.isPointInside
 [ method ]
 **
 * Determine if given point is inside this element’s shape
 **
 > Parameters
 **
 - x (number) x coordinate of the point
 - y (number) y coordinate of the point
 = (boolean) `true` if point inside the shape
\*/
elproto.isPointInside = function (x, y) {
    var rp = this.realPath = this.realPath || getPath[this.type](this),
        tr;
    return R.isPointInsidePath((tr = this.attr('transform')) && tr.length && R.transformPath(rp, tr) || rp, x, y);
};

/*\
 * Element.getBBox
 [ method ]
 **
 * Return bounding box for a given element
 **
 > Parameters
 **
 - isWithoutTransform (boolean) flag, `true` if you want to have bounding box before transformations. Default is `false`.
 = (object) Bounding box object:
 o {
 o     x: (number) top left corner x
 o     y: (number) top left corner y
 o     x2: (number) bottom right corner x
 o     y2: (number) bottom right corner y
 o     width: (number) width
 o     height: (number) height
 o }
\*/
elproto.getBBox = function (isWithoutTransform) {
    if (this.removed) {
        return {};
    }
    var _ = this._;
    if (isWithoutTransform) {
        if (_.dirty || !_.bboxwt) {
            this.realPath = getPath[this.type](this);
            _.bboxwt = pathDimensions(this.realPath);
            _.bboxwt.toString = x_y_w_h;
            _.dirty = 0;
        }
        return _.bboxwt;
    }
    if (_.dirty || _.dirtyT || !_.bbox) {
        if (_.dirty || !this.realPath) {
            _.bboxwt = 0;
            this.realPath = getPath[this.type](this);
        }
        _.bbox = pathDimensions(mapPath(this.realPath, this.matrix));
        _.bbox.toString = x_y_w_h;
        _.dirty = _.dirtyT = 0;
    }
    return _.bbox;
};

/*\
 * Element.clone
 [ method ]
 **
 = (object) clone of a given element
 **
\*/
elproto.clone = function () {
    if (this.removed) {
        return null;
    }
    var o = this,
        out = o.paper[o.type]().attr(o.attr());
    o.__set__ && o.__set__.push(out);
    return out;
};

/*\
 * Element.glow
 [ method ]
 **
 * Return set of elements that create glow-like effect around given element. See @Paper.set.
 *
 * Note: Glow is not connected to the element. If you change element attributes it won’t adjust itself.
 **
 > Parameters
 **
 - glow (object) #optional parameters object with all properties optional:
 o {
 o     width (number) size of the glow, default is `10`
 o     fill (boolean) will it be filled, default is `false`
 o     opacity (number) opacity, default is `0.5`
 o     offsetx (number) horizontal offset, default is `0`
 o     offsety (number) vertical offset, default is `0`
 o     color (string) glow colour, default is `black`
 o }
 = (object) @Paper.set of elements that represents glow
\*/
elproto.glow = function (glow) {
    if (this.type == "text") {
        return null;
    }
    glow = glow || {};
    var s = {
        width: (glow.width || 10) + (+this.attr("stroke-width") || 1),
        fill: glow.fill || false,
        opacity: glow.opacity || .5,
        offsetx: glow.offsetx || 0,
        offsety: glow.offsety || 0,
        color: glow.color || "#000"
    },
        c = s.width / 2,
        r = this.paper,
        out = r.set(),
        path = this.realPath || getPath[this.type](this);
    path = this.matrix ? mapPath(path, this.matrix) : path;
    for (var i = 1; i < c + 1; i++) {
        out.push(r.path(path).attr({
            stroke: s.color,
            fill: s.fill ? s.color : "none",
            "stroke-linejoin": "round",
            "stroke-linecap": "round",
            "stroke-width": +(s.width / c * i).toFixed(3),
            opacity: +(s.opacity / c).toFixed(3)
        }));
    }
    return out.insertBefore(this).translate(s.offsetx, s.offsety);
};
var curveslengths = {},
    getPointAtSegmentLength = function getPointAtSegmentLength(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
    if (length == null) {
        return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
    } else {
        return R.findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, getTatLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));
    }
},
    getLengthFactory = function getLengthFactory(istotal, subpath) {
    return function (path, length, onlystart) {
        path = path2curve(path);
        var x,
            y,
            p,
            l,
            sp = "",
            subpaths = {},
            point,
            len = 0;
        for (var i = 0, ii = path.length; i < ii; i++) {
            p = path[i];
            if (p[0] == "M") {
                x = +p[1];
                y = +p[2];
            } else {
                l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                if (len + l > length) {
                    if (subpath && !subpaths.start) {
                        point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                        sp += ["C" + point.start.x, point.start.y, point.m.x, point.m.y, point.x, point.y];
                        if (onlystart) {
                            return sp;
                        }
                        subpaths.start = sp;
                        sp = ["M" + point.x, point.y + "C" + point.n.x, point.n.y, point.end.x, point.end.y, p[5], p[6]].join();
                        len += l;
                        x = +p[5];
                        y = +p[6];
                        continue;
                    }
                    if (!istotal && !subpath) {
                        point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                        return {
                            x: point.x,
                            y: point.y,
                            alpha: point.alpha
                        };
                    }
                }
                len += l;
                x = +p[5];
                y = +p[6];
            }
            sp += p.shift() + p;
        }
        subpaths.end = sp;
        point = istotal ? len : subpath ? subpaths : R.findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);
        point.alpha && (point = {
            x: point.x,
            y: point.y,
            alpha: point.alpha
        });
        return point;
    };
},
    getTotalLength = getLengthFactory(1),
    getPointAtLength = getLengthFactory(),
    getSubpathsAtLength = getLengthFactory(0, 1);

R.getTotalLength = getTotalLength;

R.getPointAtLength = getPointAtLength;

R.getSubpath = function (path, from, to) {
    if (this.getTotalLength(path) - to < 1e-6) {
        return getSubpathsAtLength(path, from).end;
    }
    var a = getSubpathsAtLength(path, to, 1);
    return from ? getSubpathsAtLength(a, from).end : a;
};

/*\
 * Raphael.getTotalLength
 [ method ]
 **
 * Returns length of the given path in pixels.
 **
 > Parameters
 **
 - path (string) SVG path string.
 **
 = (number) length.
\*/
elproto.getTotalLength = function () {
    if (this.type != "path") {
        return;
    }
    if (this.node.getTotalLength) {
        return this.node.getTotalLength();
    }
    return getTotalLength(this.attrs.path);
};

/*\
 * Raphael.getPointAtLength
 [ method ]
 **
 * Return coordinates of the point located at the given length on the given path.
 **
 > Parameters
 **
 - path (string) SVG path string
 - length (number)
 **
 = (object) representation of the point:
 o {
 o     x: (number) x coordinate
 o     y: (number) y coordinate
 o     alpha: (number) angle of derivative
 o }
\*/
elproto.getPointAtLength = function (length) {
    if (this.type != "path") {
        return;
    }
    return getPointAtLength(this.attrs.path, length);
};

/*\
 * Raphael.getSubpath
 [ method ]
 **
 * Return subpath of a given path from given length to given length.
 **
 > Parameters
 **
 - path (string) SVG path string
 - from (number) position of the start of the segment
 - to (number) position of the end of the segment
 **
 = (string) pathstring for the segment
\*/
elproto.getSubpath = function (from, to) {
    if (this.type != "path") {
        return;
    }
    return R.getSubpath(this.attrs.path, from, to);
};

/*\
 * Raphael.easing_formulas
 [ property ]
 **
 * Object that contains easing formulas for animation. You could extend it with your own. By default it has following list of easing:
 # <ul>
 #     <li>“linear”</li>
 #     <li>“&lt;” or “easeIn” or “ease-in”</li>
 #     <li>“>” or “easeOut” or “ease-out”</li>
 #     <li>“&lt;>” or “easeInOut” or “ease-in-out”</li>
 #     <li>“backIn” or “back-in”</li>
 #     <li>“backOut” or “back-out”</li>
 #     <li>“elastic”</li>
 #     <li>“bounce”</li>
 # </ul>
 # <p>See also <a href="http://raphaeljs.com/easing.html">Easing demo</a>.</p>
\*/
var ef = R.easing_formulas = {
    linear: function linear(n) {
        return n;
    },
    "<": function _(n) {
        return pow(n, 1.7);
    },
    ">": function _(n) {
        return pow(n, .48);
    },
    "<>": function _(n) {
        var q = .48 - n / 1.04,
            Q = mathSqrt(.1734 + q * q),
            x = Q - q,
            X = pow(abs(x), 1 / 3) * (x < 0 ? -1 : 1),
            y = -Q - q,
            Y = pow(abs(y), 1 / 3) * (y < 0 ? -1 : 1),
            t = X + Y + .5;
        return (1 - t) * 3 * t * t + t * t * t;
    },
    backIn: function backIn(n) {
        var s = 1.70158;
        return n * n * ((s + 1) * n - s);
    },
    backOut: function backOut(n) {
        n = n - 1;
        var s = 1.70158;
        return n * n * ((s + 1) * n + s) + 1;
    },
    elastic: function elastic(n) {
        if (n == !!n) {
            return n;
        }
        return pow(2, -10 * n) * mathSin((n - .075) * (2 * PI) / .3) + 1;
    },
    bounce: function bounce(n) {
        var s = 7.5625,
            p = 2.75,
            l;
        if (n < 1 / p) {
            l = s * n * n;
        } else {
            if (n < 2 / p) {
                n -= 1.5 / p;
                l = s * n * n + .75;
            } else {
                if (n < 2.5 / p) {
                    n -= 2.25 / p;
                    l = s * n * n + .9375;
                } else {
                    n -= 2.625 / p;
                    l = s * n * n + .984375;
                }
            }
        }
        return l;
    },
    // used in line chart anchor animation
    oneBounceOut: function oneBounceOut(n) {
        var top = 120;
        if (n <= 0.9) {
            return ef.easeIn(n) * 1.33;
        }
        return 1.2 - n / 5;
    },
    // Used in translating bubble plots
    elasticOnce: function elasticOnce(n) {
        var p = 0.9;
        if (n == !!n) {
            return n;
        }
        return Math.pow(2, -10 * n) * Math.sin((n - p / 4) * (2 * Math.PI) / p) + 1;
    },
    // accelerating from zero velocity
    easeInQuad: function easeInQuad(t) {
        return t * t;
    },
    // decelerating to zero velocity
    easeOutQuad: function easeOutQuad(t) {
        return t * (2 - t);
    },
    // acceleration until halfway, then deceleration
    easeInOutQuad: function easeInOutQuad(t) {
        return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    },
    // accelerating from zero velocity
    easeInCubic: function easeInCubic(t) {
        return t * t * t;
    },
    // decelerating to zero velocity
    easeOutCubic: function easeOutCubic(t) {
        return --t * t * t + 1;
    },
    // acceleration until halfway, then deceleration
    easeInOutCubic: function easeInOutCubic(t) {
        return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
    },
    // accelerating from zero velocity
    easeInQuart: function easeInQuart(t) {
        return t * t * t * t;
    },
    // decelerating to zero velocity
    easeOutQuart: function easeOutQuart(t) {
        return 1 - --t * t * t * t;
    },
    // acceleration until halfway, then deceleration
    easeInOutQuart: function easeInOutQuart(t) {
        return t < .5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
    },
    // accelerating from zero velocity
    easeInQuint: function easeInQuint(t) {
        return t * t * t * t * t;
    },
    // decelerating to zero velocity
    easeOutQuint: function easeOutQuint(t) {
        return 1 + --t * t * t * t * t;
    },
    // acceleration until halfway, then deceleration
    easeInOutQuint: function easeInOutQuint(t) {
        return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
    }
};
ef.easeIn = ef["ease-in"] = ef["<"];
ef.easeOut = ef["ease-out"] = ef[">"];
ef.easeInOut = ef["ease-in-out"] = ef["<>"];
ef["back-in"] = ef.backIn;
ef["back-out"] = ef.backOut;

var animationElements = [],
    requestAnimFrame,

// This a temporary fix so that animation can be handled from the scheduler module.
animation = function animation() {
    var Now = +new Date(),
        l = 0,
        deqArr = [],
        i = 0,
        ll = 0,
        tmpOpacity,
        radial,
        animFrameFn;

    for (; l < animationElements.length; l++) {
        var e = animationElements[l];
        if (e.el.removed || e.paused || e.parentEl && e.parentEl.e && e.parentEl.e.paused) {
            continue;
        }
        var time = Now - e.start,
            ms = e.ms,
            easing = e.easing,
            from = e.from,
            diff = e.diff,
            to = e.to,
            t = e.t,
            that = e.el,
            set = {},
            now,
            origms,
            init = {},
            executeEvent = R.stopEvent !== false,
            key,
            i = 0,
            peekVal = e.el && e.el.animElements && e.el.animElements.peek();
        // Checking hooks
        while (peekVal && peekVal.pos <= time / ms) {
            deqArr.push(e.el.animElements.deq());
            peekVal = e.el.animElements.peek();
        }
        if (e.initstatus) {
            time = (e.initstatus * e.anim.top - e.prev) / (e.percent - e.prev) * ms;
            e.status = e.initstatus;
            delete e.initstatus;
            if (e.stop) {
                delete e.el;
                animationElements.splice(l--, 1);
            }
        } else {
            e.status = (e.prev + (e.percent - e.prev) * (time / ms)) / e.anim.top;
        }
        origms = ms;
        // If has parentEl
        if (e.parentEl && e.parentEl.animElements) {
            ms = e.delayend - e.delaystart;
            time = e.parentEl.cPos - e.delaystart;
        } else if (e.el.animElements) {
            e.el.cPos = time / ms;
        }
        if (time < 0) {
            continue;
        }
        if (time < ms) {
            var pos = easing(time / ms);
            ms = origms;
            for (var attr in from) {
                if (from[has](attr)) {
                    switch (availableAnimAttrs[attr]) {
                        case nu:
                            now = +from[attr] + pos * ms * diff[attr];
                            break;
                        case "colour":
                            if (!diff[attr].length) {
                                tmpOpacity = from[attr].opacity + pos * ms * diff[attr].opacity;
                                if (isNaN(tmpOpacity)) {
                                    tmpOpacity = 1;
                                }
                                now = "rgba(" + [upto255(round(from[attr].r + pos * ms * diff[attr].r)), upto255(round(from[attr].g + pos * ms * diff[attr].g)), upto255(round(from[attr].b + pos * ms * diff[attr].b)), tmpOpacity].join(",") + ")";
                            } else {
                                now = [];
                                for (i = 0, ii = from[attr].length; i < ii; ++i) {
                                    if (i === 0) {
                                        if (from[attr].isRadial || diff[attr].isRadial) {
                                            radial = "xr(";
                                            radial += from[attr][0].f1 * (1 - pos) + diff[attr][0].f1 * pos || '';
                                            radial += ',';
                                            radial += from[attr][0].f2 * (1 - pos) + diff[attr][0].f2 * pos || '';
                                            radial += ',';
                                            radial += (from[attr][0].f3 * (1 - pos) + diff[attr][0].f3 * pos) * 100 || '';
                                            radial += '%,';
                                            radial += from[attr][0].f4 * (1 - pos) + diff[attr][0].f4 * pos || '';
                                            radial += ',';
                                            radial += from[attr][0].f5 * (1 - pos) + diff[attr][0].f5 * pos;
                                            radial += ',';
                                            radial += from[attr][0].f6;
                                            radial += ')';
                                            now.push(radial);
                                        } else {
                                            now.push(from[attr][i] * (1 - pos) + pos * diff[attr][i]);
                                            if (now[0] <= 0) {
                                                now[0] += 360;
                                            }
                                        }
                                    } else {
                                        now.push("rgba(" + [upto255(round(from[attr][i].r + pos * ms * diff[attr][i].r)), upto255(round(from[attr][i].g + pos * ms * diff[attr][i].g)), upto255(round(from[attr][i].b + pos * ms * diff[attr][i].b)), from[attr][i].opacity + pos * ms * diff[attr][i].opacity].join(",") + "):" + from[attr][i].position);
                                    }
                                }
                                now = now.join("-");
                                // If radial focus doesnt have a separator
                                if (from[attr].isRadial || diff[attr].isRadial) {
                                    now = now.replace('-', '');
                                }
                            }
                            break;
                        case "path":
                            now = [];
                            for (var i = 0, ii = from[attr].length; i < ii; i++) {
                                now[i] = [from[attr][i][0]];
                                var jj;
                                jj = from[attr][i] ? from[attr][i].length : 0;
                                for (var j = 1; j < jj; j++) {
                                    now[i][j] = (+from[attr][i][j] + pos * ms * diff[attr][i][j]).toFixed(4);
                                }
                                now[i] = now[i].join(S);
                            }
                            now = now.join(S);
                            break;
                        case "transform":
                            if (diff[attr].real) {
                                now = [];
                                for (i = 0, ii = from[attr].length; i < ii; i++) {
                                    now[i] = [from[attr][i][0]];
                                    for (j = 1, jj = from[attr][i].length; j < jj; j++) {
                                        now[i][j] = from[attr][i][j] + pos * ms * diff[attr][i][j];
                                    }
                                }
                            } else {
                                var get = function get(i) {
                                    return +from[attr][i] + pos * ms * diff[attr][i];
                                };
                                // now = [["r", get(2), 0, 0], ["t", get(3), get(4)], ["s", get(0), get(1), 0, 0]];
                                now = [["m", get(0), get(1), get(2), get(3), get(4), get(5)]];
                            }
                            break;
                        case "csv":
                            if (attr == "clip-rect") {
                                now = [];
                                i = 4;
                                while (i--) {
                                    now[i] = +from[attr][i] + pos * ms * diff[attr][i];
                                }
                            }
                            break;
                        default:
                            var from2 = [][concat](from[attr]);
                            now = [];
                            i = that.ca[attr].length;
                            while (i--) {
                                now[i] = +from2[i] + pos * ms * diff[attr][i];
                            }
                            break;
                    }
                    set[attr] = now;
                }
            }that.attr(set);
            if (executeEvent) {
                (function (id, that, anim) {
                    setTimeout(function () {
                        (0, _eve2["default"])("raphael.anim.frame." + id, that, anim);
                    });
                })(that.id, that, e.anim);
            }
        } else {
            (function (f, el, a) {
                setTimeout(function () {
                    executeEvent && (0, _eve2["default"])("raphael.anim.frame." + el.id, el, a);
                    executeEvent && (0, _eve2["default"])("raphael.anim.finish." + el.id, el, a);
                    R.is(f, "function") && f.call(el);
                });
            })(e.callback, that, e.anim);

            that.attr(to);
            delete e.el;
            animationElements.splice(l--, 1);
            if (e.repeat > 1 && !e.next) {
                for (key in to) {
                    if (to[has](key)) {
                        init[key] = e.totalOrigin[key];
                    }
                }e.el.attr(init);
                runAnimation(e.anim, e.el, e.anim.percents[0], null, e.totalOrigin, e.repeat - 1);
            }
            if (e.next && !e.stop) {
                runAnimation(e.anim, e.el, e.next, null, e.totalOrigin, e.repeat);
            }
        }
    }
    R.svg && that && that.paper && that.paper.safari();

    // Starting animation on timer 0
    for (l = 0, ll = deqArr.length; l < ll; ++l) {
        // lib.schedular.addJob((function (l) {
        //     return function ()  {
        //         runAnimation.apply(null, deqArr[l].params);
        //     };
        // })(l), lib.priorityList.instant);
        animFrameFn = R.getInstantAnimFrameFn();
        animFrameFn(function (l) {
            return function () {
                runAnimation.apply(null, deqArr[l].params);
            };
        }(l));
    }

    animationElements.length && (requestAnimFrame || R.getAnimFrameFn())(animation);
},
    upto255 = function upto255(color) {
    return color > 255 ? 255 : color < 0 ? 0 : color;
},
    checkPercentage = function checkPercentage(num) {
    num > 1 && (num = 1);
    num < 0 && (num = 0);
    return num;
};

R.getAnimFrameFn = function () {
    return requestAnimFrame = R.requestAnimFrame || _win.webkitRequestAnimationFrame || _win.mozRequestAnimationFrame || _win.oRequestAnimationFrame || _win.msRequestAnimationFrame || function (callback) {
        setTimeout(callback, 16);
    };
};

R.getInstantAnimFrameFn = function () {
    return R.instantRequestAnimFrame || _win.webkitRequestAnimationFrame || _win.mozRequestAnimationFrame || _win.oRequestAnimationFrame || _win.msRequestAnimationFrame || function (callback) {
        setTimeout(callback, 16);
    };
};

/*\
 * Element.animateWith
 [ method ]
 **
 * Acts similar to @Element.animate, but ensure that given animation runs in sync with another given element.
 **
 > Parameters
 **
 - el (object) element to sync with
 - anim (object) animation to sync with
 - params (object) #optional final attributes for the element, see also @Element.attr
 - ms (number) #optional number of milliseconds for animation to run
 - easing (string) #optional easing type. Accept on of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
 - callback (function) #optional callback function. Will be called at the end of animation.
 - configObject (object) #optional takes an object with optional properties like
    start(what percentage to start aniation), end(what percentage to end animation), hookFn(function
    to be called before applying animation), smartMorph(whether to use smartMorphing in path animation)
 * or
 - element (object) element to sync with
 - anim (object) animation to sync with
 - animation (object) #optional animation object, see @Raphael.animation
 **
 = (object) original element
\*/
elproto.animateWith = function (el, anim, params, ms, easing, callback, configObject) {
    var element = this,
        refOb = {},
        key;
    // Copying the reference object
    configObject = configObject || {};
    for (key in configObject) {
        if (configObject.hasOwnProperty(key)) {
            refOb[key] = configObject[key];
        }
    }
    configObject = refOb;
    if (element.removed) {
        callback && callback.call(element);
        return element;
    }
    if (ms == 0) {
        if (R.is(callback, "function")) {
            setTimeout(function () {
                callback.call(element);
            }, 0);
        }
        return element.attr(params);
    }
    var a = params instanceof Animation ? params : R.animation(params, ms, easing, callback),
        x,
        y;

    configObject.start = checkPercentage(configObject.start || 0);
    configObject.end = checkPercentage(configObject.end || 1);
    if (configObject.start >= configObject.end) {
        configObject.start = configObject.end;
    }

    if (!configObject.from && configObject.start > 0.01) {
        // Initializing new Priority Queue if not present already
        el.animElements = el.animElements || new PriorityQueue(function comparator(a, b) {
            return b.pos - a.pos;
        });
        el.animElements.enq({
            pos: configObject.start,
            attr: configObject.start === configObject.end,
            params: [a, element, a.percents[0], null, element.attr(), undefined, el, {
                start: configObject.start,
                end: configObject.end,
                smartMorph: configObject.smartMorph,
                hookFn: configObject.hookFn
            }, params],
            executeOb: {
                el: this,
                attrs: params,
                callback: callback,
                hookFn: configObject.hookFn
            }
        });
    } else {
        runAnimation(a, element, a.percents[0], null, element.attr(), undefined, el, configObject);
    }
    for (var i = 0, ii = animationElements.length; i < ii; i++) {
        if (animationElements[i].anim == anim && animationElements[i].el == el) {
            animationElements[ii - 1].start = animationElements[i].start;
            break;
        }
    }
    return element;
    // var a = params ? R.animation(params, ms, easing, callback) : anim,
    //     status = element.status(anim);
    // return this.animate(a).status(a, status * anim.ms / a.ms);
};
function CubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {
    var cx = 3 * p1x,
        bx = 3 * (p2x - p1x) - cx,
        ax = 1 - cx - bx,
        cy = 3 * p1y,
        by = 3 * (p2y - p1y) - cy,
        ay = 1 - cy - by;
    function sampleCurveX(t) {
        return ((ax * t + bx) * t + cx) * t;
    }
    function solve(x, epsilon) {
        var t = solveCurveX(x, epsilon);
        return ((ay * t + by) * t + cy) * t;
    }
    function solveCurveX(x, epsilon) {
        var t0, t1, t2, x2, d2, i;
        for (t2 = x, i = 0; i < 8; i++) {
            x2 = sampleCurveX(t2) - x;
            if (abs(x2) < epsilon) {
                return t2;
            }
            d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;
            if (abs(d2) < 1e-6) {
                break;
            }
            t2 = t2 - x2 / d2;
        }
        t0 = 0;
        t1 = 1;
        t2 = x;
        if (t2 < t0) {
            return t0;
        }
        if (t2 > t1) {
            return t1;
        }
        while (t0 < t1) {
            x2 = sampleCurveX(t2);
            if (abs(x2 - x) < epsilon) {
                return t2;
            }
            if (x > x2) {
                t0 = t2;
            } else {
                t1 = t2;
            }
            t2 = (t1 - t0) / 2 + t0;
        }
        return t2;
    }
    return solve(t, 1 / (200 * duration));
}
elproto.onAnimation = function (f) {
    f ? _eve2["default"].on("raphael.anim.frame." + this.id, f) : _eve2["default"].unbind("raphael.anim.frame." + this.id);
    return this;
};
function Animation(anim, ms) {
    var percents = [],
        newAnim = {};
    this.ms = ms;
    this.times = 1;
    if (anim) {
        for (var attr in anim) {
            if (anim[has](attr)) {
                newAnim[toFloat(attr)] = anim[attr];
                percents.push(toFloat(attr));
            }
        }percents.sort(sortByNumber);
    }
    this.anim = newAnim;
    this.top = percents[percents.length - 1];
    this.percents = percents;
}

/*\
 * Animation.delay
 [ method ]
 **
 * Creates a copy of existing animation object with given delay.
 **
 > Parameters
 **
 - delay (number) number of ms to pass between animation start and actual animation
 **
 = (object) new altered Animation object
 | var anim = Raphael.animation({cx: 10, cy: 20}, 2e3);
 | circle1.animate(anim); // run the given animation immediately
 | circle2.animate(anim.delay(500)); // run the given animation after 500 ms
\*/
Animation.prototype.delay = function (delay) {
    var a = new Animation(this.anim, this.ms);
    a.times = this.times;
    a.del = +delay || 0;
    return a;
};

/*\
 * Animation.repeat
 [ method ]
 **
 * Creates a copy of existing animation object with given repetition.
 **
 > Parameters
 **
 - repeat (number) number iterations of animation. For infinite animation pass `Infinity`
 **
 = (object) new altered Animation object
\*/
Animation.prototype.repeat = function (times) {
    var a = new Animation(this.anim, this.ms);
    a.del = this.del;
    a.times = math.floor(mmax(times, 0)) || 1;
    return a;
};

/*
** Function to convert two color string in array format such that
** it is animatabale
** @param {string} c1 color 1
** @param {string} c2 color 2
** @param {function} function to getRGB
*/
function colorNormalizer(c1, c2, getRGB) {
    "use strict";

    var colorAr1 = c1.split('-'),
        colorAr2 = c2.split('-'),
        i = 0,
        ii = 0,
        j = 0,
        newColArr = [],
        newColArr2 = [],
        temp = {},
        pos = 0,
        uniqArr = [];
    if (colorAr1.length === 1 && colorAr2.length === 1) {
        return [c1, c2];
    }
    // Convert colors to linear format, and mark if any of them is radial
    // linear to radial animation is not correct
    colorAr1 = allToLinear(colorAr1);
    colorAr2 = allToLinear(colorAr2);

    // Handling if default color was added to one
    // and not other
    if (!colorAr1.defaultAngleSet && colorAr2.defaultAngleSet) {
        colorAr2[0] = colorAr1[0];
    }

    if (!colorAr2.defaultAngleSet && colorAr1.defaultAngleSet) {
        colorAr1[0] = colorAr2[0];
    }

    // If one is radial convert both to radial
    converToRadialIfOneRadial(colorAr1, colorAr2);
    /* Making a unique array to store all unique
        color positions of both color so that new color
        can be generated that have same amount of positions
        added */
    for (i = 1, ii = colorAr1.length; i < ii; ++i) {
        pos = colorAr1[i].position;
        // if(uniqArr.indexOf(pos) === -1){
        uniqArr.push(pos);
        // }
    }
    for (i = 1, ii = colorAr2.length; i < ii; ++i) {
        pos = colorAr2[i].position;
        if (uniqArr.indexOf(pos) === -1) {
            uniqArr.push(pos);
        }
    }
    uniqArr.push(0);
    // sort the positions
    uniqArr.sort(function (a, b) {
        return a - b;
    });
    // generating new colors from the existing colors
    newColArr = [colorAr1[0]];
    for (i = 1, ii = uniqArr.length; i < ii; ++i) {
        pos = uniqArr[i];
        temp = colorAr1.getColorAtPosition(pos);
        newColArr.push(temp);
    }
    newColArr2 = [colorAr2[0]];
    for (i = 1, ii = uniqArr.length; i < ii; ++i) {
        pos = uniqArr[i];
        temp = colorAr2.getColorAtPosition(pos);
        newColArr2.push(temp);
    }

    // copying isRadial property
    newColArr.isRadial = colorAr1.isRadial;
    newColArr2.isRadial = colorAr2.isRadial;
    return [newColArr, newColArr2];
    // Getting all unique points

    function converToRadialIfOneRadial(a, b, end) {
        var angle = 0;
        if (a.isRadial && !b.isRadial) {
            angle += +b[0];
            b[0] = {
                f1: 0,
                f2: 0,
                f3: 0,
                f4: 0,
                f5: 0,
                f6: ''
            };
            b.isRadial = true;
        }

        if (!end) {
            converToRadialIfOneRadial(b, a, true);
        }
    }
    // Function to convert color to array in linear format
    // and mark if any one of them is radial
    function allToLinear(arr) {
        var i = 0,
            ii = 0,
            j = 0,
            item = {},
            temp = [],
            temp2 = {},
            key,
            prevVal = 0,
            lastVal = 0,
            counter = 0,
            rPos = 0,
            openBrPos = 0,
            closedBrPos = 0,
            radial = {
            f1: 0.5,
            f2: 0.5
        };

        // Solid color operation
        if (arr.length === 1) {
            if (arr[0] === "none") {
                arr[0] = "rgba(0,0,0,0)";
            }
            // Push angle zero to start
            arr.unshift(0);
            // Mentioning that a default angle was added
            arr.defaultAngleSet = true;
        }

        // Convert angle to number
        if (isNaN(arr[0])) {
            // Check if is radial
            if (~"rx".indexOf(arr[0].charAt(0))) {
                arr.isRadial = true;

                rPos = 1;
                // check if focus if provided
                // otherwise use default focus
                if (arr[0].indexOf(')') !== -1) {
                    rPos = arr[0].indexOf(')');
                    openBrPos = arr[0].indexOf('(') + 1;
                    closedBrPos = rPos;
                    temp = arr[0].substr(openBrPos, closedBrPos - openBrPos).split(',');
                    radial.f1 = parseFloat(temp[0]) || 0;
                    radial.f2 = parseFloat(temp[1]) || 0;
                    if (~temp[2].indexOf('%')) {
                        temp[2] = parseFloat(temp[2]) / 100;
                    }
                    radial.f3 = parseFloat(temp[2]) || 0;
                    radial.f4 = parseFloat(temp[3]) || 0;
                    radial.f5 = parseFloat(temp[4]) || 0;
                    radial.f6 = temp[5];
                }
                arr[0] = arr[0].substr(closedBrPos + 1);
                arr.unshift(radial);
            } else {
                arr[0] = 0;
            }
        } else {
            arr[0] = +arr[0];
        }

        for (i = 1, ii = arr.length; i < ii; ++i) {
            temp = arr[i].split(":");
            // conver first element to rgb object and store
            temp2 = getRGB(temp[0]);
            arr[i] = {};
            arr[i].r = temp2.r;
            arr[i].g = temp2.g;
            arr[i].b = temp2.b;
            arr[i].opacity = temp2.opacity;
            // if opacity not present set  to 1
            arr[i].opacity = +arr[i].opacity;
            if (isNaN(arr[i].opacity)) {
                arr[i].opacity = 1;
            }
            // set the position
            arr[i].position = +temp[1];
        }

        // Sorting array according to position
        // angle and radial focus should be elemnt 0
        arr.sort(function (a, b) {
            if (typeof a === "number" || a.f1) {
                return -1;
            }
            if (typeof b === "number" || a.f2) {
                return 1;
            }
            if (isNaN(a.position) && isNaN(b.position)) {
                return 0;
            }
            if (isNaN(a.position)) {
                return -1;
            }
            if (isNaN(b.position)) {
                return 1;
            }
            return a.position - b.position;
        });

        // If first position is not zero
        // add new color with position zero
        if (+arr[1].position !== 0) {
            if (isNaN(arr[1].position)) {
                arr[1].position = 0;
            } else {
                temp2 = {};
                for (key in arr[1]) {
                    temp2[key] = arr[1][key];
                }
                temp2.position = 0;
                // Shifting array to add current object
                // in position 1
                arr.push({});
                for (i = arr.length - 1; i !== 1; --i) {
                    arr[i] = arr[i - 1];
                }
                arr[1] = temp2;
            }
        }
        // index to last position
        ii = arr.length - 1;
        // If last position is not 100
        // add new color with position 100
        if (arr[ii].position !== 100) {
            if (isNaN(arr[ii].position)) {
                arr[ii].position = 100;
            } else {
                temp2 = {};
                for (key in arr[ii]) {
                    temp2[key] = arr[ii][key];
                }
                temp2.position = 100;
                // Shifting array to add current object
                // in position 1
                arr.push(temp2);
            }
        }

        // Filling correct position value whereever NaN found
        for (i = 2, ii = arr.length; i < ii; ++i) {
            if (!arr[i].position) {
                prevVal = arr[i - 1].position;
                counter = 1;
                for (j = i + 1; j < ii; ++j) {
                    ++counter;
                    if (!isNaN(arr[j].position)) {
                        lastVal = +arr[j].position;
                        break;
                    }
                }
                arr[i].position = prevVal + (lastVal - prevVal) / counter;
            }
        }

        arr.getColorAtPosition = function (pos) {
            var prevPos = -1,
                nextPos = this.length,
                i = 1,
                ii = this.length,
                item = {},
                colPrev,
                colNext,
                ratio = 0,
                key = "",
                col = { r: 0, g: 0, b: 0 };

            // Critical section; check again
            for (; i < ii - 1; ++i) {
                if (this[i].position <= pos) {
                    prevPos = i;
                    nextPos = i + 1;
                }
                if (!(this[i].position < pos) && this[i].position >= pos) {
                    nextPos = i;
                    break;
                }
            }
            ratio = (pos - this[prevPos].position) / (this[nextPos].position - this[prevPos].position);
            if (isNaN(ratio)) {
                ratio = 0;
            }
            for (key in col) {
                col[key] = upto255((1 - ratio) * this[prevPos][key] + ratio * this[nextPos][key]);
            }
            col.position = pos;
            col.opacity = (1 - ratio) * this[prevPos]["opacity"] + ratio * this[nextPos]["opacity"];
            return col;
        };
        return arr;
    }
}
/**
 * Function to make to uncommon path array to a equal length
 * of path array and same type (L - lineto) to make it animatable
 * @param {array} path array 1
 * @param {array} path array 2
 * @return {object} object containing final 'from' and 'to' path
 */
function pathNormalizer(p1, p2) {
    'use strict';
    // Function to convert array to svg path (?) only for curves

    var finalp1 = [],
        finalp2 = [],
        pathArr1 = toSvgPath(p1),
        pathArr2 = toSvgPath(p2),
        i = 0,
        ii = 0,
        temp,
        createElementNS = document.createElementNS && document.createElementNS.bind(document),
        dPath = createElementNS && createElementNS("http://www.w3.org/2000/svg", "path");

    // If path invalid or svg not supported return
    if (!pathArr1 || !pathArr2 || !dPath) {
        return [p1, p2];
    }
    if (canFallback(p1, p2)) {
        return [p1, p2];
    }
    // If any of the parameters is
    // absent return to normal flow
    if (!p1 || !p2) {
        return [p1, p2];
    }
    // If svg not available return to normal flow
    if (!document.createElementNS) {
        return [p1, p2];
    }
    // Setting path again
    pathArr1 = toSvgPath(p1);
    pathArr2 = toSvgPath(p2);
    // If invalid path return the original path
    if (pathArr1.join().indexOf('undefined') !== -1) {
        return [p1, p2];
    }
    if (pathArr2.join().indexOf('undefined') !== -1) {
        return [p1, p2];
    }
    // If svg functions not available return to normal flow
    if (!dPath.getTotalLength || !dPath.getPointAtLength) {
        return [p1, p2];
    }
    /* Function to check if the current environment
    ** can animate the path, as pathNormalizer pauses
    ** getTotalLength and getPointAtLength function of svg
    ** which are not supported by all browsers
    */
    function canFallback(path1, path2) {
        var str1 = '',
            str2 = '',
            testLen,
            testPoint;
        // Checking path totoalLength is accurate or not
        // testing with a known path
        // this check is for Firefox
        dPath.setAttribute('d', 'M300 10 L300 300 C50 310,50 640,350 650' + 'C600 640,600 310,400 300 L400 10 L295 10');
        testLen = dPath.getTotalLength();
        testPoint = dPath.getPointAtLength(10);
        if (testLen < 1829.1 || testLen > 1829.2) {
            return true;
        }
        if (Math.round(testPoint.x) !== 300 || Math.round(testPoint.y) !== 20) {
            return true;
        }
        // path1 and path2 are in array
        function trimPathArray(arr) {
            var i = arr.length;
            while (i-- - 1) {
                if (arr[i].join('') === arr[i - 1].join('')) {
                    arr.pop();
                } else {
                    break;
                }
            }
        }
        function getPathFromArray(arr) {
            var str = '',
                i = 0,
                ii = arr.length;
            for (; i < ii; ++i) {
                str += arr[i].join(' ');
            }
            return str;
        }
        trimPathArray(path1);
        trimPathArray(path2);
        str1 = getPathFromArray(path1);
        str2 = getPathFromArray(path2);
        if (str1.split(/[Mm]/).length > 2 || str2.split(/[Mm]/).length > 2) {
            return false;
        }
        if (path1.length === path2.length) {
            return true;
        }
        return false;
    }
    /* Convert svg path array to string,
        Also removes repeated commands */
    function toSvgPath(arr) {
        var str = [],
            i = 0,
            ii = arr.length,
            item = [];
        if (typeof arr === 'string') {
            return arr;
        }
        // Converting the array to string; path type
        for (i = 0; i < ii; ++i) {
            if (!arr[i].join) {
                return;
            } else {
                // Removing continuous Move commands
                // Picking up the last one
                if (!i || !arr[i + 1] || arr[i + 1][0] !== 'M' || arr[i][0] !== 'M') {
                    str.push(arr[i].join(' '));
                }
            }
        }
        str = str.join('');
        str = str.split(/[Mm]/).slice(1);
        for (i = 0, ii = str.length; i < ii; ++i) {
            str[i] = 'M' + str[i];
        }
        return str;
    }

    ii = Math.max(pathArr1.length, pathArr2.length);
    for (i = 0; i < ii; ++i) {
        temp = _pathNormalizer(pathArr1[i], pathArr2[i]);
        pathArr1[i] = temp[0];
        pathArr2[i] = temp[1];
    }
    // Convert line path 2 dimensional array to string
    function linetopath(arr) {
        var i = 0,
            ii = 0,
            str = [];
        arr = arr || [];
        ii = arr.length;
        for (i = 0; i < ii; ++i) {
            if (arr[i].length - 1) {
                str.push(arr[i].join(' '));
            }
        }
        return str.join('');
    }
    /* path2curve appends repeated last path command,
        this function removes it or any other repeated path command */
    function removeBlanks(arr, pos) {
        var i = arr.length,
            j = 0,
            path;
        while (i-- - 1) {
            // Pop if length is zero
            if (arr[i].slice(1).toString() === arr[i - 1].slice(1).toString()) {
                arr.pop();
            } else {
                break;
            }
        }
        if (arr.length === 1 && pos) {
            arr.length = 0;
        }
    }
    /* Divide a path array to number to a given number of times
        as provided in parameters, All path array should start with M command */
    function _divide(arr, times) {
        var resArr = [],
            locArr = [],
            arrLen = arr.length,
            i = 0,
            ii = 0,
            x = 0,
            prevPos = 0,
            y = 0,

        // If array size is smaller than
        // divisions needed
        diffTimes = times - arrLen;
        while (diffTimes >= 0) {
            i = arr.length - 1;
            arr.push(arr.slice(i)[0]);
            --diffTimes;
        }
        arrLen = arr.length;
        for (i = 0; i <= times; ++i) {
            locArr.push(Math.round(i / times * arrLen));
        }
        for (i = 0, ii = locArr.length - 1; i < ii; ++i) {
            resArr.push(arr.slice(locArr[i], locArr[i + 1]));
            if (resArr[i][0][0] !== 'M' && resArr[i][0][0] !== 'm') {
                prevPos = resArr[i - 1].length - 1;
                x = resArr[i - 1][prevPos][1];
                y = resArr[i - 1][prevPos][2];
                resArr[i].unshift(['M', x, y]);
            }
        }
        return resArr;
    }
    /* If two path array have different number of MoveTo commands,
        divide the smaller number of MoveTo command holder to match the other one */
    function divideArray(diff) {
        var arrToDivide = [],
            countArr = [],
            transArr = [],
            i = 0,
            ii = 0,
            isArr1 = true;
        if (diff === 0) {
            return;
        } else if (diff > 0) {
            arrToDivide = pathArr2;
            isArr1 = false;
        } else {
            diff = -diff;
            arrToDivide = pathArr1;
        }
        // Maintaining a count array to judge number of times a1
        // path needs to be divided, 1 means dont divide
        for (i = 0, ii = arrToDivide.length; i < ii; ++i) {
            countArr.push(1);
        }
        while (diff--) {
            --i;
            if (i < 0) {
                i = ii - 1;
            }
            countArr[i]++;
        }

        for (i = 0; i < ii; ++i) {
            if (countArr[i] === 1) {
                transArr.push(arrToDivide[i]);
            } else {
                transArr.push.apply(transArr, _divide(arrToDivide[i], countArr[i]));
            }
        }
        if (isArr1) {
            pathArr1 = transArr;
        } else {
            pathArr2 = transArr;
        }
    }
    for (i = pathArr1.length; i--;) {
        removeBlanks(pathArr1[i], i);
        // If last element is blank pop it
        pathArr1[i].length || pathArr1.pop();
    }
    for (i = pathArr2.length; i--;) {
        removeBlanks(pathArr2[i], i);
        pathArr2[i].length || pathArr2.pop();
    }
    // Making number off moveto commands equal in both path
    divideArray(pathArr1.length - pathArr2.length);

    ii = Math.max(pathArr1.length, pathArr2.length);
    for (i = 0; i < ii; ++i) {
        temp = _pathNormalizer(linetopath(pathArr1[i]), linetopath(pathArr2[i]));
        pathArr1[i] = temp[0];
        pathArr2[i] = temp[1];
    }

    for (i = 0, ii = pathArr1.length; i < ii; ++i) {
        finalp1 = finalp1.concat(pathArr1[i]);
    }
    for (i = 0, ii = pathArr2.length; i < ii; ++i) {
        finalp2 = finalp2.concat(pathArr2[i]);
    }
    return [finalp1, finalp2];
}

// A function to calculate common path
// in two given paths
function commonPathCalculator(p1, p2) {
    'use strict';

    var i = 0,
        j = 0,
        ii = 0,
        jj = 0,
        k = 0,
        kk = 0,
        uncommon1 = 0,
        uncommon2 = 0,
        lim1 = 0,
        lim2 = 0,
        nearestPoint1,
        nearestPoint2,
        map1 = {},
        map2 = {},
        groupedPath1 = [],
        groupedPath2 = [],
        gpIndex1 = -1,
        gpIndex2 = -1,
        isSame = true;
    // Splitting the string commands to get
    // particular points later
    // Will be required while breaking paths
    // into common and uncommon parts
    function splitter(path) {
        var i = 0,
            ii = 0;
        path = path.split(/[MCLmcl]/).slice(1);
        for (i = 0, ii = path.length; i < ii; ++i) {
            path[i] = path[i].split(' ').slice(1);
            i || path[i].unshift('M');
            if (i) {
                path[i].length === 2 && path[i].unshift('L') || path[i].unshift('C');
            }
        }
        return path;
    }
    // populate the arr to object in reverse manner
    // i.e value to key mapping
    function mapper(arr, ob) {
        var i = 0,
            ii = arr.length,
            val,
            item;
        for (i = 0, ii = arr.length; i < ii; ++i) {
            val = arr[i].join(' ');
            item = arr[i];
            if (item[0] === 'C' && item[3] === item[5] && item[4] === item[6]) {
                arr[i].stringValue = ['L', item[3], item[4]].join(' ');
            } else item.stringValue = val;
            // Creating an array if undefined
            // pushing otherwise
            ob[item.stringValue] && ob[item.stringValue].push(i);
            ob[item.stringValue] || (ob[item.stringValue] = [i]);
        }
    }
    // Function to get nearest point that exist
    // in the other array
    function getNearestExistingPoint(arr, map, start, ii, lim) {
        var i = start,
            k = 0,
            kk = 0,
            item;
        for (; i < ii; ++i) {
            item = map[arr[i].stringValue];
            if (item) {
                for (k = 0, kk = item.length; k < kk; ++k) {
                    if (item[k] >= lim) {
                        return {
                            index: i,
                            mapValue: item[k],
                            diff: i - start
                        };
                    }
                }
            }
        }
        return -1;
    }
    // function to get last coordinate for CurveTo command
    function getCoordinateAsMove(arr) {
        var last = arr.length - 1;
        return ['M', arr[last - 1], arr[last]].join(' ');
    }
    // function to conver path array to string
    function pathToString(arr) {
        return arr.join('');
    }
    // commonPathCalculator flow here
    p1 = splitter(p1);
    p2 = splitter(p2);
    mapper(p1, map1);
    mapper(p2, map2);
    // Setting length
    ii = p1.length;
    jj = p2.length;
    i = 0;
    j = 0;
    // Making partitions for common
    // and uncommon parts
    // Checking if first is common or uncommon
    while (i < ii && j < jj) {
        ++gpIndex1;
        ++gpIndex2;
        // initializing blank arrays
        groupedPath1[gpIndex1] = [];
        groupedPath2[gpIndex2] = [];
        isSame = p1[i].stringValue === p2[j].stringValue;
        if (i) {
            // Logic to push prev coordinate as move command
            groupedPath1[gpIndex1].push(getCoordinateAsMove(p1[i - 1]));
            groupedPath2[gpIndex2].push(getCoordinateAsMove(p2[j - 1]));
        }
        if (isSame) {
            while (i < ii && j < jj && p1[i].stringValue === p2[j].stringValue) {
                groupedPath1[gpIndex1].push(p1[i].stringValue);
                groupedPath2[gpIndex2].push(p2[j].stringValue);
                ++i;
                ++j;
            }
        } else {
            nearestPoint1 = getNearestExistingPoint(p1, map2, i, ii, j);
            nearestPoint2 = getNearestExistingPoint(p2, map1, j, jj, i);
            // Assuming nearestPoint1 is nearer than nearestPoint2
            lim1 = nearestPoint1.index;
            lim2 = nearestPoint1.mapValue;
            // If nearestPoint2 is nearer
            if (!~nearestPoint1 || nearestPoint1.diff > nearestPoint2.diff) {
                lim1 = nearestPoint2.mapValue;
                lim2 = nearestPoint2.index;
            }
            if (!~nearestPoint1 && !~nearestPoint2) {
                // If both not found include all as uncommon
                lim1 = ii - 1;
                lim2 = jj - 1;
            }
            // Pushing uncommon paths
            while (i <= lim1) {
                groupedPath1[gpIndex1].push(p1[i].stringValue);
                ++i;
            }
            while (j <= lim2) {
                groupedPath2[gpIndex2].push(p2[j].stringValue);
                ++j;
            }
        }
        groupedPath1[gpIndex1] = pathToString(groupedPath1[gpIndex1]);
        groupedPath2[gpIndex2] = pathToString(groupedPath2[gpIndex2]);
    }
    // If Any one is left add them all
    if (i < ii) {
        ++gpIndex1;
        groupedPath1[gpIndex1] = [];
        groupedPath1[gpIndex1].push(getCoordinateAsMove(p1[i - 1]));
        ++gpIndex2;
        groupedPath2[gpIndex2] = [];
        groupedPath2[gpIndex2].push(getCoordinateAsMove(p2[j - 1]));
        while (i < ii) {
            groupedPath1[gpIndex1].push(p1[i].stringValue);
            ++i;
        }
        groupedPath1[gpIndex1] = pathToString(groupedPath1[gpIndex1]);
    }
    if (j < jj) {
        ++gpIndex1;
        groupedPath1[gpIndex1] = [];
        groupedPath1[gpIndex1].push(getCoordinateAsMove(p1[i - 1]));
        ++gpIndex2;
        groupedPath2[gpIndex2] = [];
        groupedPath2[gpIndex2].push(getCoordinateAsMove(p2[j - 1]));
        while (j < jj) {
            groupedPath2[gpIndex2].push(p2[j].stringValue);
            ++j;
        }
        groupedPath2[gpIndex2] = pathToString(groupedPath2[gpIndex2]);
    }
    return [groupedPath1, groupedPath2];
}

// function to get equal points for two different path
// We set path to an dynamically created svg path node
// and get equal number of path commands from two different
// paths. Uses getPointAtLength and getTotalLength of svg that
// arent supported on every browser
function _pathNormalizer(p1, p2) {
    'use strict';

    var i = 0,
        j = 0,
        ii = 0,
        jj = 0,
        item = {},
        fPath1 = [],
        fPath2 = [],
        divisions = 0,
        commonPath,
        tmp;
    // Uncommon path normalizer
    function normalizeUncommonPaths(p1, p2) {
        var dPath1,
            dPath2,
            i = 0,
            j = 0,
            item = {},
            pathLen1 = 0,
            pathLen2 = 0,
            fPath1 = [],
            fPath2 = [],
            divisions = 0,
            round = Math.round;
        // Creating path elements to use functions 'getTotalLength'
        // and 'getPointAtLength'
        dPath1 = document.createElementNS("http://www.w3.org/2000/svg", "path");
        dPath1.setAttribute("d", p1);

        dPath2 = document.createElementNS("http://www.w3.org/2000/svg", "path");
        dPath2.setAttribute("d", p2);

        // Getting length of the paths
        pathLen1 = dPath1.getTotalLength();
        pathLen2 = dPath2.getTotalLength();

        // Number of divisions will depend on larger path
        divisions = 0.15 * Math.max(pathLen1, pathLen2);
        divisions = Math.ceil(divisions);

        if (!divisions || !isFinite(divisions) || divisions < 10) {
            divisions = 10;
        }

        for (i = 0; i <= divisions; ++i) {
            item = dPath1.getPointAtLength(i / divisions * pathLen1);
            fPath1.push([i ? "L" : "M", round(item.x), round(item.y)]);
            item = dPath2.getPointAtLength(i / divisions * pathLen2);
            fPath2.push([i ? "L" : "M", round(item.x), round(item.y)]);
        }
        return [fPath1, fPath2];
    }
    if (!p1 || p1 === 'M  ') {
        p1 = p2.split(' ').slice(0, 3).join(' ').replace(/[LC]/, '');
    }
    if (!p2 || p2 === 'M  ') {
        p2 = p1.split(' ').slice(0, 3).join(' ').replace(/[LC]/, '');
    }
    commonPath = commonPathCalculator(p1, p2);

    for (i = 0, ii = commonPath[0].length; i < ii; ++i) {
        tmp = normalizeUncommonPaths(commonPath[0][i], commonPath[1][i]);
        if (i) {
            fPath1 = fPath1.concat(tmp[0].slice(1));
            fPath2 = fPath2.concat(tmp[1].slice(1));
        } else {
            fPath1 = fPath1.concat(tmp[0]);
            fPath2 = fPath2.concat(tmp[1]);
        }
    }
    return [fPath1, fPath2];
}

function runAnimation(anim, element, percent, status, totalOrigin, times, parentEl, configObject) {
    percent = toFloat(percent);
    var params,
        isInAnim,
        isInAnimSet,
        percents = [],
        next,
        prev,
        temp,
        timestamp,
        tempDiff,
        change,
        ms = anim.ms,
        from = {},
        to = {},
        diff = {};

    if (element.type === null) {
        return;
    }

    configObject = configObject || {};
    configObject.hookFn && configObject.hookFn.call(element);
    configObject.from = configObject.from || {};
    if (status) {
        for (i = 0, ii = animationElements.length; i < ii; i++) {
            var e = animationElements[i];
            if (e.el.id == element.id && e.anim == anim) {
                if (e.percent != percent) {
                    delete e.el.e;
                    delete e.el;
                    animationElements.splice(i, 1);
                    isInAnimSet = 1;
                } else {
                    isInAnim = e;
                }
                element.attr(e.totalOrigin);
                break;
            }
        }
    } else {
        status = +to; // NaN
    }
    for (var i = 0, ii = anim.percents.length; i < ii; i++) {
        if (anim.percents[i] == percent || anim.percents[i] > status * anim.top) {
            percent = anim.percents[i];
            prev = anim.percents[i - 1] || 0;
            ms = ms / anim.top * (percent - prev);
            next = anim.percents[i + 1];
            params = anim.anim[percent];
            break;
        } else if (status) {
            element.attr(anim.anim[anim.percents[i]]);
        }
    }
    if (!params) {
        return;
    }
    if (!isInAnim) {
        for (var attr in params) {
            if (params[has](attr)) {
                if (availableAnimAttrs[has](attr) || element.ca[attr]) {
                    from[attr] = configObject.from[attr] || element.attr(attr);
                    from[attr] == null && (from[attr] = availableAttrs[attr]);
                    to[attr] = params[attr];
                    change = false;
                    switch (availableAnimAttrs[attr]) {
                        case nu:
                            tempDiff = to[attr] - from[attr];
                            (tempDiff || isNaN(tempDiff)) && (change = true);
                            diff[attr] = tempDiff / ms;
                            break;
                        case "colour":
                            if (from[attr] === to[attr]) {
                                break;
                            } else {
                                change = true;
                            }
                            var colorsNormalized = colorNormalizer(from[attr], to[attr], R.getRGB);
                            from[attr] = colorsNormalized[0];
                            var toColour = colorsNormalized[1];
                            if (typeof toColour === "string") {
                                if (from[attr].toLowerCase() !== "none") {
                                    from[attr] = R.getRGB(from[attr]);
                                    if (!from[attr].opacity) {
                                        from[attr].opacity = 1;
                                    }
                                } else {
                                    from[attr] = {
                                        r: 0,
                                        g: 0,
                                        b: 0,
                                        opacity: 0
                                    };
                                }
                                if (to[attr].toLowerCase() !== "none") {
                                    toColour = R.getRGB(to[attr]);
                                    if (!toColour.opacity) {
                                        toColour.opacity = 1;
                                    }
                                } else {
                                    toColour = {
                                        r: 0,
                                        g: 0,
                                        b: 0,
                                        opacity: 0
                                    };
                                }
                                diff[attr] = {
                                    r: (toColour.r - from[attr].r) / ms,
                                    g: (toColour.g - from[attr].g) / ms,
                                    b: (toColour.b - from[attr].b) / ms,
                                    opacity: (toColour.opacity - from[attr].opacity) / ms
                                };
                            } else {
                                diff[attr] = [];
                                for (i = 0, ii = from[attr].length; i < ii; ++i) {
                                    if (i === 0) {
                                        diff[attr].push(toColour[0]);
                                    } else {
                                        diff[attr].push({
                                            r: (toColour[i].r - from[attr][i].r) / ms,
                                            g: (toColour[i].g - from[attr][i].g) / ms,
                                            b: (toColour[i].b - from[attr][i].b) / ms,
                                            opacity: (toColour[i].opacity - from[attr][i].opacity) / ms
                                        });
                                    }
                                }
                            }
                            break;
                        case "path":
                            var toPath,
                                pathes = path2curve(from[attr], to[attr]);
                            if (configObject.smartMorph) {
                                pathes = pathNormalizer(pathes[0], pathes[1], configObject);
                            }
                            toPath = pathes[1];
                            from[attr] = pathes[0];
                            diff[attr] = [];
                            for (i = 0, ii = from[attr].length; i < ii; i++) {
                                diff[attr][i] = [0];
                                var jj;
                                jj = from[attr][i] ? from[attr][i].length : 0;
                                for (var j = 1; j < jj; j++) {
                                    diff[attr][i][j] = (toPath[i][j] - from[attr][i][j]) / ms;
                                    !change && diff[attr][i][j] && (change = true);
                                }
                            }
                            break;
                        case "transform":
                            var _ = element._,
                                eq = equaliseTransform(_[attr], to[attr]);
                            change = true;
                            if (eq) {
                                from[attr] = eq.from;
                                to[attr] = eq.to;
                                diff[attr] = [];
                                diff[attr].real = true;
                                for (i = 0, ii = from[attr].length; i < ii; i++) {
                                    diff[attr][i] = [from[attr][i][0]];
                                    for (j = 1, jj = from[attr][i].length; j < jj; j++) {
                                        diff[attr][i][j] = (to[attr][i][j] - from[attr][i][j]) / ms;
                                    }
                                }
                            } else {
                                var m = element.matrix || new Matrix(),
                                    to2 = {
                                    _: {
                                        transform: _.transform
                                    },
                                    getBBox: function getBBox() {
                                        return element.getBBox(1);
                                    }
                                };
                                from[attr] = [m.a, m.b, m.c, m.d, m.e, m.f];
                                extractTransform(to2, to[attr]);
                                to[attr] = to2._.transform;
                                diff[attr] = [(to2.matrix.a - m.a) / ms, (to2.matrix.b - m.b) / ms, (to2.matrix.c - m.c) / ms, (to2.matrix.d - m.d) / ms, (to2.matrix.e - m.e) / ms, (to2.matrix.f - m.f) / ms];
                                // from[attr] = [_.sx, _.sy, _.deg, _.dx, _.dy];
                                // var to2 = {_:{}, getBBox: function () { return element.getBBox(); }};
                                // extractTransform(to2, to[attr]);
                                // diff[attr] = [
                                //     (to2._.sx - _.sx) / ms,
                                //     (to2._.sy - _.sy) / ms,
                                //     (to2._.deg - _.deg) / ms,
                                //     (to2._.dx - _.dx) / ms,
                                //     (to2._.dy - _.dy) / ms
                                // ];
                            }
                            break;
                        case "csv":
                            var values = Str(params[attr])[split](separator),
                                from2 = Str(from[attr])[split](separator);
                            if (attr == "clip-rect") {
                                from[attr] = from2;
                                diff[attr] = [];
                                i = from2.length;
                                while (i--) {
                                    tempDiff = values[i] - from[attr][i];
                                    (tempDiff || isNaN(tempDiff)) && (change = true);
                                    diff[attr][i] = tempDiff / ms;
                                }
                            }
                            to[attr] = values;
                            break;
                        default:
                            values = [][concat](params[attr]);
                            from2 = [][concat](from[attr]);
                            diff[attr] = [];
                            i = element.ca[attr].length;
                            while (i--) {
                                tempDiff = (values[i] || 0) - (from2[i] || 0);
                                (tempDiff || isNaN(tempDiff)) && (change = true);
                                diff[attr][i] = tempDiff / ms;
                            }
                            break;
                    }
                    if (!change) {
                        delete from[attr];
                        delete to[attr];
                        delete params[attr];
                        delete diff[attr];
                    }
                } else if (R._availableAttrs[has](attr) || attr === 'text' || element.ca[attr]) {
                    element.attr(attr, params[attr]);
                    delete params[attr];
                }
            }
        }var easing = params.easing,
            easyeasy = R.easing_formulas[easing];
        if (!easyeasy) {
            easyeasy = Str(easing).match(bezierrg);
            if (easyeasy && easyeasy.length == 5) {
                var curve = easyeasy;
                easyeasy = function easyeasy(t) {
                    return CubicBezierAtTime(t, +curve[1], +curve[2], +curve[3], +curve[4], ms);
                };
            } else {
                easyeasy = pipe;
            }
        }
        timestamp = params.start || anim.start || +new Date();
        element.e = e = {
            anim: anim,
            percent: percent,
            timestamp: timestamp,
            start: timestamp + (anim.del || 0),
            status: 0,
            initstatus: status || 0,
            stop: false,
            ms: ms,
            easing: easyeasy,
            from: from,
            diff: diff,
            to: to,
            el: element,
            callback: params.callback,
            prev: prev,
            next: next,
            repeat: times || anim.times,
            origin: element.attr(),
            totalOrigin: totalOrigin,
            parentEl: parentEl,
            delayend: configObject && configObject.end,
            delaystart: configObject && configObject.start
        };
        animationElements.push(e);

        if (status && !isInAnim && !isInAnimSet) {
            e.stop = true;
            e.start = new Date() - ms * status;
            if (animationElements.length == 1) {
                return animation();
            }
        }
        if (isInAnimSet) {
            e.start = new Date() - e.ms * status;
        }
        animationElements.length == 1 && (requestAnimFrame || R.getAnimFrameFn())(animation);
    } else {
        isInAnim.initstatus = status;
        isInAnim.start = new Date() - isInAnim.ms * status;
    }
    R.stopEvent !== false && (0, _eve2["default"])("raphael.anim.start." + element.id, element, anim);
}

/*\
 * Raphael.animation
 [ method ]
 **
 * Creates an animation object that can be passed to the @Element.animate or @Element.animateWith methods.
 * See also @Animation.delay and @Animation.repeat methods.
 **
 > Parameters
 **
 - params (object) final attributes for the element, see also @Element.attr
 - ms (number) number of milliseconds for animation to run
 - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
 - callback (function) #optional callback function. Will be called at the end of animation.
 **
 = (object) @Animation
\*/
R.animation = function (params, ms, easing, callback, event) {
    if (params instanceof Animation) {
        return params;
    }
    if (R.is(easing, "function") || !easing) {
        callback = callback || easing || null;
        easing = null;
    }
    R.stopEvent === undefined && (R.stopEvent = event);
    params = Object(params);
    ms = +ms || 0;
    var p = {},
        json,
        attr;
    for (attr in params) {
        if (params[has](attr) && toFloat(attr) != attr && toFloat(attr) + "%" != attr) {
            json = true;
            p[attr] = params[attr];
        }
    }if (!json) {
        return new Animation(params, ms);
    } else {
        easing && (p.easing = easing);
        callback && (p.callback = callback);
        return new Animation({
            100: p
        }, ms);
    }
};

/*\
 * Element.animate
 [ method ]
 **
 * Creates and starts animation for given element.
 **
 > Parameters
 **
 - params (object) final attributes for the element, see also @Element.attr
 - ms (number) number of milliseconds for animation to run
 - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
 - callback (function) #optional callback function. Will be called at the end of animation.
 * or
 - animation (object) animation object, see @Raphael.animation
 **
 = (object) original element
\*/
elproto.animate = function (params, ms, easing, callback) {
    var element = this;
    if (element.removed) {
        callback && callback.call(element);
        return element;
    }
    var anim = params instanceof Animation ? params : R.animation(params, ms, easing, callback);
    runAnimation(anim, element, anim.percents[0], null, element.attr());
    return element;
};

/*\
 * Element.setTime
 [ method ]
 **
 * Sets the status of animation of the element in milliseconds. Similar to @Element.status method.
 **
 > Parameters
 **
 - anim (object) animation object
 - value (number) number of milliseconds from the beginning of the animation
 **
 = (object) original element if `value` is specified
 * Note, that during animation following events are triggered:
 *
 * On each animation frame event `anim.frame.<id>`, on start `anim.start.<id>` and on end `anim.finish.<id>`.
\*/
elproto.setTime = function (anim, value) {
    if (anim && value != null) {
        this.status(anim, mmin(value, anim.ms) / anim.ms);
    }
    return this;
};

/*\
 * Element.status
 [ method ]
 **
 * Gets or sets the status of animation of the element.
 **
 > Parameters
 **
 - anim (object) #optional animation object
 - value (number) #optional 0 – 1. If specified, method works like a setter and sets the status of a given animation to the value. This will cause animation to jump to the given position.
 **
 = (number) status
 * or
 = (array) status if `anim` is not specified. Array of objects in format:
 o {
 o     anim: (object) animation object
 o     status: (number) status
 o }
 * or
 = (object) original element if `value` is specified
\*/
elproto.status = function (anim, value) {
    var out = [],
        i = 0,
        len,
        e;
    if (value != null) {
        runAnimation(anim, this, -1, mmin(value, 1));
        return this;
    } else {
        len = animationElements.length;
        for (; i < len; i++) {
            e = animationElements[i];
            if (e.el.id == this.id && (!anim || e.anim == anim)) {
                if (anim) {
                    return e.status;
                }
                out.push({
                    anim: e.anim,
                    status: e.status
                });
            }
        }
        if (anim) {
            return 0;
        }
        return out;
    }
};

/*\
 * Element.pause
 [ method ]
 **
 * Stops animation of the element with ability to resume it later on.
 **
 > Parameters
 **
 - anim (object) #optional animation object
 - resumeChildAnimation (boolean) #pauses the animation of the elements which are in sync with the current element
 **
 = (object) original element
\*/
elproto.pause = function (anim, pauseChildAnimation) {
    var now = +new Date(),
        e,
        i;
    for (i = 0; i < animationElements.length; i++) {
        e = animationElements[i];
        // @todo - need a scope to implement the logic for nested animations.
        if ((e.el.id === this.id || pauseChildAnimation && e.parentEl && e.parentEl.e.el && e.parentEl.e.el.id === this.id) && (!anim || e.anim == anim)) {
            if ((0, _eve2["default"])("raphael.anim.pause." + this.id, this, e.anim) !== false) {
                e.paused = true;
                e.pauseStart = now;
            }
        }
    }
    return this;
};

/*\
 * Element.resume
 [ method ]
 **
 * Resumes animation if it was paused with @Element.pause method.
 **
 > Parameters
 **
 - anim (object) #optional animation object
 - resumeChildAnimation (boolean) #resumes the animation of the elements which are in sync with the current element
 **
 = (object) original element
\*/
elproto.resume = function (anim, resumeChildAnimation) {
    var now = +new Date(),
        e,
        i;
    for (i = 0; i < animationElements.length; i++) {
        e = animationElements[i];
        // @todo - need a scope to implement the logic for nested animations.
        if ((e.el.id === this.id || resumeChildAnimation && e.parentEl && e.parentEl.e.el && e.parentEl.e.el.id === this.id) && (!anim || e.anim == anim)) {
            if ((0, _eve2["default"])("raphael.anim.resume." + this.id, this, e.anim) !== false) {
                delete e.paused;
                e.el.status(e.anim, e.status);
                e.pauseEnd = now;
                e.start += (e.parentEl && e.parentEl.e.pauseEnd || e.pauseEnd) - (e.parentEl && e.parentEl.e.pauseStart || e.pauseStart) || 0;
            }
        }
    }
    return this;
};

/*\
 * Element.stop
 [ method ]
 **
 * Stops animation of the element.
 **
 > Parameters
 **
 - anim (object) #optional animation object
 - stopChildAnimation (boolean) #optional stops the animation of all the element which are in sync with the current element
 - jumpToEnd (boolean) #optional takes the current animation to its end value
 **
 = (object) original element
\*/
elproto.stop = function (anim, stopChildAnimation, jumpToEnd) {
    var e, i, ele;
    if (stopChildAnimation) {
        for (i = animationElements.length - 1; i >= 0; i--) {
            e = animationElements[i];
            // @todo - need a scope to implement the logic for nested animations.
            if ((e.el.id === this.id || e.parentEl && e.parentEl.id === this.id) && (!anim || animationElements[i].anim == anim)) {
                ele = e.el;
                jumpToEnd && ele.attr(e.to);
                e.callback && e.callback.call(ele);
                delete ele.e;
                delete e.el;
                animationElements.splice(i, 1);
            }
        }
    } else {
        for (var i = 0; i < animationElements.length; i++) {
            e = animationElements[i];
            if (e.el.id === this.id && (!anim || e.anim === anim)) {
                if ((0, _eve2["default"])("raphael.anim.stop." + this.id, this, e.anim) !== false) {
                    animationElements.splice(i--, 1);
                }
            }
        }
    }
    // In case root object has hooked animation elements
    // in priority queue execute them all
    if (this.animElements) {
        executeAnimQueue(this.animElements);
    }
    return this;
};

function executeAnimQueue(queue) {
    var ob;
    // Looping until all executed
    while (ob = queue.deq()) {
        ob = ob.executeOb;
        ob.hookFn && ob.hookFn.call(ob.el);
        ob.el.attr(ob.attrs);
        ob.callback && ob.callback.call(ob.el);
    }
}

function stopAnimation(paper) {
    for (var i = 0; i < animationElements.length; i++) {
        if (animationElements[i].el.paper == paper) {
            animationElements.splice(i--, 1);
        }
    }
}
_eve2["default"].on("raphael.remove", stopAnimation);
_eve2["default"].on("raphael.clear", stopAnimation);
elproto.toString = function () {
    return "Rapha\xEBl\u2019s object";
};

elproto.toFront = function () {
    if (this.removed) {
        return this;
    }

    var o = this,
        thisNode = R._engine.getNode(o),
        parent = o.parent,
        followers = o.followers,
        follower,
        i,
        ii;

    if (R._tofront(o, parent)) {
        parent.canvas.appendChild(thisNode);
    }

    for (i = 0, ii = followers.length; i < ii; i++) {
        (follower = followers[i]).stalk && follower.el[follower.stalk](o);
    }
    return o;
};

elproto.toBack = function () {
    if (this.removed) {
        return this;
    }

    var o = this,
        thisNode = R._engine.getNode(o),
        parent = o.parent,
        followers = o.followers,
        follower,
        i,
        ii;

    if (R._toback(o, parent)) {
        parent.canvas.insertBefore(thisNode, parent.canvas.firstChild);
    }

    for (i = 0, ii = followers.length; i < ii; i++) {
        (follower = followers[i]).stalk && follower.el[follower.stalk](o);
    }
    return o;
};

elproto.insertAfter = function (element) {
    if (this.removed) {
        return this;
    }

    var o = this,
        thisNode = R._engine.getNode(o),
        thatNode = R._engine.getLastNode(element),
        parentNode = element.parent.canvas,
        followers = o.followers,
        follower,
        i,
        ii;

    if (thatNode.nextSibling) {
        parentNode.insertBefore(thisNode, thatNode.nextSibling);
    } else {
        parentNode.appendChild(thisNode);
    }
    R._insertafter(o, element, o.parent, element.parent);

    for (i = 0, ii = followers.length; i < ii; i++) {
        (follower = followers[i]).stalk && follower.el[follower.stalk](element);
    }
    return o;
};

elproto.insertBefore = function (element) {
    if (this.removed) {
        return this;
    }

    var o = this,
        thisNode = R._engine.getNode(o),
        thatNode = R._engine.getNode(element),
        followers = o.followers,
        follower,
        i,
        ii;

    element.parent.canvas.insertBefore(thisNode, thatNode);
    R._insertbefore(o, element, o.parent, element.parent);
    o.parent = element.parent;

    for (i = 0, ii = followers.length; i < ii; i++) {
        (follower = followers[i]).stalk && follower.el[follower.stalk](element);
    }
    return this;
};

elproto.appendChild = function (element) {
    if (this.removed || this.type !== 'group') {
        return this;
    }

    var group = this,
        followers = group.followers,
        follower,
        thatNode,
        i,
        ii;

    // If appending in same group, simply perform toFront().
    if (element.parent === group) {
        element.toFront();
        return group;
    }

    thatNode = R._engine.getNode(element);

    // first remove from own group
    R._tear(element, element.parent);

    group.canvas.appendChild(thatNode);
    element.parent = group;

    !group.bottom && (group.bottom = element);
    element.prev = group.top;
    element.next = null;
    group.top && (group.top.next = element);
    group.top = element;

    for (i = 0, ii = followers.length; i < ii; i++) {
        (follower = followers[i]).stalk && follower.el[follower.stalk](element);
    }

    return group;
};

elproto.removeChild = function (element) {
    if (this.removed || this.type !== 'group' || element.parent !== this) {
        return this;
    }

    var o = this,
        thatNode = R._engine.getNode(element),
        paper = o.paper;

    R._tear(element, o);
    paper.canvas.appendChild(thatNode);

    o.parent = paper;
    !paper.bottom && (paper.bottom = o);

    o.prev = paper.top;
    paper.top && (paper.top.next = o);
    paper.top = o;
    o.next = null;

    return o;
};

// Set
var Set = function Set(items) {
    this.items = [];
    this.length = 0;
    this.type = "set";
    if (items) {
        for (var i = 0, ii = items.length; i < ii; i++) {
            if (items[i] && (items[i].constructor == elproto.constructor || items[i].constructor == Set)) {
                this[this.items.length] = this.items[this.items.length] = items[i];
                this.length++;
            }
        }
    }
},
    setproto = Set.prototype;

/*\
 * Set.push
 [ method ]
 **
 * Adds each argument to the current set.
 = (object) original element
\*/
setproto.push = function () {
    var item, len;
    for (var i = 0, ii = arguments.length; i < ii; i++) {
        item = arguments[i];
        if (item && (item.constructor == elproto.constructor || item.constructor == Set)) {
            len = this.items.length;
            this[len] = this.items[len] = item;
            this.length++;
        }
    }
    return this;
};

/*\
 * Set.pop
 [ method ]
 **
 * Removes last element and returns it.
 = (object) element
\*/
setproto.pop = function () {
    this.length && delete this[this.length--];
    return this.items.pop();
};

/*\
 * Set.forEach
 [ method ]
 **
 * Executes given function for each element in the set.
 *
 * If function returns `false` it will stop loop running.
 **
 > Parameters
 **
 - callback (function) function to run
 - thisArg (object) context object for the callback
 = (object) Set object
\*/
setproto.forEach = function (callback, thisArg) {
    for (var i = 0, ii = this.items.length; i < ii; i++) {
        if (callback.call(thisArg, this.items[i], i) === false) {
            return this;
        }
    }
    return this;
};
for (var method in elproto) {
    if (elproto[has](method)) {
        setproto[method] = function (methodname) {
            return function () {
                var arg = arguments;
                return this.forEach(function (el) {
                    el[methodname][apply](el, arg);
                });
            };
        }(method);
    }
}setproto.attr = function (name, value) {
    if (name && R.is(name, array) && R.is(name[0], object)) {
        for (var j = 0, jj = name.length; j < jj; j++) {
            this.items[j].attr(name[j]);
        }
    } else {
        for (var i = 0, ii = this.items.length; i < ii; i++) {
            this.items[i].attr(name, value);
        }
    }
    return this;
};

/*\
 * Set.clear
 [ method ]
 **
 * Removeds all elements from the set
\*/
setproto.clear = function () {
    while (this.length) {
        this.pop();
    }
};

/*\
 * Set.splice
 [ method ]
 **
 * Removes given element from the set
 **
 > Parameters
 **
 - index (number) position of the deletion
 - count (number) number of element to remove
 - insertion… (object) #optional elements to insert
 = (object) set elements that were deleted
\*/
setproto.splice = function (index, count, insertion) {
    index = index < 0 ? mmax(this.length + index, 0) : index;
    count = mmax(0, mmin(this.length - index, isNaN(count) && this.length || count));
    var tail = [],
        todel = [],
        args = [],
        i;
    for (i = 2; i < arguments.length; i++) {
        args.push(arguments[i]);
    }
    for (i = 0; i < count; i++) {
        todel.push(this[index + i]);
    }
    for (; i < this.length - index; i++) {
        tail.push(this[index + i]);
    }
    var arglen = args.length;
    for (i = 0; i < arglen + tail.length; i++) {
        this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];
    }
    i = this.items.length = this.length -= count - arglen;
    while (this[i]) {
        delete this[i++];
    }
    return new Set(todel);
};

/*\
 * Set.exclude
 [ method ]
 **
 * Removes given element from the set
 **
 > Parameters
 **
 - element (object) element to remove
 = (boolean) `true` if object was found & removed from the set
\*/
setproto.exclude = function (el) {
    for (var i = 0, ii = this.length; i < ii; i++) {
        if (this[i] == el) {
            this.splice(i, 1);
            return true;
        }
    }
};
setproto.animate = function (params, ms, easing, callback) {
    (R.is(easing, "function") || !easing) && (callback = easing || null);
    var len = this.items.length,
        i = len,
        item,
        set = this,
        collector;
    if (!len) {
        return this;
    }
    callback && (collector = function collector() {
        ! --len && callback.call(set);
    });
    easing = R.is(easing, string) ? easing : collector;
    var anim = R.animation(params, ms, easing, collector);
    item = this.items[--i].animate(anim);
    while (i--) {
        this.items[i] && !this.items[i].removed && this.items[i].animateWith(item, anim, anim);
    }
    return this;
};
setproto.insertAfter = function (el) {
    var i = this.items.length;
    while (i--) {
        this.items[i].insertAfter(el);
    }
    return this;
};
setproto.getBBox = function () {
    var x = [],
        y = [],
        x2 = [],
        y2 = [];
    for (var i = this.items.length; i--;) {
        if (!this.items[i].removed) {
            var box = this.items[i].getBBox();
            x.push(box.x);
            y.push(box.y);
            x2.push(box.x + box.width);
            y2.push(box.y + box.height);
        }
    }x = mmin[apply](0, x);
    y = mmin[apply](0, y);
    x2 = mmax[apply](0, x2);
    y2 = mmax[apply](0, y2);
    return {
        x: x,
        y: y,
        x2: x2,
        y2: y2,
        width: x2 - x,
        height: y2 - y
    };
};
setproto.clone = function (s) {
    s = new Set();
    for (var i = 0, ii = this.items.length; i < ii; i++) {
        s.push(this.items[i].clone());
    }
    return s;
};
setproto.toString = function () {
    return "Rapha\xEBl\u2018s set";
};

setproto.glow = function (glowConfig) {
    var ret = this.paper.set();
    this.forEach(function (shape, index) {
        var g = shape.glow(glowConfig);
        if (g != null) {
            g.forEach(function (shape2, index2) {
                ret.push(shape2);
            });
        }
    });
    return ret;
};

/*\
 * Raphael.registerFont
 [ method ]
 **
 * Adds given font to the registered set of fonts for Raphaël. Should be used as an internal call from within Cufón’s font file.
 * Returns original parameter, so it could be used with chaining.
 # <a href="http://wiki.github.com/sorccu/cufon/about">More about Cufón and how to convert your font form TTF, OTF, etc to JavaScript file.</a>
 **
 > Parameters
 **
 - font (object) the font to register
 = (object) the font you passed in
 > Usage
 | Cufon.registerFont(Raphael.registerFont({…}));
\*/
R.registerFont = function (font) {
    if (!font.face) {
        return font;
    }
    this.fonts = this.fonts || {};
    var fontcopy = {
        w: font.w,
        face: {},
        glyphs: {}
    },
        family = font.face["font-family"];
    for (var prop in font.face) {
        if (font.face[has](prop)) {
            fontcopy.face[prop] = font.face[prop];
        }
    }if (this.fonts[family]) {
        this.fonts[family].push(fontcopy);
    } else {
        this.fonts[family] = [fontcopy];
    }
    if (!font.svg) {
        fontcopy.face["units-per-em"] = toInt(font.face["units-per-em"], 10);
        for (var glyph in font.glyphs) {
            if (font.glyphs[has](glyph)) {
                var path = font.glyphs[glyph];
                fontcopy.glyphs[glyph] = {
                    w: path.w,
                    k: {},
                    d: path.d && "M" + path.d.replace(/[mlcxtrv]/g, function (command) {
                        return {
                            l: "L",
                            c: "C",
                            x: "z",
                            t: "m",
                            r: "l",
                            v: "c"
                        }[command] || "M";
                    }) + "z"
                };
                if (path.k) {
                    for (var k in path.k) {
                        if (path[has](k)) {
                            fontcopy.glyphs[glyph].k[k] = path.k[k];
                        }
                    }
                }
            }
        }
    }
    return font;
};

/*\
 * Paper.getFont
 [ method ]
 **
 * Finds font object in the registered fonts by given parameters. You could specify only one word from the font name, like “Myriad” for “Myriad Pro”.
 **
 > Parameters
 **
 - family (string) font family name or any word from it
 - weight (string) #optional font weight
 - style (string) #optional font style
 - stretch (string) #optional font stretch
 = (object) the font object
 > Usage
 | paper.print(100, 100, "Test string", paper.getFont("Times", 800), 30);
\*/
paperproto.getFont = function (family, weight, style, stretch) {
    stretch = stretch || "normal";
    style = style || "normal";
    weight = +weight || {
        normal: 400,
        bold: 700,
        lighter: 300,
        bolder: 800
    }[weight] || 400;
    if (!R.fonts) {
        return;
    }
    var font = R.fonts[family];
    if (!font) {
        var name = new RegExp("(^|\\s)" + family.replace(/[^\w\d\s+!~.:_-]/g, E) + "(\\s|$)", "i");
        for (var fontName in R.fonts) {
            if (R.fonts[has](fontName)) {
                if (name.test(fontName)) {
                    font = R.fonts[fontName];
                    break;
                }
            }
        }
    }
    var thefont;
    if (font) {
        for (var i = 0, ii = font.length; i < ii; i++) {
            thefont = font[i];
            if (thefont.face["font-weight"] == weight && (thefont.face["font-style"] == style || !thefont.face["font-style"]) && thefont.face["font-stretch"] == stretch) {
                break;
            }
        }
    }
    return thefont;
};

/*\
 * Paper.print
 [ method ]
 **
 * Creates path that represent given text written using given font at given position with given size.
 * Result of the method is path element that contains whole text as a separate path.
 **
 > Parameters
 **
 - x (number) x position of the text
 - y (number) y position of the text
 - string (string) text to print
 - font (object) font object, see @Paper.getFont
 - size (number) #optional size of the font, default is `16`
 - origin (string) #optional could be `"baseline"` or `"middle"`, default is `"middle"`
 - letter_spacing (number) #optional number in range `-1..1`, default is `0`
 = (object) resulting path element, which consist of all letters
 > Usage
 | var txt = r.print(10, 50, "print", r.getFont("Museo"), 30).attr({fill: "#fff"});
\*/
paperproto.print = function (x, y, string, font, size, origin, letter_spacing) {
    origin = origin || "middle"; // baseline|middle
    letter_spacing = mmax(mmin(letter_spacing || 0, 1), -1);
    var letters = Str(string)[split](E),
        shift = 0,
        notfirst = 0,
        path = E,
        scale;
    R.is(font, string) && (font = this.getFont(font));
    if (font) {
        scale = (size || 16) / font.face["units-per-em"];
        var bb = font.face.bbox[split](separator),
            top = +bb[0],
            lineHeight = bb[3] - bb[1],
            shifty = 0,
            height = +bb[1] + (origin == "baseline" ? lineHeight + +font.face.descent : lineHeight / 2);
        for (var i = 0, ii = letters.length; i < ii; i++) {
            if (letters[i] == "\n") {
                shift = 0;
                curr = 0;
                notfirst = 0;
                shifty += lineHeight;
            } else {
                var prev = notfirst && font.glyphs[letters[i - 1]] || {},
                    curr = font.glyphs[letters[i]];
                shift += notfirst ? (prev.w || font.w) + (prev.k && prev.k[letters[i]] || 0) + font.w * letter_spacing : 0;
                notfirst = 1;
            }
            if (curr && curr.d) {
                path += R.transformPath(curr.d, ["t", shift * scale, shifty * scale, "s", scale, scale, top, height, "t", (x - top) / scale, (y - height) / scale]);
            }
        }
    }
    return this.path(path).attr({
        fill: "#000",
        stroke: "none"
    });
};

/*\
 * Paper.add
 [ method ]
 **
 * Imports elements in JSON array in format `{type: type, <attributes>}`
 **
 > Parameters
 **
 - json (array)
 = (object) resulting set of imported elements
 > Usage
 | paper.add([
 |     {
 |         type: "circle",
 |         cx: 10,
 |         cy: 10,
 |         r: 5
 |     },
 |     {
 |         type: "rect",
 |         x: 10,
 |         y: 10,
 |         width: 10,
 |         height: 10,
 |         fill: "#fc0"
 |     }
 | ]);
\*/
paperproto.add = function (json) {
    if (R.is(json, "array")) {
        var res = this.set(),
            i = 0,
            ii = json.length,
            j;
        for (; i < ii; i++) {
            j = json[i] || {};
            elements[has](j.type) && res.push(this[j.type]().attr(j));
        }
    }
    return res;
};

/*\
 * Raphael.format
 [ method ]
 **
 * Simple format function. Replaces construction of type “`{<number>}`” to the corresponding argument.
 **
 > Parameters
 **
 - token (string) string to format
 - … (string) rest of arguments will be treated as parameters for replacement
 = (string) formated string
 > Usage
 | var x = 10,
 |     y = 20,
 |     width = 40,
 |     height = 50;
 | // this will draw a rectangular shape equivalent to "M10,20h40v50h-40z"
 | paper.path(Raphael.format("M{0},{1}h{2}v{3}h{4}z", x, y, width, height, -width));
\*/
R.format = function (token, params) {
    var args = R.is(params, array) ? [0][concat](params) : arguments;
    token && R.is(token, string) && args.length - 1 && (token = token.replace(formatrg, function (str, i) {
        return args[++i] == null ? E : args[i];
    }));
    return token || E;
};

/*\
 * Raphael.fullfill
 [ method ]
 **
 * A little bit more advanced format function than @Raphael.format. Replaces construction of type “`{<name>}`” to the corresponding argument.
 **
 > Parameters
 **
 - token (string) string to format
 - json (object) object which properties will be used as a replacement
 = (string) formated string
 > Usage
 | // this will draw a rectangular shape equivalent to "M10,20h40v50h-40z"
 | paper.path(Raphael.fullfill("M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z", {
 |     x: 10,
 |     y: 20,
 |     dim: {
 |         width: 40,
 |         height: 50,
 |         "negative width": -40
 |     }
 | }));
\*/
R.fullfill = function () {
    var tokenRegex = /\{([^\}]+)\}/g,
        objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g,
        // matches .xxxxx or ["xxxxx"] to run over object properties
    replacer = function replacer(all, key, obj) {
        var res = obj;
        key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {
            name = name || quotedName;
            if (res) {
                if (name in res) {
                    res = res[name];
                }
                typeof res == "function" && isFunc && (res = res());
            }
        });
        res = (res == null || res == obj ? all : res) + "";
        return res;
    };
    return function (str, obj) {
        return String(str).replace(tokenRegex, function (all, key) {
            return replacer(all, key, obj);
        });
    };
}();

/*\
 * Raphael.ninja
 [ method ]
 **
 * If you want to leave no trace of Raphaël (Well, Raphaël creates only one global variable `Raphael`, but anyway.) You can use `ninja` method.
 * Beware, that in this case plugins could stop working, because they are depending on global variable existance.
 **
 = (object) Raphael object
 > Usage
 | (function (local_raphael) {
 |     var paper = local_raphael(10, 10, 320, 200);
 |     …
 | })(Raphael.ninja());
\*/
R.ninja = function () {
    oldRaphael.was ? g.win.Raphael = oldRaphael.is : delete g.win.Raphael;
    return R;
};

var crispFixer = R.vml && 0.5 || 0;

R.crispBound = cacher(function (x, y, w, h, s) {
    var at = {},
        normalizer;

    x = x || 0;
    y = y || 0;
    w = w || 0;
    h = h || 0;
    s = s || 0;
    normalizer = s % 2 / 2 + crispFixer;

    // normalize for crisp edges
    at.x = round(x + normalizer) - normalizer;
    at.y = round(y + normalizer) - normalizer;
    at.width = round(x + w + normalizer) - normalizer - at.x;
    at.height = round(y + h + normalizer) - normalizer - at.y;
    at['stroke-width'] = s;

    // adjust to single pixel if resultant dimension is zero.
    at.width === 0 && w !== 0 && (at.width = 1);
    at.height === 0 && h !== 0 && (at.height = 1);

    return at;
}, R);

elproto.crisp = function () {
    var o = this,
        attrs = o.attrs,
        key,
        attr = {},
        values = o.attr(['x', 'y', 'width', 'height', 'stroke-width']);

    values = R.crispBound(values.x, values.y, values.width, values.height, values['stroke-width']);

    for (key in values) {
        if (attrs[key] === values[key]) {
            // only set attribute if changed
            delete values[key];
        }
    }

    return o.attr(values);
};

/*\
 * Raphael.st
 [ property (object) ]
 **
 * You can add your own method to elements and sets. It is wise to add a set method for each element method
 * you added, so you will be able to call the same method on sets too.
 **
 * See also @Raphael.el.
 > Usage
 | Raphael.el.red = function () {
 |     this.attr({fill: "#f00"});
 | };
 | Raphael.st.red = function () {
 |     this.forEach(function (el) {
 |         el.red();
 |     });
 | };
 | // then use it
 | paper.set(paper.circle(100, 100, 20), paper.circle(110, 100, 20)).red();
\*/
R.st = setproto;

/*\
 * Raphael.define
 [ method ]
 **
 * Allows a unified definition of composite shapes and other behaviours using
 * simple directives.
 **
 > Parameters
 **
 - definition (object) the shape definition
\*/
R.define = function (name, init, ca, fn, e, data) {
    var i, ii;

    // multi definition
    if (R.is(name, array)) {
        for (i = 0, ii = name.length; i < ii; i++) {
            R.define(name[i]);
        }
        return;
    }
    // object definition
    else if (R.is(name, object)) {
            R.define(name.name, name[name.name], name.ca, name.fn, name.e, name.data);
            return;
        }
        // invalid or duplicate definition
        else if (!name || R.fn[name]) {
                return;
            }

    R.fn[name] = function () {
        var args = arguments,
            element = init.apply(this, args),
            key;

        if (fn && R.is(fn, object)) {
            for (key in fn) {
                element[key] = fn[key];
            }
        }

        if (e && R.is(e, object)) {
            for (key in e) {
                element[key] && element[key](e[key]);
            }
        }

        if (ca) {
            if (R.is(ca, 'function')) {
                element.ca[name] = ca;
            } else {
                for (key in ca) {
                    element.ca[key] = ca[key];
                }
            }

            // Check if namesake ca exists and apply it
            if (element.ca[name]) {
                R._lastArgIfGroup(args, true); // purge group
                args.length && element.attr(name, arraySlice.call(args));
            }
        }

        return element;
    };

    if (ca) {
        R.fn[name].ca = ca;
    }
    if (fn) {
        R.fn[name].fn = fn;
    }
    if (e) {
        R.fn[name].e = e;
    }
    if (data) {
        R.fn[name].data = data;
    }

    return R.fn[name];
};
// Firefox <3.6 fix: http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html
(function (doc, loaded, _f) {
    if (doc.readyState == null && doc.addEventListener) {
        doc.addEventListener(loaded, _f = function f() {
            doc.removeEventListener(loaded, _f, false);
            doc.readyState = "complete";
        }, false);
        doc.readyState = "loading";
    }
    function isLoaded() {
        /in/.test(doc.readyState) ? setTimeout(isLoaded, 9) : R.eve("raphael.DOMload");
    }
    isLoaded();
})(doc, "DOMContentLoaded");

_eve2["default"].on("raphael.DOMload", function () {
    loaded = true;
});

// EXPOSE
// SVG and VML are appended just before the EXPOSE line
// Even with AMD, Raphael should be defined globally
// oldRaphael.was ? (g.win.Raphael = R) : (Raphael = R);

exports["default"] = R;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)))

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(87);
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};

/***/ }),
/* 87 */
/***/ (function(module, exports) {

module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),
/* 88 */
/***/ (function(module, exports) {

module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};

/***/ }),
/* 89 */
/***/ (function(module, exports) {

module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys       = __webpack_require__(204)
  , enumBugKeys = __webpack_require__(139);

module.exports = Object.keys || function keys(O){
  return $keys(O, enumBugKeys);
};

/***/ }),
/* 91 */
/***/ (function(module, exports) {

var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _lib = __webpack_require__(5);

var _helper = __webpack_require__(26);

var _toolBarFactoryHelper = __webpack_require__(25);

var _componentInterface = __webpack_require__(6);

var _componentInterface2 = _interopRequireDefault(_componentInterface);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */

var UNDEF = void 0,
    convertColor = _lib.graphics.convertColor,
    getLightColor = _lib.graphics.getLightColor,
    rawRGBtoHEX = _lib.graphics.rawRGBtoHEX;

/**
 * Creates SymbolClass class
 */

var SymbolClass = function (_ComponentInterface) {
  _inherits(SymbolClass, _ComponentInterface);

  /**
   * Constructor function of class SymbolClass
   * @param {string} componentName name of Symbol component required
   * @param {boolean} isPlaintext Checks for a Symbol component or text component
   * @param {number} idCount toolbox id
   * @param {number} poolId poolId toolbox pool id
   */
  function SymbolClass(componentName, isPlaintext, idCount, poolId) {
    _classCallCheck(this, SymbolClass);

    var _this = _possibleConstructorReturn(this, _ComponentInterface.call(this));

    _this.symbol = componentName;
    _this._id = 'TB_SYMBOL' + (idCount || 0);
    _this.node = UNDEF;
    _this.pId = poolId;
    _this.isPlaintext = isPlaintext;
    _this.conf = {
      btnTextStyle: {
        'stroke-width': '1px',
        'stroke': 'none'
      }
    };
    _this.evt = {
      tooltext: UNDEF,
      click: _lib.stubFN,
      hover: [_lib.stubFN, _lib.stubFN]
    };
    return _this;
  }
  /**
   * Register new Symbol
   * @param {Function} fn callback for new symbol draw
   */


  SymbolClass.prototype.registerSymbol = function registerSymbol(fn) {
    _helper.SymbolStore.register(this.symbol, fn);
  };
  /**
   * Configure the Symbol component
   * @param {Object} conf configuration object
   */


  SymbolClass.prototype._setConfiguaration = function _setConfiguaration(conf) {
    if (!this.conf) {
      this.conf = conf;
    } else {
      (0, _helper.mergeConf)(conf, this.conf, true);
    }
  };
  /**
   * Attach events to Symbol components
   * @param {Object} eventMap object of callback fn as event
   * @param {Object} hooks hook callback fn as event
   * @return {Object} self instance
   */


  SymbolClass.prototype.attachEventHandlers = function attachEventHandlers(eventMap, hooks) {
    var self = this,
        evt = self.evt,
        toolText = eventMap.tooltext,
        clickFn = eventMap.click || _lib.stubFN,
        HoverFn = eventMap.hover,
        clickHook = hooks && hooks.click || _lib.stubFN,
        managedClickFn;

    if (typeof clickFn === 'function') {
      managedClickFn = function managedClickFn() {
        clickHook();
        clickFn.apply(self, arguments);
      };
    } else {
      managedClickFn = function managedClickFn() {
        var oriFn = clickFn.fn,
            context = clickFn.context,
            args = (clickFn.args || []).slice(0);

        if (clickFn.hasOwnProperty('context')) {
          args.push(self);
        } else {
          context = self;
        }

        [].push.apply(args, arguments);
        clickHook();
        oriFn.apply(context, args);
      };
    }

    if (toolText) {
      evt.tooltext = toolText;
    }
    evt.click = managedClickFn;

    if (HoverFn && HoverFn instanceof Array) {
      evt.hover = HoverFn;
    }

    if (this.node) {
      this.node.tooltip(this.evt.tooltext).buttonclick(this.evt.click).hover(this.evt.hover[0], this.evt.hover[1]);
    }

    return this;
  };
  /**
   * Returns dimension needed for this component
   * @return {Object} dimension in wdth, height
   */


  SymbolClass.prototype.getLogicalSpace = function getLogicalSpace() {
    return {
      width: this.conf.width,
      height: this.conf.height
    };
  };
  /**
   * Shows the component
   */


  SymbolClass.prototype.show = function show() {
    var node = this.node;
    if (node) {
      node.css({
        display: 'block'
      });
    }
  };
  /**
   * Hides the component
   */


  SymbolClass.prototype.hide = function hide() {
    var node = this.node;
    if (node) {
      node.css({
        display: 'none'
      });
    }
  };
  /**
   * Draws the component
   * @param {number} x x coordinate
   * @param {number} y y coordinate
   * @param {Object} options Configuration object
   * @return {Object} Component graphics element
   */


  SymbolClass.prototype.draw = function draw(x, y, options) {
    var elem,
        btnConfig = this.conf || {},
        symbol,
        text,
        newCreated,
        instanceFn,
        componentPool = _toolBarFactoryHelper.ToolBarFactoryHelper.getComponentPool(),
        keys = componentPool.getKeys(),
        chart = _toolBarFactoryHelper.ToolBarFactoryHelper.getOptions().chart,
        animationObj = chart.get('config', 'animationObj'),
        animObj = animationObj.animObj,
        dummyObj = animationObj.dummyObj,
        animationDuration = animationObj.duration;

    if (this.isPlaintext) {
      text = this.symbol;
    } else {
      symbol = this.symbol;
    }

    if (options.idCount !== UNDEF) {
      this._id += options.idCount;
    }

    if (!btnConfig.hoverFill) {
      btnConfig.hoverFill = convertColor(getLightColor(rawRGBtoHEX(btnConfig.fill), 80));
    } else {
      btnConfig.hoverFill = convertColor(btnConfig.hoverFill);
    }

    instanceFn = componentPool.getComponent(this._id, this.pId, keys.KEY_BUTTON, true);
    elem = this.node = instanceFn(x, y, text, symbol, {
      width: btnConfig.width,
      height: btnConfig.height,
      r: btnConfig.radius,
      verticalPadding: btnConfig.symbolHPadding * btnConfig.scale,
      horizontalPadding: btnConfig.symbolHPadding
    }, options.parentLayer).labelcss(this.conf.btnTextStyle);

    elem.attr({
      ishot: true,
      fill: [btnConfig.fill, btnConfig.labelFill, btnConfig.symbolFill, btnConfig.hoverFill, true],
      stroke: [btnConfig.stroke, btnConfig.symbolStroke],
      'stroke-width': [btnConfig.strokeWidth, btnConfig.symbolStrokeWidth]
    }).tooltip(this.evt.tooltext).buttonclick(this.evt.click).hover(this.evt.hover[0], this.evt.hover[1]);

    newCreated = componentPool.getCreationStatus();

    if (!newCreated) {
      this.node.unclick();

      this.node.animateWith(dummyObj, animObj, {
        'button-repaint': [x, y, btnConfig.width, btnConfig.height, btnConfig.radius]
      }, animationDuration, animationObj.animType);
      this.node.attr({
        'button-label': text,
        'button-padding': [btnConfig.symbolHPadding, btnConfig.symbolHPadding * btnConfig.scale]
      });
      this.node.buttonclick(this.evt.click);
    }

    elem.getBBox = function () {
      return {
        x: x,
        y: y,
        width: btnConfig.width,
        height: btnConfig.height
      };
    };
    return elem;
  };
  /**
   * Disposes the graphics of the component
   */


  SymbolClass.prototype.dispose = function dispose() {
    var node = this.node;

    if (node) {
      node.remove();
    }

    this.node = UNDEF;
  };

  return SymbolClass;
}(_componentInterface2['default']);

exports['default'] = SymbolClass;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/** !
 * @license FusionCharts JavaScript Library - KDtree
 * Copyright FusionCharts, Inc.
 * License Information at <http://www.fusioncharts.com/license>
 *
 * @version //? write(JSON.parse(require('fs').readFileSync('./package.json')).version);
 */
/* ?
 // metascript to check license status for creditLabel
 var licenseActive = (!global.licensed + ' &&');
 */
/**
 * @private
 * @module fusioncharts.renderer.javascript.kdtree
 * @export fusioncharts.kdtree.js
 */

/*
  * compareFunction : An optional argument for Array.Prototype.sort(). Used to change the default sorting order.
  * @param a {Object} and @param b {Object} - two elements being compared during the sort.
*/
// sorts the Array w.r.t to 'x' property of the array elements in an ascending order.
var UNDEF,
    isWithinCircle = function isWithinCircle(x, y, cx, cy, r) {
  return Math.pow(cx - x, 2) + Math.pow(cy - y, 2) <= Math.pow(r, 2);
},
    mathPI = Math.PI,
    mathCos = Math.cos,
    mathSin = Math.sin,
    mathMax = Math.max,
    mathMin = Math.min,
    deg2rad = mathPI / 180,
    rad = function rad(deg) {
  return deg % 360 * deg2rad;
},
    orientation = function orientation(p1x, p1y, q1x, q1y, p2x, p2y) {
  var A = q1y - p1y,
      B = p2x - q1x,
      C = q1x - p1x,
      D = p2y - q1y,
      val1,
      val2,
      val;

  val1 = A * B;
  val2 = C * D;

  if (isNaN(val1)) {
    val1 = 0;
  }

  if (isNaN(val2)) {
    val2 = 0;
  }

  val = val1 - val2;

  if (val === 0) {
    return 0; // colinear
  }

  return val > 0 ? 1 : 2;
},
    onSegment = function onSegment(p1x, p1y, q1x, q1y, p2x, p2y) {
  if (q1x <= mathMax(p1x, p2x) && q1x >= mathMin(p1x, p2x) && q1y <= mathMax(p1y, p2y) && q1y >= mathMin(p1y, p2y)) {
    return true;
  }
  return false;
},
    doIntersect = function doIntersect(p1x, p1y, q1x, q1y, p2x, p2y, q2x, q2y) {
  // Find the four orientations needed for general and
  // special cases
  var o1 = orientation(p1x, p1y, q1x, q1y, p2x, p2y),
      o2 = orientation(p1x, p1y, q1x, q1y, q2x, q2y),
      o3 = orientation(p2x, p2y, q2x, q2y, p1x, p1y),
      o4 = orientation(p2x, p2y, q2x, q2y, q1x, q1y);

  // General case
  if (o1 !== o2 && o3 !== o4) {
    return true;
  }

  // Special Cases
  // p1, q1 and p2 are colinear and p2 lies on segment p1q1
  if (o1 === 0 && onSegment(p1x, p1y, p2x, p2y, q1x, q1y)) {
    return true;
  }

  // p1, q1 and p2 are colinear and q2 lies on segment p1q1
  if (o2 === 0 && onSegment(p1x, p1y, q2x, q2y, q1x, q1y)) {
    return true;
  }

  // p2, q2 and p1 are colinear and p1 lies on segment p2q2
  if (o3 === 0 && onSegment(p2x, p2y, p1x, p1y, q2x, q2y)) {
    return true;
  }

  // p2, q2 and q1 are colinear and q1 lies on segment p2q2
  if (o4 === 0 && onSegment(p2x, p2y, q1x, q1y, q2x, q2y)) {
    return true;
  }

  return false; // Doesn't fall in any of the above cases
},
    isWithinPolygon = function isWithinPolygon(x, y, cx, cy, r, sides, startAngle) {
  var i,
      extreme = Infinity,
      angle,
      count = 0,
      p1x,
      p2x,
      p2y,
      p1y,
      inangle,
      inside = false;

  if (isWithinCircle(x, y, cx, cy, r) && sides >= 3) {
    angle = startAngle === UNDEF ? mathPI * 0.5 : rad(startAngle);
    inangle = 2 * mathPI / sides;
    p1x = cx + r * mathCos(-angle);
    p1y = cy + r * mathSin(-angle);

    for (i = 0; i < sides; i++) {
      angle += inangle;
      p2x = cx + r * mathCos(-angle);
      p2y = cy + r * mathSin(-angle);

      if (doIntersect(p1x, p1y, p2x, p2y, x, y, extreme, y)) {
        if (orientation(p1x, p1y, x, y, p2x, p2y) === 0) {
          return onSegment(p1x, p1y, x, y, p2x, p2y);
        }

        count++;
      }
      p1x = p2x;
      p1y = p2y;
    }

    inside = count % 2 !== 0;
  }

  return inside;
},

/*
  * If two points are very closely spreaded, the point that was parsed later is given preference and returned
  hence.
  * This is important when two plots are very near, the tooltip and hover effects of the one that comes avobe is
  being displayed
  * @param p1 {Object} - The first point being compared.
  * @param p2 {Object} - The second point being compared in close vicinity of the first point (p1).
  * @return {Object} - The point that occurs later in the JSON data gets the preference.
*/
_compair2closest = function _compair2closest(p1, p2) {
  if (!p1 || p1 && p2 && p2.i > p1.i) {
    return p2;
  }
  return p1;
};

function kdTreeAbs(arr) {
  'use strict';
  // Max radius will be tolerance

  var tolerance = arr && arr[0] && arr[0].r || 5,
      i,
      max = Math.max,
      floor = Math.floor,
      sqrt = Math.sqrt,
      min = Math.min,
      log = Math.log,
      exp = Math.exp,
      pow = Math.pow,
      _quickselectX,
      _quickselectY;

  function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
  }
  _quickselectX = function quickselectX(arr, k, left, right) {
    var n, m, z, s, sd, newLeft, newRight, t, i, j;

    while (right > left) {
      if (right - left > 600) {
        n = right - left + 1;
        m = k - left + 1;
        z = log(n);
        s = 0.5 * exp(2 * z / 3);
        sd = 0.5 * sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
        newLeft = max(left, floor(k - m * s / n + sd));
        newRight = min(right, floor(k + (n - m) * s / n + sd));
        _quickselectX(arr, k, newLeft, newRight);
      }

      t = arr[k];
      i = left;
      j = right;

      swap(arr, left, k);
      if (arr[right].x > t.x) {
        swap(arr, left, right);
      }

      while (i < j) {
        swap(arr, i, j);
        i++;
        j--;
        while (arr[i].x < t.x) {
          i++;
        }
        while (arr[j].x > t.x) {
          j--;
        }
      }

      if (arr[left].x === t.x) {
        swap(arr, left, j);
      } else {
        j++;
        swap(arr, j, right);
      }

      if (j <= k) {
        left = j + 1;
      }
      if (k <= j) {
        right = j - 1;
      }
    }
  };

  _quickselectY = function quickselectY(arr, k, left, right) {
    var n, m, z, s, sd, newLeft, newRight, t, i, j;

    while (right > left) {
      if (right - left > 600) {
        n = right - left + 1;
        m = k - left + 1;
        z = log(n);
        s = 0.5 * exp(2 * z / 3);
        sd = 0.5 * sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
        newLeft = max(left, floor(k - m * s / n + sd));
        newRight = min(right, floor(k + (n - m) * s / n + sd));
        _quickselectY(arr, k, newLeft, newRight);
      }

      t = arr[k];
      i = left;
      j = right;

      swap(arr, left, k);
      if (arr[right].y > t.y) {
        swap(arr, left, right);
      }

      while (i < j) {
        swap(arr, i, j);
        i++;
        j--;
        while (arr[i].y < t.y) {
          i++;
        }
        while (arr[j].y > t.y) {
          j--;
        }
      }

      if (arr[left].y === t.y) {
        swap(arr, left, j);
      } else {
        j++;
        swap(arr, j, right);
      }

      if (j <= k) {
        left = j + 1;
      }
      if (k <= j) {
        right = j - 1;
      }
    }
  };

  arr = arr || [];
  // Find tolerance as the max radius
  // of the element
  for (i = arr.length; i--;) {
    if (arr[i].r > tolerance) {
      tolerance = arr[i].r;
    }
    // Setting the index
    arr[i].i = i;
    arr[i].x = +arr[i].x;
    arr[i].y = +arr[i].y;
  }
  // KdTree Definition below
  function buildKdTree(arr, left, right, isY) {
    var ob = {},
        mid,
        access = isY ? 'y' : 'x';
    if (left === right) {
      ob.point = arr[left];
      return ob;
    }
    if (right - left === 1) {
      if (arr[left][access] > arr[right][access]) {
        ob.point = arr[left];
        ob.left = {
          point: arr[right]
        };
      } else {
        ob.point = arr[right];
        ob.left = {
          point: arr[left]
        };
      }
      return ob;
    }

    mid = left + right >> 1;

    if (isY) {
      _quickselectY(arr, mid, left, right);
    } else {
      _quickselectX(arr, mid, left, right);
    }

    ob.point = arr[mid];
    ob.left = buildKdTree(arr, left, mid - 1, !isY);
    ob.right = buildKdTree(arr, mid + 1, right, !isY);
    return ob;
  }

  return {
    tree: arr.length === 0 ? {} : buildKdTree(arr, 0, arr.length - 1, false),
    search: function search(x, y, type, options) {
      // Actual search logic
      var tree = this.tree,
          res,
          x1 = x - tolerance,
          x2 = x + tolerance,
          y1 = y - tolerance,
          y2 = y + tolerance,
          lastHovered = false,
          lastDist = 0,
          searchX,
          searchY;
      options = options || {};
      // Calculate  distance between two points
      function calcDist(x, y, p, q) {
        return sqrt(pow(x - p, 2) + pow(y - q, 2));
      }
      // Check a point is in range w.r.t
      // to given range
      function inRange(a, b) {
        if (type === 'circle') {
          return calcDist(a, b, x, y) <= x1;
        }
        return a >= x1 && a <= x2 && b >= y1 && b <= y2;
      }
      function inRangeApply(a, r1, r2) {
        return a >= r1 && a <= r2;
      }
      // Helper function for search
      // to apply data if found
      function apply(ob) {
        var currentHovered = inRangeApply(x, ob.x1, ob.x2) && inRangeApply(y, ob.y1, ob.y2),
            currentDist = calcDist(x, y, ob.point.x, ob.point.y);

        if (!res) {
          res = ob;
          lastHovered = currentHovered;
          lastDist = currentDist;
          return;
        }
        if (currentHovered) {
          if (lastHovered) {
            if (ob.point.i > res.point.i) {
              res = ob;
              lastHovered = currentHovered;
              lastDist = currentDist;
            }
          } else {
            res = ob;
            lastHovered = currentHovered;
            lastDist = currentDist;
          }
        } else {
          if (!lastHovered) {
            if (currentDist < lastDist) {
              res = ob;
              lastHovered = currentHovered;
              lastDist = currentDist;
            }
          }
        }
      }
      function defineSearchArea(rx, ry) {
        if (type === 'circle') {
          // Defining box again
          x1 = rx;
        } else {
          x1 = x - rx || 0;
          x2 = x + rx || 0;
          y1 = y - ry || 0;
          y2 = y + ry || 0;
        }
      }

      // X and Y searching different for
      // maintaing performance
      searchY = function searchY(ob) {
        var rx, ry;
        // Not found
        if (!ob || !ob.point) {
          return;
        }
        rx = options.rx || ob.point.r;
        ry = options.ry || ob.point.r;
        // defining search area
        defineSearchArea(rx, ry);
        // If match found return
        if (inRange(ob.point.x, ob.point.y)) {
          apply(ob);
        }
        // If smaller x1 go left
        if (y1 <= ob.point.y) {
          searchX(ob.left);
        }
        // If bigger x2 goto right
        if (y2 >= ob.point.y) {
          searchX(ob.right);
        }
      };
      searchX = function searchX(ob) {
        var rx, ry;
        // Not found
        if (!ob || !ob.point) {
          return;
        }
        rx = options.rx || ob.point.r;
        ry = options.ry || ob.point.r;
        // defining search area
        defineSearchArea(rx, ry);
        // If match found return
        if (inRange(ob.point.x, ob.point.y)) {
          apply(ob);
        }
        // If smaller x1 go left
        if (x1 <= ob.point.x) {
          searchY(ob.left);
        }
        // If bigger x2 goto right
        if (x2 >= ob.point.x) {
          searchY(ob.right);
        }
      };

      searchX(tree);
      // Return point otherwise UNDEF value
      return res && res.point || res;
    }
  };
}
/*
  * The entire data of the dataset is converted to a tree like structure(namely kdTree).
  * This is very useful to traverse and extract details(e.g. for a tooltip) from a million array elements especially
  * to extract information of the hovered plot on each mouseMove.
  * @constructor
  */

var KdTree = function () {
  function KdTree(shape) {
    _classCallCheck(this, KdTree);

    var kdTreeObj = this;
    kdTreeObj.configure(shape);
  }

  KdTree.prototype.configure = function configure(shape) {
    var kdTreeObj = this;
    kdTreeObj.validatorFn = shape ? kdTreeObj.shapeValidator() : kdTreeObj.defaultValidator();
  };
  /*
    * Check Function: To determine if the mouseMove Point and the point to be searched are within limits
    * @param mousePoint {Object} - point extracted from the mouseMove.
    * @return {Function} - Returns if the setElem is in limit wrt the mouseMoved point.
  */


  KdTree.prototype.defaultValidator = function defaultValidator() {
    var kdTreeObj = this;
    return function (setElem) {
      var mousePoint = kdTreeObj.mousePoint;
      // Refer to the 2-D distance formula for two points
      // @returns {Boolean} - If the calculated distances are within the limits.
      return !!(setElem && Math.pow((setElem.x - mousePoint.x) / kdTreeObj.xLimit, 2) + Math.pow((setElem.y - mousePoint.y) / kdTreeObj.yLimit, 2) <= 1);
    };
  };

  KdTree.prototype.shapeValidator = function shapeValidator() {
    var kdTreeObj = this;

    return function (setElem) {
      var mousePoint = kdTreeObj.mousePoint,
          shapeInfo = setElem && setElem.shapeInfo,
          inside = false,
          type,
          innerradius,
          r,
          x = mousePoint.x,
          y = mousePoint.y,
          sides,
          startAngle,
          x1,
          x2,
          y1,
          y2;

      type = shapeInfo && shapeInfo.type;

      switch (type) {
        case 'circle':
          r = shapeInfo.radius;
          inside = isWithinCircle(x, y, setElem.x, setElem.y, r);
          break;

        case 'arc':
          innerradius = shapeInfo.innerradius;
          r = shapeInfo.radius;
          inside = !isWithinCircle(x, y, setElem.x, setElem.y, innerradius) && isWithinCircle(x, y, setElem.x, setElem.y, r);
          break;

        case 'polygon':
          r = shapeInfo.radius;
          startAngle = shapeInfo.startAngle;
          sides = shapeInfo.sides;
          inside = isWithinPolygon(x, y, setElem.x, setElem.y, r, sides, startAngle);
          break;

        case 'rect':
          x1 = setElem.x;
          y1 = setElem.y;
          x2 = x1 + (shapeInfo.width || 0);
          y2 = y1 + (shapeInfo.height || 0);
          inside = x >= x1 && x <= x2 && y >= y1 && y <= y2;
          break;

        case 'default':
          inside = false;
          break;
      }

      return inside;
    };
  };
  /*
    * Builds the tree structure from the data points provided.
    * @param points {Array} - The set level elements belonging to a particular dataset
    * Updates the tree structure in the tree property of the current instance.
    */


  KdTree.prototype.buildKdTree = function buildKdTree(points) {
    /*
      * _buildKdTree is for the internal use to build the tree recursively.
      * @param points {Array} - The set level elements.
      * @param isX {Boolean} - isX determines the sorting order. Initially setting the isX = false ensures that
      * the initial sorting order of the array is w.r.t to y - axis
    */
    this.kdTree = kdTreeAbs(points);
    this.tree = this.kdTree.tree;
    return this;
  };
  /*
    * Returns the nearest point to the point given.
    * @param point {Object} - the point of reference in whose neighbour the point required is to be returned
    * @return {Object} - The neighbouring point w.r.t to the point is hunted and returned once within limits
  */


  KdTree.prototype.getNeighbour = function getNeighbour(point, basicSearch, type) {
    var kDTreeObj = this,
        // Instance of the kdTree class specific to indivual dataset instance.
    tree = kDTreeObj.tree,
        // refer to the created tree like structure for that dataset instance.
    // limitBox - set the limiting boundaries for the neighbour hunt of the given point.
    limitBox = {
      x1: point.x - kDTreeObj.xLimit,
      x2: point.x + kDTreeObj.xLimit,
      y1: point.y - kDTreeObj.yLimit,
      y2: point.y + kDTreeObj.yLimit
    },

    // function specific to a paricular point that retruns Boolean if the neighbour searched is within limits
    validatorFn = kDTreeObj.validatorFn;
    kDTreeObj.mousePoint = point;
    // If basic search is on will use the search function from the
    // abstract implementation of kdTree
    if (basicSearch) {
      return this.kdTree && this.kdTree.search(point.x, point.y, type, point.options);
    }
    // When the renderring turns heavy, probably then the tree is not yet build.
    // Proceed further only if the tree exists.
    if (tree) {
      // search the nearest points within limits and return it.
      return kDTreeObj._searchBtwnLimit(limitBox, tree, true, validatorFn);
    }
  };
  /*
    * Search and return the nearest neighbouring point in the pre defined limits.
    * @param limitBox {Object} - Boundary conditions for the tolerance for the neighbourhood search.
    * @param tree {Object} - The tree within which the point is needed to be searched,
    * @param isX {Boolean} - Flag representative of the axis. This gets swapped everytime the function is called
    recursively
    * @param validatorFn {Function} - Returns if the point is within the limits.
    * @return returnPoint {Object} - neighbouring point.
  */


  KdTree.prototype._searchBtwnLimit = function _searchBtwnLimit(limitBox, tree, isX, validatorFn) {
    var point,
        returnPoint,
        kdTreeObj = this,
        axis = isX ? 'x' : 'y',

    // get the lower and upper limits in accordance to the axis being referenced.
    lowerLimit = isX ? limitBox.x1 : limitBox.y1,
        upperLimit = isX ? limitBox.x2 : limitBox.y2;
    // Proceed further only when tree is defined
    point = tree && tree.point && tree.point[axis];
    if (point === UNDEF) {
      return;
    }
    // point1 is within limit;
    if (validatorFn(tree.point)) {
      // In case of two closely spaced points, they are chosen preferably using _compair2closest()
      returnPoint = tree.point;
    }
    // search the left side if required
    if (point >= lowerLimit && tree.left) {
      // if left is available then search on left
      returnPoint = _compair2closest(returnPoint, kdTreeObj._searchBtwnLimit(limitBox, tree.left, !isX, validatorFn));
    }
    // search the right side if required
    if (point <= upperLimit && tree.right) {
      // if left is available then search on left
      returnPoint = _compair2closest(returnPoint, kdTreeObj._searchBtwnLimit(limitBox, tree.right, !isX, validatorFn));
    }
    return returnPoint;
  };
  /*
    * Sets the tolerance limit for kdTree search after every zoom level
    * @param xLimit {Number} - The limiting tolerance in the x-axis
    * @param yLimit {Number} - The limiting tolerance in the y-axis
    */


  KdTree.prototype._setSearchLimit = function _setSearchLimit(xLimit, yLimit) {
    var kdTree = this;
    // sets the x and y limits.
    kdTree.xLimit = xLimit;
    kdTree.yLimit = yLimit;
  };

  return KdTree;
}();
// reset the constructor


KdTree.prototype.constructor = KdTree;

exports['default'] = KdTree;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports._createDatasets = undefined;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(14);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _column = __webpack_require__(8);

var _column2 = _interopRequireDefault(_column);

var _cartesian = __webpack_require__(18);

var _cartesian2 = _interopRequireDefault(_cartesian);

var _column3 = __webpack_require__(15);

var _column4 = _interopRequireDefault(_column3);

var _lib = __webpack_require__(5);

var _fill = __webpack_require__(95);

var _fill2 = _interopRequireDefault(_fill);

var _map = __webpack_require__(60);

var _map2 = _interopRequireDefault(_map);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * function to  create dataset, groupmaneger.
 * assign dataset to group manager.
 **/
var __createDatasets = function __createDatasets() {
  var iapi = this,
      jsonData = iapi._getJSONdata(),
      pDatasetsJSON = jsonData.dataset,
      pLength = pDatasetsJSON && pDatasetsJSON.length,
      i = void 0,
      length = void 0,
      prevLength = 0,
      datasetsJSON = void 0,
      canvas = iapi.getChildren('canvas')[0],
      vCanvas = canvas.getChildren('vCanvas')[0],
      indices = void 0,
      stackGroups = void 0,
      stackGroupParent = void 0;

  if (!pDatasetsJSON) {
    iapi.setChartMessage();
    return;
  }

  (0, _lib.componentFactory)(vCanvas, _column4['default'], 'multiSeriesGroup_column');
  stackGroupParent = vCanvas.getChildren('multiSeriesGroup_column')[0];

  (0, _lib.componentFactory)(stackGroupParent, iapi.getDSGroupdef(), 'stackedGroup_column', pLength);
  stackGroups = stackGroupParent.getChildren('stackedGroup_column');
  for (i = 0; i < stackGroups.length; i++) {
    if (stackGroups[i].getState('removed') !== true) {
      datasetsJSON = pDatasetsJSON[i].dataset;
      if (!datasetsJSON) {
        iapi.setChartMessage();
        return;
      }
      length = datasetsJSON && datasetsJSON.length;
      indices = _map2['default'].call(_fill2['default'].call(Array(length), i * prevLength), function (n, j) {
        return n + j;
      });
      (0, _lib.datasetFactory)(stackGroups[i], iapi.getDSdef(), 'dataset_column', length, datasetsJSON, indices);

      prevLength = length;
    }
  }
  iapi.config._lastDatasetIndex = indices[indices.length - 1];
};

var MSStackedColumn2D = function (_MSCartesian) {
  _inherits(MSStackedColumn2D, _MSCartesian);

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  MSStackedColumn2D.getName = function getName() {
    return 'MSStackedColumn2D';
  };

  function MSStackedColumn2D() {
    _classCallCheck(this, MSStackedColumn2D);

    var _this = _possibleConstructorReturn(this, _MSCartesian.call(this));

    _this.defaultDatasetType = 'column';
    _this.friendlyName = 'Multi-series Stacked Column Chart';
    return _this;
  }

  MSStackedColumn2D.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _MSCartesian.prototype.__setDefaultConfig && _MSCartesian.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    config.isstacked = true;
    config.enablemousetracking = true;
  };

  /**
   * Function to get the json data
   * @return {Object} the json data
   */


  MSStackedColumn2D.prototype._getJSONdata = function _getJSONdata() {
    return this.jsonData;
  };
  /**
   * function to  create dataset, groupmaneger.
   * assign dataset to group manager.
   **/


  MSStackedColumn2D.prototype._createDatasets = function _createDatasets() {
    __createDatasets.call(this);
  };

  /**
   * This method return the dataset definations for this charts
   * @return {object} return column dataset
   */


  MSStackedColumn2D.prototype.getDSdef = function getDSdef() {
    return _column2['default'];
  };
  /** This method return the dataset-group definations for this charts **/


  MSStackedColumn2D.prototype.getDSGroupdef = function getDSGroupdef() {
    return _cartesian2['default'];
  };

  return MSStackedColumn2D;
}(_fusioncharts2['default']);

exports['default'] = MSStackedColumn2D;
exports._createDatasets = __createDatasets;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(442);
module.exports = __webpack_require__(66)('Array').fill;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports._createDatasets = undefined;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(57);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _column = __webpack_require__(8);

var _column2 = _interopRequireDefault(_column);

var _area = __webpack_require__(20);

var _area2 = _interopRequireDefault(_area);

var _line = __webpack_require__(11);

var _line2 = _interopRequireDefault(_line);

var _column3 = __webpack_require__(15);

var _column4 = _interopRequireDefault(_column3);

var _lib = __webpack_require__(5);

var _lib2 = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var UNDEF = void 0,
    MULTISERIESCOLUMNMANAGER = 'multiseriesColumnManager',
    LINE = 'line',
    AREA = 'area',
    _createDatasets = void 0,

/**
 * splice a given array with the given value
 * @param  {Array} array   on which splice opration will be executed
 * @param  {generic} value criteria to splice the array
 */
arraySpliceByValue = function arraySpliceByValue(array, value) {
  var indexOf = array.indexOf(value);
  if (indexOf !== -1) {
    array.splice(indexOf, 1);
  }
},

/**
 * function to remove component if name is matched with value in set
 * @param  {Object} component from where it would iterate
 * @param  {Array} set        criteria; if matched then remove
 */
removeComponents = function removeComponents(component, set) {
  var i = void 0;
  component && component.iterateComponents(function (child) {
    for (i = 0; i < set.length; i++) {
      if (child.getName() === set[i]) {
        child.remove();
      }
    }
  });
},
    SEVENTYSTRING = _lib2.preDefStr.SEVENTYSTRING;

var MSCombidy2D = function (_MSDyBaseCartesian) {
  _inherits(MSCombidy2D, _MSDyBaseCartesian);

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  MSCombidy2D.getName = function getName() {
    return 'MSCombidy2D';
  };

  function MSCombidy2D() {
    _classCallCheck(this, MSCombidy2D);

    var _this = _possibleConstructorReturn(this, _MSDyBaseCartesian.call(this));

    _this.friendlyName = 'Multi-series Dual Y-Axis Combination Chart';
    _this.isDual = true;
    _this.defaultDatasetType = 'column';
    _this.sDefaultDatasetType = 'line';
    return _this;
  }

  MSCombidy2D.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _MSDyBaseCartesian.prototype.__setDefaultConfig && _MSDyBaseCartesian.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    config.enablemousetracking = true;
    config.isdual = 1;
    // Area default configurations
    config.anchorborderthickness = 1;
    config.anchorimageurl = UNDEF;
    config.anchorimagepadding = 1;
    config.anchorsides = 1;
    config.anchoralpha = UNDEF;
    config.anchorbgalpha = _lib2.HUNDREDSTRING;
    config.anchorimagealpha = _lib2.HUNDREDSTRING;
    config.anchorimagescale = 100;
    config.anchorstartangle = 90;
    config.anchorshadow = 0;
    config.anchorbgcolor = UNDEF;
    config.anchorbordercolor = UNDEF;
    config.anchorradius = 3;
    config.showvalues = 1;
    config.plotfillalpha = SEVENTYSTRING;
    config.linedashlen = 5;
    config.linedashgap = 4;
    config.linedashed = UNDEF;
    config.linealpha = _lib2.HUNDREDSTRING;
    config.linethickness = 2;
    config.drawfullareaborder = 1;
    config.connectnulldata = 0;
  };
  /**
   * function to  create dataset, groupmaneger.
   * assign dataset to group manager.
   **/


  MSCombidy2D.prototype._createDatasets = function _createDatasets() {
    var iapi = this,
        jsonData = iapi.jsonData,
        datasetsJSON = jsonData.dataset,
        children = iapi.getChildren(),
        canvas = children.canvas[0],
        vCanvasArr = canvas.getChildren('vCanvas'),
        vCanvas = vCanvasArr[0],
        svCanvas = vCanvasArr[1],
        datasetJSON = void 0,
        isdual = iapi.getFromEnv('chartConfig').isdual,
        i = void 0,
        canvasDatasetsDef = {
      vCanvasDatasetsDef0: {},
      vCanvasDatasetsDef1: {}
    },
        datasetsDef = void 0,
        datasetDef = void 0,
        DsGroupClass = void 0,
        dsType = void 0,
        parentyaxis = void 0,
        relatedVCanvas = void 0,
        relatedPrevDatasetMap = void 0,
        prevDatasetMap = {
      vCanvas0: [MULTISERIESCOLUMNMANAGER, LINE, AREA],
      vCanvas1: [MULTISERIESCOLUMNMANAGER, LINE, AREA]
    };

    if (!datasetsJSON) {
      iapi.setChartMessage();
    }

    for (i = 0; i < datasetsJSON.length; i++) {
      datasetJSON = datasetsJSON[i];
      parentyaxis = datasetJSON.parentyaxis || '';
      if (parentyaxis.toLowerCase() === 's' && isdual) {
        dsType = (0, _lib.pluck)(datasetJSON.renderas, iapi.sDefaultDatasetType);
        relatedVCanvas = svCanvas;
        relatedPrevDatasetMap = prevDatasetMap.vCanvas1;
        datasetsDef = canvasDatasetsDef.vCanvasDatasetsDef1;
      } else {
        dsType = (0, _lib.pluck)(datasetJSON.renderas, iapi.defaultDatasetType);
        relatedVCanvas = vCanvas;
        relatedPrevDatasetMap = prevDatasetMap.vCanvas0;
        datasetsDef = canvasDatasetsDef.vCanvasDatasetsDef0;
      }
      dsType = iapi.getDSType(dsType);
      DsGroupClass = iapi.getDSGroupdef(dsType, parentyaxis);
      if (DsGroupClass) {
        (0, _lib2.componentFactory)(relatedVCanvas, DsGroupClass, MULTISERIESCOLUMNMANAGER);
        arraySpliceByValue(relatedPrevDatasetMap, MULTISERIESCOLUMNMANAGER);
      }
      if (datasetsDef[dsType]) {
        datasetsDef[dsType].conf.push(datasetJSON);
        datasetsDef[dsType].indices.push(i);
      } else {
        datasetsDef[dsType] = {};
        datasetsDef[dsType].indices = [i];
        datasetsDef[dsType].classDef = iapi.getDSdef(dsType);
        datasetsDef[dsType].conf = [datasetJSON];
        datasetsDef[dsType].pYAxis = parentyaxis.toLowerCase();
        datasetsDef[dsType].parent = DsGroupClass ? relatedVCanvas.getChildren(MULTISERIESCOLUMNMANAGER)[0] : relatedVCanvas;
      }
    }
    for (var key in canvasDatasetsDef) {
      if (canvasDatasetsDef.hasOwnProperty(key)) {
        datasetsDef = canvasDatasetsDef[key];
        for (dsType in datasetsDef) {
          if (datasetsDef.hasOwnProperty(dsType)) {
            datasetDef = datasetsDef[dsType];
            arraySpliceByValue(datasetDef.pYAxis === 's' && isdual ? prevDatasetMap.vCanvas1 : prevDatasetMap.vCanvas0, dsType);
            (0, _lib2.datasetFactory)(datasetDef.parent, datasetDef.classDef, 'dataset_' + dsType, datasetDef.conf.length, datasetDef.conf, datasetDef.indices);
          }
        }
      }
    }

    removeComponents(vCanvasArr[0], prevDatasetMap.vCanvas0);
    removeComponents(vCanvasArr[1], prevDatasetMap.vCanvas1);
  };
  /**
   * This method return the dataset definations for this charts
   * @param  {string} name type of dataset class
   * @return {class}      class of dataset
   */


  MSCombidy2D.prototype.getDSdef = function getDSdef(name) {
    return name === 'area' ? _area2['default'] : name === 'line' ? _line2['default'] : _column2['default'];
  };
  /**
   * This method return the dataset group definations for this charts
   * @param  {string} name type of dataset group class
   * @return {class}      class of dataset group
   */


  MSCombidy2D.prototype.getDSGroupdef = function getDSGroupdef(name) {
    return name === 'column' ? _column4['default'] : UNDEF;
  };
  /**
   * function to return dataset type applicable for this chart
   * @param   {string}  name  dataset type
   * @return  {string}        dataset type applicable for this chart
   */


  MSCombidy2D.prototype.getDSType = function getDSType(name) {
    return name && name.toLowerCase() === 'area' ? 'area' : name && name.toLowerCase() === 'line' ? 'line' : 'column';
  };

  return MSCombidy2D;
}(_fusioncharts2['default']);

exports._createDatasets = _createDatasets = MSCombidy2D.prototype._createDatasets;
exports._createDatasets = _createDatasets;
exports['default'] = MSCombidy2D;

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.configure = exports._resetViewPortConfig = exports._setAxisScale = undefined;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(14);

var _fusioncharts2 = __webpack_require__(23);

var _fusioncharts3 = _interopRequireDefault(_fusioncharts2);

var _column = __webpack_require__(8);

var _column2 = _interopRequireDefault(_column);

var _column3 = __webpack_require__(15);

var _column4 = _interopRequireDefault(_column3);

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */


var mathFloor = Math.floor,
    UNDEF = void 0;
/**
 * Sets xAxis scale visible region
 */
function _setAxisScale2() {
  var iapi = this,
      config = iapi.config,
      xAxis = iapi.getChildren('xAxis')[0],
      xAxisConfig = xAxis.config,
      catCount = xAxis.getCategoryLen(),
      jsonData = iapi.jsonData,
      chartAttr = jsonData.chart,
      chartWidth = config.width,
      xAxisMin,
      xAxisMax,
      minVisiblePlots = 2,
      // at the least a scroll chart must show 2 plots
  numOfColumnSeries = 0,
      totalNumPoint,
      visibleRange,
      scrollToEnd = config.scrollToEnd,

  // number of columns to be drawn.
  numVisiblePlot = (0, _lib.pluckNumber)(chartAttr.numvisibleplot, mathFloor(chartWidth / iapi.avgScrollPointWidth));

  iapi.iterateComponents(function (child) {
    if (child.getType && child.getType() === 'dataset') {
      if (child.getName && child.getName() === 'column') {
        numOfColumnSeries++;
      }
    }
  });

  if (iapi.config.isstacked) {
    numOfColumnSeries = 1;
  }

  numOfColumnSeries = numOfColumnSeries || 1;

  totalNumPoint = catCount * numOfColumnSeries;

  if (xAxis.tempAxis) {
    xAxisMin = xAxis.tempAxis.visibleRange.min;
    xAxisMax = xAxis.tempAxis.visibleRange.max;
  } else {
    xAxisMin = xAxisConfig.axisRange.min;
    xAxisMax = xAxisConfig.axisRange.max;
  }

  if (numVisiblePlot >= minVisiblePlots && numVisiblePlot < totalNumPoint) {
    visibleRange = numVisiblePlot / numOfColumnSeries;
    xAxis.setScrollType('always');
    if (scrollToEnd) {
      xAxisMin = xAxisMax - visibleRange;
    } else {
      xAxisMax = xAxisMin + visibleRange;
    }
    xAxis.setVisibleConfig(xAxisMin, xAxisMax);
  } else {
    xAxis.setScrollType('none');
  }
}

/**
 * Reset view port
 */
function _resetViewPortConfig2() {
  var iapi = this;

  iapi.config.viewPortConfig = {
    scaleX: 1,
    scaleY: 1,
    x: 0,
    y: 0
  };
}

/**
 * function to create component and configure and also configure the chart
 * It creates components which are depend on data and configure them and also configure chart
 * It calls helper function namely, configure
 * @param  {Object} dataObj contains json data of the chart
 */
function _configure(dataObj) {
  var chart = this,
      jsonData = chart.jsonData,
      chartAttr = jsonData.chart,
      chartConfig;
  _fusioncharts.configure.call(this, dataObj);
  chartConfig = chart.config;
  chartConfig.scrollToEnd = (0, _lib.pluckNumber)(chartAttr.scrolltoend, 0);
  chartConfig.lastScrollPosition = UNDEF;
}
/**
 * Creates ScrollColumn2D class
 */

var ScrollColumn2D = function (_MScolumn2D) {
  _inherits(ScrollColumn2D, _MScolumn2D);

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  ScrollColumn2D.getName = function getName() {
    return 'ScrollColumn2D';
  };

  /**
   * Constructor fn of ScrollColumn2D class
   */


  function ScrollColumn2D() {
    _classCallCheck(this, ScrollColumn2D);

    var _this = _possibleConstructorReturn(this, _MScolumn2D.call(this));

    _this.friendlyName = 'Scrollable Multi-series Column Chart';
    _this.tooltipConstraint = 'plot';
    _this.canvasborderthickness = 1;
    _this.defaultDatasetType = 'column';
    _this.avgScrollPointWidth = 40;
    _this.hasScroll = true;
    _this.defaultPlotShadow = 1;
    _this.binSize = 0;
    return _this;
  }

  /**
   * function to create component and configure and also configure the chart
   * It creates components which are depend on data and configure them and also configure chart
   * It calls helper function namely, configure
   * @param  {Object} dataObj contains json data of the chart
   */


  ScrollColumn2D.prototype.configure = function configure(dataObj) {
    _configure.call(this, dataObj);
  };

  /**
   * Sets xAxis scale visible region
   */


  ScrollColumn2D.prototype._setAxisScale = function _setAxisScale() {
    _setAxisScale2.call(this);
  };

  /**
   * Reset view port
   */


  ScrollColumn2D.prototype._resetViewPortConfig = function _resetViewPortConfig() {
    _resetViewPortConfig2.call(this);
  };
  /**
   * Returns dataset class
   * @return {class} returns ColumnDataset class
   */


  ScrollColumn2D.prototype.getDSdef = function getDSdef() {
    return _column2['default'];
  };
  /**
   * Returns dataset group class
   * @return {class} returns Columngroup class
   */


  ScrollColumn2D.prototype.getDSGroupdef = function getDSGroupdef() {
    return _column4['default'];
  };

  return ScrollColumn2D;
}(_fusioncharts3['default']);

exports['default'] = ScrollColumn2D;
exports._setAxisScale = _setAxisScale2;
exports._resetViewPortConfig = _resetViewPortConfig2;
exports.configure = _configure;

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(23);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var ScatterBase = function (_MSColumn2D) {
  _inherits(ScatterBase, _MSColumn2D);

  function ScatterBase() {
    _classCallCheck(this, ScatterBase);

    return _possibleConstructorReturn(this, _MSColumn2D.apply(this, arguments));
  }

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  ScatterBase.getName = function getName() {
    return 'ScatterBase';
  };

  ScatterBase.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _MSColumn2D.prototype.__setDefaultConfig && _MSColumn2D.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    config.zeroplanethickness = 1;
    config.zeroplanealpha = 40;
    config.showzeroplaneontop = 0;
    config.setadaptivexmin = 1;
  };

  ScatterBase.prototype._setCategories = function _setCategories() {
    var iapi = this,
        dataObj = iapi.jsonData,
        chartAttr = dataObj.chart,
        xAxis = iapi.getChildren('xAxis'),
        xAxisLabelMode = (0, _lib.pluck)(chartAttr.xaxislabelmode, 'categories'),
        categories = dataObj.categories && dataObj.categories[0].category;
    xAxis[0].setAxisConfig({
      xAxisLabelMode: 'categories'
    });
    if (xAxisLabelMode !== 'auto' && xAxisLabelMode !== 'mixed' && categories && categories.length > 0) {
      xAxis[0].setCategory(categories);
    } else if (xAxisLabelMode !== 'auto') {
      xAxis[0].setCategory(categories, false);
      xAxis[0].setAxisConfig({
        xAxisLabelMode: 'mixed'
      });
    } else {
      xAxis[0].setAxisConfig({
        xAxisLabelMode: 'auto'
      });
    }
  };
  /*
   * Gets the starting index and difference information for data hiding.
  */
  // _getDiff (DataDiff, currDataLength) {
  //   return {
  //     diff: DataDiff,
  //     startIndex: currDataLength
  //   };
  // }


  return ScatterBase;
}(_fusioncharts2['default']);

exports['default'] = ScatterBase;

/***/ }),
/* 99 */,
/* 100 */,
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports._createDatasets = undefined;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(96);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _column = __webpack_require__(8);

var _column2 = _interopRequireDefault(_column);

var _mssplinearea = __webpack_require__(45);

var _mssplinearea2 = _interopRequireDefault(_mssplinearea);

var _msspline = __webpack_require__(27);

var _msspline2 = _interopRequireDefault(_msspline);

var _column3 = __webpack_require__(15);

var _column4 = _interopRequireDefault(_column3);

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */


var UNDEFINED,

/**
 * splice a given array with the given value
 * @param  {Array} array   on which splice opration will be executed
 * @param  {generic} value criteria to splice the array
 */
arraySpliceByValue = function arraySpliceByValue(array, value) {
  var indexOf = array.indexOf(value);
  if (indexOf !== -1) {
    array.splice(indexOf, 1);
  }
},

/**
 * function to remove component if name is matched with value in set
 * @param  {Object} component from where it would iterate
 * @param  {Array} set        criteria; if matched then remove
 */
removeComponents = function removeComponents(component, set) {
  var i = void 0;
  component && component.iterateComponents(function (child) {
    for (i = 0; i < set.length; i++) {
      if (child.getName() === set[i]) {
        child.remove();
      }
    }
  });
},
    MULTISERIESCOLUMNMANAGER = 'multiseriesColumnManager',
    SPLINE = 'spline',
    SPLINEAREA = 'splinearea',

/**
 * function to  create dataset, groupmaneger.
 * assign dataset to group manager.
 **/
_createDatasets2 = function _createDatasets2() {
  var iapi = this,
      jsonData = iapi.jsonData,
      datasetsJSON = jsonData.dataset,
      children = iapi.getChildren(),
      canvas = children.canvas[0],
      vCanvasArr = canvas.getChildren('vCanvas'),
      vCanvas = vCanvasArr[0],
      svCanvas = vCanvasArr[1],
      datasetJSON = void 0,
      isdual = iapi.getFromEnv('chartConfig').isdual,
      i = void 0,
      canvasDatasetsDef = {
    vCanvasDatasetsDef0: {},
    vCanvasDatasetsDef1: {}
  },
      datasetsDef = void 0,
      datasetDef = void 0,
      DsGroupClass = void 0,
      dsType = void 0,
      parentyaxis = void 0,
      relatedVCanvas = void 0,
      relatedPrevDatasetMap = void 0,
      prevDatasetMap = {
    vCanvas0: [MULTISERIESCOLUMNMANAGER, SPLINE, SPLINEAREA],
    vCanvas1: [MULTISERIESCOLUMNMANAGER, SPLINE, SPLINEAREA]
  };

  if (!datasetsJSON) {
    iapi.setChartMessage();
  }

  for (i = 0; i < datasetsJSON.length; i++) {
    datasetJSON = datasetsJSON[i];
    parentyaxis = datasetJSON.parentyaxis || '';
    if (parentyaxis.toLowerCase() === 's' && isdual) {
      dsType = (0, _lib.pluck)(datasetJSON.renderas, iapi.sDefaultDatasetType);
      relatedVCanvas = svCanvas;
      relatedPrevDatasetMap = prevDatasetMap.vCanvas1;
      datasetsDef = canvasDatasetsDef.vCanvasDatasetsDef1;
    } else {
      dsType = (0, _lib.pluck)(datasetJSON.renderas, iapi.defaultDatasetType);
      relatedVCanvas = vCanvas;
      relatedPrevDatasetMap = prevDatasetMap.vCanvas0;
      datasetsDef = canvasDatasetsDef.vCanvasDatasetsDef0;
    }
    dsType = iapi.getDSType(dsType);
    DsGroupClass = iapi.getDSGroupdef(dsType, parentyaxis);
    if (DsGroupClass) {
      (0, _lib.componentFactory)(relatedVCanvas, DsGroupClass, MULTISERIESCOLUMNMANAGER);
      arraySpliceByValue(relatedPrevDatasetMap, MULTISERIESCOLUMNMANAGER);
    }
    if (datasetsDef[dsType]) {
      datasetsDef[dsType].conf.push(datasetJSON);
      datasetsDef[dsType].indices.push(i);
    } else {
      datasetsDef[dsType] = {};
      datasetsDef[dsType].indices = [i];
      datasetsDef[dsType].classDef = iapi.getDSdef(dsType);
      datasetsDef[dsType].conf = [datasetJSON];
      datasetsDef[dsType].pYAxis = parentyaxis.toLowerCase();
      datasetsDef[dsType].parent = DsGroupClass ? relatedVCanvas.getChildren(MULTISERIESCOLUMNMANAGER)[0] : relatedVCanvas;
    }
  }
  for (var key in canvasDatasetsDef) {
    if (canvasDatasetsDef.hasOwnProperty(key)) {
      datasetsDef = canvasDatasetsDef[key];
      for (dsType in datasetsDef) {
        if (datasetsDef.hasOwnProperty(dsType)) {
          datasetDef = datasetsDef[dsType];

          arraySpliceByValue(datasetDef.pYAxis === 's' && isdual ? prevDatasetMap.vCanvas1 : prevDatasetMap.vCanvas0, dsType);
          (0, _lib.datasetFactory)(datasetDef.parent, datasetDef.classDef, 'dataset_' + dsType, datasetDef.conf.length, datasetDef.conf, datasetDef.indices);
        }
      }
    }
  }

  removeComponents(vCanvasArr[0], prevDatasetMap.vCanvas0);
  removeComponents(vCanvasArr[1], prevDatasetMap.vCanvas1);
};
/**
 * class definition for MSCombiDy2DSpline chart API
 */

var MSCombiDy2DSpline = function (_MSCombidy2D) {
  _inherits(MSCombiDy2DSpline, _MSCombidy2D);

  /**
   * constructor fn
   */
  function MSCombiDy2DSpline() {
    _classCallCheck(this, MSCombiDy2DSpline);

    var _this = _possibleConstructorReturn(this, _MSCombidy2D.call(this));

    _this.friendlyName = 'Multi-series Combination Spline Chart';
    _this.defaultDatasetType = 'column';
    _this.sDefaultDatasetType = 'spline';
    return _this;
  }

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */


  MSCombiDy2DSpline.getName = function getName() {
    return 'MSCombiDy2DSpline';
  };

  /**
   * function to  create dataset, groupmaneger.
   * assign dataset to group manager.
   **/


  MSCombiDy2DSpline.prototype._createDatasets = function _createDatasets() {
    _createDatasets2.call(this);
  };
  /**
   * This method return the dataset definations for this charts
   * @param  {string} name type of dataset class
   * @return {Object}      dataset class
   */


  MSCombiDy2DSpline.prototype.getDSdef = function getDSdef(name) {
    return name === 'splinearea' ? _mssplinearea2['default'] : name === 'spline' ? _msspline2['default'] : _column2['default'];
  };
  /**
   * This method return the dataset-group definations for this charts
   * @param  {string} name is type of dataset group
   * @return {Object} <dataset group class>     dataset group class
   */


  MSCombiDy2DSpline.prototype.getDSGroupdef = function getDSGroupdef(name) {
    return name === 'column' ? _column4['default'] : UNDEFINED;
  };
  /**
   * function to return dataset type applicable for this chart
   * @param   {string}  name  dataset type
   * @return  {string}        dataset type applicable for this chart
   */


  MSCombiDy2DSpline.prototype.getDSType = function getDSType(name) {
    return name && name.toLowerCase() === 'splinearea' ? 'splinearea' : name && name.toLowerCase() === 'spline' ? 'spline' : 'column';
  };

  return MSCombiDy2DSpline;
}(_fusioncharts2['default']);

exports['default'] = MSCombiDy2DSpline;
exports._createDatasets = _createDatasets2;

/***/ }),
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

/***/ }),
/* 111 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};

/***/ }),
/* 112 */
/***/ (function(module, exports) {

module.exports = true;

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(64);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function(it, S){
  if(!isObject(it))return it;
  var fn, val;
  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ }),
/* 114 */
/***/ (function(module, exports) {

module.exports = {};

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject    = __webpack_require__(63)
  , dPs         = __webpack_require__(284)
  , enumBugKeys = __webpack_require__(118)
  , IE_PROTO    = __webpack_require__(116)('IE_PROTO')
  , Empty       = function(){ /* empty */ }
  , PROTOTYPE   = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function(){
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(176)('iframe')
    , i      = enumBugKeys.length
    , lt     = '<'
    , gt     = '>'
    , iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(288).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties){
  var result;
  if(O !== null){
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty;
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(117)('keys')
  , uid    = __webpack_require__(76);
module.exports = function(key){
  return shared[key] || (shared[key] = uid(key));
};

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(32)
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};

/***/ }),
/* 118 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(38).f
  , has = __webpack_require__(40)
  , TAG = __webpack_require__(51)('toStringTag');

module.exports = function(it, tag, stat){
  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
};

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(111);
module.exports = function(it){
  return Object(defined(it));
};

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(51);

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

var global         = __webpack_require__(32)
  , core           = __webpack_require__(19)
  , LIBRARY        = __webpack_require__(112)
  , wksExt         = __webpack_require__(121)
  , defineProperty = __webpack_require__(38).f;
module.exports = function(name){
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
};

/***/ }),
/* 123 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

var pIE            = __webpack_require__(77)
  , createDesc     = __webpack_require__(75)
  , toIObject      = __webpack_require__(33)
  , toPrimitive    = __webpack_require__(113)
  , has            = __webpack_require__(40)
  , IE8_DOM_DEFINE = __webpack_require__(175)
  , gOPD           = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(39) ? gOPD : function getOwnPropertyDescriptor(O, P){
  O = toIObject(O);
  P = toPrimitive(P, true);
  if(IE8_DOM_DEFINE)try {
    return gOPD(O, P);
  } catch(e){ /* empty */ }
  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
};

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(31)
  , core    = __webpack_require__(19)
  , fails   = __webpack_require__(49);
module.exports = function(KEY, exec){
  var fn  = (core.Object || {})[KEY] || Object[KEY]
    , exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
};

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.getValue = exports.getMetaSentence = exports.moduleDependencies = exports.injectModuleDependency = exports.cleanupWaitingCommands = exports.needsModule = exports.getDependentFileName = exports.moduleCmdQueue = exports.cmdQueue = exports.loadModule = exports.hasFileLoaded = exports.hasModule = undefined;

var _iterator = __webpack_require__(9);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(10);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2['default'] === "function" && typeof _iterator2['default'] === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2['default'] === "function" && obj.constructor === _symbol2['default'] && obj !== _symbol2['default'].prototype ? "symbol" : typeof obj; };

var _lib = __webpack_require__(5);

var _eventApi = __webpack_require__(7);

var _constructor = __webpack_require__(79);

var _constructor2 = _interopRequireDefault(_constructor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var // MODULE_NAME_BASE = 'modules.renderer.js-',
getMetaSentence = function () {
  var cache = {};
  return function (composite) {
    composite = composite && composite.replace(/(^\s*)|(\s*$)/g, '') || '';
    return cache[composite] || (cache[composite] = {
      key: composite,
      subject: composite.replace(/[^\/]*?$/ig, ''),
      predicate: composite.replace(/^.*\//ig, '')
    });
  };
}(),
    moduleCmdQueue = {
  base: [],
  charts: [],
  powercharts: [],
  widgets: [],
  maps: []
},
    moduleDependencies = {},
    cmdQueue = [],

/**
 * The enumeration of default filenames for each of the dependent
 * modules.
 * @type object
 * @constant
 */
moduleMeta = {
  base: 'fusioncharts.js',
  charts: 'fusioncharts.charts.js',
  powercharts: 'fusioncharts.powercharts.js',
  widgets: 'fusioncharts.widgets.js',
  maps: 'fusioncharts.maps.js'
},


/**
 * getter funtion for moduleMeta
 * @param {string} key The shorthand file name
 * @return {string} The full file name
 */
getFileName = function getFileName(key) {
  return moduleMeta[key] || key;
},


/**
 * Function to get the value against a key of an object ignoring its case
 * @param {Object} obj The concerned object
 * @param {string} key The concerned key
 * @return {value} The value against the key
 */
getValue = function getValue(obj, key) {
  for (var i in obj) {
    if (obj.hasOwnProperty(i) && i.toLowerCase() === key) {
      return obj[i];
    }
  }
},
    blockedModules = {},
    hasModule = void 0,
    hasFileLoaded = void 0,
    loadModule = void 0,
    needsModule = void 0,
    injectModuleDependency = void 0,
    cleanupWaitingCommands = void 0,
    getDependentFileName = void 0,
    rendererInterface = void 0,
    _global = void 0,
    UNDEF = void 0;

// Function that checks whether a particular module is loaded.
exports.hasModule = hasModule = function hasModule(name) {
  var i, l;
  // In case we check presense of multiple modules.
  if (name instanceof Array) {
    for (i = 0, l = name.length; i < l; i += 1) {
      if (!_constructor2['default'].getDep(name, 'chart')) {
        return false;
      }
    }
    return true;
  }
  return Boolean(_constructor2['default'].getDep(name, 'chart'));
};

/**
 * Function to check if the file has been loaded
 * @param {string} name file name
 * @return {boolean} true/false
 */
exports.hasFileLoaded = hasFileLoaded = function hasFileLoaded(name) {
  var i, l;
  if (name instanceof Array) {
    for (i = 0, l = name.length; i < l; i += 1) {
      if (!_constructor2['default'].getFile(getFileName(name))) {
        return false;
      }
    }
    return true;
  }
  return _constructor2['default'].getFile(getFileName(name));
};

// Function to call the global loadScript function for loading an html5 module.
exports.loadModule = loadModule = function loadModule(name, success, failure) {
  // convert single string to array of one string.
  if (!(name instanceof Array)) {
    name = [name];
  }

  var l = name.length,
      count = 0,
      _loadFile; // fn

  _loadFile = function loadFile() {
    // Proceed with callback when load completes.
    if (count >= l) {
      success && success();
      return;
    }

    var metaKey = name[count],
        metaPredicate = metaKey && metaKey.match(/[^\/]*$/i)[0],
        // actual alias
    meta = getFileName(metaKey),
        file,
        userSrc;

    // Increment counter.
    count += 1;

    // If user has overridden file names.
    userSrc = _global.options && _global.options['html5' + (0, _lib.capitalizeString)(metaPredicate) + 'Src'];
    file = userSrc === undefined ? meta : userSrc;

    if (!metaKey) {
      failure && failure(metaPredicate);
    } else if (hasFileLoaded(file)) {
      // Check if module already exists
      _loadFile();
      return;
    } else if (blockedModules[metaPredicate]) {
      // Check if loading has been blocked. If yes, then assume that
      // module exists.
      (0, _eventApi.raiseError)(_global.core || _global.core, '1112201445A', 'run', 'JavaScriptRenderer~loadModule() ', 'required resources are absent or blocked from loading.');
      failure && failure(metaPredicate);
      return;
    }

    _global.loadScript(file, {
      success: function success() {
        // Even after successful load, we should check whether it
        // actually loaded the module.
        if (hasFileLoaded(metaPredicate)) {
          _loadFile();
        } else {
          failure && failure(metaPredicate);
        }
      },

      failure: failure && function () {
        failure(metaPredicate);
      }
    }, UNDEF, true);
  };

  _loadFile();
};

/**
 * Find the relevant required module names from a given chart type.
 *
 * @param {string} type depermines the chart type (alias) that needs to
 * be looked up for dependent module names
 *
 * @type Array
 */
exports.getDependentFileName = getDependentFileName = function getDependentFileName(type) {
  var modules = [],
      i,
      j,
      dynamicFiles = _global.core.getDep('dependency');

  if (dynamicFiles && (modules = getValue(dynamicFiles, type))) {
    return modules;
  }
  type = getMetaSentence(type).predicate;
  for (i in moduleDependencies) {
    if ((j = moduleDependencies[i][type]) === UNDEF) {
      continue;
    }
    modules[j] = i;
  }

  return modules;
};

// Determine whether a chart-type needs a particular module.
exports.needsModule = needsModule = function needsModule(name, type) {
  name = getMetaSentence(name).predicate;
  type = getMetaSentence(type).predicate;
  return (moduleDependencies[name] && moduleDependencies[name][type]) !== UNDEF;
};

/**
 * Adds a dynamic dependency item
 */
exports.injectModuleDependency = injectModuleDependency = function injectModuleDependency(module, coreOptions, alias, order) {
  var isInjected = false,
      metaSubject = getMetaSentence(module).subject,
      metaPredicate = getMetaSentence(module).predicate;

  alias = alias === UNDEF ? metaPredicate : getMetaSentence(alias).predicate;

  if (!moduleDependencies[metaPredicate]) {
    moduleDependencies[metaPredicate] = {};
    if (!moduleCmdQueue[metaPredicate]) {
      moduleCmdQueue[metaPredicate] = [];

      moduleMeta[metaPredicate] = metaSubject + coreOptions.html5ScriptNamePrefix + (alias && alias.replace && alias.replace(/^[\s\S]*\//ig, '') // do not allow path in alias
      .replace(/\?/g, '%3F') // encode url destructive chars
      .replace(/\#/g, '%23').replace(/\:/g, '%3A') || '') + coreOptions.html5ScriptNameSuffix;
    }

    isInjected = true;
  }
  moduleDependencies[metaPredicate][alias] = order || 0;

  return isInjected; // indicate alias already injected
};

/**
 * Remove all waiting commands for a specific chart-object
 */
exports.cleanupWaitingCommands = cleanupWaitingCommands = function cleanupWaitingCommands(chart) {
  var type = chart.chartType(),
      modules = getDependentFileName(type),
      module,
      requeue = [],
      queue,
      item;

  // Iterate through all modules that this chart is dependent on.
  while (module = modules.shift()) {
    queue = moduleCmdQueue[module] || [];
    while (item = queue.shift()) {
      // Check whether the scope object matches the one passed in params.
      if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object' && item.obj !== chart) {
        requeue.push(item);
      }
    }
    // Restore re-queued items back in queue
    queue.concat(requeue);
    requeue = [];
  }
};

/**
 * Function to use the fcGlobal object in the given file
 * @param {Object} fcGlobal conatins vairious global level methods and properties
 */
rendererInterface = function rendererInterface(fcGlobal) {
  _global = fcGlobal;
};

exports.hasModule = hasModule;
exports.hasFileLoaded = hasFileLoaded;
exports.loadModule = loadModule;
exports.cmdQueue = cmdQueue;
exports.moduleCmdQueue = moduleCmdQueue;
exports.getDependentFileName = getDependentFileName;
exports.needsModule = needsModule;
exports.cleanupWaitingCommands = cleanupWaitingCommands;
exports.injectModuleDependency = injectModuleDependency;
exports.moduleDependencies = moduleDependencies;
exports.getMetaSentence = getMetaSentence;
exports.getValue = getValue;
exports['default'] = rendererInterface;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

var dP         = __webpack_require__(339)
  , createDesc = __webpack_require__(344);
module.exports = __webpack_require__(128) ? function(object, key, value){
  return dP.f(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(129)(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});

/***/ }),
/* 129 */
/***/ (function(module, exports) {

module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__(195)('unscopables')
  , ArrayProto  = Array.prototype;
if(ArrayProto[UNSCOPABLES] == undefined)__webpack_require__(127)(ArrayProto, UNSCOPABLES, {});
module.exports = function(key){
  ArrayProto[UNSCOPABLES][key] = true;
};

/***/ }),
/* 131 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

/***/ }),
/* 132 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};

/***/ }),
/* 133 */
/***/ (function(module, exports) {

module.exports = true;

/***/ }),
/* 134 */
/***/ (function(module, exports) {

var core = module.exports = {version: '2.4.0'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(87);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function(it, S){
  if(!isObject(it))return it;
  var fn, val;
  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ }),
/* 136 */
/***/ (function(module, exports) {

module.exports = {};

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(138)('keys')
  , uid    = __webpack_require__(91);
module.exports = function(key){
  return shared[key] || (shared[key] = uid(key));
};

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(36)
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};

/***/ }),
/* 139 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(54).f
  , has = __webpack_require__(43)
  , TAG = __webpack_require__(56)('toStringTag');

module.exports = function(it, tag, stat){
  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
};

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(56);

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

var global         = __webpack_require__(36)
  , core           = __webpack_require__(134)
  , LIBRARY        = __webpack_require__(133)
  , wksExt         = __webpack_require__(141)
  , defineProperty = __webpack_require__(54).f;
module.exports = function(name){
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
};

/***/ }),
/* 143 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _assign = __webpack_require__(13);

var _assign2 = _interopRequireDefault(_assign);

var _componentInterface = __webpack_require__(6);

var _componentInterface2 = _interopRequireDefault(_componentInterface);

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var setterGetter = function setterGetter(key, value) {
  key = 'comp_' + key;
  value && (this.config[key] = value);
  return (value || !this.config[key]) && this || this.config[key];
},
    _getTranslationString = function _getTranslationString(scaleX, scaleY) {
  return ['T', scaleX, ',', scaleY].join('');
},
    _getTranslation = function _getTranslation(axis) {
  return -axis.getTranslation();
},

// global = this,
// Calculate final transform string based on both axis
calculateTranslation = function calculateTranslation(axes) {
  return _getTranslationString(_getTranslation(axes.h), _getTranslation(axes.v));
},

// Simple function to get object
// based on parameters
getHVOb = function getHVOb(h, v) {
  return {
    h: h,
    v: v
  };
},
    groupsArr = ['columnShadowVcanvasGroup', 'columnVcanvasGroup', 'areaShadowVcanvasGroup', 'areaVcanvasGroup', 'lineShadowVcanvasGroup', 'lineVcanvasGroup', 'defaultShadowVcanvasGroup', 'defaultVcanvasGroup', 'sumLabelsLayer', 'vcanvasLabelGroup'];

/**
 * <h2>VCanvas</h2>
 * <h4> Requirement </h4>
 * vCanvas is a component that was introduced to centralize all scrolling and add new capabilities
 * to chart like multiple canvas.
 * <h4> Concept </h4>
 * Every vCanvas has always only one x-axis and one y-axis attached to it but multiple vcanvas can be
 * linked to one axis. And any number of datasets can attach themselves
 * to a vcanvas.
 * When a axis scrolls all vcanvas linked to that axis scrolls and all dataset attached to that vcanvas
 * also scrolls.
 *
 * Example:
 *
 * Assume there are 3 x-Axis : x1, x2, x3
 *
 * and 2 y-Axis y1 and y2.
 *
 * There are 3 vcanvas v1, v2, v3
 *
 * who are attached to axes in these manner:
 *
 * - v1 - x1 and y1
 * - v2 - x1 and y2
 * - v3 - x2 and y2
 *
 * And there are 4 dataset d1, d2, d3, d4
 *
 * attached to vanvas in these manner:
 * - d1 - v1
 * - d2 - v2
 * - d3 - v1
 * - d4 - v3
 *
 * When axis x1 scroll:
 * - v1 and v2 are attached to x1 so they will scroll
 * - d1 and d3 are attached to v1 and d2 is attached to v2 so they d1, d2, d3 will scroll.
 */

var VirtualCanvas = function (_ComponentInterface) {
  _inherits(VirtualCanvas, _ComponentInterface);

  function VirtualCanvas() {
    _classCallCheck(this, VirtualCanvas);

    return _possibleConstructorReturn(this, _ComponentInterface.apply(this, arguments));
  }

  /**
   * Setter getter for xAxis
   * @param {Object} xAxis x-axis
   * @return {Object}      xAxis reference
   */
  VirtualCanvas.prototype.xAxis = function xAxis(_xAxis) {
    var axis = setterGetter.call(this, 'xAxis', _xAxis);
    _xAxis && this.listenToAxis(_xAxis);
    _xAxis && this.addToEnv('xAxis', _xAxis);
    return axis;
  };

  /**
   * Setter getter for yAxis
   * @param {Object} yAxis yAxis
   * @return {Object}      yAxis reference
   */


  VirtualCanvas.prototype.yAxis = function yAxis(_yAxis) {
    var axis = setterGetter.call(this, 'yAxis', _yAxis);
    _yAxis && this.listenToAxis(_yAxis);
    _yAxis && this.addToEnv('yAxis', _yAxis);
    return axis;
  };

  /**
   * Setter getter for paper
   * @param {Object} paper
   */


  VirtualCanvas.prototype.paper = function paper(_paper) {
    return setterGetter.call(this, 'paper', _paper);
  };

  /**
   * Setter getter for canvas
   * @param {Object} canvas
   */


  VirtualCanvas.prototype.canvas = function canvas(_canvas) {
    return setterGetter.call(this, 'canvas', _canvas);
  };
  /**
   * function to configure itself and its children
   */


  VirtualCanvas.prototype.configure = function configure() {
    var conf = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var vCanvas = this,
        chartConfig = vCanvas.getFromEnv('chartConfig'),
        config = vCanvas.config;
    (0, _assign2['default'])(config, conf);
    config.transposeAxis = chartConfig.transposeAxis;
    config.xAxisSetAxisRange = chartConfig.xAxisSetAxisRange;
    this._mapChildren(function (child) {
      if (child.getState('removed') || child.getType() === 'dataset') {
        return;
      }
      child.configure && child.configure();
    });
  };

  VirtualCanvas.prototype.getHorizontalVerticalAxes = function getHorizontalVerticalAxes() {
    var vcanvas = this,
        xAxis = vcanvas.xAxis(),
        yAxis = vcanvas.yAxis();
    // Returning axes based on who is
    // horizontal or vertical
    return yAxis.config.isVertical ? getHVOb(xAxis, yAxis) : getHVOb(yAxis, xAxis);
  };

  VirtualCanvas.prototype.preDraw = function preDraw() {
    var transposeAxis = this.config.transposeAxis,
        _getDataLimits = this.getDataLimits(!transposeAxis),
        min = _getDataLimits.min,
        max = _getDataLimits.max,
        xMin = _getDataLimits.xMin,
        xMax = _getDataLimits.xMax,
        _getAxisValuePadding = this.getAxisValuePadding(),
        left = _getAxisValuePadding.left,
        right = _getAxisValuePadding.right;

    this._setAxisValuePadding(left, right);
    (min !== Infinity || max !== -Infinity) && this._setYAxisLimits(min, max);
    (xMin !== Infinity || xMax !== -Infinity) && this._setXAxisLimits(xMin, xMax);
  };
  /**
   * function to accomodate the changes of its child and notify its parent for further action if its needed
   * @param  {Object} updateInfo is an object with the informations about the changes in its child
   */


  VirtualCanvas.prototype.childChanged = function childChanged() {
    var updateInfo = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var vCanvas = this,
        config = vCanvas.config,
        transposeAxis = config.transposeAxis,
        range = void 0;

    if (updateInfo.dataLimitChanged !== false) {
      range = vCanvas.getDataLimits();
      if (transposeAxis && (range.min !== config.range.min || range.max !== config.range.max)) {
        config.range.min = range.min;
        config.range.max = range.max;
        (range.min !== Infinity || range.max !== -Infinity) && vCanvas._setYAxisLimits(range.min, range.max);
      }
      if (range.xMin !== config.range.xMin || range.xMax !== config.range.xMax) {
        config.range.xMin = range.xMin;
        config.range.xMax = range.xMax;
        vCanvas._setXAxisLimits(range.xMin, range.xMax);
      }
    }
    vCanvas.asyncDraw();
  };
  /**
   * Create child containers
   */


  VirtualCanvas.prototype.createContainer = function createContainer() {
    var vCanvas = this,
        paper = vCanvas.getFromEnv('paper'),
        key = void 0,
        parent = vCanvas.getLinkedParent(),
        pContainer = void 0,
        parentChildContainers = parent.getChildContainer();

    for (key in parentChildContainers) {
      if (!parentChildContainers.hasOwnProperty(key)) {
        continue;
      }
      pContainer = parentChildContainers[key];
      !vCanvas.getChildContainer(key) && vCanvas.addChildContainer(key, paper.group('vCanvas-' + key, pContainer));
    }
  };

  VirtualCanvas.prototype._setAxisValuePadding = function _setAxisValuePadding(left, right) {
    this.getFromEnv('xAxis').setAxisPadding(left, right);
    this.getFromEnv('yAxis').setAxisPadding(left, right);
  };

  VirtualCanvas.prototype.getAxisValuePadding = function getAxisValuePadding() {
    var vcanvas = this,
        axisPaddingLeft = -Infinity,
        axisPaddingRight = -Infinity,
        paddingObj;

    vcanvas._mapChildren(function (child) {
      paddingObj = child.getAxisValuePadding && child.getAxisValuePadding() || {};
      axisPaddingLeft = Math.max(axisPaddingLeft, paddingObj.left || -Infinity);
      axisPaddingRight = Math.max(axisPaddingRight, paddingObj.right || -Infinity);
    });

    if (axisPaddingLeft === -Infinity) {
      axisPaddingLeft = 0;
    }
    if (axisPaddingRight === -Infinity) {
      axisPaddingRight = 0;
    }
    if (!this.config.padding) {
      this.config.padding = {};
      this.config.padding.left = axisPaddingLeft;
      this.config.padding.right = axisPaddingRight;
    }
    return {
      left: axisPaddingLeft,
      right: axisPaddingRight
    };
  };

  VirtualCanvas.prototype._setYAxisLimits = function _setYAxisLimits(min, max) {
    // var chartConfig = this.getFromEnv('chartConfig'),
    //   yAxis = this.getFromEnv('yAxis');
    // @TODO setAdaptiveMin value from feedAxesRawData API in chart API
    // yAxis.setAxisConfig({
    //   setAdaptiveMin: chartConfig.setAdaptiveMin
    // });
    this.getFromEnv('yAxis').setDataLimit(max, min);
  };

  VirtualCanvas.prototype._setXAxisLimits = function _setXAxisLimits(xMin, xMax) {
    if (xMax !== -Infinity || xMin !== +Infinity) {
      if (this.config.xAxisSetAxisRange) {
        this.getFromEnv('xAxis').setAxisRange({
          min: xMin - 0.5,
          max: xMax + 0.5,
          tickInterval: 1
        });
      } else {
        this.getFromEnv('xAxis').setDataLimit(xMax, xMin);
      }
    }
  };

  VirtualCanvas.prototype.getDataLimits = function getDataLimits(allVisible) {
    var vcanvas = this,
        chart = vcanvas.getFromEnv('chart'),
        infMin = -Infinity,
        infMax = +Infinity,
        max = infMin,
        min = infMax,
        xMin = infMax,
        xMax = infMin,
        maxminObj,
        xMaxValue,
        xMinValue,
        getMaxMin = function getMaxMin(_maxminObj) {
      xMaxValue = (0, _lib.pluck)(_maxminObj.xMax, infMin);
      xMinValue = (0, _lib.pluck)(_maxminObj.xMin, infMax);
      max = Math.max(max, _maxminObj.max);
      min = Math.min(min, _maxminObj.min);
      xMax = Math.max(xMax, xMaxValue);
      xMin = Math.min(xMin, xMinValue);
    };

    vcanvas._mapChildren(function (child) {
      if (!child.getDataLimits) {
        return;
      }
      maxminObj = child.getDataLimits(allVisible);
      getMaxMin(maxminObj);
    });

    // (max === -Infinity) && (max = 0);
    // (min === +Infinity) && (min = 0);
    if (!this.config.range) {
      this.config.range = {};
      this.config.range.min = min;
      this.config.range.max = max;
      this.config.range.xMin = xMin;
      this.config.range.xMax = xMax;
    }
    chart.config.yMax = max;
    chart.config.yMin = min;

    return { min: min, max: max, xMin: xMin, xMax: xMax };
  };
  // event listeners
  /**
   * Set a listener to axis so that any change in visible range could be catched and
   * proper action should be taken
   * @param {Axis} axis
   */


  VirtualCanvas.prototype.listenToAxis = function listenToAxis(axis) {
    var vcanvas = this,
        axisScrollFn;

    axisScrollFn = function axisScrollFn() {
      if (vcanvas.getFromEnv('chart').state === 'initial') {
        return;
      }
      // Apply action
      vcanvas.asyncDraw({
        noCancel: true
      });
    };
    vcanvas.addExtEventListener('visiblerangeset', axisScrollFn, axis);
  };

  /**
   * Get or create containers that will be parent containers of datasets
   */


  VirtualCanvas.prototype.getContainer = function getContainer() {
    var vcanvas = this,
        canvas = vcanvas.getLinkedParent(),
        chart = vcanvas.getFromEnv('chart'),
        paper = vcanvas.getFromEnv('paper');

    !vcanvas.getChildContainer('columnShadowVcanvasGroup') && vcanvas.addChildContainer('columnShadowVcanvasGroup', paper.group('vcanvas-column-shadow', canvas.getChildContainer('columnShadowGroup')));
    !vcanvas.getChildContainer('columnVcanvasGroup') && vcanvas.addChildContainer('columnVcanvasGroup', paper.group('vcanvas-column-plot', canvas.getChildContainer('columnGroup')));

    !vcanvas.getChildContainer('areaShadowVcanvasGroup') && vcanvas.addChildContainer('areaShadowVcanvasGroup', paper.group('vcanvas-area-shadow', canvas.getChildContainer('areaShadowGroup')));
    !vcanvas.getChildContainer('areaVcanvasGroup') && vcanvas.addChildContainer('areaVcanvasGroup', paper.group('vcanvas-area-plot', canvas.getChildContainer('areaGroup')));

    !vcanvas.getChildContainer('lineShadowVcanvasGroup') && vcanvas.addChildContainer('lineShadowVcanvasGroup', paper.group('vcanvas-line-shadow', canvas.getChildContainer('lineShadowGroup')));
    !vcanvas.getChildContainer('lineVcanvasGroup') && vcanvas.addChildContainer('lineVcanvasGroup', paper.group('vcanvas-line-plot', canvas.getChildContainer('lineGroup')));

    !vcanvas.getChildContainer('defaultShadowVcanvasGroup') && vcanvas.addChildContainer('defaultShadowVcanvasGroup', paper.group('vcanvas-default-shadow', canvas.getChildContainer('defaultShadowGroup')));
    !vcanvas.getChildContainer('defaultVcanvasGroup') && vcanvas.addChildContainer('defaultVcanvasGroup', paper.group('vcanvas-default-plot', canvas.getChildContainer('defaultGroup')));

    !vcanvas.getChildContainer('vcanvasLabelGroup') && vcanvas.addChildContainer('vcanvasLabelGroup', paper.group('vcanvas-label', chart.getChildContainer('datalabelsGroup')));

    !vcanvas.getChildContainer('columnTrendGroup') && vcanvas.addChildContainer('columnTrendGroup', paper.group('columnTrendGroup', vcanvas.getChildContainer('columnVcanvasGroup')));

    !vcanvas.getChildContainer('sumLabelsLayer') && vcanvas.addChildContainer('sumLabelsLayer', paper.group('vcanvas-sumLabelsLayer', canvas.getChildContainer('sumLabelsLayer')));
  };

  // Apply translation


  VirtualCanvas.prototype.applyTranslation = function applyTranslation() {
    var vcanvas = this,
        axes = vcanvas.getHorizontalVerticalAxes(),
        translation = calculateTranslation(axes),

    // anim = {
    //   data: []
    // },
    pushAnimData = function pushAnimData(el) {
      el = vcanvas.getChildContainer(el);
      // anim.data.push({
      //   el: el,
      //   attrs: {
      //     transform: translation
      //   }
      // });
      // Changing the vCanvas translation via attr as internally it is executed as 0 animation. As a result we can
      // apply translation on vCanvas
      el.attr({
        transform: translation
      });
    };
    // Creating container
    vcanvas.getContainer();

    groupsArr.forEach(function (val) {
      pushAnimData(val);
    });

    // this.getFromEnv('animationManager').registerAnimation([anim], 'plot');
  };

  // Calculate zooming or panning


  VirtualCanvas.prototype.draw = function draw() {
    // apply translation
    this.applyTranslation();
    this.childrenSyncDraw();
  };
  /**
   * function to return canvas padding by calculating the max padding need to be applied
   * @return {{paddingLeft : Number, paddingRight: Number, paddingTop: Number, paddingBottom: Number}}
   */


  VirtualCanvas.prototype.getCanvasPadding = function getCanvasPadding() {
    var iapi = this,
        dim,
        key,
        returnDimension = {
      paddingLeft: 0,
      paddingRight: 0,
      paddingTop: 0,
      paddingBottom: 0
    };
    iapi._mapChildren(function (child) {
      dim = child.getCanvasPadding && child.getCanvasPadding() || {};
      for (key in dim) {
        if (dim.hasOwnProperty(key)) {
          returnDimension[key] = Math.max(dim[key], returnDimension[key]);
        }
      }
    });
    return returnDimension;
  };
  /**
   * Used in realtime scenarios, to make the realtime animation look proper
   */


  VirtualCanvas.prototype.rtShiftAnim = function rtShiftAnim(x, y) {
    var vcanvas = this,
        translateString,
        xAxis = vcanvas.getFromEnv('xAxis'),
        yAxis = vcanvas.getFromEnv('yAxis'),
        xDiff = xAxis.getPixel(1) - xAxis.getPixel(0),
        yDiff = yAxis.getPixel(1) - yAxis.getPixel(0),
        animData = [],
        translateFn = function translateFn() {
      this.attr({
        transform: translateString
      });
    };
    x = (x || 0) * xDiff;
    y = (y || 0) * yDiff;
    translateString = _getTranslationString(x, y);

    groupsArr.forEach(function (val) {
      animData.push({
        el: vcanvas.getChildContainer(val),
        attrs: {
          transform: 'T0,0'
        },
        preAnimFn: translateFn
      });
    });

    this.getFromEnv('animationManager').registerAnimation([{
      data: animData
    }], 'plot');
  };

  return VirtualCanvas;
}(_componentInterface2['default']);

exports['default'] = VirtualCanvas;

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports._postSpaceManagement = exports._spaceManager = exports._feedAxesRawData = exports._createAxes = undefined;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(14);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _cartesian = __webpack_require__(22);

var _cartesian2 = _interopRequireDefault(_cartesian);

var _column = __webpack_require__(8);

var _column2 = _interopRequireDefault(_column);

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */

/**
 * This method create axis compoenents and attach with chart and linked with canvas.
 */
function __createAxes() {
  var iapi = this,
      canvas = iapi.getChildren().canvas[0],
      zoomObj = {
    zoomable: true,
    pannable: true
  },
      yAxis,
      xAxis;

  (0, _lib.componentFactory)(iapi, _cartesian2['default'], 'yAxis');
  (0, _lib.componentFactory)(iapi, _cartesian2['default'], 'xAxis');

  yAxis = iapi.getChildren('yAxis')[0];
  xAxis = iapi.getChildren('xAxis')[0];

  canvas.attachAxis(xAxis, false, iapi.zoomX ? zoomObj : {});
  canvas.attachAxis(yAxis, true, iapi.zoomY ? zoomObj : {});
  // set the chart categories
  iapi._setCategories();
}
/**
 * This method parse all the attributes which are associated with axis compoenents.
 * So that axis compoenents can be configured.
 */
function __feedAxesRawData() {
  var iapi = this,
      chartConfig = iapi.config,
      children = iapi.getChildren(),
      colorM = iapi.getFromEnv('color-manager'),
      dataObj = iapi.jsonData,
      chartAttrs = dataObj.chart,
      xAxisConf,
      yAxisConf,
      is3d = iapi.is3d,
      palleteString = is3d ? _lib.chartPaletteStr.chart3D : _lib.chartPaletteStr.chart2D,
      yAxis,
      xAxis;

  xAxisConf = {
    isVertical: true,
    isReverse: false,
    isOpposit: false,
    outCanfontFamily: (0, _lib.pluck)(chartAttrs.outcnvbasefont, chartAttrs.basefont, 'Verdana,sans'),
    outCanfontSize: (0, _lib.pluckFontSize)(chartAttrs.outcnvbasefontsize, chartAttrs.basefontsize, 10),
    outCancolor: (0, _lib.pluck)(chartAttrs.outcnvbasefontcolor, chartAttrs.basefontcolor, colorM.getColor(palleteString.baseFontColor)).replace(/^#? ([a-f0-9]+)/ig, '#$1'),
    axisNamePadding: chartAttrs.xaxisnamepadding,
    maxLabelWidthPercent: chartAttrs.maxlabelwidthpercent,
    axisValuePadding: chartAttrs.labelpadding,
    axisNameFont: chartAttrs.xaxisnamefont,
    axisNameFontSize: chartAttrs.xaxisnamefontsize,
    axisNameFontColor: chartAttrs.xaxisnamefontcolor,
    axisNameFontBold: chartAttrs.xaxisnamefontbold,
    axisNameFontItalic: chartAttrs.xaxisnamefontitalic,
    axisNameBgColor: chartAttrs.xaxisnamebgcolor,
    axisNameBorderColor: chartAttrs.xaxisnamebordercolor,
    axisNameAlpha: chartAttrs.xaxisnamealpha,
    axisNameFontAlpha: chartAttrs.xaxisnamefontalpha,
    axisNameBgAlpha: chartAttrs.xaxisnamebgalpha,
    axisNameBorderAlpha: chartAttrs.xaxisnameborderalpha,
    axisNameBorderPadding: chartAttrs.xaxisnameborderpadding,
    axisNameBorderRadius: chartAttrs.xaxisnameborderradius,
    axisNameBorderThickness: chartAttrs.xaxisnameborderthickness,
    axisNameBorderDashed: chartAttrs.xaxisnameborderdashed,
    axisNameBorderDashLen: chartAttrs.xaxisnameborderdashlen,
    axisNameBorderDashGap: chartAttrs.xaxisnameborderdashgap,
    axisNameWidth: chartAttrs.xaxisnamewidth,
    useEllipsesWhenOverflow: chartAttrs.useellipseswhenoverflow,
    divLineColor: (0, _lib.pluck)(chartAttrs.vdivlinecolor, chartAttrs.divlinecolor, colorM.getColor(palleteString.divLineColor)),
    divLineAlpha: (0, _lib.pluck)(chartAttrs.vdivlinealpha, chartAttrs.divlinealpha, is3d ? colorM.getColor('divLineAlpha3D') : colorM.getColor('divLineAlpha')),
    divLineThickness: (0, _lib.pluckNumber)(chartAttrs.vdivlinethickness, chartAttrs.divlinethickness, 1),
    divLineIsDashed: Boolean((0, _lib.pluckNumber)(chartAttrs.vdivlinedashed, chartAttrs.vdivlineisdashed, chartAttrs.divlinedashed, chartAttrs.divlineisdashed, 0)),
    divLineDashLen: (0, _lib.pluckNumber)(chartAttrs.vdivlinedashlen, chartAttrs.divlinedashlen, 4),
    divLineDashGap: (0, _lib.pluckNumber)(chartAttrs.vdivlinedashgap, chartAttrs.divlinedashgap, 2),
    showAlternateGridColor: (0, _lib.pluckNumber)(chartAttrs.showalternatehgridcolor, 1),
    alternateGridColor: (0, _lib.pluck)(chartAttrs.alternatehgridcolor, colorM.getColor('altHGridColor')),
    alternateGridAlpha: (0, _lib.pluck)(chartAttrs.alternatehgridalpha, colorM.getColor('altHGridAlpha')),
    numDivLines: chartAttrs.numvdivlines,
    labelFont: chartAttrs.labelfont,
    labelFontSize: chartAttrs.labelfontsize,
    labelFontColor: chartAttrs.labelfontcolor,
    labelFontAlpha: chartAttrs.labelalpha,
    labelFontBold: chartAttrs.labelfontbold,
    labelFontItalic: chartAttrs.labelfontitalic,
    axisName: chartAttrs.xaxisname,
    axisMinValue: chartAttrs.xaxisminvalue,
    axisMaxValue: chartAttrs.xaxismaxvalue,
    setAdaptiveMin: chartAttrs.setadaptivexmin,
    adjustDiv: chartAttrs.adjustvdiv,
    labelDisplay: chartAttrs.labeldisplay,
    showLabels: chartAttrs.showlabels,
    rotateLabels: chartAttrs.rotatelabels,
    slantLabel: (0, _lib.pluckNumber)(chartAttrs.slantlabels, chartAttrs.slantlabel),
    labelStep: (0, _lib.pluckNumber)(chartAttrs.labelstep, chartAttrs.xaxisvaluesstep),
    showAxisValues: (0, _lib.pluckNumber)(chartAttrs.showxaxisvalues, chartAttrs.showxaxisvalue),
    showLimits: chartAttrs.showvlimits,
    showDivLineValues: (0, _lib.pluckNumber)(chartAttrs.showvdivlinevalues, chartAttrs.showvdivlinevalues),
    // showZeroPlane: chartAttrs.showvzeroplane,
    zeroPlaneColor: chartAttrs.vzeroplanecolor,
    zeroPlaneThickness: (0, _lib.pluckNumber)(chartAttrs.vzeroplanethickness, chartAttrs.vdivlinethickness, 2),
    zeroPlaneAlpha: (0, _lib.pluckNumber)(chartAttrs.vzeroplanealpha, chartAttrs.vdivlinealpha, chartConfig.zeroplanealpha),
    showZeroPlaneValue: chartAttrs.showvzeroplanevalue,
    trendlineColor: chartAttrs.trendlinecolor,
    trendlineToolText: chartAttrs.trendlinetooltext,
    trendlineThickness: chartAttrs.trendlinethickness,
    rotateAxisName: (0, _lib.pluckNumber)(chartAttrs.rotatexaxisname, 1),
    trendlineAlpha: chartAttrs.trendlinealpha,
    showTrendlinesOnTop: chartAttrs.showtrendlinesontop,
    showAxisLine: is3d ? 0 : (0, _lib.pluckNumber)(chartAttrs.showxaxisline, chartAttrs.showaxislines, chartAttrs.drawAxisLines, 0),
    axisLineThickness: (0, _lib.pluckNumber)(chartAttrs.xaxislinethickness, chartAttrs.axislinethickness, 1),
    axisLineAlpha: (0, _lib.pluckNumber)(chartAttrs.xaxislinealpha, chartAttrs.axislinealpha, 100),
    axisLineColor: (0, _lib.pluck)(chartAttrs.xaxislinecolor, chartAttrs.axislinecolor, '#000000')
  };
  yAxisConf = {
    isVertical: false,
    isReverse: false,
    isOpposit: false,
    outCanfontFamily: (0, _lib.pluck)(chartAttrs.outcnvbasefont, chartAttrs.basefont, 'Verdana,sans'),
    outCanfontSize: (0, _lib.pluckFontSize)(chartAttrs.outcnvbasefontsize, chartAttrs.basefontsize, 10),
    outCancolor: (0, _lib.pluck)(chartAttrs.outcnvbasefontcolor, chartAttrs.basefontcolor, colorM.getColor(palleteString.baseFontColor)).replace(/^#? ([a-f0-9]+)/ig, '#$1'),
    axisNamePadding: chartAttrs.yaxisnamepadding,
    axisValuePadding: chartAttrs.yaxisvaluespadding,
    axisNameFont: chartAttrs.yaxisnamefont,
    axisNameFontSize: chartAttrs.yaxisnamefontsize,
    axisNameFontColor: chartAttrs.yaxisnamefontcolor,
    axisNameFontBold: chartAttrs.yaxisnamefontbold,
    axisNameFontItalic: chartAttrs.yaxisnamefontitalic,
    axisNameBgColor: chartAttrs.yaxisnamebgcolor,
    axisNameBorderColor: chartAttrs.yaxisnamebordercolor,
    axisNameAlpha: chartAttrs.yaxisnamealpha,
    axisNameFontAlpha: chartAttrs.yaxisnamefontalpha,
    axisNameBgAlpha: chartAttrs.yaxisnamebgalpha,
    axisNameBorderAlpha: chartAttrs.yaxisnameborderalpha,
    axisNameBorderPadding: chartAttrs.yaxisnameborderpadding,
    axisNameBorderRadius: chartAttrs.yaxisnameborderradius,
    axisNameBorderThickness: chartAttrs.yaxisnameborderthickness,
    axisNameBorderDashed: chartAttrs.yaxisnameborderdashed,
    axisNameBorderDashLen: chartAttrs.yaxisnameborderdashlen,
    axisNameBorderDashGap: chartAttrs.yaxisnameborderdashgap,
    axisNameWidth: chartAttrs.yaxisnamewidth,
    useEllipsesWhenOverflow: chartAttrs.useellipseswhenoverflow,
    axisName: chartAttrs.yaxisname,
    divLineColor: (0, _lib.pluck)(chartAttrs.divlinecolor, colorM.getColor(palleteString.divLineColor)),
    divLineAlpha: (0, _lib.pluck)(chartAttrs.divlinealpha, is3d ? colorM.getColor('divLineAlpha3D') : colorM.getColor('divLineAlpha')),
    divLineThickness: (0, _lib.pluckNumber)(chartAttrs.divlinethickness, 1),
    divLineIsDashed: Boolean((0, _lib.pluckNumber)(chartAttrs.divlinedashed, chartAttrs.divlineisdashed, 0)),
    divLineDashLen: (0, _lib.pluckNumber)(chartAttrs.divlinedashlen, 4),
    divLineDashGap: (0, _lib.pluckNumber)(chartAttrs.divlinedashgap, 2),
    showAlternateGridColor: (0, _lib.pluckNumber)(chartAttrs.showalternatevgridcolor, 1),
    alternateGridColor: (0, _lib.pluck)(chartAttrs.alternatevgridcolor, colorM.getColor('altVGridColor')),
    alternateGridAlpha: (0, _lib.pluck)(chartAttrs.alternatevgridalpha, colorM.getColor('altVGridAlpha')),
    numDivLines: chartAttrs.numdivlines,
    axisMinValue: chartAttrs.yaxisminvalue,
    axisMaxValue: chartAttrs.yaxismaxvalue,
    setAdaptiveMin: chartAttrs.setadaptiveymin,
    adjustDiv: chartAttrs.adjustdiv,
    labelStep: chartAttrs.yaxisvaluesstep,
    showAxisValues: (0, _lib.pluckNumber)(chartAttrs.showyaxisvalues, chartAttrs.showyaxisvalue),
    showLimits: (0, _lib.pluckNumber)(chartAttrs.showyaxislimits, chartAttrs.showlimits, iapi.showLimits),
    showDivLineValues: (0, _lib.pluckNumber)(chartAttrs.showdivlinevalues, chartAttrs.showdivlinevalue),
    // showZeroPlane: chartAttrs.showzeroplane,
    zeroPlaneColor: chartAttrs.zeroplanecolor,
    zeroPlaneThickness: (0, _lib.pluckNumber)(chartAttrs.zeroplanethickness, chartAttrs.divlinethickness, 2),
    zeroPlaneAlpha: (0, _lib.pluckNumber)(chartAttrs.zeroplanealpha, chartAttrs.divlinealpha, chartConfig.zeroplanealpha),
    showZeroPlaneValue: chartAttrs.showzeroplanevalue,
    trendlineColor: chartAttrs.trendlinecolor,
    trendlineToolText: chartAttrs.trendlinetooltext,
    trendlineThickness: chartAttrs.trendlinethickness,
    trendlineAlpha: chartAttrs.trendlinealpha,
    // Applicable only for bar as to change the behavior of scatter charts
    isTrendZone: 0,
    showTrendlinesOnTop: chartAttrs.showtrendlinesontop,
    showAxisLine: is3d ? 0 : (0, _lib.pluckNumber)(chartAttrs.showyaxisline, chartAttrs.showaxislines, chartAttrs.drawAxisLines, 0),
    axisLineThickness: (0, _lib.pluckNumber)(chartAttrs.yaxislinethickness, chartAttrs.axislinethickness, 1),
    axisLineAlpha: (0, _lib.pluckNumber)(chartAttrs.yaxislinealpha, chartAttrs.axislinealpha, 100),
    axisLineColor: (0, _lib.pluck)(chartAttrs.yaxislinecolor, chartAttrs.axislinecolor, '#000000'),
    numberFormatterFn: 'yAxis'
  };
  yAxisConf.vtrendlines = dataObj.trendlines;
  xAxisConf.trendlines = dataObj.vtrendlines;
  yAxis = children.yAxis[0];
  xAxis = children.xAxis[0];

  yAxis.configure(yAxisConf);
  xAxis.configure(xAxisConf);
}

/**
* This method first assigns the entire area of the chart to canvas. Then every component (for example toolbox,
* caption etc) is asked to allocate its own space. Once every compoenent has had its space allocated, the canvas is
* assigned the remaining space.
*/
function __spaceManager() {
  // @TODO marge _allocateSpace and _spacemanager
  var availableWidth,
      availableHeight,
      iapi = this,
      config = iapi.config,
      children = iapi.getChildren(),
      xAxis = children.yAxis && children.yAxis[0],
      yAxisArr = children.xAxis && children.xAxis || [],
      yAxis,
      POSITION_BOTTOM = _lib.preDefStr.POSITION_BOTTOM,
      legend = children.legend[0],
      legendPosition = legend.config.legendPos,
      xDepth = config.xDepth,
      yDepth = config.yDepth,
      canvasBgDepth = config.canvasBgDepth,
      canvasBaseDepth = config.canvasBaseDepth,
      canvasBasePadding = config.canvasBasePadding,
      canvasBorderWidth = children.canvas[0].config.canvasBorderWidth,
      showRTValue = config.realTimeConfig && config.realTimeConfig.showRTValue,
      chartBorderWidth = config.borderWidth,
      canvasMarginTop = config.canvasMarginTop,
      canvasMarginBottom = config.canvasMarginBottom,
      canvasMarginLeft = config.canvasMarginLeft,
      canvasMarginRight = config.canvasMarginRight,
      minCanvasHeight = config.minCanvasHeight,
      minCanvasWidth = config.minCanvasWidth,
      minChartWidth = config.minChartWidth,
      minChartHeight = config.minChartHeight,
      height = config.height,
      width = config.width,
      diff,
      heightAdjust = false,
      widthAdjust = false,
      top,
      bottom,
      left,
      right,
      currentCanvasHeight,
      currentCanvasWidth,
      origCanvasTopMargin = config.origCanvasTopMargin,
      origCanvasBottomMargin = config.origCanvasBottomMargin,
      origCanvasLeftMargin = config.origCanvasLeftMargin,
      origCanvasRightMargin = config.origCanvasRightMargin,
      chartBorderHorizontal,
      chartBorderVertical,
      canvasBorderHorizontal,
      actionBarSpace,
      spaceForActionBar,
      canvasBorderVertical,
      yAxisSpaceAllocation,
      xAxisSpaceAllocation,
      sum;

  if (config.canvasWidth - 2 * chartBorderWidth < minChartWidth) {
    chartBorderVertical = (config.canvasWidth - minChartWidth) / 2;
  }

  if (config.canvasHeight - 2 * chartBorderWidth < minChartHeight) {
    chartBorderHorizontal = (config.canvasHeight - minChartHeight) / 2;
  }

  iapi._allocateSpace({
    top: chartBorderHorizontal || chartBorderWidth,
    bottom: chartBorderHorizontal || chartBorderWidth,
    left: chartBorderVertical || chartBorderWidth,
    right: chartBorderVertical || chartBorderWidth
  });

  yAxis = yAxisArr[0];
  //* ***** Manage space
  availableWidth = config.availableWidth * 0.7;
  config.yAxisSpaceAllocation = yAxisSpaceAllocation = yAxis && yAxis.placeAxis(availableWidth);
  yAxis && iapi._allocateSpace(yAxisSpaceAllocation);

  spaceForActionBar = config.availableHeight * 0.225;
  actionBarSpace = iapi._manageActionBarSpace && iapi._manageActionBarSpace(spaceForActionBar) || {};
  iapi._allocateSpace(actionBarSpace);

  // No space is allocated for legend drawing in single series charts
  iapi._manageLegendSpace();

  availableHeight = legendPosition === POSITION_BOTTOM ? config.availableHeight * 0.6 : config.availableWidth * 0.6;

  // space management for 3d canvas
  if (yDepth) {
    iapi._allocateSpace({
      left: yDepth
    });
    config.shift = xDepth + canvasBasePadding + canvasBaseDepth;
  }
  if (canvasBgDepth) {
    iapi._allocateSpace({
      top: canvasBgDepth
    });
  }

  if (config.canvasWidth - 2 * canvasBorderWidth < minCanvasWidth) {
    canvasBorderVertical = (config.canvasWidth - minCanvasWidth) / 2;
  }

  iapi._allocateSpace({
    left: canvasBorderVertical || canvasBorderWidth,
    right: canvasBorderVertical || canvasBorderWidth
  });

  // Check for minimun canvas width for applying canvas left and right margin.
  if (minCanvasWidth > width - canvasMarginLeft - canvasMarginRight) {
    widthAdjust = true;
    diff = config.canvasWidth - minCanvasWidth;
    sum = canvasMarginLeft + canvasMarginRight;
    canvasMarginLeft = config.canvasMarginLeft = diff * canvasMarginLeft / sum;
    canvasMarginRight = config.canvasMarginRight = diff * canvasMarginRight / sum;
  }

  // Calculating the left and right canvas margin.
  left = canvasMarginLeft > config.canvasLeft ? canvasMarginLeft - config.canvasLeft : 0;
  right = canvasMarginRight > width - config.canvasRight ? canvasMarginRight + config.canvasRight - width : 0;

  iapi._allocateSpace({
    left: left,
    right: right
  });

  iapi._allocateSpace({
    left: canvasBaseDepth
  });

  // Forcing canvas width to its minimum
  if (widthAdjust) {
    sum = origCanvasLeftMargin + origCanvasRightMargin;
    currentCanvasWidth = config.canvasWidth;
    if (currentCanvasWidth > minCanvasWidth) {
      diff = currentCanvasWidth - minCanvasWidth;
      left = diff * origCanvasLeftMargin / sum;
      right = diff * origCanvasRightMargin / sum;
    }
    iapi._allocateSpace({
      left: left,
      right: right
    });
  }

  config.actualCanvasMarginRight = right;
  config.actualCanvasMarginBottom = bottom;

  // a space manager that manages the space for the tools as well as the captions.
  iapi._manageChartMenuBar(availableHeight);

  availableHeight = config.availableHeight * 0.2;

  iapi._allocateSpace(iapi._getSumValueSpace(availableHeight));

  availableHeight = config.availableHeight * 0.3;
  if (config.realtimeEnabled) {
    if (showRTValue) {
      iapi._allocateSpace(iapi._realTimeValuePositioning(availableHeight));
    } else {
      iapi._hideRealTimeValue();
    }
  }

  availableHeight = config.availableHeight * 0.6;
  config.xAxisSpaceAllocation = xAxisSpaceAllocation = xAxis && xAxis.placeAxis(availableHeight);
  xAxis && iapi._allocateSpace(xAxisSpaceAllocation);

  // alocate the space for scroll.
  availableHeight = config.availableHeight * 0.3;
  iapi._manageScrollerPosition && iapi._manageScrollerPosition(availableHeight);

  if (config.canvasHeight - 2 * canvasBorderWidth < minCanvasHeight) {
    canvasBorderHorizontal = (config.canvasHeight - minCanvasHeight) / 2;
  }

  iapi._allocateSpace({
    top: canvasBorderHorizontal || canvasBorderWidth,
    bottom: canvasBorderHorizontal || canvasBorderWidth
  });

  // Check for minimum canvas height for applying top and bottom margin.
  if (minCanvasHeight > height - canvasMarginTop - canvasMarginBottom) {
    heightAdjust = true;
    diff = config.canvasHeight - minCanvasHeight;
    sum = canvasMarginTop + canvasMarginBottom;
    canvasMarginTop = config.canvasMarginTop = diff * canvasMarginTop / sum;
    canvasMarginBottom = config.canvasMarginBottom = diff * canvasMarginBottom / sum;
  }

  // Allocate space for canvas margin only if the margin is less than the margin entered by the user.
  top = canvasMarginTop > config.canvasTop ? canvasMarginTop - config.canvasTop : 0;
  bottom = canvasMarginBottom > height - config.canvasBottom ? canvasMarginBottom + config.canvasBottom - height : 0;

  iapi._allocateSpace({
    top: top,
    bottom: bottom
  });

  // Forcing canvas height to its minimum
  if (heightAdjust) {
    sum = origCanvasTopMargin + origCanvasBottomMargin;
    currentCanvasHeight = config.canvasHeight;
    if (currentCanvasHeight > minCanvasHeight) {
      diff = currentCanvasHeight - minCanvasHeight;
      top = diff * origCanvasTopMargin / sum;
      bottom = diff * origCanvasBottomMargin / sum;
    }
    iapi._allocateSpace({
      top: top,
      bottom: bottom
    });
  }

  config.actualCanvasMarginTop = top;
  config.actualCanvasMarginLeft = left;
}
/**
 * This function is adjusting value padding depending upon data and axis labels and set dimention to axis
 */
function __postSpaceManagement() {
  var iapi = this,
      config = iapi.config,
      children = iapi.getChildren(),
      xAxis = children.xAxis && children.xAxis[0],
      yAxis = children.yAxis && children.yAxis[0],
      legend = children.legend[0],
      xDepth = config.xDepth,
      canvasConfig = children.canvas[0].config,
      canvasBorderWidth = canvasConfig.canvasBorderWidth,
      canvasPadding = canvasConfig.canvasPadding,
      canvasPaddingLeft,
      math = Math,
      mathMax = math.max,
      canvasPaddingRight,
      canvasPaddingTop,
      canvasPaddingBottom;

  // function for adjusting value padding depending upon data and axis labels.
  yAxis && iapi._allocateXAxisLabelSpace(yAxis);
  canvasPaddingLeft = canvasConfig.canvasPaddingLeft;
  canvasPaddingRight = canvasConfig.canvasPaddingRight;
  canvasPaddingTop = canvasConfig.canvasPaddingTop;
  canvasPaddingBottom = canvasConfig.canvasPaddingBottom;

  yAxis && yAxis.setAxisDimention({
    x: config.canvasLeft + canvasPaddingLeft,
    y: config.canvasBottom + canvasBorderWidth,
    opposite: config.canvasTop - canvasBorderWidth,
    axisLength: config.canvasWidth - canvasPaddingLeft - canvasPaddingRight
  });
  xAxis && xAxis.setAxisDimention({
    x: config.canvasLeft - (config.shift || 0) - canvasBorderWidth,
    y: config.canvasTop + (xDepth || 0) + mathMax(canvasPaddingTop, canvasPadding),
    opposite: config.canvasRight + canvasBorderWidth,
    axisLength: config.canvasHeight - (xDepth || 0) - mathMax(canvasPaddingTop, canvasPadding) - mathMax(canvasPaddingBottom, canvasPadding)
  });
  legend.postSpaceManager();
}

/**
 * This class is base class for multi series bar charts.
 */

var MSBarCartesian = function (_MSCartesian) {
  _inherits(MSBarCartesian, _MSCartesian);

  function MSBarCartesian() {
    _classCallCheck(this, MSBarCartesian);

    return _possibleConstructorReturn(this, _MSCartesian.apply(this, arguments));
  }

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  MSBarCartesian.getName = function getName() {
    return 'MSBarCartesian';
  };

  /**
   * This method create axis compoenents and attach with chart and linked with canvas.
   */


  MSBarCartesian.prototype._createAxes = function _createAxes() {
    __createAxes.call(this);
  };
  /**
   * parse defualt configuration of the chart
   */


  MSBarCartesian.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _MSCartesian.prototype.__setDefaultConfig.call(this);
    this.config.enablemousetracking = true;
  };
  /**
   * This method parse all the attributes which are associated with axis compoenents.
   * So that axis compoenents can be configured.
   */


  MSBarCartesian.prototype._feedAxesRawData = function _feedAxesRawData() {
    __feedAxesRawData.call(this);
  };
  /**
  * This method first assigns the entire area of the chart to canvas. Then every component (for example toolbox,
  * caption etc) is asked to allocate its own space. Once every compoenent has had its space allocated, the canvas is
  * assigned the remaining space.
  */


  MSBarCartesian.prototype._spaceManager = function _spaceManager() {
    __spaceManager.call(this);
  };
  /**
   * This function is adjusting value padding depending upon data and axis labels and set dimention to axis
   */


  MSBarCartesian.prototype._postSpaceManagement = function _postSpaceManagement() {
    __postSpaceManagement.call(this);
  };
  /**
   * This method return the dataset definations for this charts
   * @return {Object} dataset class for bar2d
   */


  MSBarCartesian.prototype.getDSdef = function getDSdef() {
    return _column2['default'];
  };
  /**
   * This method return the dataset-group definations for this charts. Here return value is undefined
   */


  MSBarCartesian.prototype.getDSGroupdef = function getDSGroupdef() {
    // this fn overrides
  };

  return MSBarCartesian;
}(_fusioncharts2['default']);

exports._createAxes = __createAxes;
exports._feedAxesRawData = __feedAxesRawData;
exports._spaceManager = __spaceManager;
exports._postSpaceManagement = __postSpaceManagement;
exports['default'] = MSBarCartesian;

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _column = __webpack_require__(8);

var _column2 = _interopRequireDefault(_column);

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */

var UNDEF = void 0,
    configStr = _lib.preDefStr.configStr,
    animationObjStr = _lib.preDefStr.animationObjStr,
    visibleStr = _lib.preDefStr.visibleStr,
    POSITION_MIDDLE = _lib.preDefStr.POSITION_MIDDLE,
    POSITION_START = _lib.preDefStr.POSITION_START,
    POSITION_END = _lib.preDefStr.POSITION_END,
    math = Math,
    mathMin = math.min,
    mathMax = math.max,
    defined = function defined(obj) {
  return obj !== UNDEF && obj !== null;
};

/**
 * Representing bar2d dataset
 */

var Bar2DDataset = function (_ColumnDataset) {
  _inherits(Bar2DDataset, _ColumnDataset);

  /**
   * constructor method of this class
   */
  function Bar2DDataset() {
    _classCallCheck(this, Bar2DDataset);

    var _this = _possibleConstructorReturn(this, _ColumnDataset.call(this));

    _this.type = 'column';
    return _this;
  }
  /**
   * This set the default configuration for this chart
   */


  Bar2DDataset.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _ColumnDataset.prototype.__setDefaultConfig && _ColumnDataset.prototype.__setDefaultConfig.call(this);
  };
  /**
   * Function to draw label for every data plot.
   * It calculates where to draw the label for data plot.
   */


  Bar2DDataset.prototype.drawLabel = function drawLabel() {
    var dataSet = this,
        chart = dataSet.getFromEnv('chart'),
        resize = chart.state === 'resize',
        noAnim = chart.state === 'noAnim',
        realTimeUpdate = chart.state === 'realTimeUpdate',
        chartConf = chart.config,
        JSONData = dataSet.JSONData,
        canvasConf = chart.getChildren('canvas')[0].config,
        style = chart.config.dataLabelStyle,
        setDataArr = JSONData.data,
        categories = chart.config.categories,
        is3D = chart.is3D,
        isStacked = chart.config.isstacked,
        catLen = categories && categories.length,
        dataSetLen = setDataArr.length,
        len,
        dataStore = dataSet.getData(),
        paper = chart.getFromEnv('paper'),
        SmartLabel = chart.getFromEnv('smartLabel'),
        dataObj,
        attr,
        yDepth = canvasConf.yDepth,
        xDepth = canvasConf.xDepth,
        numberFormatter = chart.getFromEnv('number-formatter'),
        i,
        displayValue = '',
        setData,
        placeValuesInside = chartConf.placevaluesinside,
        canvasWidth = chartConf.canvasWidth,
        canvasLeft = chartConf.canvasLeft,
        graphic,
        height,
        gutter = 2,
        valuePadding = chartConf.valuepadding + gutter,
        textY,
        textX,
        outsideColSpace,
        isNegative,
        yPos,
        xPos,
        width,
        setValue,
        animationObj = chart.get(configStr, animationObjStr),
        animType = animationObj.animType,
        dataLabelContainer = dataSet.getContainer('labelGroup'),
        textAnchor,
        textWidth,
        xAdjust,
        GUTTER_4 = 4,
        dataArr = [],
        animCallBack = function animCallBack(attr) {
      return function () {
        !resize && this.attr(attr);
      };
    },
        config,
        plotLabel,
        dim,
        tempGraphics,
        pool = dataSet.components.pool || {},
        visible = dataSet.getState('visible');

    dataLabelContainer.show();
    if (!resize && !noAnim && !realTimeUpdate) {
      dataArr.push({
        el: dataLabelContainer,
        attrs: {
          opacity: 0
        },
        callback: function callback() {
          if (!visible) {
            this.hide();
          }
        },
        animConfig: [{
          syncWith: 'initial'
        }]
      });
      dataArr.push({
        el: dataLabelContainer,
        attrs: {
          opacity: visible ? 1 : 0
        },
        animConfig: [{
          syncWith: 'final'
        }]
      });
    }

    SmartLabel.setStyle(style);
    len = catLen < dataSetLen ? catLen : dataSetLen;

    if (visible) {
      for (i = 0; i < len; i++) {
        dataObj = dataStore[i];
        config = dataObj && dataObj.config;
        setValue = config && config.setValue;
        // Condition arises when user has removed data in real time update
        if (dataObj === UNDEF || setValue === UNDEF || setValue === null || config.labelSkip === true) {
          tempGraphics = dataObj && dataObj.graphics;
          if (tempGraphics) {
            tempGraphics.label && tempGraphics.label.hide();
          }

          config && delete config.labelSkip;

          continue;
        }
        graphic = dataObj.graphics;

        // Condition arises when feedData enters less number of data in a dataset compared to the other.
        if (!graphic) {
          continue;
        }

        setData = setDataArr[i];
        yPos = dataObj._yPos;
        xPos = dataObj._xPos;
        setValue = numberFormatter.getCleanValue(setData.value);
        isNegative = (0, _lib.pluckNumber)(setValue) < 0;
        height = dataObj._height;
        width = dataObj._width;

        textAnchor = isStacked ? POSITION_MIDDLE : isNegative ?
        /** @todo this boolean check needs optimisation */
        placeValuesInside ? POSITION_START : POSITION_END : placeValuesInside ? POSITION_END : POSITION_START;
        displayValue = config.displayValue;
        plotLabel = graphic.label;
        // Dont draw values if the respective conditions are not satisfied
        if (config.showValue && defined(displayValue) && displayValue !== _lib.BLANKSTRING && setValue !== null) {
          // Preparing the attributes of the text
          attr = {
            text: displayValue,
            fill: style.color,
            'text-bound': [style.backgroundColor, style.borderColor, style.borderThickness, style.borderPadding, style.borderRadius, style.borderDash],
            'line-height': style.lineHeight,
            // todo-text direction missing
            visibility: visibleStr
          };

          dim = SmartLabel.getOriSize(displayValue);

          textWidth = dim.width;
          textWidth += valuePadding;
          xAdjust = valuePadding;
          textY = yPos + height * 0.5;

          textX = xPos + (isNegative ? 0 : width);

          if (isNegative) {
            outsideColSpace = xPos - canvasLeft;
          } else {
            outsideColSpace = canvasLeft + canvasWidth - (xPos + width);
          }
          // For stacked charts values are always placed at middle
          if (isStacked) {
            textX += (isNegative ? width : -width) * 0.5;
            textX = mathMax(canvasLeft + textWidth * 0.5, textX);
            textX = mathMin(canvasLeft + canvasWidth - textWidth * 0.5, textX);
            // If 3D chart then xDepth and yDepth is also to be considered for
            // calculating x y position
            textX -= is3D ? xDepth : 0;
            textY += is3D ? yDepth : 0;
          } else {
            if (placeValuesInside) {
              // If label fits inside the data plot
              if (width >= textWidth) {
                textX += isNegative ? xAdjust : -xAdjust;
                if (is3D) {
                  textY += yDepth;
                  textX -= xDepth;
                }
              } else {
                // If label fits outside the data plot
                if (textWidth < outsideColSpace) {
                  textX += isNegative ? -xAdjust : xAdjust;
                  textAnchor = isNegative ? POSITION_END : POSITION_START;
                  if (is3D && isNegative) {
                    textX -= xDepth;
                  }
                } else {
                  // Label management for negative values
                  if (isNegative) {
                    textX = xPos + width + mathMax(textWidth - xPos - width + canvasLeft, 0) - xAdjust;
                    // If negative value then drawing text from end
                    textAnchor = POSITION_END;
                  } else {
                    textX = xPos - mathMax(textWidth - (canvasLeft + canvasWidth - xPos), 0) + xAdjust;
                    textAnchor = POSITION_START;
                  }
                  // Taking xDepth yDepth into consideration for 3d charts
                  if (is3D) {
                    textX -= xDepth;
                    textY += yDepth;
                  }
                }
              }
            } else {
              // If space is available inside plot
              if (outsideColSpace >= textWidth) {
                textX += isNegative ? -xAdjust : xAdjust;
                if (is3D && isNegative) {
                  textX -= xDepth;
                  textY += xDepth;
                }
              } else {
                // If space not available inside plot
                textX += isNegative ? xAdjust + textWidth : -(xAdjust + textWidth);
                if (is3D) {
                  textX -= xDepth;
                  textY += yDepth;
                }
              }
            }
          }
          // If value gets out of canvas
          if (textX > canvasLeft + canvasWidth || textX < canvasLeft) {
            textX = canvasLeft + GUTTER_4;
            textAnchor = POSITION_START;
          }

          attr['text-anchor'] = textAnchor;

          plotLabel = graphic.label || pool.label && pool.label.shift();
          // If label is not created then create it
          attr.x = textX;
          attr.y = textY;
          if (!plotLabel) {
            delete attr['text-bound'];
            plotLabel = graphic.label = paper.text(attr, dataLabelContainer).attr({ opacity: 0 });
          }
          attr['text-bound'] = [style.backgroundColor, style.borderColor, style.borderThickness, style.borderPadding, style.borderRadius, style.borderDash];
          plotLabel.show();
          dataArr.push({
            el: plotLabel,
            attrs: {
              opacity: 1
            },
            animConfig: [{
              syncWith: 'final',
              hookFn: animCallBack(attr)
            }]
          });

          if (dataSet.labelDrawn) {
            if (chart.state === 'realTimeUpdate') {
              plotLabel.attr(attr);
            } else if (resize) {
              dataArr.push({
                el: plotLabel,
                attrs: attr,
                animConfig: [{
                  syncWith: 'plot'
                }]
              });
            }
          }
        } else {
          plotLabel && plotLabel.hide();
        }
      }
    }
    chart.getFromEnv('animationManager').registerAnimation([{
      animType: animType,
      data: dataArr
    }], 'final');
    dataSet.labelDrawn = true;
  };

  return Bar2DDataset;
}(_column2['default']);

exports['default'] = Bar2DDataset;

/***/ }),
/* 147 */,
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports._realTimeConfigure = undefined;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _column = __webpack_require__(8);

var _column2 = _interopRequireDefault(_column);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */


/**
 * Real time column dataset class definition
 */
var RealtimeColumnDataset = function (_ColumnDataset) {
  _inherits(RealtimeColumnDataset, _ColumnDataset);

  function RealtimeColumnDataset() {
    _classCallCheck(this, RealtimeColumnDataset);

    return _possibleConstructorReturn(this, _ColumnDataset.apply(this, arguments));
  }

  /**
   * Setting the dataStore as per the numDisplaySets attributes.
   * @param  {boolean} force set true during clear chart
   */
  RealtimeColumnDataset.prototype._realTimeConfigure = function _realTimeConfigure(force) {
    var dataSet = this,
        chart = dataSet.getFromEnv('chart'),
        datasetStore = dataSet.components.data,
        tempArr = [],
        numDisplaySets = chart.config.realTimeConfig.numDisplaySets,
        catLen;

    catLen = force ? 0 : dataSet.getFromEnv('xAxis').getCategoryLen();

    if (catLen < numDisplaySets) {
      tempArr.length = numDisplaySets - catLen;
      dataSet.components.data = tempArr.concat(datasetStore);
    } else if (catLen > numDisplaySets) {
      dataSet.components.data.splice(numDisplaySets, catLen - numDisplaySets);
    }
    dataSet.resetCatPos && dataSet.resetCatPos();
  };

  return RealtimeColumnDataset;
}(_column2['default']);

var _realTimeConfigure = RealtimeColumnDataset.prototype._realTimeConfigure;
exports._realTimeConfigure = _realTimeConfigure;
exports['default'] = RealtimeColumnDataset;

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(97);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _area = __webpack_require__(20);

var _area2 = _interopRequireDefault(_area);

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var UNDEF = void 0,
    SEVENTYSTRING = _lib.preDefStr.SEVENTYSTRING;
/**
 * Creates ScrollArea2D class
 */

var ScrollArea2D = function (_ScrollColumn2D) {
  _inherits(ScrollArea2D, _ScrollColumn2D);

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  ScrollArea2D.getName = function getName() {
    return 'ScrollArea2D';
  };

  /**
   * Constructor fn of ScrollArea2D class
   */


  function ScrollArea2D() {
    _classCallCheck(this, ScrollArea2D);

    var _this = _possibleConstructorReturn(this, _ScrollColumn2D.call(this));

    _this.friendlyName = 'Scrollable Multi-series Area Chart';
    _this.tooltipConstraint = 'plot';
    _this.canvasborderthickness = 1;
    _this.hasScroll = true;
    _this.defaultDatasetType = 'scrollarea2d';
    _this.applicableDSList = { 'scrollarea2d': true };
    _this.avgScrollPointWidth = 75;
    _this.defaultPlotShadow = 0;
    _this.binSize = 0;
    return _this;
  }
  /**
   * Sets default chart configuration
   */


  ScrollArea2D.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _ScrollColumn2D.prototype.__setDefaultConfig && _ScrollColumn2D.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    config.enablemousetracking = true;
    config.anchorborderthickness = 1;
    config.anchorimageurl = UNDEF;
    config.anchorimagepadding = 1;
    config.anchorsides = 1;
    config.anchoralpha = UNDEF;
    config.anchorbgalpha = _lib.HUNDREDSTRING;
    config.anchorimagealpha = _lib.HUNDREDSTRING;
    config.anchorimagescale = 100;
    config.anchorstartangle = 90;
    config.anchorshadow = 0;
    config.anchorbgcolor = UNDEF;
    config.anchorbordercolor = UNDEF;
    config.anchorradius = 3;
    config.showvalues = 1;
    config.plotfillalpha = SEVENTYSTRING;
    config.linedashlen = 5;
    config.linedashgap = 4;
    config.linedashed = UNDEF;
    config.linealpha = _lib.HUNDREDSTRING;
    config.linethickness = 2;
    config.drawfullareaborder = 1;
    config.connectnulldata = 0;
  };

  /** This method return the dataset definations for this charts **/


  ScrollArea2D.prototype.getDSdef = function getDSdef() {
    return _area2['default'];
  };
  /** This method return the dataset-group definations for this charts **/


  ScrollArea2D.prototype.getDSGroupdef = function getDSGroupdef() {
    return undefined;
  };

  return ScrollArea2D;
}(_fusioncharts2['default']);

exports['default'] = ScrollArea2D;

/***/ }),
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY        = __webpack_require__(112)
  , $export        = __webpack_require__(31)
  , redefine       = __webpack_require__(177)
  , hide           = __webpack_require__(48)
  , has            = __webpack_require__(40)
  , Iterators      = __webpack_require__(114)
  , $iterCreate    = __webpack_require__(283)
  , setToStringTag = __webpack_require__(119)
  , getPrototypeOf = __webpack_require__(289)
  , ITERATOR       = __webpack_require__(51)('iterator')
  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
  , FF_ITERATOR    = '@@iterator'
  , KEYS           = 'keys'
  , VALUES         = 'values';

var returnThis = function(){ return this; };

module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
  $iterCreate(Constructor, NAME, next);
  var getMethod = function(kind){
    if(!BUGGY && kind in proto)return proto[kind];
    switch(kind){
      case KEYS: return function keys(){ return new Constructor(this, kind); };
      case VALUES: return function values(){ return new Constructor(this, kind); };
    } return function entries(){ return new Constructor(this, kind); };
  };
  var TAG        = NAME + ' Iterator'
    , DEF_VALUES = DEFAULT == VALUES
    , VALUES_BUG = false
    , proto      = Base.prototype
    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , $default   = $native || getMethod(DEFAULT)
    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
    , methods, key, IteratorPrototype;
  // Fix native
  if($anyNative){
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
    if(IteratorPrototype !== Object.prototype){
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if(DEF_VALUES && $native && $native.name !== VALUES){
    VALUES_BUG = true;
    $default = function values(){ return $native.call(this); };
  }
  // Define iterator
  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG]  = returnThis;
  if(DEFAULT){
    methods = {
      values:  DEF_VALUES ? $default : getMethod(VALUES),
      keys:    IS_SET     ? $default : getMethod(KEYS),
      entries: $entries
    };
    if(FORCED)for(key in methods){
      if(!(key in proto))redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(282);
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(39) && !__webpack_require__(49)(function(){
  return Object.defineProperty(__webpack_require__(176)('div'), 'a', {get: function(){ return 7; }}).a != 7;
});

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(64)
  , document = __webpack_require__(32).document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(48);

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

var has          = __webpack_require__(40)
  , toIObject    = __webpack_require__(33)
  , arrayIndexOf = __webpack_require__(285)(false)
  , IE_PROTO     = __webpack_require__(116)('IE_PROTO');

module.exports = function(object, names){
  var O      = toIObject(object)
    , i      = 0
    , result = []
    , key;
  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while(names.length > i)if(has(O, key = names[i++])){
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(180);
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};

/***/ }),
/* 180 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(33)
  , gOPN      = __webpack_require__(182).f
  , toString  = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function(it){
  try {
    return gOPN(it);
  } catch(e){
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it){
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys      = __webpack_require__(178)
  , hiddenKeys = __webpack_require__(118).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
  return $keys(O, hiddenKeys);
};

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(306), __esModule: true };

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.hasAttribDefs = exports.setAttribDefs = exports.parseConfiguration = exports.attribDefs = undefined;

var _lib = __webpack_require__(5);

var blankObj = {},
    // @note: readonly object. Don't write anything in this object
mathMax = Math.max,
    attribDefs;

// add attribute parsing methods
// @todo: this part need to to be properly planed and written.
/**
 * @private
 * @module fusioncharts.renderer.javascript.lib-attr
 */

function parseConfiguration(userConfig, defaultConfig, parentConfig, ignoreList, helperComponents, localAttribDefs) {
  var key,
      val,
      type,
      attrUpdateCount = 1,
      tempDefs;

  exports.attribDefs = attribDefs = attribDefs || blankObj;

  ignoreList = ignoreList || blankObj;
  localAttribDefs = localAttribDefs || blankObj;
  helperComponents = helperComponents || {};
  // appaly user given attributes
  for (key in userConfig) {
    if (!ignoreList[key]) {
      val = userConfig[key];
      if (!(!val && val !== false && val !== 0)) {
        type = (tempDefs = localAttribDefs[key] || attribDefs[key]) && tempDefs.type;
        switch (type) {
          case _lib.attrTypeNum:
            val = Number(val);
            if (!isNaN(val)) {
              defaultConfig[key] = val;
            }
            break;
          case _lib.attrTypeBool:
            val = Number(val);
            if (!isNaN(val)) {
              defaultConfig[key] = !!val;
            }
            break;
          default:
            defaultConfig[key] = val;
        }
      }
    }
  }

  // Update attributes thar are inherated from parentConfig
  if (parentConfig) {
    for (key in defaultConfig) {
      // if the attribute value is UNDEF and the defination says it will be inherited from parent
      if (defaultConfig[key] === _lib.UNDEF && (tempDefs = localAttribDefs[key] || attribDefs[key]) && tempDefs.pAttr) {
        defaultConfig[key] = parentConfig[tempDefs.pAttr];
      }
    }
  }

  // Update attributes thar are inherated from another attributes
  // Update attributes whos values will be updated through some function call
  while (attrUpdateCount) {
    attrUpdateCount = 0;
    for (key in defaultConfig) {
      // if the attribute value is UNDEF and the defination says it will be inherited from parent
      if (defaultConfig[key] === _lib.UNDEF && (tempDefs = localAttribDefs[key] || attribDefs[key])) {
        // attribute that will be inherited from another
        if (tempDefs.attr) {
          if ((val = defaultConfig[tempDefs.attr]) !== _lib.UNDEF) {
            defaultConfig[key] = val;
            attrUpdateCount += 1;
          }
        } else if (tempDefs.parser) {
          if ((val = tempDefs.parser(defaultConfig, parentConfig, helperComponents)) !== _lib.UNDEF) {
            defaultConfig[key] = val;
            attrUpdateCount += 1;
          }
        }
      }
    }
  }
}

/**
 * Set an attribute defination
 * @param {string} name name of the defination or an object containg the definations as key pair object
 * @param {type} def defination of the object
 */
function setAttribDefs(name, def) {
  var attribObj, key;

  exports.attribDefs = attribDefs = attribDefs || {};

  if (typeof name === 'string') {
    attribObj = {};
    attribObj[name] = def;
  } else {
    attribObj = name;
  }
  for (key in attribObj) {
    // the defination is not previously added, then only the definations
    if (!attribDefs[key]) {
      attribDefs[key] = attribObj[key];
    }
  }
}

function hasAttribDefs(name) {
  // assuming definations should not be UNDEF
  return !!attribDefs[name];
}

/**
 * Store for all attributes definations
 * possible defination object properties
 *  `type`: type of the attribute. Attribute will be parsed into proper format
 *  `pAttr`: name of the parent scope attribute, from which the attribute value will be inherited
 *  `attr`: Name fo another attribute of same scope from which the default value will be inherited
 *  `parser`: Defination the parser function using which the value fo this attribute will be generated.
 *            The parser will get the current scope config and the parent scope config as arguments respectively.
 *
 */
exports.attribDefs = attribDefs = {
  setBorderWidth: {
    type: _lib.attrTypeNum,
    pAttr: 'plotborderthickness'
  },
  plotborderthickness: {
    type: _lib.attrTypeNum,
    pAttr: 'plotborderthickness'
  },
  showBorderEffect: {
    parser: function parser() {
      var pConfig = arguments[1],
          plotBorderThicknessLimit = 0.1;

      return +pConfig.showplotborder === 1 && pConfig.plotborderthickness === plotBorderThicknessLimit ? 1 : 0;
    }
  },
  alphaanimation: {
    type: _lib.attrTypeNum
  },
  showplotborder: {
    type: _lib.attrTypeNum,
    pAttr: 'showplotborder'
  },
  zeroplanethickness: {
    type: _lib.attrTypeNum
  },
  showzeroplaneontop: {
    type: _lib.attrTypeNum
  },
  stickytracking: {
    type: _lib.attrTypeNum
  },

  // realtime related attributes
  usemessagelog: {
    type: _lib.attrTypeNum
  },
  showtooltip: {
    type: _lib.attrTypeNum,
    pAttr: 'showtooltip'
  },
  seriesnameintooltip: {
    type: _lib.attrTypeNum
  },
  plothovereffect: {
    type: _lib.attrTypeNum,
    attr: 'anchorhovereffect'
  },
  anchorhovereffect: {
    type: _lib.attrTypeNum,
    attr: 'showhovereffect'
  },
  showhovereffect: {
    type: _lib.attrTypeNum,
    attr: 'drawcrossline'
  },
  drawcrossline: {
    type: _lib.attrTypeNum
  },
  linethickness: {
    type: _lib.attrTypeNum,
    pAttr: 'linethickness'
  },
  dashed: {
    type: _lib.attrTypeNum,
    pAttr: 'linedashed'
  },
  linedashed: {
    type: _lib.attrTypeNum,
    attr: 'plotborderdashed'
  },
  plotborderdashed: {
    type: _lib.attrTypeNum,
    pAttr: 'plotborderdashed'
  },
  linedashlen: {
    type: _lib.attrTypeNum,
    pAttr: 'linedashlen'
  },
  linedashgap: {
    type: _lib.attrTypeNum,
    pAttr: 'linedashgap'
  },
  anchoralpha: {
    pAttr: 'anchoralpha'
  },
  anchorsides: {
    type: _lib.attrTypeNum,
    pAttr: 'anchorsides'
  },
  anchorradius: {
    type: _lib.attrTypeNum,
    pAttr: 'anchorradius'
  },
  anchorbgalpha: {
    pAttr: 'anchorbgalpha'
  },
  anchorbgcolor: {
    pAttr: 'anchorbgcolor'
  },
  anchorbordercolor: {
    pAttr: 'anchorbordercolor'
  },
  anchorstartangle: {
    type: _lib.attrTypeNum,
    pAttr: 'anchorstartangle'
  },
  anchorimageurl: {
    pAttr: 'anchorimageurl'
  },
  anchorimagescale: {
    type: _lib.attrTypeNum,
    pAttr: 'anchorimagescale'
  },
  anchorimagealpha: {
    pAttr: 'anchorimagealpha'
  },
  anchorimagepadding: {
    type: _lib.attrTypeNum,
    pAttr: 'anchorimagepadding'
  },
  anchorborderthickness: {
    type: _lib.attrTypeNum,
    pAttr: 'anchorborderthickness'
  },
  anchorshadow: {
    type: _lib.attrTypeNum,
    pAttr: 'anchorshadow'
  },
  valuepadding: {
    type: _lib.attrTypeNum,
    pAttr: 'valuepadding'
  },
  valueposition: {
    pAttr: 'valueposition'
  },
  plotfillangle: {
    type: _lib.attrTypeNum,
    pAttr: 'plotfillangle'
  },
  useplotgradientcolor: {
    type: _lib.attrTypeNum
  },
  rotatevalues: {
    type: _lib.attrTypeNum,
    pAttr: 'rotatevalues'
  },
  includeinlegend: {
    type: _lib.attrTypeNum
  },
  connectnulldata: {
    type: _lib.attrTypeNum
  },
  plotfillalpha: {
    pAttr: 'plotfillalpha'
  },
  alpha: {
    pAttr: 'linealpha'
  },
  linealpha: {
    pAttr: 'plotfillalpha'
  },
  showvalues: {
    type: _lib.attrTypeNum,
    pAttr: 'showvalues'
  },
  showpercentvalues: {
    type: _lib.attrTypeNum,
    parser: function parser(config) {
      return config.isstacked && config.stack100percent ? 1 : 0;
    }
  },
  showpercentintooltip: {
    type: _lib.attrTypeNum,
    parser: function parser(config) {
      return config.isstacked && config.stack100percent ? 1 : 0;
    }
  },
  stack100percent: {
    type: _lib.attrTypeNum,
    attr: 'usepercentdistribution'
  },
  drawfullareaborder: {
    type: _lib.attrTypeNum
  },
  use3dlineshift: {
    type: _lib.attrTypeNum
  },
  parentyaxis: {
    type: _lib.attrTypeNum
  },
  radarborderthickness: {
    type: _lib.attrTypeNum
  },
  radarborderradius: {
    type: _lib.attrTypeNum
  },
  gaugeoriginx: {
    type: _lib.attrTypeNum
  },
  hasgaugeoriginx: {
    attr: 'gaugeoriginx'
  },
  gaugeoriginy: {
    type: _lib.attrTypeNum
  },
  hasgaugeoriginy: {
    attr: 'gaugeoriginy'
  },
  gaugeradius: {
    type: _lib.attrTypeNum
  },
  hasgaugeradius: {
    attr: 'gaugeradius'
  },
  showgaugeborder: {
    type: _lib.attrTypeNum
  },
  setAdaptiveMin: {
    type: _lib.attrTypeNum
  },
  adjustDiv: {
    type: _lib.attrTypeNum
  },
  axisNameWidth: {
    type: _lib.attrTypeNum
  },
  rotateAxisName: {
    type: _lib.attrTypeNum
  },
  useEllipsesWhenOverflow: {
    type: _lib.attrTypeNum
  },
  showZeroPlane: {
    type: _lib.attrTypeNum
  },
  zeroPlaneAlpha: {
    type: _lib.attrTypeNum
  },
  showZeroPlaneValue: {
    type: _lib.attrTypeNum
  },
  zeroPlaneOnTop: {
    type: _lib.attrTypeNum
  },
  trendlineThickness: {
    type: _lib.attrTypeNum
  },
  showTrendlinesOnTop: {
    type: _lib.attrTypeNum
  },
  trendlinesAreDashed: {
    type: _lib.attrTypeNum
  },
  trendlinesDashLen: {
    type: _lib.attrTypeNum
  },
  trendlinesDashGap: {
    type: _lib.attrTypeNum
  },
  showTrendlines: {
    type: _lib.attrTypeNum
  },
  showTrendlineLabels: {
    type: _lib.attrTypeNum
  },
  showLabels: {
    type: _lib.attrTypeNum
  },
  rotateLabels: {
    type: _lib.attrTypeNum
  },
  slantLabel: {
    type: _lib.attrTypeNum
  },
  showAxisValues: {
    type: _lib.attrTypeNum
  },
  showTooltip: {
    type: _lib.attrTypeNum
  },
  maxLabelHeight: {
    type: _lib.attrTypeNum
  },
  useroundedges: {
    type: _lib.attrTypeNum,
    pAttr: 'useroundedges'
  },
  placevaluesinside: {
    type: _lib.attrTypeNum
  },
  plotpaddingpercent: {
    type: _lib.attrTypeNum
  },
  use3dlighting: {
    type: _lib.attrTypeNum,
    pAttr: 'use3dlighting'
  },
  usedataplotcolorforlabels: {
    type: _lib.attrTypeNum
  },
  plotspacepercent: {
    type: _lib.attrTypeNum,
    parser: function parser(config) {
      return mathMax(config.plotspacepercent % 100, 0);
    }
  },
  ratio: {
    pAttr: 'plotfillratio'
  },
  base: {
    type: _lib.attrTypeNum
  },
  showMinorDivLineValues: {
    type: _lib.attrTypeNum
  },
  numMinorDivLines: {
    type: _lib.attrTypeNum
  },
  majorTMNumber: {
    type: _lib.attrTypeNum
  },
  majorTMHeight: {
    type: _lib.attrTypeNum
  },
  showTickMarks: {
    type: _lib.attrTypeNum
  },
  majorTMThickness: {
    type: _lib.attrTypeNum
  },
  adjustTM: {
    type: _lib.attrTypeBool
  },
  minorTMNumber: {
    type: _lib.attrTypeNum
  },
  minorTMThickness: {
    type: _lib.attrTypeNum
  },
  tickMarkDistance: {
    type: _lib.attrTypeNum
  },
  placeTicksInside: {
    type: _lib.attrTypeNum
  },
  placeValuesInside: {
    type: _lib.attrTypeNum
  },
  axisValuePadding: {
    type: _lib.attrTypeNum
  },
  gridLineWidth: {
    type: _lib.attrTypeNum
  },
  showRadarBorder: {
    type: _lib.attrTypeNum
  },
  radarBorderThickness: {
    type: _lib.attrTypeNum
  },
  maxcolwidth: {
    type: _lib.attrTypeNum,
    parser: function parser(config) {
      return Math.abs(config.maxcolwidth);
    }
  },
  maxbarheight: {
    type: _lib.attrTypeNum,
    parser: function parser(config) {
      return Math.abs(config.maxbarheight);
    }
  },
  plotborderalpha: {
    parser: function parser(config, pConfig) {
      return pConfig.plotborderalpha || config.plotfillalpha;
    }
  },
  autoscale: {
    type: _lib.attrTypeNum
  },
  plotborderdashlen: {
    type: _lib.attrTypeNum,
    pAttr: 'plotborderdashlen'
  },
  plotborderdashgap: {
    type: _lib.attrTypeNum,
    pAttr: 'plotborderdashgap'
  },
  plotfillratio: {
    pAttr: 'plotfillratio'
  },
  drawverticaljoins: {
    type: _lib.attrTypeNum,
    pAttr: 'drawverticaljoins'
  },
  useforwardsteps: {
    type: _lib.attrTypeNum,
    pAttr: 'useforwardsteps'
  },
  minimizetendency: {
    type: _lib.attrTypeNum
  },
  usepercentdistribution: {
    type: _lib.attrTypeNum
  },
  stepatmiddle: {
    type: _lib.attrTypeNum
  }
};

exports.attribDefs = attribDefs;
exports.parseConfiguration = parseConfiguration;
exports.setAttribDefs = setAttribDefs;
exports.hasAttribDefs = hasAttribDefs;

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__(9);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(10);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2['default'] === "function" && typeof _iterator2['default'] === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2['default'] === "function" && obj.constructor === _symbol2['default'] && obj !== _symbol2['default'].prototype ? "symbol" : typeof obj; };

exports['default'] = function (obj1, obj2, skipUndef) {
  // if none of the arguments are object then return back
  if ((typeof obj1 === 'undefined' ? 'undefined' : _typeof(obj1)) !== 'object' && (typeof obj2 === 'undefined' ? 'undefined' : _typeof(obj2)) !== 'object') {
    return null;
  }

  if ((typeof obj2 === 'undefined' ? 'undefined' : _typeof(obj2)) !== 'object' || obj2 === null) {
    return obj1;
  }

  if (typeof obj1 === 'undefined') {
    obj1 = obj2 instanceof Array ? [] : {};
  }
  merge(obj1, obj2, skipUndef);
  return obj1;
};

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */
var UNDEF = void 0,
    arrayToStr = '[object Array]',
    objectToStr = '[object Object]',
    checkCyclicRef = function checkCyclicRef(obj, parentArr) {
  var i = parentArr.length,
      bIndex = -1;

  while (i--) {
    if (obj === parentArr[i]) {
      bIndex = i;
      return bIndex;
    }
  }

  return bIndex;
},
    merge = function merge(obj1, obj2, skipUndef, tgtArr, srcArr) {
  var item, srcVal, tgtVal, str, cRef;
  // check whether obj2 is an array
  // if array then iterate through it's index
  //* *** MOOTOOLS precution
  if (!srcArr) {
    tgtArr = [obj1];
    srcArr = [obj2];
  } else {
    tgtArr.push(obj1);
    srcArr.push(obj2);
  }

  if (obj2 instanceof Array) {
    for (item = 0; item < obj2.length; item += 1) {
      try {
        srcVal = obj1[item];
        tgtVal = obj2[item];
      } catch (e) {
        continue;
      }

      if ((typeof tgtVal === 'undefined' ? 'undefined' : _typeof(tgtVal)) !== 'object') {
        if (!(skipUndef && tgtVal === UNDEF)) {
          obj1[item] = tgtVal;
        }
      } else {
        if (srcVal === null || (typeof srcVal === 'undefined' ? 'undefined' : _typeof(srcVal)) !== 'object') {
          srcVal = obj1[item] = tgtVal instanceof Array ? [] : {};
        }
        cRef = checkCyclicRef(tgtVal, srcArr);
        if (cRef !== -1) {
          srcVal = obj1[item] = tgtArr[cRef];
        } else {
          merge(srcVal, tgtVal, skipUndef, tgtArr, srcArr);
        }
      }
    }
  } else {
    for (item in obj2) {
      try {
        srcVal = obj1[item];
        tgtVal = obj2[item];
      } catch (e) {
        continue;
      }

      if (tgtVal !== null && (typeof tgtVal === 'undefined' ? 'undefined' : _typeof(tgtVal)) === 'object') {
        // Fix for issue BUG: FWXT-602
        // IE < 9 Object.prototype.toString.call(null) gives
        // '[object Object]' instead of '[object Null]'
        // that's why null value becomes Object in IE < 9
        str = Object.prototype.toString.call(tgtVal);
        if (str === objectToStr) {
          if (srcVal === null || (typeof srcVal === 'undefined' ? 'undefined' : _typeof(srcVal)) !== 'object') {
            srcVal = obj1[item] = {};
          }
          cRef = checkCyclicRef(tgtVal, srcArr);
          if (cRef !== -1) {
            srcVal = obj1[item] = tgtArr[cRef];
          } else {
            merge(srcVal, tgtVal, skipUndef, tgtArr, srcArr);
          }
        } else if (str === arrayToStr) {
          if (srcVal === null || !(srcVal instanceof Array)) {
            srcVal = obj1[item] = [];
          }
          cRef = checkCyclicRef(tgtVal, srcArr);
          if (cRef !== -1) {
            srcVal = obj1[item] = tgtArr[cRef];
          } else {
            merge(srcVal, tgtVal, skipUndef, tgtArr, srcArr);
          }
        } else {
          obj1[item] = tgtVal;
        }
      } else {
        obj1[item] = tgtVal;
      }
    }
  }
  return obj1;
};
/**
 * Function extend one object's properties with another one
 * @param  {Object} obj1 The object that will be extend
 * @param  {Objcet} obj2 The object, properties of which will be extended into the first one.
 * @param  {boolean} skipUndef Whether to skip the properties with undefined value
 * @return {Object} return the extend object
 */

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.onDataLoadRequestCancel = exports.onDataLoadRequest = exports.sourceName = undefined;

var _ajax = __webpack_require__(187);

var _ajax2 = _interopRequireDefault(_ajax);

var _eventApi = __webpack_require__(7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */
var SOURCE_NAME = 'XmlHttpRequest';

var UNDEF = void 0;

/**
  * Default action of DataLoadRequestCompleted event. Upon request completion
  * the data needs to be set to the chart.
  *
  * @param {type} event DataLoadRequestCompleted event object
  * @param {type} args DataLoadRequestCompleted event arguments
  *
  * @note This function is expected to be executed from `xmlhttpSuccess` function
  */
function onDataLoadComplete(event, args) {
  // Update the chart's dataStore with data received from url
  event.sender.jsVars.stallLoad = false;
  event.sender.setChartData(args.dataSource, args.dataFormat, args.config, args.successcallback, args.silent);
}

/**
  * Prevented action of DataLoadRequestCompleted event. Upon request
  * prevention, ongoing XHR needs aborting and a subsequent cancel event
  * to be raised.
  *
  * @param {type} event DataLoadRequestCompleted event object
  * @param {type} args DataLoadRequestCompleted event arguments
  *
  * @note This function is expected to be executed from `xmlhttpSuccess`
  * function
  */
function onDataLoadCancel(event, args) {
  /**
   * When the default action of {@link FusionCharts#event:dataLoadRequested} event is cancelled using
   * `eventObject.preventDefault()`, this event is raised. Subsequently, the associated AJAX requests are
   * aborted.
   * @event FusionCharts#dataLoadCancelled
   *
   * @param {string} url - Url of the requested data source.
   * @param {FusionCharts~dataFormats} dataFormat - The data format that was specified to be expected from the
   * contents of the `url`.
   */
  (0, _eventApi.triggerEvent)('dataLoadCancelled', event.sender, args);
  args.xmlHttpRequestObject.abort();
}

/**
  * When the AJAX call was a success this method triggers an event
  *
  * @param {string} responseText The response received from the server
  * @param {Object} wrapper The object which sent the AJAX request
  * @param {Object} data Arguments
  * @param {string} url The URL to which the request was sent
  */
function xmlhttpSuccess(responseText, wrapper, data, url) {
  // Allow cancellation of data loaing
  var obj = data.obj,
      args = data.args;

  args.dataSource = responseText;
  args.xmlHttpRequestObject = wrapper;
  args.source = SOURCE_NAME;
  args.url = url;

  /**
   * Sometimes, the data to the Fusion charts object is loaded from a `URL` instead of a static file(*XML* or
   * *JSON*) on the client environment. The {@link FusionCharts#event:dataLoadRequested} event is fired when
   * the data is to be loaded from a *url*. Once the data is successfully loaded form the *url*, the
   * `dataLoadRequestCompleted` event is fired.
   *
   * The arguments object of this event contains the :
   *
   * * `URL` from which the data is loaded.
   * * `Data` loaded to the Fusion Charts object.
   * * `DataFormat` fo the data loaded from the URL.
   *
   * @event FusionCharts#dataLoadRequestCompleted
   *
   * @param {string} url - The Url of the data source from where the data was fetched.
   * @param {string} dataSource - The content of the dataSource as fetched from the `url`.
   * @param {FusionCharts~dataFormats} dataFormat Type of data format that was provided to be expected from
   * the `dataSource`.
   */
  (0, _eventApi.triggerEvent)('dataLoadRequestCompleted', obj, args, UNDEF, onDataLoadComplete, onDataLoadCancel);
}

/**
  * Callback function executed by AJAX wrapper class upon failure to
  * complete data load request (from setChartDataUrl)
  *
  * @param {type} resp The response from server (usually meaningless!)
  * @param {type} wrapper Reference to the callee
  * @param {type} data  is the additional data that is passed on to this
  * function via Ajax Wrapper class. This generally contains the relevant
  * variables that this function needs from the original setChartDataUrl
  * function
  * @param {type} url is the URL that could not be loaded!
  *
  * @return {undefined}
  */
function xmlhttpFailure(resp, wrapper, data /* , url */) {
  // Compile argument for event.
  var obj = data.obj,
      args = data.args;

  args.error = resp;
  args.httpStatus = wrapper.xhr && wrapper.xhr.status ? wrapper.xhr.status : -1;
  args.xmlHttpRequestObject = wrapper;

  /**
   * The `dataLoadError` event is raised when there is an error loading data to the chart object from the
   * specified `URL`.It informs the user of :
   *
   * * The `URL` from which the data could not be fetched.
   * * The `dataFormat` of the *dataSource*.
   * * The `error object` which is useful for debugging purposes.
   * * The `httpStatus` to identify the server communication issues
   *
   * This information can be used to show an error message to the user or to take a corrective measure so that
   *  the data is loaded successfully.
   * @event FusionCharts#dataLoadError
   *
   * @param {string} url - The Url that could not be successfully loaded.
   * @param {FusionCharts~dataFormats} dataFormat - The format of the data that was expected from the Url.
   * @param {string} error - In case any aspect of loading data results in a JavaScript error, the error
   * object is passed on to this event for debugging purposes.
   * @param {number} httpStatus - In case of an error, this parameter is useful to identify server
   * communication issues - such as `404` status returned when the `url` provided is not found.
   */
  (0, _eventApi.triggerEvent)('dataLoadError', obj, args);

  // // Call legacy event handler.
  // if (typeof window.FC_DataLoadError === 'function') { // jshint ignore:line
  //   window.FC_DataLoadError(obj.id, args); // jshint ignore:line
  // }
}

/**
  * Handles the success callback of the dataloadrequest event.
  *
  * @param {Event} event The event object
  * @param {Object} args The callback atrguments
  */
function onDataLoadRequest(event, args) {
  var chart = event.sender,
      state = chart.__state,
      url = args.url;

  // Update reference to data-source.
  chart.options.dataSource = args.url;

  // Create an XMLHttpRequest object if it is not already
  if (!state.dhmXhrObj) {
    // eslint-disable-next-line new-cap
    state.dhmXhrObj = new _ajax2['default'](xmlhttpSuccess, xmlhttpFailure);
  }

  // Initiate XmlHttpRequest.
  state.dhmXhrObj.get(typeof window.decodeURIComponent === 'function' ? window.decodeURIComponent(url) : window.unescape(url), {
    obj: chart,
    args: args
  });
}

/**
  * Handles the cancellation of the data load request
  *
  * @param {Event} event The event object
  * @param {Object} args The callback arguments
  */
function onDataLoadRequestCancel(event, args) {
  var chart = event.sender,
      state = chart.__state;
  /**
   * This event is raised when the data load process is cancelled by calling the
   * `eventObject.preventDefault()` of {@link FusionCharts#event:dataLoadRequested} event. In cases where the
   * data source is a local path or if the `URL` fails internal security checks, the
   * `dataLoadRequestCancelled` event  is internally fired.
   * @event FusionCharts#dataLoadRequestCancelled
   *
   * @param {string} url - `URL` of the data source.
   * @param {FusionCharts~dataFormats} dataFormat - The data format that was specified to be expected from the
   * contents of the `url`.
   */
  (0, _eventApi.triggerEvent)('dataLoadRequestCancelled', chart, args);
  // In case cancel was hit even before this function reached here,
  // we then do not proceed.
  if (state && state.dhmXhrObj) {
    state.dhmXhrObj.abort();
  }
}

exports.sourceName = SOURCE_NAME;
exports.onDataLoadRequest = onDataLoadRequest;
exports.onDataLoadRequestCancel = onDataLoadRequestCancel;

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

exports.__esModule = true;

var _iterator = __webpack_require__(9);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(10);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2['default'] === "function" && typeof _iterator2['default'] === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2['default'] === "function" && obj.constructor === _symbol2['default'] && obj !== _symbol2['default'].prototype ? "symbol" : typeof obj; };

var _eventApi = __webpack_require__(7);

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * This module handles all XMLHttpRequests by exposing a managed AJAX module.
 * @private
 */
var UNDEF,

// define constants for future use.
MSXMLHTTP = 'Microsoft.XMLHTTP',
    MSXMLHTTP2 = 'Msxml2.XMLHTTP',
    FUNCTION = 'function',
    GET = 'GET',
    POST = 'POST',
    XHREQERROR = 'XmlHttprequest Error',
    RUN = 'run',
    ERRNO = '1110111515A',
    win = window,
    // keep a local reference of window scope

// Probe IE version
version = parseFloat(win.navigator.appVersion.split('MSIE')[1]),
    ielt8 = !!(version >= 5.5 && version <= 7),
    firefox = /mozilla/i.test(win.navigator.userAgent),


// Calculate flags.
// Check whether the page is on file protocol.
fileProtocol = win.location.protocol === 'file:',
    AXObject = win.ActiveXObject,


// Check if native xhr is present
XHRNative = (!AXObject || !fileProtocol) && win.XMLHttpRequest,


/**
 * These counters keep a track of various http requests sent by FusionCharts. These can be retrieved using
 * {@link FusionCharts.ajax.stats}
 * @memberOf FusionCharts.ajax~
 *
 * @property {number} objects - The number of internal `Ajax` objects created by FusionCharts. This is not same
 * as `XMLHttpRequest` object since one `Ajax` object can have a number of `XMLHttpRequest` objects.
 * @property {number} xhr - A count of all `XMLHttpRequest` objects created.
 * @property {number} requests - Sum of all requests sent to server (both GET and POST.)
 * @property {number} success - The total number of requests that had a successful return from server.
 * @property {number} failure - The total number of requests that failed to communicate with server due to
 * various factors.
 * @property {number} idle - `XMLHttpRequest` objects that are idle for later use or has not been disposed yet.
 */
counters = {
  objects: 0,
  xhr: 0,
  requests: 0,
  success: 0,
  failure: 0,
  idle: 0
},


// Prepare function to retrieve compatible xmlhttprequest.
_newXmlHttpRequest = function newXmlHttpRequest() {
  var xmlhttp;

  // if xmlhttprequest is present as native, use it.
  if (XHRNative) {
    _newXmlHttpRequest = function newXmlHttpRequest() {
      counters.xhr++;
      return new XHRNative();
    };
    return _newXmlHttpRequest();
  }

  // Use activeX for IE
  try {
    xmlhttp = new AXObject(MSXMLHTTP2);
    _newXmlHttpRequest = function newXmlHttpRequest() {
      counters.xhr++;
      return new AXObject(MSXMLHTTP2);
    };
  } catch (e) {
    try {
      xmlhttp = new AXObject(MSXMLHTTP);
      _newXmlHttpRequest = function newXmlHttpRequest() {
        counters.xhr++;
        return new AXObject(MSXMLHTTP);
      };
    } catch (err) {
      xmlhttp = false;
    }
  }
  return xmlhttp;
};

var Ajax = function () {
  function Ajax(success, error) {
    _classCallCheck(this, Ajax);

    this.onSuccess = success;
    this.onError = error;
    this.open = false;
    counters.objects++;
    counters.idle++;
    this.headers = {
      /**
       * Prevents cacheing of AJAX requests.
       * @type {string}
       */
      'If-Modified-Since': 'Sat, 29 Oct 1994 19:43:31 GMT',
      /**
       * Lets the server know that this is an AJAX request.
       * @type {string}
       */
      'X-Requested-With': 'XMLHttpRequest',
      /**
       * Lets server know which web application is sending requests.
       * @type {string}
       */
      'X-Requested-By': 'FusionCharts',
      /**
       * Mentions content-types that are acceptable for the response. Some servers require this for Ajax
       * communication.
       * @type {string}
       */
      'Accept': 'text/plain, */*',
      /**
       * The MIME type of the body of the request along with its charset.
       * @type {string}
       */
      'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
    };
  }

  /**
   * Returns the statistics of AJAX requests sent by FusionCharts.
   *
   * @param {string} [type] - Optionally, one can request a specific type of statistic by providing the type as
   * one of the property-name of {@link FusionCharts.ajax~counters}.
   *
   * @return {FusionCharts.ajax~counters} If no specific nature of statistics is passed to the `type`
   * parameter, this function would return an object containing all counters, otherwise it returns a specific
   * counter as in {@link FusionCharts.ajax~counters}.
   */


  Ajax.stats = function stats(type) {
    return type ? counters[type] : (0, _lib.extend2)({}, counters);
  };

  Ajax.prototype.transact = function transact(method, url, data, callbackArgs) {
    var wrapper = this,
        xmlhttp = wrapper.xmlhttp,
        headers = wrapper.headers,
        errorCallback = wrapper.onError,
        successCallback = wrapper.onSuccess,
        isPost = method === POST,
        postData,
        xRequestedBy = 'X-Requested-By',
        hasOwn = Object.prototype.hasOwnProperty,
        i;

    // X-Requested-By is removed from header during cross domain ajax call
    if (url.search(/^(http:\/\/|https:\/\/)/) !== -1 && win.location.hostname !== /(http:\/\/|https:\/\/)([^\/\:]*)/.exec(url)[2]) {
      // If the url does not contain http or https, then its a same domain call. No need to use regex to get
      // domain. If it contains then checks domain.
      delete headers[xRequestedBy];
    } else {
      !hasOwn.call(headers, xRequestedBy) && (headers[xRequestedBy] = 'FusionCharts');
    }

    if (!xmlhttp || ielt8 || firefox) {
      xmlhttp = _newXmlHttpRequest();
      wrapper.xmlhttp = xmlhttp;
    }

    xmlhttp.onreadystatechange = function () {
      try {
        if (xmlhttp.readyState === 4) {
          if (!xmlhttp.status && fileProtocol || xmlhttp.status >= 200 && xmlhttp.status < 300 || xmlhttp.status === 304 || xmlhttp.status === 1223 || xmlhttp.status === 0) {
            successCallback && successCallback(xmlhttp.responseText, wrapper, callbackArgs, url);
            counters.success++;
          } else if (errorCallback) {
            errorCallback(new Error(XHREQERROR), wrapper, callbackArgs, url);
            counters.failure++;
          }
          counters.idle--;
          wrapper.open = false;
        }
      } catch (error) {
        if (errorCallback) {
          errorCallback(error, wrapper, callbackArgs, url);
        }
        if (win.FC_DEV_ENVIRONMENT) {
          setTimeout(function () {
            throw error;
          }, 0);
        }
        counters.failure++;
      }
    };

    try {
      xmlhttp.open(isPost ? POST : GET, url, true);

      if (xmlhttp.overrideMimeType) {
        xmlhttp.overrideMimeType('text/plain');
      }

      if (isPost) {
        if (typeof data === 'string') {
          postData = data;
        } else {
          postData = [];
          for (i in data) {
            postData.push(i + '=' + (data[i] + '').replace(/\=/g, '%3D').replace(/\&/g, '%26'));
          }
          postData = postData.join('&');
        }
      } else {
        postData = null;
      }
      for (i in headers) {
        xmlhttp.setRequestHeader(i, headers[i]);
      }

      xmlhttp.send(postData);
      counters.requests++;
      counters.idle++;
      wrapper.open = true;
    } catch (e) {
      /**
       * AJAX runtime error. Raised when AJAX transactions raise error (security or others). The error
       * message describes the nature of the error.
       *
       * @typedef {RuntimeException} Error-1110111515A
       * @memberOf FusionCharts.debugger
       * @group debugger-error
       */
      (0, _eventApi.raiseError)(global.core, ERRNO, RUN, XHREQERROR, e.message);
    }

    return xmlhttp;
  };

  Ajax.prototype.get = function get(url, callbackArgs) {
    return this.transact(GET, url, UNDEF, callbackArgs);
  };

  Ajax.prototype.post = function post(url, data, callbackArgs) {
    return this.transact(POST, url, data, callbackArgs);
  };

  Ajax.prototype.abort = function abort() {
    var instance = this,
        xmlhttp = instance.xmlhttp;
    instance.open = false;
    return xmlhttp && _typeof(xmlhttp.abort) === FUNCTION && xmlhttp.readyState && xmlhttp.readyState !== 0 && xmlhttp.abort();
  };

  Ajax.prototype.dispose = function dispose() {
    var instance = this;
    instance.open && instance.abort();

    delete instance.onError;
    delete instance.onSuccess;
    delete instance.xmlhttp;
    delete instance.open;

    counters.objects--;
    return instance = null;
  };

  return Ajax;
}();

exports['default'] = Ajax;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)))

/***/ }),
/* 188 */
/***/ (function(module, exports) {

var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(347);
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};

/***/ }),
/* 190 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(349);
module.exports = function(it){
  return Object(defined(it));
};

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(193)
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

/***/ }),
/* 193 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(190);
module.exports = Array.isArray || function isArray(arg){
  return cof(arg) == 'Array';
};

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

var store      = __webpack_require__(352)('wks')
  , uid        = __webpack_require__(188)
  , Symbol     = __webpack_require__(65).Symbol
  , USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function(name){
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(129);

module.exports = function(method, arg){
  return !!method && fails(function(){
    arg ? method.call(null, function(){}, 1) : method.call(null);
  });
};

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(363), __esModule: true };

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY        = __webpack_require__(133)
  , $export        = __webpack_require__(199)
  , redefine       = __webpack_require__(202)
  , hide           = __webpack_require__(53)
  , has            = __webpack_require__(43)
  , Iterators      = __webpack_require__(136)
  , $iterCreate    = __webpack_require__(368)
  , setToStringTag = __webpack_require__(140)
  , getPrototypeOf = __webpack_require__(375)
  , ITERATOR       = __webpack_require__(56)('iterator')
  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
  , FF_ITERATOR    = '@@iterator'
  , KEYS           = 'keys'
  , VALUES         = 'values';

var returnThis = function(){ return this; };

module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
  $iterCreate(Constructor, NAME, next);
  var getMethod = function(kind){
    if(!BUGGY && kind in proto)return proto[kind];
    switch(kind){
      case KEYS: return function keys(){ return new Constructor(this, kind); };
      case VALUES: return function values(){ return new Constructor(this, kind); };
    } return function entries(){ return new Constructor(this, kind); };
  };
  var TAG        = NAME + ' Iterator'
    , DEF_VALUES = DEFAULT == VALUES
    , VALUES_BUG = false
    , proto      = Base.prototype
    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , $default   = $native || getMethod(DEFAULT)
    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
    , methods, key, IteratorPrototype;
  // Fix native
  if($anyNative){
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
    if(IteratorPrototype !== Object.prototype){
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if(DEF_VALUES && $native && $native.name !== VALUES){
    VALUES_BUG = true;
    $default = function values(){ return $native.call(this); };
  }
  // Define iterator
  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG]  = returnThis;
  if(DEFAULT){
    methods = {
      values:  DEF_VALUES ? $default : getMethod(VALUES),
      keys:    IS_SET     ? $default : getMethod(KEYS),
      entries: $entries
    };
    if(FORCED)for(key in methods){
      if(!(key in proto))redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

var global    = __webpack_require__(36)
  , core      = __webpack_require__(134)
  , ctx       = __webpack_require__(366)
  , hide      = __webpack_require__(53)
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , IS_WRAP   = type & $export.W
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , expProto  = exports[PROTOTYPE]
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
    , key, own, out;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if(own && key in exports)continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function(C){
      var F = function(a, b, c){
        if(this instanceof C){
          switch(arguments.length){
            case 0: return new C;
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if(IS_PROTO){
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library` 
module.exports = $export;

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(55) && !__webpack_require__(88)(function(){
  return Object.defineProperty(__webpack_require__(201)('div'), 'a', {get: function(){ return 7; }}).a != 7;
});

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(87)
  , document = __webpack_require__(36).document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(53);

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject    = __webpack_require__(86)
  , dPs         = __webpack_require__(369)
  , enumBugKeys = __webpack_require__(139)
  , IE_PROTO    = __webpack_require__(137)('IE_PROTO')
  , Empty       = function(){ /* empty */ }
  , PROTOTYPE   = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function(){
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(201)('iframe')
    , i      = enumBugKeys.length
    , lt     = '<'
    , gt     = '>'
    , iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(374).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties){
  var result;
  if(O !== null){
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty;
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

var has          = __webpack_require__(43)
  , toIObject    = __webpack_require__(44)
  , arrayIndexOf = __webpack_require__(371)(false)
  , IE_PROTO     = __webpack_require__(137)('IE_PROTO');

module.exports = function(object, names){
  var O      = toIObject(object)
    , i      = 0
    , result = []
    , key;
  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while(names.length > i)if(has(O, key = names[i++])){
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

/***/ }),
/* 205 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(381), __esModule: true };

/***/ }),
/* 207 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys      = __webpack_require__(204)
  , hiddenKeys = __webpack_require__(139).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
  return $keys(O, hiddenKeys);
};

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__(9);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(10);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2['default'] === "function" && typeof _iterator2['default'] === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2['default'] === "function" && obj.constructor === _symbol2['default'] && obj !== _symbol2['default'].prototype ? "symbol" : typeof obj; };

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var win = window,
    doc = win.document;

/*
* DOM Animation Manager
*
* ~param {object} parent The parent object in which the instance of the
* Animation framework will be stored
*/

exports['default'] = function () {
  var animatable = {
    width: {
      suffix: 'px'
    },
    height: {
      suffix: 'px'
    },
    opacity: true,
    top: {
      suffix: 'px'
    },
    left: {
      suffix: 'px'
    }
  },
      predefinedAnimations = {},
      effects = {
    linear: function linear(diff, iterations) {
      var returnArr = [],
          increment = diff / iterations,
          i = 0;

      for (; i < iterations; i += 1) {
        returnArr[i] = increment * (i + 1);
      }

      return returnArr;
    }
  },
      isIE = /msie/i.test(win.navigator.userAgent) && !win.opera,
      UNIT_INTERVAL = 40,
      doAnimation;

  /*
   *
   * ~param {type} ele
   * ~param {type} rule
   * ~returns {number} strValue The current numeric value of the css rule.
   */
  function getAppliedStyle(ele, rule) {
    var strValue = '';
    if (doc.defaultView && doc.defaultView.getComputedStyle) {
      strValue = doc.defaultView.getComputedStyle(ele, '').getPropertyValue(rule);
    } else if (ele.currentStyle) {
      // eslint-disable-next-line no-unused-vars
      rule = rule.replace(/\-(\w)/g, function (strMatch, p1) {
        return p1.toUpperCase();
      });
      strValue = ele.currentStyle[rule];
    }
    strValue = parseInt(strValue, 10);

    return isNaN(strValue) ? 0 : strValue;
  }

  /*
  *
  * ~param {type} element
  * ~param {type} duration
  * ~param {type} start
  * ~param {type} end
  * ~param {type} rule
  * ~param {type} effect
  * ~param {type} callback
  * ~param {type} suff
  * ~returns {undefined}
  */
  function animatorStyle(element, duration, start, end, rule, effect, callback, suff) {
    var iterations = duration / UNIT_INTERVAL,
        diff = end - start,
        incrementArr = effects[effect || 'linear'](diff, iterations),
        counter = 0,
        startTime,
        progress,
        requestAnimFrame = win.requestAnimationFrame || win.webkitRequestAnimationFrame || win.mozRequestAnimationFrame || win.oRequestAnimationFrame || win.msRequestAnimationFrame || function (callback) {
      setTimeout(callback, UNIT_INTERVAL);
    },
        stepFn = function stepFn(timestamp) {
      var diff,
          setValue,
          val,
          value,
          reduce = false;

      if (timestamp) {
        if (!startTime) {
          startTime = timestamp;
        }
        progress = timestamp - startTime;

        diff = Math.abs(start - end);

        reduce = !(start - end < 0);

        setValue = reduce ? Math.max(start - progress * (diff / duration), end) + suff : Math.min(start + progress * (diff / duration), end) + suff;

        element.style[rule] = setValue;

        if (isIE && rule === 'opacity') {
          setValue = Number(setValue) * 100;
          element.style.filter = 'progid:DXImageTransform.Microsoft.Alpha(Opacity=' + setValue + ')';
        }

        if (progress < duration) {
          requestAnimFrame(stepFn);
        } else {
          callback && callback();
        }
      } else {
        if (counter < iterations) {
          val = incrementArr[counter];
          element.style[rule] = start + val + suff;
          if (isIE && rule === 'opacity') {
            value = Number(val) * 100;
            element.style.filter = 'progid:DXImageTransform.Microsoft.Alpha(Opacity=' + value + ')';
          }

          counter += 1;
          setTimeout(stepFn, UNIT_INTERVAL);
        } else {
          callback && callback();
        }
      }
    };

    suff = suff || '';
    requestAnimFrame(stepFn);
  }

  /*
  *
  * ~param {type} element
  * ~param {type} toAnimate
  * ~param {type} duration
  * ~param {type} effect
  * ~param {type} callback
  * ~returns {undefined}
  */
  doAnimation = function doAnimation(element, stylesToAnimate, duration) {
    var effect = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'linear';
    var callback = arguments[4];

    // 1. validate the styles
    var finalStyle = {},
        currentStyle = {},
        finished = 0,
        total = 0,
        iCB = function iCB() {
      finished += 1;
      if (finished === total) {
        typeof callback === 'function' && callback();
      }
    },
        suff,
        rule,
        rulePrev;

    if (duration < UNIT_INTERVAL) {
      // If the duration of animation is less than the
      // minimum frame length then apply the styles directly.
      for (rule in stylesToAnimate) {
        element.style[rule] = stylesToAnimate[rule];
      }

      callback && callback();
      return;
    }

    for (rule in stylesToAnimate) {
      rulePrev = null;
      if (rule === 'x') {
        rulePrev = rule;
        rule = 'left';
      } else if (rule === 'y') {
        rulePrev = rule;
        rule = 'top';
      }

      if (animatable[rule]) {
        total += 1;
        finalStyle[rule] = stylesToAnimate[rulePrev || rule];
        currentStyle[rule] = getAppliedStyle(element, rule);
        suff = _typeof(animatable[rule]) === 'object' && animatable[rule].suffix;

        animatorStyle(element, duration, currentStyle[rule], finalStyle[rule], rule, effect, iCB, suff);
      }
    }
  };

  return (0, _lib.extend2)({
    animate: doAnimation
  }, predefinedAnimations);
}();

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _componentInterface = __webpack_require__(6);

var _componentInterface2 = _interopRequireDefault(_componentInterface);

var _axisRefVisuals = __webpack_require__(403);

var _axisRefVisuals2 = _interopRequireDefault(_axisRefVisuals);

var _lib = __webpack_require__(5);

var _find = __webpack_require__(211);

var _find2 = _interopRequireDefault(_find);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var mathMax = Math.max,
    MAX_MITER_LINEJOIN = 2,
    miterStr = _lib.preDefStr.miterStr,
    NONE = _lib.preDefStr.noneStr,
    ROUND = _lib.preDefStr.ROUND,
    clipSumValue = 'clip-sum-value',
    clipCanvasInitStr = 'clip-canvas-init',
    clipCanvasStr = 'clip-canvas';
/**
 * Canvas is responsible for create the groups where the chart is going to render.
 * Canvas has also ability to add input buttons, all input components have to be added to
 * canvas to activate them. Ex. ZoomIn,ZoomOut etc Button in zoomscatter chart.
 * Before adding any input component to canvas it is required to attach axes to canvas,
 * so that input components can recognize what axis is zoomable or pannable.
 */

var Canvas = function (_ComponentInterface) {
  _inherits(Canvas, _ComponentInterface);

  function Canvas() {
    _classCallCheck(this, Canvas);

    var _this = _possibleConstructorReturn(this, _ComponentInterface.call(this));

    var canvas = _this,
        axisRefComp = new _axisRefVisuals2['default']();
    canvas.config = {};
    canvas.config.axes = canvas.config.axes || [];

    canvas.attachChild(axisRefComp, 'axisRefVisuals');
    canvas.addToEnv('canvasConfig', _this.config);
    return _this;
  }

  Canvas.prototype.createGroup = function createGroup() {
    var canvas = this,
        chart = canvas.getFromEnv('chart'),
        chartChildContainer = chart.getChildContainer(),
        parentGroup = chart.getContainer('parentGroup'),
        axisBottomGroup = chartChildContainer.axisBottomGroup,
        sumLabelsLayer = chartChildContainer.sumLabelsLayer,
        plotGroup = chartChildContainer.plotGroup,
        paper = chart.getFromEnv('paper');

    !canvas.getContainer('canvasGroup') && canvas.addContainer('canvasGroup', paper.group('canvas', parentGroup)).insertBefore(axisBottomGroup);

    !canvas.getChildContainer('quadrantGroup') && canvas.addChildContainer('quadrantGroup', paper.group('quadrant', parentGroup)).insertBefore(sumLabelsLayer);

    !canvas.getChildContainer('axisReferenceVisualsBottom') && canvas.addChildContainer('axisReferenceVisualsBottom', paper.group('axisReferenceVisualsBottom', parentGroup)).insertBefore(chartChildContainer.belowPlotGroup);

    !canvas.getChildContainer('axisReferenceVisualsTop') && canvas.addChildContainer('axisReferenceVisualsTop', paper.group('axisReferenceVisualsTop', parentGroup)).insertAfter(chartChildContainer.abovePlotGroup);

    !canvas.getChildContainer('sumLabelsLayer') && canvas.addChildContainer('sumLabelsLayer', chartChildContainer.sumLabelsLayer);

    !canvas.getChildContainer('columnShadowGroup') && canvas.addChildContainer('columnShadowGroup', paper.group('column-shadow-group', plotGroup));
    !canvas.getChildContainer('columnGroup') && canvas.addChildContainer('columnGroup', paper.group('column', plotGroup));

    !canvas.getChildContainer('areaShadowGroup') && canvas.addChildContainer('areaShadowGroup', paper.group('area-shadow-group', plotGroup));
    !canvas.getChildContainer('areaGroup') && canvas.addChildContainer('areaGroup', paper.group('area', plotGroup));

    !canvas.getChildContainer('lineShadowGroup') && canvas.addChildContainer('lineShadowGroup', paper.group('line-shadow-group', plotGroup));
    !canvas.getChildContainer('lineGroup') && canvas.addChildContainer('lineGroup', paper.group('line', plotGroup));

    !canvas.getChildContainer('defaultShadowGroup') && canvas.addChildContainer('defaultShadowGroup', paper.group('default-shadow-group', plotGroup));
    !canvas.getChildContainer('defaultGroup') && canvas.addChildContainer('defaultGroup', paper.group('default', plotGroup));
  };

  /**
   * this function calculate the colaborative space and padding required by the datasets
   */


  Canvas.prototype.setCanvasPadding = function setCanvasPadding() {
    var iapi = this,
        canvasConfig = iapi.config,
        dimensions;

    dimensions = iapi.getCanvasPadding();

    canvasConfig.canvasPaddingLeft = mathMax(canvasConfig.canvasPaddingLeft, dimensions.paddingLeft || 0);
    canvasConfig.canvasPaddingRight = mathMax(canvasConfig.canvasPaddingRight, dimensions.paddingRight || 0);
    canvasConfig.canvasPaddingTop = mathMax(canvasConfig.canvasPaddingTop, dimensions.paddingTop || 0);
    canvasConfig.canvasPaddingBottom = mathMax(canvasConfig.canvasPaddingBottom, dimensions.paddingBottom || 0);
  };

  Canvas.prototype.getEffectiveDimensions = function getEffectiveDimensions() {
    var canvas = this,
        config = canvas.config,
        left = config.canvasLeft,
        top = config.canvasTop,
        width = config.canvasWidth,
        height = config.canvasHeight,
        paddingLeft = config.canvasPaddingLeft,
        paddingTop = config.canvasPaddingTop,
        paddingRight = config.canvasPaddingRight,
        paddingBottom = config.canvasPaddingBottom;
    return {
      left: left,
      top: top,
      width: width,
      height: height,
      paddingLeft: paddingLeft,
      paddingTop: paddingTop,
      paddingRight: paddingRight,
      paddingBottom: paddingBottom
    };
  };

  Canvas.prototype.setDimension = function setDimension(dim) {
    var canvas = this,
        config = canvas.config;
    config.canvasTop = dim.top;
    config.canvasLeft = dim.left;
    config.canvasWidth = dim.width;
    config.canvasHeight = dim.height;
  };

  Canvas.prototype.getCanvasPadding = function getCanvasPadding() {
    var iapi = this,
        dim,
        key,
        chartConfig = iapi.getFromEnv('chartConfig'),
        canvasWidth = chartConfig.canvasWidth,
        canvasConfig = iapi.config,
        paddingLeft,
        paddingRight,
        spaceLimit = canvasConfig.maxPaddingPercent * canvasWidth / 100,
        returnDimension = {
      paddingLeft: 0,
      paddingRight: 0,
      paddingTop: 0,
      paddingBottom: 0
    };
    iapi._mapChildren(function (child) {
      dim = child.getCanvasPadding && child.getCanvasPadding() || {};
      for (key in dim) {
        if (dim.hasOwnProperty(key)) {
          returnDimension[key] = mathMax(dim[key], returnDimension[key]);
        }
      }
    });
    paddingLeft = returnDimension.paddingLeft || 0;
    paddingRight = returnDimension.paddingRight || 0;

    if (spaceLimit < paddingLeft) {
      returnDimension.paddingLeft = spaceLimit;
    }
    if (spaceLimit < paddingRight) {
      returnDimension.paddingRight = spaceLimit;
    }
    return returnDimension;
  };
  /**
   * function to configure itself and its children
   */


  Canvas.prototype.configure = function configure() {
    // Adding the input component array
    this.config.inputComponents = [];
    this.config.maxPaddingPercent = 12.5;
    this._mapChildren(function (child) {
      if (child.getState('removed') || child.getType && child.getType() === 'dataset') {
        return;
      }
      child.configure && child.configure();
    });
  };
  /*
   * dispose all inputs attached
  */


  Canvas.prototype.disposeAllInputs = function disposeAllInputs() {
    this.config.inputComponents.forEach(function (input) {
      input.dispose();
    });
    this.config.inputComponents.length = 0;
  };

  Canvas.prototype.axisExists = function axisExists(axis) {
    var axisArr = this.config.axes,
        i = void 0,
        ii = void 0,
        status = false;

    for (i = 0, ii = axisArr.length; i < ii; i++) {
      if (axisArr[i].axis === axis) {
        status = true;
        break;
      }
    }

    return status;
  };

  Canvas.prototype.attachAxis = function attachAxis(axis, isY, config) {
    var axisArr = this.config.axes,
        axisType = isY ? 'yAxis' : 'xAxis',
        axes = this.getFromEnv(axisType);

    if (!this.axisExists(axis)) {
      axisArr.push({
        axis: axis,
        isY: isY,
        config: config || {}
      });
    }
    axes || (axes = []);
    axes.push(axis);
    this.addToEnv(axisType, axes);
    return this;
  };

  /**
   * Function for setting the primary axis wrt to the canvas
   * @param {string} type xAxis/yAxis
   * @param {Object} axis The axis object
   */


  Canvas.prototype.setPrimaryAxis = function setPrimaryAxis(type, axis) {
    var axisConfig = this.config,
        primaryAxis = axisConfig.primaryAxis || (axisConfig.primaryAxis = {});
    primaryAxis[type] = _find2['default'].call(axisConfig.axes, function (obj) {
      return obj.axis === axis;
    });
  };

  /**
   * If primary axis is set then only the primary axis are returned else all the axis
   * @return {Object} Axis
   */


  Canvas.prototype.getAxes = function getAxes() {
    var axisConfig = this.config,
        primaryAxis;
    if (primaryAxis = axisConfig.primaryAxis) {
      return [primaryAxis.xAxis, primaryAxis.yAxis];
    }
    return this.config.axes.slice(0);
  };

  Canvas.prototype.detachAxis = function detachAxis(axis, _index) {
    var axisArr = this.config.axes,
        index = Infinity;
    if (_index) {
      return axisArr.splice(_index, 1);
    }
    axisArr.forEach(function (axisOb, i) {
      if (axisOb.axis === axis) {
        index = i;
      }
    });
    return axisArr.splice(index, 1);
  };

  Canvas.prototype.preDraw = function preDraw() {
    this._mapChildren(function (child) {
      child.preDraw && child.preDraw();
    });
  };

  Canvas.prototype.draw = function draw() {
    this.createGroup();
    !this.getFromEnv('chart').config.skipCanvasDrawing && this.drawCanvas();
    this._mapChildren(function (child) {
      child.syncDraw && child.syncDraw();
    });
  };

  Canvas.prototype.drawCanvas = function drawCanvas() {
    var canvas = this,
        chart = canvas.getFromEnv('chart'),
        jsonData = chart.jsonData,
        chartAttrs = jsonData.chart,
        chartConfig = chart.config,
        paper = canvas.getFromEnv('paper'),
        config = canvas.config,
        clip = config.clip = {},
        clipCanvas = void 0,
        dsGroup = chart.getChildContainer('plotGroup'),
        dataLabelsLayer = chart.getChildContainer('datalabelsGroup'),
        sumLabelsLayer = canvas.getChildContainer('sumLabelsLayer'),
        canvasBorderElement = canvas.getGraphicalElement('canvasBorderElement'),


    // animationObj = chart.get(configStr, animationObjStr),
    // animType = animationObj.animType,
    // animObj = animationObj.animObj,
    // dummyObj = animationObj.dummyObj,
    // animationDuration = animationObj.duration,

    canvasElement = canvas.getGraphicalElement('canvasElement'),
        canvasLeft = config.canvasLeft || (config.canvasLeft = chartConfig.canvasLeft),
        canvasTop = config.canvasTop || (config.canvasTop = chartConfig.canvasTop),
        canvasWidth = config.canvasWidth || (config.canvasWidth = chartConfig.canvasWidth),
        canvasHeight = config.canvasHeight || (config.canvasHeight = chartConfig.canvasHeight),
        xDepth = config.xDepth = chartConfig.xDepth || 0,
        yDepth = config.yDepth = chartConfig.yDepth || 0,
        canvasGroup = canvas.getContainer('canvasGroup'),
        quadrantGroup = canvas.getChildContainer('quadrantGroup'),
        canvasBorderRadius = config.canvasBorderRadius,
        canvasBorderWidth = config.canvasBorderWidth,
        borderWHlf = canvasBorderWidth * 0.5,
        canvasBorderColor = config.canvasBorderColor,
        canBGColor = config.canBGColor,
        canBGAlpha = config.canBGAlpha,
        shadow = config.shadow,
        canvasBgColor = void 0,
        attr = void 0,
        dataArr = [],
        showCanvasBg = config.showCanvasBG = Boolean((0, _lib.pluckNumber)(chartAttrs.showcanvasbg, 1)),
        shadowOnCanvasFill = config.shadowOnCanvasFill,
        showCanvasBorder = config.showCanvasBorder;

    canvasBgColor = canBGColor;

    attr = {
      x: canvasLeft - borderWHlf,
      y: canvasTop - borderWHlf,
      width: canvasWidth + canvasBorderWidth,
      height: canvasHeight + canvasBorderWidth,
      r: canvasBorderRadius,
      'stroke-width': canvasBorderWidth,
      stroke: canvasBorderColor,
      'stroke-linejoin': canvasBorderWidth > MAX_MITER_LINEJOIN ? ROUND : miterStr
    };

    if (showCanvasBorder) {
      if (!canvasBorderElement) {
        canvas.addGraphicalElement('canvasBorderElement', paper.rect(attr, canvasGroup)).shadow(shadow);
      } else {
        canvasBorderElement.show();
        // canvasBorderElement.animateWith(dummyObj, animObj, {
        //     x: canvasLeft - borderWHlf,
        //     y: canvasTop - borderWHlf,
        //     width: canvasWidth + canvasBorderWidth,
        //     height: canvasHeight + canvasBorderWidth,
        //     r: canvasBorderRadius
        // }, animationDuration, animType);
        // canvasBorderElement.attr ({
        //     'stroke-width': canvasBorderWidth,
        //     stroke: canvasBorderColor,
        //     'stroke-linejoin': canvasBorderWidth > MAX_MITER_LINEJOIN ? ROUND : miterStr
        // });

        dataArr.push({
          el: canvasBorderElement,
          attrs: {
            x: canvasLeft - borderWHlf,
            y: canvasTop - borderWHlf,
            width: canvasWidth + canvasBorderWidth,
            height: canvasHeight + canvasBorderWidth,
            r: canvasBorderRadius,
            'stroke-width': canvasBorderWidth,
            stroke: canvasBorderColor,
            'stroke-linejoin': canvasBorderWidth > MAX_MITER_LINEJOIN ? ROUND : miterStr
          }
        });

        canvasBorderElement.shadow(shadow);
      }
    } else {
      canvasBorderElement && canvasBorderElement.hide();
    }

    // create a clip-rect to clip canvas for later use
    clip[clipCanvasStr] = [mathMax(0, canvasLeft - xDepth), mathMax(0, canvasTop - yDepth), mathMax(1, canvasWidth + xDepth * 2), mathMax(1, canvasHeight + yDepth)];
    clip[clipSumValue] = [mathMax(0, canvasLeft - xDepth), 0, mathMax(1, canvasWidth + xDepth * 2), mathMax(1, canvasHeight + yDepth)];
    clip[clipCanvasInitStr] = [mathMax(0, canvasLeft - xDepth), mathMax(0, canvasTop - yDepth), 1, mathMax(1, canvasHeight + yDepth * 2)];

    if (!chartConfig.skipClipping) {
      clipCanvas = clip[clipCanvasStr].slice(0);
      if (!dsGroup.attrs['clip-rect']) {
        dsGroup.attr({
          'clip-rect': clipCanvas
        });
      } else {
        dataArr.push({
          el: dsGroup,
          attrs: {
            'clip-rect': clipCanvas
          }
        });
      }

      if (!dataLabelsLayer.attrs['clip-rect']) {
        dataLabelsLayer.attr({
          'clip-rect': clipCanvas
        });
      } else {
        dataArr.push({
          el: dataLabelsLayer,
          attrs: {
            'clip-rect': clipCanvas
          }
        });
      }
      if (!sumLabelsLayer.attrs['clip-rect']) {
        sumLabelsLayer.attr({
          'clip-rect': clip[clipSumValue]
        });
      } else {
        dataArr.push({
          el: sumLabelsLayer,
          attrs: {
            'clip-rect': clip[clipSumValue]
          }
        });
      }
      if (!quadrantGroup.attrs['clip-rect']) {
        quadrantGroup.attr({
          'clip-rect': clipCanvas
        });
      } else {
        dataArr.push({
          el: quadrantGroup,
          attrs: {
            'clip-rect': clipCanvas
          }
        });
      }
    }

    if (showCanvasBg) {
      attr = {
        x: canvasLeft,
        y: canvasTop,
        width: canvasWidth,
        height: canvasHeight,
        r: canvasBorderRadius,
        'stroke-width': 0,
        'stroke': NONE,
        fill: (0, _lib.toRaphaelColor)(canvasBgColor)
      };

      if (!canvasElement) {
        canvasElement = canvas.addGraphicalElement('canvasElement', paper.rect(attr, canvasGroup));
      } else {
        canvasElement.show();

        dataArr.push({
          el: canvasElement,
          attrs: {
            x: canvasLeft,
            y: canvasTop,
            width: canvasWidth,
            height: canvasHeight,
            r: canvasBorderRadius,
            'stroke-width': 0,
            'stroke': NONE,
            fill: (0, _lib.toRaphaelColor)(canvasBgColor)
          }
        });

        // canvasElement.animateWith(dummyObj, animObj, {
        //     x: canvasLeft,
        //     y: canvasTop,
        //     width: canvasWidth,
        //     height: canvasHeight,
        //     r: canvasBorderRadius
        // }, animationDuration, animType);
        // canvasElement.attr ({
        //     'stroke-width': 0,
        //     'stroke': NONE,
        //     fill: toRaphaelColor (canvasBgColor)
        // });
      }
      if (shadowOnCanvasFill) {
        canvasElement.shadow({ opacity: canBGAlpha / 100 });
      } else {
        canvasElement.shadow(false);
      }
    } else {
      canvasElement && canvasElement.hide();
    }
    chart.getFromEnv('animationManager').registerAnimation([{
      data: dataArr
    }], 'axis');
  };

  Canvas.prototype.addInput = function addInput(input) {
    // Initialize and configure the components
    // Draw should be called from configure
    // input.init(this);
    input.configure();
    this.config.inputComponents.push(input);
  };

  // Return 0 - none 1 - some 2 - all


  Canvas.prototype.isInputEnabledAny = function isInputEnabledAny(tag) {
    var inputComponents = this.config.inputComponents,
        enabledComponents = 0;
    inputComponents.forEach(function (component) {
      if (~component.tags.indexOf(tag) && component.isEnabled()) {
        enabledComponents++;
      }
    });
    if (inputComponents.length && enabledComponents === inputComponents.length) {
      return 2;
    }
    return +!!enabledComponents;
  };

  Canvas.prototype.notifyChange = function notifyChange(event) {
    // Inform all child Components that event has occured
    this.config.inputComponents.forEach(function (input) {
      if (input === event.component) {
        return;
      }
      input.onEvent && input.onEvent(event);
    });
  };

  return Canvas;
}(_componentInterface2['default']);

exports['default'] = Canvas;

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(404);
module.exports = __webpack_require__(66)('Array').find;

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _lib = __webpack_require__(5);

var _componentInterface = __webpack_require__(6);

var _componentInterface2 = _interopRequireDefault(_componentInterface);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var mathMax = Math.max,
    mathMin = Math.min,
    mathCeil = Math.ceil,
    mathRound = Math.round;

var Caption = function (_ComponentInterface) {
  _inherits(Caption, _ComponentInterface);

  function Caption() {
    _classCallCheck(this, Caption);

    return _possibleConstructorReturn(this, _ComponentInterface.apply(this, arguments));
  }

  Caption.prototype.configure = function configure() {
    var iapi = this.getFromEnv('chart'),
        chartAttrs = iapi.getFromEnv('chart-attrib'),
        caption = this,
        captionConfig = caption.config || {},
        style = iapi.getFromEnv('style'),
        outCanfontFamily = style.outCanfontFamily,
        outCancolor = style.outCancolor,
        fontSize = style.fontSize,
        subCaption = iapi.getChildren('subCaption')[0],
        subCaptionConfig = subCaption.config || {};

    caption.config.text = (0, _lib.parseUnsafeString)(chartAttrs.caption);
    subCaption.config.text = (0, _lib.parseUnsafeString)(chartAttrs.subcaption);

    // subCaptionStyle = subCaptionConfig.style;
    captionConfig.style = {
      fontFamily: (0, _lib.pluck)(chartAttrs.captionfont, outCanfontFamily),
      color: (0, _lib.convertColor)((0, _lib.pluck)(chartAttrs.captionfontcolor, outCancolor).replace(/^#? ([a-f0-9]+)/ig, '#$1')),
      fontSize: (0, _lib.pluckNumber)(chartAttrs.captionfontsize, fontSize + 3) + _lib.PXSTRING,
      fontWeight: (0, _lib.pluckNumber)(chartAttrs.captionfontbold) === 0 ? _lib.NORMAL : _lib.BOLD
    };

    if (!captionConfig.align) {
      captionConfig.align = '';
    }
    if (!subCaptionConfig.align) {
      subCaptionConfig.align = '';
    }
    captionConfig.align = subCaptionConfig.align = (0, _lib.pluck)(chartAttrs.captionalignment, _lib.POSITION_CENTER);
    switch (captionConfig.align) {
      case _lib.POSITION_RIGHT:
        captionConfig.align = _lib.POSITION_END;
        break;
      case _lib.POSITION_LEFT:
        captionConfig.align = _lib.POSITION_START;
        break;
      default:
        captionConfig.align = _lib.POSITION_MIDDLE;
    }

    captionConfig.isOnTop = subCaptionConfig.isOnTop = (0, _lib.pluckNumber)(chartAttrs.captionontop, 1);

    // Spark charts configuration captionPosition and captionOnRight
    captionConfig.isOnLeft = !(0, _lib.pluckNumber)(chartAttrs.captiononright, 0);
    captionConfig.captionPosition = (0, _lib.getValidValue)(chartAttrs.captionposition, _lib.POSITION_TOP).toLowerCase();

    captionConfig.alignWithCanvas = subCaptionConfig.alignWithCanvas = (0, _lib.pluckNumber)(iapi.aligncaptionwithcanvas, chartAttrs.aligncaptionwithcanvas, 1);
    captionConfig.horizontalPadding = subCaptionConfig.horizontalPadding = (0, _lib.pluckNumber)(chartAttrs.captionhorizontalpadding, captionConfig.alignWithCanvas ? 0 : 15);
    captionConfig.drawCaption = true;
    (0, _lib.setLineHeight)(captionConfig.style);

    subCaptionConfig.style = {
      fontFamily: (0, _lib.pluck)(chartAttrs.subcaptionfont, chartAttrs.captionfont, outCanfontFamily),
      color: (0, _lib.convertColor)((0, _lib.pluck)(chartAttrs.subcaptionfontcolor, chartAttrs.captionfontcolor, outCancolor).replace(/^#? ([a-f0-9]+)/ig, '#$1')),
      fontSize: (0, _lib.pluckNumber)(chartAttrs.subcaptionfontsize, (0, _lib.pluckNumber)(mathMax((0, _lib.pluckNumber)(chartAttrs.captionfontsize) - 3, -1), fontSize) + (0, _lib.pluckNumber)(iapi.subTitleFontSizeExtender, 1)) + _lib.PXSTRING,
      fontWeight: (0, _lib.pluckNumber)(chartAttrs.subcaptionfontbold, iapi.subTitleFontWeight, chartAttrs.captionfontbold) === 0 ? _lib.NORMAL : _lib.BOLD
    };
    (0, _lib.setLineHeight)(subCaptionConfig.style);
  };

  Caption.prototype.getName = function getName() {
    return 'caption';
  };

  Caption.isDifferent = function isDifferent(newCaptionAttrs, oldCaptionAttrs) {
    return newCaptionAttrs.fill !== oldCaptionAttrs.fill || newCaptionAttrs.text !== oldCaptionAttrs.text || newCaptionAttrs['text-anchor'] !== oldCaptionAttrs['text-anchor'] || newCaptionAttrs['vertical-align'] !== oldCaptionAttrs['vertical-align'] || newCaptionAttrs.visibility !== oldCaptionAttrs.visibility || newCaptionAttrs.x !== oldCaptionAttrs.x || newCaptionAttrs.y !== oldCaptionAttrs.y;
  };

  Caption.prototype.draw = function draw() {
    var iapi = this.getFromEnv('chart'),
        chartConfig = iapi.config,
        textDirection = iapi.config.textDirection,

    // chartGraphics = iapi.graphics,
    captionGroup = iapi.getChildContainer().captionGroup,
        paper = iapi.getFromEnv('paper'),
        smartLabel = iapi.getFromEnv('smartLabel'),
        caption = iapi.getChildren('caption')[0],
        captionElement = caption.getGraphicalElement('captionElement'),
        subCaption = iapi.getChildren('subCaption')[0],
        subCaptionElement = subCaption.getGraphicalElement('subCaptionElement'),
        captionConfig = caption.config,
        subCaptionConfig = subCaption.config,
        captionStyle = captionConfig.style,
        subCaptionStyle = subCaptionConfig.style,
        hasCaption = captionConfig.text,
        hasSubcaption = subCaptionConfig.text,
        captionX = captionConfig.x,
        align = captionConfig.align,
        isSingleStepAnim = chartConfig.isSingleStepAnim,
        attrObj,
        showToolTip = chartConfig.showToolTip,
        animElems = {
      initial: {
        data: []
      },
      plot: {
        data: []
      },
      final: {
        data: []
      }
    },
        key;

    // if captions are needed, then we need to ensure that it is placed
    // within a group.
    // if (hasCaption || hasSubcaption) {
    //   if (!captionGroup) {
    //     captionGroup = chartGraphics.captionGroup = paper.group(CAPTION);
    //     captionGroup.trackTooltip(true);

    //     if (chartGraphics.tracker) {
    //       captionGroup.insertBefore(chartGraphics.trackerGroup);
    //     } else {
    //       captionGroup.insertAfter(chartGraphics.datasetGroup);
    //     }
    //   }
    // }

    // if definition has caption, we proceed creating one and if there
    // is no caption we remove any previously created caption element.
    if (hasCaption) {
      // iapi._addCSSDefinition (DOT + fcCaptionStr, captionStyle);
      attrObj = {
        // 'class': fcCaptionStr,
        text: captionConfig.text,
        fill: captionStyle.color,
        x: captionX,
        y: captionConfig.y,
        'text-anchor': align || _lib.POSITION_MIDDLE,
        'vertical-align': captionConfig.verticalAlign || _lib.POSITION_TOP,
        visibility: captionConfig.drawCaption ? _lib.visibleStr : _lib.hiddenStr,
        direction: textDirection
        // title: (optionsCap.originalText || BLANK)
      };

      if (!captionElement) {
        captionElement = caption.addGraphicalElement('captionElement', paper.text(attrObj, captionStyle, captionGroup));
        animElems.initial.data.push({
          el: captionElement,
          type: 'fadeIn'
        });
      } else {
        if (Caption.isDifferent(captionElement.attr(), attrObj)) {
          if (isSingleStepAnim) {
            animElems.plot.data.push({
              el: captionElement,
              callback: function callback() {
                this.css(captionStyle);
              },
              attrs: attrObj
            });
          } else {
            animElems.initial.data.push({
              el: captionElement,
              type: 'fadeOut'
            });
            animElems['final'].data.push({
              el: captionElement,
              type: 'fadeIn',
              animConfig: [{
                hookFn: function hookFn() {
                  captionElement.attr(attrObj);
                  captionElement.css(captionStyle);
                }
              }]
            });
          }
        }
      }
      captionElement.tooltip(captionConfig.originalText);

      if (smartLabel) {
        smartLabel.useEllipsesOnOverflow(chartConfig.useEllipsesWhenOverflow);
        smartLabel.setStyle(captionStyle);
        // captionHeight = smartLabel.getOriSize(captionComponents.text).height;
      } /* else {
        captionHeight = 10;
        } */
    } else if (captionElement) {
      // TODO: Investigate captionElement.remove() function
      caption._graphics.captionElement = captionElement.remove();
    }

    if (hasSubcaption) {
      // iapi._addCSSDefinition (DOT + fcSubCaptionStr, subCaptionStyle);
      attrObj = {
        // 'class': fcSubCaptionStr,
        text: subCaptionConfig.text,
        fill: subCaptionStyle.color,
        x: captionX,
        y: subCaptionConfig.y,
        'text-anchor': align || _lib.POSITION_MIDDLE,
        'vertical-align': _lib.POSITION_TOP,
        direction: textDirection,
        visibility: captionConfig.drawCaption ? _lib.visibleStr : _lib.hiddenStr
      };

      if (!subCaptionElement) {
        subCaptionElement = subCaption.addGraphicalElement('subCaptionElement', paper.text(attrObj, subCaptionStyle, captionGroup));
        animElems.initial.data.push({
          el: subCaptionElement,
          type: 'fadeIn'
        });
      } else {
        if (Caption.isDifferent(subCaptionElement.attr(), attrObj)) {
          if (isSingleStepAnim) {
            animElems.plot.data.push({
              el: subCaptionElement,
              callback: function callback() {
                this.css(subCaptionStyle);
              },
              attrs: attrObj
            });
          } else {
            animElems.initial.data.push({
              el: subCaptionElement,
              type: 'fadeOut'
            });
            animElems['final'].data.push({
              el: subCaptionElement,
              type: 'fadeIn',
              animConfig: [{
                hookFn: function hookFn() {
                  subCaptionElement.attr(attrObj);
                  subCaptionElement.css(subCaptionStyle);
                }
              }]
            });
          }
        }
      }
      subCaptionElement.tooltip(subCaptionConfig.originalText);
    } else if (subCaptionElement) {
      // TODO: Investigate subCaptionElement.remove()
      subCaptionElement = subCaption._graphics.subCaptionElement = subCaptionElement.remove();
    }

    for (key in animElems) {
      if (animElems.hasOwnProperty(key)) {
        iapi.getFromEnv('animationManager').registerAnimation([animElems[key]], key);
      }
    }

    captionGroup && captionGroup.trackTooltip(!!showToolTip);

    chartConfig.savedCaption = captionElement;
    chartConfig.savedSubCaption = subCaptionElement;

    // if neither caption or subcaption is needed, we need to dump the group as well.
    // if (!(hasCaption || hasSubcaption || !captionGroup)) {
    //           // TODO: Investigate captionGroup.remove()
    //   chartGraphics.captionGroup = captionGroup.remove();
    // }
  };

  Caption.prototype.manageSpace = function manageSpace(availableHeight, availableWidth) {
    var iapi = this.getFromEnv('chart'),
        chartConfig = iapi.config,
        caption = iapi.getChildren('caption')[0],
        subCaption = iapi.getChildren('subCaption')[0],
        captionConfig = caption.config,
        subCaptionConfig = subCaption.config,
        chartAttrs = iapi.jsonData.chart,
        SmartLabel = iapi.getFromEnv('smartLabel'),
        allowedHeight = availableHeight,
        titleText = (0, _lib.parseUnsafeString)(chartAttrs.caption),
        subTitleText = (0, _lib.parseUnsafeString)(chartAttrs.subcaption),
        captionPadding = (0, _lib.pluckNumber)(chartAttrs.captionpadding, 10),
        oriCapPadding = captionPadding,
        canvasWidth = chartConfig.canvasWidth,
        isPaddingReduced = false,
        captionObj,
        subcaptionObj,
        totalHeight = 0,
        capStyle,
        dimensions,
        subCapStyle,
        difference = 0,
        extraSpace = 0,
        captionLineHeight = 0,
        subCaptionLineHeight = 0,
        topGutterWidth = 5,
        canvasBorderThickness = mathMax(iapi.getChildren('canvas')[0].config.canvasBorderThickness, 0),
        captionWidth = 0,
        subCaptionWidth = 0;
    // if no width is mentioned then it utilises the entire canvasWidth
    !availableWidth && (availableWidth = canvasWidth);

    // text below 3px is not properly visible
    if (allowedHeight > 3) {
      if (captionPadding < canvasBorderThickness) {
        captionPadding = canvasBorderThickness + 2;
      }

      if (titleText !== _lib.BLANKSTRING) {
        // calculatethe single line's height
        capStyle = captionConfig.style;
        captionLineHeight = mathCeil((0, _lib.pluckNumber)(parseFloat(capStyle.fontHeight, 10), parseFloat(capStyle.lineHeight, 10), 12));
      }
      if (subTitleText !== _lib.BLANKSTRING) {
        subCapStyle = subCaptionConfig.style;
        subCaptionLineHeight = (0, _lib.pluckNumber)(parseInt(subCapStyle.fontHeight, 10), parseInt(subCapStyle.lineHeight, 10), 12);
      }

      if (captionLineHeight > 0 || subCaptionLineHeight > 0) {
        // calculate the min height required
        allowedHeight = mathMax(allowedHeight, 0);
        totalHeight = captionLineHeight + subCaptionLineHeight + captionPadding;
        // now decide whether it has space shgaortfall or excess
        if (totalHeight > allowedHeight) {
          difference = allowedHeight - totalHeight;
          isPaddingReduced = true;
          // first reduce the padding
          if (difference < captionPadding) {
            captionPadding = mathMax(difference, 5);
          } else {
            // if the difference is more then padding then remove the subcap also
            difference -= captionPadding;
            captionPadding = 0;
            // if the subcap is gretter then diff add the remaning space to the extraSpace
            if (subCaptionLineHeight > difference) {
              extraSpace = subCaptionLineHeight - difference + 10;
              subCaptionLineHeight = 0;
              subCaptionConfig._originalText = subCaptionConfig.text;
              subCaptionConfig.text = _lib.BLANKSTRING;
            } else {
              difference -= subCaptionLineHeight;
              subCaptionLineHeight = 0;
              // now remove the caption also
              if (captionLineHeight > difference) {
                extraSpace = captionLineHeight - difference;
              }
            }
          }
        } else {
          extraSpace = allowedHeight - totalHeight;
        }

        // //// now place the elements
        SmartLabel.useEllipsesOnOverflow(chartConfig.useEllipsesWhenOverflow);
        if (captionLineHeight > 0) {
          // set the caption style and get the caption's requared space
          SmartLabel.setStyle(capStyle);
          captionLineHeight += extraSpace;
          captionObj = SmartLabel.getSmartText(titleText, availableWidth, captionLineHeight);
          extraSpace = captionLineHeight - captionObj.height;
          captionConfig.height = captionLineHeight = captionObj.height;
          captionConfig.text = captionObj.text;
          captionConfig.originalText = captionObj.tooltext ? captionObj.tooltext : false;
          captionWidth = captionObj.width;
        }
        if (subCaptionLineHeight > 0) {
          // set the caption style and get the caption's requared space
          SmartLabel.setStyle(subCapStyle);
          subCaptionLineHeight += extraSpace;
          subcaptionObj = SmartLabel.getSmartText(subTitleText, availableWidth, subCaptionLineHeight);
          extraSpace = subCaptionLineHeight - subcaptionObj.height;
          subCaptionLineHeight = subcaptionObj.height;
          subCaptionConfig.text = subcaptionObj.text;
          subCaptionConfig.height = subcaptionObj.height;
          subCaptionConfig.originalText = subcaptionObj.tooltext ? subcaptionObj.tooltext : false;
          subCaptionWidth = subcaptionObj.width;
        }
        if (isPaddingReduced && extraSpace > 0) {
          captionPadding += mathMin(oriCapPadding - captionPadding, extraSpace);
        }
        captionConfig.captionPadding = captionPadding;
        captionConfig.height = captionLineHeight;
        captionConfig.width = captionWidth;
        subCaptionConfig.width = subCaptionWidth;
        subCaptionConfig.height = subCaptionLineHeight;

        // //now add the top margin
        totalHeight = captionLineHeight + subCaptionLineHeight + captionPadding;
      }

      if (totalHeight > chartConfig.canvasHeight) {
        totalHeight = 0;
        captionConfig.drawCaption = false;
      } else {
        captionConfig.drawCaption = true;
      }

      // totalHeight = totalHeight || canvasBorderThickness;
      if (captionConfig.isOnTop) {
        dimensions = {
          top: totalHeight
        };
      } else {
        dimensions = {
          bottom: totalHeight,
          top: topGutterWidth
        };
      }
    } else {
      dimensions = {
        bottom: 0,
        top: 0
      };
      captionConfig.drawCaption = false;
    }
    return dimensions;
  };

  Caption.prototype.managePosition = function managePosition() {
    var iapi = this.getFromEnv('chart'),
        chartConfig = iapi.config,
        caption = iapi.getChildren('caption')[0],
        subCaption = iapi.getChildren('subCaption')[0],
        captionConfig = caption.config,
        widgetValueHeight = captionConfig.widgetValueHeight || 0,
        subCaptionConfig = subCaption.config,
        captionX = captionConfig.x,
        canvasWidth = chartConfig.canvasWidth,
        capAlign = captionConfig.align,
        hasCaption = captionConfig.text,
        alignWtCanvas = captionConfig.alignWithCanvas,
        hPadding = captionConfig.horizontalPadding,
        width = chartConfig.width,
        canvasLeft = chartConfig.canvasLeft,
        canvasRight = chartConfig.canvasRight,
        marginRight = chartConfig.marginRight,
        marginLeft = chartConfig.marginLeft,
        marginTop = chartConfig.marginTop,
        canvasCentre = (mathRound(canvasLeft) || 0) + (0, _lib.pluckNumber)(canvasWidth, width) / 2,
        interCaptionGap = 2,
        captionLineHeight = captionConfig.height,
        subCaptionLineHeight = subCaptionConfig.height,
        legendConfig = iapi.getChildren('legend')[0].config,
        legendHeight = legendConfig.height,
        legendPadding = legendConfig.legendPadding,
        legendPos = legendConfig.legendPos,
        gradientLegend = iapi.getFromEnv('gradientLegend') || {},
        gradientLegendHeight = 0,
        showLegendAttr = !!(gradientLegend.conf || {}).showLegend,
        borderWidth = iapi.config.borderWidth,
        actionBar = iapi.getChildren('actionBar') && iapi.getChildren('actionBar')[0],
        actionBarHeight = 0,
        actionBarSpace;

    if (!legendConfig.isActive) {
      legendHeight = 0;
    }

    if (showLegendAttr && iapi.config.gLegendEnabled) {
      gradientLegendHeight = gradientLegend.getLogicalSpace().height;
    }

    switch (capAlign) {
      case _lib.POSITION_END:
        captionX = alignWtCanvas ? canvasRight - hPadding : width - hPadding;
        break;
      case _lib.POSITION_START:
        captionX = alignWtCanvas ? canvasLeft + hPadding : hPadding;
        break;
      default:
        captionX = alignWtCanvas ? canvasCentre : marginLeft + (width - marginLeft - marginRight) * 0.5 || width / 2;
    }
    // if (capAlign === POSITION_LEFT) {
    //   canvasCaptionGap = 0;
    //   canvasSubCaptionGap = 0;
    // } else if (capAlign === POSITION_RIGHT) {
    //   canvasCaptionGap = captionWidth;
    //   canvasSubCaptionGap = subCaptionWidth;
    // } else {
    //   canvasCaptionGap = captionWidth / 2;
    //   canvasSubCaptionGap = subCaptionWidth / 2;
    // }
    captionConfig.x = captionX;

    if (captionConfig.isOnTop) {
      captionConfig.y = (borderWidth || 0) + (marginTop || 0);
    } else {
      if (legendPos === _lib.POSITION_RIGHT) {
        legendPadding = 0;
        legendHeight = 0;
        gradientLegendHeight = 0;
      }

      if (actionBar) {
        actionBarSpace = actionBar.getLogicalSpace() || {};
        actionBarHeight = actionBarSpace.height;
        if (actionBarHeight === _lib.UNDEF || actionBarHeight === Infinity || actionBarHeight < 0) {
          actionBarHeight = 0;
        }
      }

      captionConfig.y = iapi.config.height - iapi.config.marginBottom - captionLineHeight - (subCaptionLineHeight || 0) - (borderWidth || 0) - (legendPadding || 0) - (legendHeight || 0) - gradientLegendHeight - widgetValueHeight - actionBarHeight;
    }
    captionConfig.y += captionConfig._offsetHeight || 0;
    subCaptionConfig.y = hasCaption ? captionConfig.y + captionLineHeight + interCaptionGap : captionConfig.y || marginTop || 0;
  };

  return Caption;
}(_componentInterface2['default']);

exports['default'] = Caption;

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
/* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */
var paletteColorsArr = ['AFD8F8', 'F6BD0F', '8BBA00', 'FF8E46', '008E8E', 'D64646', '8E468E', '588526', 'B3AA00', '008ED6', '9D080D', 'A186BE', 'CC6600', 'FDC689', 'ABA000', 'F26D7D', 'FFF200', '0054A6', 'F7941C', 'CC3300', '006600', '663300', '6DCFF6'],
    BGRATIOSTRING = '0,100',
    COLOR_WHITE = 'FFFFFF',
    HUNDREDSTRING = '100',
    BLANK = '',
    verticalRotation = 270,
    OPAQUE = 100;
var paletteColors = exports.paletteColors = [paletteColorsArr, paletteColorsArr, paletteColorsArr, paletteColorsArr, paletteColorsArr],
    bgColor = exports.bgColor = ['CBCBCB,E9E9E9', 'CFD4BE,F3F5DD', 'C5DADD,EDFBFE', 'A86402,FDC16D', 'FF7CA0,FFD1DD'],
    bgAngle = exports.bgAngle = [verticalRotation, verticalRotation, verticalRotation, verticalRotation, verticalRotation],
    bgRatio = exports.bgRatio = [BGRATIOSTRING, BGRATIOSTRING, BGRATIOSTRING, BGRATIOSTRING, BGRATIOSTRING],
    bgAlpha = exports.bgAlpha = ['50,50', '60,50', '40,20', '20,10', '30,30'],
    canvasBgColor = exports.canvasBgColor = [COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE],
    canvasBgAngle = exports.canvasBgAngle = [0, 0, 0, 0, 0],
    canvasBgAlpha = exports.canvasBgAlpha = [HUNDREDSTRING, HUNDREDSTRING, HUNDREDSTRING, HUNDREDSTRING, HUNDREDSTRING],
    canvasBgRatio = exports.canvasBgRatio = [BLANK, BLANK, BLANK, BLANK, BLANK],
    canvasBorderColor = exports.canvasBorderColor = ['545454', '545454', '415D6F', '845001', '68001B'],
    canvasBorderAlpha = exports.canvasBorderAlpha = [OPAQUE, OPAQUE, OPAQUE, 90, OPAQUE],
    showShadow = exports.showShadow = [0, 1, 1, 1, 1],
    divLineColor = exports.divLineColor = ['717170', '7B7D6D', '92CDD6', '965B01', '68001B'],
    divLineAlpha = exports.divLineAlpha = [40, 45, 65, 40, 30],
    altHGridColor = exports.altHGridColor = ['EEEEEE', 'D8DCC5', '99C4CD', 'DEC49C', 'FEC1D0'],
    altHGridAlpha = exports.altHGridAlpha = [50, 35, 10, 20, 15],
    altVGridColor = exports.altVGridColor = ['767575', 'D8DCC5', '99C4CD', 'DEC49C', 'FEC1D0'],
    altVGridAlpha = exports.altVGridAlpha = [10, 20, 10, 15, 10],
    anchorBgColor = exports.anchorBgColor = [COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE],
    toolTipBgColor = exports.toolTipBgColor = [COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE],
    toolTipBorderColor = exports.toolTipBorderColor = ['545454', '545454', '415D6F', '845001', '68001B'],
    baseFontColor = exports.baseFontColor = ['555555', '60634E', '025B6A', 'A15E01', '68001B'],
    borderColor = exports.borderColor = ['767575', '545454', '415D6F', '845001', '68001B'],
    borderAlpha = exports.borderAlpha = [50, 50, 50, 50, 50],
    legendBgColor = exports.legendBgColor = [COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE],
    legendBorderColor = exports.legendBorderColor = ['545454', '545454', '415D6F', '845001', 'D55979'],
    plotGradientColor = exports.plotGradientColor = [COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE],
    plotBorderColor = exports.plotBorderColor = ['333333', '8A8A8A', COLOR_WHITE, COLOR_WHITE, COLOR_WHITE],
    plotFillColor = exports.plotFillColor = ['767575', 'D8DCC5', '99C4CD', 'DEC49C', 'FEC1D0'],

// -------------- For 3D Chart --------------//
bgColor3D = exports.bgColor3D = [COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE],
    bgAlpha3D = exports.bgAlpha3D = [HUNDREDSTRING, HUNDREDSTRING, HUNDREDSTRING, HUNDREDSTRING, HUNDREDSTRING],
    bgAngle3D = exports.bgAngle3D = [90, 90, 90, 90, 90],
    bgRatio3D = exports.bgRatio3D = [BLANK, BLANK, BLANK, BLANK, BLANK],
    canvasBgColor3D = exports.canvasBgColor3D = ['DDE3D5', 'D8D8D7', 'EEDFCA', 'CFD2D8', 'FEE8E0'],
    canvasBaseColor3D = exports.canvasBaseColor3D = ['ACBB99', 'BCBCBD', 'C8A06C', '96A4AF', 'FAC7BC'],
    divLineColor3D = exports.divLineColor3D = ['ACBB99', 'A4A4A4', 'BE9B6B', '7C8995', 'D49B8B'],
    divLineAlpha3D = exports.divLineAlpha3D = [OPAQUE, OPAQUE, OPAQUE, OPAQUE, OPAQUE],
    legendBgColor3D = exports.legendBgColor3D = ['F0F3ED', 'F3F3F3', 'F7F0E8', 'EEF0F2', 'FEF8F5'],
    legendBorderColor3D = exports.legendBorderColor3D = ['C6CFB8', 'C8C8C8', 'DFC29C', 'CFD5DA', 'FAD1C7'],
    toolTipbgColor3D = exports.toolTipbgColor3D = [COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE],
    toolTipBorderColor3D = exports.toolTipBorderColor3D = ['49563A', '666666', '49351D', '576373', '681C09'],
    baseFontColor3D = exports.baseFontColor3D = ['49563A', '4A4A4A', '49351D', '48505A', '681C09'],
    anchorBgColor3D = exports.anchorBgColor3D = [COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE];

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _lib = __webpack_require__(5);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */


/**
 * A RedRaphael element
 * @typedef {Object} RaphaelElement
 */

/**
 * The ElementRecycler's purpose is to recycle any unused axis elements and store them for
 * future reuse.
 * @class
 */
var ElementRecycler = function () {
  /**
   * Initiates the element recycler with an empty element store. This store is used to recycle the
   * elements passed to the element recycler.
   * @memberof ElementRecycler
   */
  function ElementRecycler() {
    _classCallCheck(this, ElementRecycler);

    /**
     * An object holding elements for recycling
     * @member {Object}
     */
    this.elementObj = {};
  }

  /**
   * This function transfers all given elements to the pool so that they can be used during drawing.
   * @param {Object}  reserveElementObj The element to be recycled for future reuse
   * @return {Object}                   An ElementRecycler instance
   */


  ElementRecycler.prototype.preProcessor = function preProcessor(reserveElementObj) {
    var self = this,
        elements = self.elementObj,
        aa,
        a;
    for (a in elements) {
      if (elements.hasOwnProperty(a) && elements[a].pool) {
        self.insertReserveElement(a, reserveElementObj && reserveElementObj[a]);
        for (aa in elements[a].elements) {
          if (elements[a].elements.hasOwnProperty(aa)) {
            elements[a].pool[aa] = elements[a].elements[aa];
            delete elements[a].elements[aa];
          }
        }
      }
    }
    return this;
  };

  /**
   * This function hides the element present in the pool.
   * @param  {Function} fn The callback to be invoked
   * @return {Object}      An ElementRecycler instance
   */


  ElementRecycler.prototype.postProcessor = function postProcessor(fn) {
    var self = this,
        elements = self.elementObj,
        aa,
        a;
    for (a in elements) {
      elements[a].oldObjArr = (0, _lib.extend2)([], elements[a].reserveElement);
      if (elements.hasOwnProperty(a) && elements[a].pool) {
        for (aa in elements[a].pool) {
          if (elements[a].pool.hasOwnProperty(aa)) {
            fn(elements[a].pool[aa]);
          }
        }
      }
    }
    return this;
  };

  /**
   * Creates an element of the given type.
   * @param  {string} type The type of the element to be created
   * @return {Object}      The created element
   */


  ElementRecycler.prototype.createElementType = function createElementType(type) {
    return this.elementObj[type] = {
      elements: {},
      pool: {},
      reserveElement: [],
      oldObjArr: []
    };
  };

  /**
    * This function returns the suitable element from the pool if there or return undefined
    * @param {string}  type The pool of the element to be used
    * @param {string}  name Name of the element to get
    * @return {Object}      Raphael element or undefined
    */


  ElementRecycler.prototype.getElementIfExist = function getElementIfExist(type, name) {
    var self = this,
        elementsObj,
        returnElem,
        isOtherElem = false,
        a;

    if (!(elementsObj = self.elementObj[type])) {
      elementsObj = self.createElementType(type);
    }

    if (elementsObj.pool[name]) {
      returnElem = elementsObj.pool[name];
      delete elementsObj.pool[name];
    } else {
      for (a in elementsObj.pool) {
        if (elementsObj.pool.hasOwnProperty(a) && elementsObj.reserveElement.indexOf(a) === -1 && elementsObj.oldObjArr.indexOf(a) === -1) {
          returnElem = elementsObj.pool[a];
          delete elementsObj.pool[a];
          isOtherElem = true;
          break;
        }
      }
    }
    if (returnElem !== _lib.UNDEF) {
      return {
        elem: elementsObj.elements[name] = returnElem,
        isOtherElem: isOtherElem
      };
    } else {
      return _lib.UNDEF;
    }
  };

  /**
   * Processes elements of a specific type by invoking a callback on each element of that
   * type
   * @param  {string}   type The type of elements to process
   * @param  {Function} fn   The callback function to process the elements with
   */


  ElementRecycler.prototype.processOldElem = function processOldElem(type, fn) {
    var self = this,
        elementsObj = self.elementObj[type],
        pool = elementsObj && elementsObj.pool,
        oldObjArr = elementsObj ? elementsObj.oldObjArr : [],
        i,
        ln,
        key;
    for (i = 0, ln = oldObjArr.length; i < ln; i += 1) {
      key = oldObjArr[i];
      if (pool[key]) {
        fn(key, pool[key]);
        elementsObj.elements[key] = pool[key];
        delete pool[key];
      }
    }
  };

  /**
   * Gets an element of a specific type by the given name.
   * @param  {string} type The type of the element
   * @param  {string} name The name of the element
   * @return {Object}      The element found by the given name, of the given type
   */


  ElementRecycler.prototype.getDrawnElements = function getDrawnElements(type, name) {
    var self = this,
        elementsObj = self.elementObj[type],
        elements = elementsObj && elementsObj.elements;
    return elements && elements[name];
  };

  /**
   * Inserts an element in the element pool to be reused later
   * @param  {string}         type The type to store the element as
   * @param  {string}         name The name by which to store the element within a specific type
   * @param  {RaphaelElement} elem The element to be stored
   * @return {Object}              An instance of the class
   */


  ElementRecycler.prototype.insertElement = function insertElement(type, name, elem) {
    var self = this,
        elementsObj = self.elementObj[type];

    elementsObj && (elementsObj.elements[name] = elem);
    return self;
  };

  /**
   * Inserts elements of the specified type into the element pool to be reused later. These
   * elements can only be reused when requested with the exact type and name.
   * @param  {string} type                The type of the elements to be inserted
   * @param  {Array<RaphaelElement>} arr  The array of elements to be stored
   * @return {Object}                     An instance of the given class
   */


  ElementRecycler.prototype.insertReserveElement = function insertReserveElement(type, arr) {
    var self = this,
        elementsObj = self.elementObj[type] || self.createElementType(type);

    if (elementsObj) {
      elementsObj.reserveElement.length = 0;
      elementsObj.reserveElement = arr || [];
    }
    return self;
  };

  return ElementRecycler;
}();

exports['default'] = ElementRecycler;

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
/* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */

var StoreInstance = {
  setNewInstance: function setNewInstance(id, newInstance) {
    StoreInstance.instances[id] = newInstance;
  },
  getInstanceById: function getInstanceById(id) {
    return StoreInstance.instances[id];
  },
  instances: {}
};

exports.StoreInstance = StoreInstance;

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _helper = __webpack_require__(26);

var _symbolClass = __webpack_require__(92);

var _symbolClass2 = _interopRequireDefault(_symbolClass);

var _listContainerManager = __webpack_require__(421);

var _listContainerManager2 = _interopRequireDefault(_listContainerManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */

var UNDEF = void 0,
    DEFAULT_TIMEOUT = 300;
/**
 * Creates SymbolWithContext class
 */

var SymbolWithContext = function (_SymbolClass) {
  _inherits(SymbolWithContext, _SymbolClass);

  /**
   * Constructor function of SymbolWithContext class
   * @param {string} symbolName name of symbol required
   * @param {number} id toolbox id
   * @param {number} poolId toolbox pool id
   */
  function SymbolWithContext(symbolName, id, poolId) {
    _classCallCheck(this, SymbolWithContext);

    var cont;

    var _this = _possibleConstructorReturn(this, _SymbolClass.call(this, symbolName, UNDEF, id, poolId));

    _this.rawContextDefinitation = UNDEF;
    _this.listContainerManager = new _listContainerManager2['default'](_this.position).init(poolId);

    cont = _this.listContainerManager.getFirstContainer();
    _this.evt.hover = [function (e) {
      cont.show((0, _helper.normalizeTarget)(e.target || e.fromElement, e));
    }, function (e) {
      cont.hide(DEFAULT_TIMEOUT, e.target);
    }];
    return _this;
  }

  /**
   * Returns instance of ListContainerManager class
   * @return {Object} class instance
   */


  SymbolWithContext.prototype.getListRefernce = function getListRefernce() {
    return this.listContainerManager;
  };

  /**
   * Attach tooltext with mouse event
   * @param {Object} eventMap object of callback fn
   */


  SymbolWithContext.prototype.attachEventHandler = function attachEventHandler(eventMap) {
    var evt = this.evt,
        toolText = eventMap.tooltext;

    if (toolText) {
      evt.tooltext = toolText;
    }
  };

  /**
   * Decides space needed for Symbol
   * @return {Object} Consists of width, height
   */


  SymbolWithContext.prototype.getLogicalSpace = function getLogicalSpace() {
    var firstContainer = this.listContainerManager.getFirstContainer(),
        atomicLists = firstContainer.atomicLists;

    if (atomicLists && atomicLists.length === 0) {
      return {
        width: 0,
        height: 0
      };
    }

    return _symbolClass2['default'].prototype.getLogicalSpace.call(this);
  };

  /**
   * Draws the SymbolContext
   * @return {Object} Group element of Symbol
   */


  SymbolWithContext.prototype.draw = function draw() {
    var firstContainer = this.listContainerManager.getFirstContainer(),
        atomicLists = firstContainer.atomicLists,
        res;

    if (atomicLists && atomicLists.length === 0) {
      this.hide();
      return {
        getBBox: function getBBox() {
          return {
            width: 0,
            height: 0
          };
        }
      };
    }

    res = _symbolClass2['default'].prototype.draw.apply(this, arguments);
    SymbolWithContext.allNodes.push(this.node);

    return res;
  };
  /**
   * Dispose function to dispose the elements of SymbolContext
   */


  SymbolWithContext.prototype.dispose = function dispose() {
    this.listContainerManager && this.listContainerManager.dispose();
    this.listContainerManager = UNDEF;
    _symbolClass2['default'].prototype.dispose.call(this);
  };

  return SymbolWithContext;
}(_symbolClass2['default']);

SymbolWithContext.POSITION_TOP = 'top';
SymbolWithContext.POSITION_BOTTOM = 'bottom';
SymbolWithContext.allNodes = [];

exports['default'] = SymbolWithContext;

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _toolBarFactoryHelper = __webpack_require__(25);

var _helper = __webpack_require__(26);

var _atomicList = __webpack_require__(218);

var _atomicList2 = _interopRequireDefault(_atomicList);

var _symbolWithContext = __webpack_require__(216);

var _symbolWithContext2 = _interopRequireDefault(_symbolWithContext);

var _componentInterface = __webpack_require__(6);

var _componentInterface2 = _interopRequireDefault(_componentInterface);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */

var UNDEF = void 0,
    PXSTR = 'px',
    DEFAULT_TIMEOUT = 300;
/**
 * Creates ListContainer class
 */

var ListContainer = function (_ComponentInterface) {
  _inherits(ListContainer, _ComponentInterface);

  /**
   * Constructor function of ListContainer class
   * @param {Object} containerNode Graphics node of container
   * @param {Object} measurement dimension object
   */
  function ListContainer(containerNode, measurement) {
    _classCallCheck(this, ListContainer);

    var conStyle,
        styleKey,
        top = measurement && measurement.top || 0,
        left = measurement && measurement.left,
        right = measurement && measurement.right,
        chart = _toolBarFactoryHelper.ToolBarFactoryHelper.getOptions().chart,
        self,
        hoverEvtListeners;

    var _this = _possibleConstructorReturn(this, _ComponentInterface.call(this));

    self = _this;
    self.container = containerNode;
    self.position = ListContainer.POSITION_BOTTOM;
    self.atomicLists = [];
    self.refContainers = [];
    self.parentListCon = UNDEF;
    self.hideFnIds = [];
    self.target = UNDEF;

    if (!(left && right)) {
      self.positionCalculation = true;
    }

    self.hoverOverStyle = {
      background: '#333333',
      color: '#FFFFFF',
      cursor: 'pointer'
    };

    self.hoverOutStyle = {
      background: '#FFFFFF',
      color: '#000000'
    };

    self._defaultStyle = {
      position: 'absolute',
      'z-index': 50,
      top: top === UNDEF ? 'auto' : top + PXSTR,
      right: right === UNDEF ? 'auto' : right + PXSTR,
      left: left === UNDEF ? 'auto' : left + PXSTR,
      overflow: 'hidden',
      background: '#ffffff',
      border: '1px solid #646464',
      'box-shadow': '#999999 2px 2px 5px',
      padding: '5px 3px',
      display: 'none'
    };

    conStyle = self.container.style;

    for (styleKey in self._defaultStyle) {
      conStyle[styleKey] = self._defaultStyle[styleKey];
    }

    if (!chart.linkedItems) {
      return _possibleConstructorReturn(_this);
    }
    chart.getFromEnv('chart-container').appendChild(self.container);

    hoverEvtListeners = (0, _helper.getEventHandlersFor)('hover', self.container);

    hoverEvtListeners(function () {
      self.show(this);
    }, function () {
      self.hide(DEFAULT_TIMEOUT, this);
    });
    return _this;
  }
  /**
   * Add list items to components
   * @param {Object} item List items to be added
   */


  ListContainer.prototype.addAtomicListItem = function addAtomicListItem(item) {
    if (!(item instanceof _atomicList2['default'])) {
      return;
    }
    this.atomicLists.push(item);
    item.stickIntoContainer(this.container, this);
  };
  /**
   * Shows the component graphics
   * @param {Object} target container graphics node
   */


  ListContainer.prototype.show = function show(target) {
    var idArr = this.hideFnIds,
        chart = _toolBarFactoryHelper.ToolBarFactoryHelper.getOptions().chart,
        refWidth = chart.config.width,
        positionCalculation = this.positionCalculation,
        index = 0,
        length,
        parentContainer,
        listWidth,
        diffScale,
        bBox;

    this.target = this.target || target;

    for (length = idArr.length; index < length; index++) {
      clearTimeout(idArr[index]);
    }

    idArr.length = 0;

    parentContainer = this.parentListCon;
    if (parentContainer) {
      parentContainer.show(this.target);
      this.container.style.left = parentContainer.container.offsetLeft + parentContainer.container.offsetWidth + PXSTR;
      this.container.style.top = parentContainer.container.offsetTop + this.target.offsetTop + PXSTR;
    } else if (!(0, _helper.isDIV)(target)) {
      bBox = target.getBBox();

      if (positionCalculation) {
        // Show the container so that the width can be retrieved.
        this.container.style.display = 'block';

        listWidth = this.container.offsetWidth;
        if (listWidth + bBox.x > refWidth) {
          this.container.style.left = 'auto';
          this.container.style.right = refWidth - bBox.x - bBox.width + PXSTR;
        } else {
          this.container.style.left = bBox.x + PXSTR;
          this.container.style.right = 'auto';
        }

        // When all the calculations are done, hides it
        this.container.style.display = 'none';
      }
      if (this.position === _symbolWithContext2['default'].POSITION_BOTTOM) {
        diffScale = bBox.isArtificial ? 0.5 : 1.5;
        this.container.style.top = bBox.y + bBox.height * diffScale + PXSTR;
        this.container.style.bottom = 'auto';
      } else {
        this.container.style.bottom = chart.config.height - bBox.y + PXSTR;
        this.container.style.top = 'auto';
      }
    }

    this.container.style.display = 'block';
  };
  /**
   * Hides the componet graphics
   * @param {number} timeout time in ms after which the component is hidden
   */


  ListContainer.prototype.hide = function hide(timeout) {
    var con = this.container,
        parentContainer;

    parentContainer = this.parentListCon;

    if (parentContainer) {
      parentContainer.hide(DEFAULT_TIMEOUT);
    }

    this.hideFnIds.push(setTimeout(function () {
      con.style.display = 'none';
    }, timeout));
  };
  /**
   * Disposes component graphics
   */


  ListContainer.prototype.dispose = function dispose() {
    var atomicLists = this.atomicLists,
        refContainers = this.refContainers,
        index,
        length;

    this.hideFnIds.length = 0;

    for (index = 0, length = atomicLists.length; index < length; index++) {
      atomicLists[index].dispose();
    }

    atomicLists.length = 0;

    for (index = 0, length = refContainers.length; index < length; index++) {
      refContainers[index].dispose();
    }

    refContainers.length = 0;
  };

  return ListContainer;
}(_componentInterface2['default']);

ListContainer.POSITION_TOP = 'top';
ListContainer.POSITION_BOTTOM = 'bottom';

exports['default'] = ListContainer;

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _helper = __webpack_require__(26);

var _toolbox = __webpack_require__(67);

var _lib = __webpack_require__(5);

var _listContainer = __webpack_require__(217);

var _listContainer2 = _interopRequireDefault(_listContainer);

var _toolBarFactoryHelper = __webpack_require__(25);

var _componentInterface = __webpack_require__(6);

var _componentInterface2 = _interopRequireDefault(_componentInterface);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */

var doc = window.document,
    UNDEF = void 0,
    DIV = 'div',
    PXSTR = 'px',
    CLICK = 'click',
    DEFAULT_TIMEOUT = 300,
    HOVER = 'hover';
/**
 * Creates AtomicList class
 */

var AtomicList = function (_ComponentInterface) {
  _inherits(AtomicList, _ComponentInterface);

  /**
   * Constructor fn of AtomicList class
   * @param {Object} options hoverstyle configurations
   */
  function AtomicList(options) {
    _classCallCheck(this, AtomicList);

    var _this = _possibleConstructorReturn(this, _ComponentInterface.call(this));

    options = options || {};
    _this.name = options.name;
    _this.handler = options.handler || _lib.stubFN;
    _this.action = options.action && options.action.toLowerCase() || CLICK;
    _this.eventMap = {};

    _this.style = {
      padding: '3px 8px',
      margin: '2px 0px',
      fontFamily: _toolbox.contextMenuSpecAttr.baseFontFamily,
      fontSize: _toolbox.contextMenuSpecAttr.baseFontSize + PXSTR
    };

    _this.hoverOverStyle = options.hoverOverStyle || {};
    _this.hoverOutStyle = options.hoverOutStyle || {};

    (0, _helper.mergeConf)(options.style || {}, _this.style);
    _this.subConRef = UNDEF;
    _this.node = UNDEF;
    return _this;
  }
  /**
   * Updates name of list items
   * @param {string} name name of list
   */


  AtomicList.prototype.updateName = function updateName(name) {
    this.name = name;
    this.node && (this.node.innerHTML = name);
  };
  /**
   * Create sub container of list item
   * @param {Object} container Graphics container
   */


  AtomicList.prototype.assignSubContainer = function assignSubContainer(container) {
    if (!(container instanceof _listContainer2['default'])) {
      return;
    }
    this.subConRef = container;
  };
  /**
   * Create list item
   * @param {Object} container Graphics container
   * @param {Object} listContainerInstance list object
   */


  AtomicList.prototype.stickIntoContainer = function stickIntoContainer(container, listContainerInstance) {
    var node = this.node = doc.createElement(DIV),
        style = this.style,
        name,
        nodeStyle,
        hoverEvtListeners,
        clickEvtListeners,
        chart = _toolBarFactoryHelper.ToolBarFactoryHelper.getOptions().chart,
        fn,
        self = this;

    node && (node.ishot = true);
    if (this.handler) {
      this.eventMap[this.action] = this.handler;
    }

    container.appendChild(node);

    node.innerHTML = this.name;

    nodeStyle = node.style;
    for (name in style) {
      nodeStyle[name] = style[name];
    }

    hoverEvtListeners = (0, _helper.getEventHandlersFor)(HOVER, node);
    clickEvtListeners = (0, _helper.getEventHandlersFor)(CLICK, node);

    clickEvtListeners(function () {
      if (self.handler) {
        fn = self.eventMap[CLICK];
        fn && fn.apply(self, [chart]);
        listContainerInstance.hide();
      }
    });

    hoverEvtListeners(function () {
      var key,
          elemStyle = node.style,
          hoverStyle = self.hoverOverStyle;

      for (key in hoverStyle) {
        elemStyle[key] = hoverStyle[key];
      }

      if (self.subConRef) {
        self.subConRef.show(this);
      }
    }, function () {
      var key,
          elemStyle = node.style,
          hoverStyle = self.hoverOutStyle;

      for (key in hoverStyle) {
        elemStyle[key] = hoverStyle[key];
      }

      if (self.subConRef) {
        self.subConRef.hide(DEFAULT_TIMEOUT, this);
      }
    });
  };
  /**
   * Set css style
   * @param {Object} syleObj Style object
   */


  AtomicList.prototype.setStyle = function setStyle(syleObj) {
    (0, _helper.mergeConf)(syleObj || {}, this.style);
  };
  /**
   * Disposes component
   */


  AtomicList.prototype.dispose = function dispose() {
    var node = this.node;

    if (node) {
      node.remove && node.remove();
    }

    this.node = UNDEF;
  };

  return AtomicList;
}(_componentInterface2['default']);

exports['default'] = AtomicList;

/***/ }),
/* 219 */,
/* 220 */,
/* 221 */,
/* 222 */,
/* 223 */,
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(12);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _line = __webpack_require__(11);

var _line2 = _interopRequireDefault(_line);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var UNDEF = void 0;

var MSLine = function (_AreaBase) {
  _inherits(MSLine, _AreaBase);

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  MSLine.getName = function getName() {
    return 'MSLine';
  };

  function MSLine() {
    _classCallCheck(this, MSLine);

    var _this = _possibleConstructorReturn(this, _AreaBase.call(this));

    _this.name = 'msline';
    _this.standaloneInit = true;
    _this.friendlyName = 'Multi-series Line Chart';
    _this.defaultDatasetType = 'line';
    _this.defaultPlotShadow = 1;
    _this.axisPaddingLeft = 0;
    _this.axisPaddingRight = 0;
    _this.applicableDSList = { 'line': true };
    return _this;
  }

  MSLine.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _AreaBase.prototype.__setDefaultConfig && _AreaBase.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    config.zeroplanethickness = 1;
    config.zeroplanealpha = 40;
    config.showzeroplaneontop = 0;
    config.enablemousetracking = true;
  };
  // This method return the dataset definations for this charts


  MSLine.prototype.getDSdef = function getDSdef() {
    return _line2['default'];
  };
  // This method return the dataset-group definations for this charts


  MSLine.prototype.getDSGroupdef = function getDSGroupdef() {
    return UNDEF;
  };

  return MSLine;
}(_fusioncharts2['default']);

exports['default'] = MSLine;

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusionchartsAreabase = __webpack_require__(12);

var _fusioncharts = __webpack_require__(57);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _fusioncharts3 = __webpack_require__(94);

var _line = __webpack_require__(11);

var _line2 = _interopRequireDefault(_line);

var _column = __webpack_require__(8);

var _column2 = _interopRequireDefault(_column);

var _cartesian = __webpack_require__(18);

var _cartesian2 = _interopRequireDefault(_cartesian);

var _lib = __webpack_require__(5);

var _fill = __webpack_require__(95);

var _fill2 = _interopRequireDefault(_fill);

var _map = __webpack_require__(60);

var _map2 = _interopRequireDefault(_map);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var removeLineSet = function removeLineSet(component) {
  var lineSet = component.getChildren('dataset_line'),
      i = void 0;
  for (i = lineSet && lineSet.length - 1; i > -1; i--) {
    lineSet[i].remove();
  }
};

var MSStackedColumn2DLineDy = function (_MSDyBaseCartesian) {
  _inherits(MSStackedColumn2DLineDy, _MSDyBaseCartesian);

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  MSStackedColumn2DLineDy.getName = function getName() {
    return 'MSStackedColumn2DLineDy';
  };

  function MSStackedColumn2DLineDy() {
    _classCallCheck(this, MSStackedColumn2DLineDy);

    var _this = _possibleConstructorReturn(this, _MSDyBaseCartesian.call(this));

    _this.friendlyName = 'Multi-series Dual Y-Axis Stacked Column and Line Chart';
    _this.stack100percent = 0;
    _this.defaultDatasetType = 'column';
    _this.sDefaultDatasetType = 'line';
    _this.hasLineSet = true;
    _this.lineset = true;
    return _this;
  }

  MSStackedColumn2DLineDy.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _MSDyBaseCartesian.prototype.__setDefaultConfig && _MSDyBaseCartesian.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    config.isdual = true;
    config.haslineset = true;
    config.isstacked = true;
    config.enablemousetracking = true;
    _fusionchartsAreabase._setDefaultConfig.call(this);
  };
  /**
   * function to  create dataset, groupmaneger.
   * assign dataset to group manager.
   **/


  MSStackedColumn2DLineDy.prototype._createDatasets = function _createDatasets() {
    var iapi = this,
        jsonData = iapi.jsonData,
        dataset = jsonData.dataset,
        lineSets = jsonData.lineset,
        linesetStartIndex = void 0,
        indices = void 0,
        canvas = iapi.getChildren('canvas')[0],
        vCanvas = canvas.getChildren('vCanvas')[1];

    if (!dataset && lineSets.length === 0) {
      iapi.setChartMessage();
      return;
    }
    _fusioncharts3._createDatasets.call(this);
    linesetStartIndex = iapi.config._lastDatasetIndex + 1;
    if (lineSets && lineSets.length) {
      indices = _map2['default'].call(_fill2['default'].call(Array(lineSets.length), linesetStartIndex), function (n, j) {
        return n + j;
      });
      (0, _lib.datasetFactory)(vCanvas, iapi.getDSdef('line'), 'dataset_line', lineSets.length, lineSets, indices);
    } else {
      removeLineSet(vCanvas);
    }
  };

  MSStackedColumn2DLineDy.prototype.getDSdef = function getDSdef(name) {
    return name === 'line' ? _line2['default'] : _column2['default'];
  };

  MSStackedColumn2DLineDy.prototype.getDSGroupdef = function getDSGroupdef() {
    return _cartesian2['default'];
  };

  return MSStackedColumn2DLineDy;
}(_fusioncharts2['default']);

exports['default'] = MSStackedColumn2DLineDy;

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(149);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _column = __webpack_require__(8);

var _column2 = _interopRequireDefault(_column);

var _area = __webpack_require__(20);

var _area2 = _interopRequireDefault(_area);

var _line = __webpack_require__(11);

var _line2 = _interopRequireDefault(_line);

var _column3 = __webpack_require__(15);

var _column4 = _interopRequireDefault(_column3);

var _fusioncharts3 = __webpack_require__(69);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */


var UNDEFINED;
/**
 * Creates ScrollCombi2D class
 */

var ScrollCombi2D = function (_ScrollArea2D) {
  _inherits(ScrollCombi2D, _ScrollArea2D);

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  ScrollCombi2D.getName = function getName() {
    return 'ScrollCombi2D';
  };

  /**
   * Constructor fn of ScrollCombi2D class
   */


  function ScrollCombi2D() {
    _classCallCheck(this, ScrollCombi2D);

    var _this = _possibleConstructorReturn(this, _ScrollArea2D.call(this));

    _this.friendlyName = 'Scrollable Combination Chart';
    _this.tooltipConstraint = 'plot';
    _this.hasScroll = true;
    _this.canvasborderthickness = 1;
    _this.avgScrollPointWidth = 40;
    _this.defaultPlotShadow = 1;
    _this.defaultDatasetType = 'column';
    _this.applicableDSList = { 'area': true, 'line': true, 'column': true };
    return _this;
  }

  /**
   * Sets default chart configuration
   */


  ScrollCombi2D.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _ScrollArea2D.prototype.__setDefaultConfig && _ScrollArea2D.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    config.zeroplanethickness = 1;
    config.zeroplanealpha = 40;
    config.showzeroplaneontop = 0;
    config.enablemousetracking = true;
  };

  /**
   * function to  create dataset, groupmaneger.
   * assign dataset to group manager.
   **/


  ScrollCombi2D.prototype._createDatasets = function _createDatasets() {
    _fusioncharts3._createDatasets.call(this);
  };
  /**
   * This method return the dataset definations for this charts
   * @param  {string} name type of dataset class
   * @return {Object}      dataset class
   */


  ScrollCombi2D.prototype.getDSdef = function getDSdef(name) {
    return name === 'area' ? _area2['default'] : name === 'line' ? _line2['default'] : _column2['default'];
  };
  /**
   * This method return the dataset-group definations for this charts
   * @param  {string} name is type of dataset group
   * @return {Object} <dataset group class>     dataset group class
   */


  ScrollCombi2D.prototype.getDSGroupdef = function getDSGroupdef(name) {
    return name !== 'line' && name !== 'area' ? _column4['default'] : UNDEFINED;
  };
  /**
   * function to return dataset type applicable for this chart
   * @param   {string}  name  dataset type
   * @return  {string}        dataset type applicable for this chart
   */


  ScrollCombi2D.prototype.getDSType = function getDSType(name) {
    return name && name.toLowerCase() === 'area' ? 'area' : name && name.toLowerCase() === 'line' ? 'line' : 'column';
  };

  return ScrollCombi2D;
}(_fusioncharts2['default']);

exports['default'] = ScrollCombi2D;

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _fusioncharts = __webpack_require__(96);

var _fusioncharts2 = _interopRequireDefault(_fusioncharts);

var _fusioncharts3 = __webpack_require__(97);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */


/**
 * Creates ScrollCombiDy2D class
 */
var ScrollCombiDy2D = function (_MSCombidy2D) {
  _inherits(ScrollCombiDy2D, _MSCombidy2D);

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  ScrollCombiDy2D.getName = function getName() {
    return 'ScrollCombiDy2D';
  };

  /**
   * Constructor fn of class ScrollCombiDy2D
   */


  function ScrollCombiDy2D() {
    _classCallCheck(this, ScrollCombiDy2D);

    var _this = _possibleConstructorReturn(this, _MSCombidy2D.call(this));

    _this.friendlyName = 'Scrollable Dual Y-Axis Combination Chart';
    _this.tooltipConstraint = 'plot';
    _this.defaultDatasetType = 'column';
    _this.canvasborderthickness = 1;
    _this.avgScrollPointWidth = 40;
    _this.hasScroll = true;
    return _this;
  }

  /**
   * function to create component and configure and also configure the chart
   * It creates components which are depend on data and configure them and also configure chart
   * It calls helper function namely, configure
   * @param  {Object} dataObj contains json data of the chart
   */


  ScrollCombiDy2D.prototype.configure = function configure(dataObj) {
    _fusioncharts3.configure.call(this, dataObj);
  };

  /**
   * Sets xAxis scale visible region
   */


  ScrollCombiDy2D.prototype._setAxisScale = function _setAxisScale() {
    _fusioncharts3._setAxisScale.call(this);
  };

  /**
   * Reset view port
   */


  ScrollCombiDy2D.prototype._resetViewPortConfig = function _resetViewPortConfig() {
    _fusioncharts3._resetViewPortConfig.call(this);
  };

  return ScrollCombiDy2D;
}(_fusioncharts2['default']);

exports['default'] = ScrollCombiDy2D;

/***/ }),
/* 228 */,
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _inputBase = __webpack_require__(37);

var _inputBase2 = _interopRequireDefault(_inputBase);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * ZoomReset Component adds a button to the canvas that reset the axis view when clicked upon it.
 * ZoomReset listens to zooming events and catches the positions prior to zooming and saves it in a
 * stack. Thus when ZoomReset is clicked it sets the axis view to the first state. It also fires
 * a zoomReset event so that other component saving the zoomStates can clear their stack.
 */
var ZoomReset = function (_Base) {
  _inherits(ZoomReset, _Base);

  function ZoomReset() {
    _classCallCheck(this, ZoomReset);

    var _this = _possibleConstructorReturn(this, _Base.call(this));

    _this.tags = [];
    return _this;
  }

  ZoomReset.prototype.configure = function configure() {
    _Base.prototype.configure.call(this);
    var input = this;
    // Creating button for zoomIn
    input.button = input.createButton({
      icon: 'resetIcon',
      handlers: {
        click: function click() {
          input.zoomReset();
        },
        tooltext: input.options.tooltext
      }
    });
    this.fetchZoomableAxes();
    input.disable();
  };
  /**
   * Fetch all the axes that are zoomable
   */


  ZoomReset.prototype.fetchZoomableAxes = function fetchZoomableAxes() {
    var axesObArr = this.config.axesObArr = [];
    this.canvas.getAxes().forEach(function (axisOb) {
      if (axisOb.config.zoomable) {
        axesObArr.push({
          axis: axisOb.axis,
          stack: []
        });
      }
    });
  };
  /**
   * Remove all zoomstate and set axis set to initial zoom state
   * that was received, also fire rest event so that other input
   * components could also clear the their states.
   */


  ZoomReset.prototype.zoomReset = function zoomReset() {
    var input = this,
        visiblerange;
    this.config.axesObArr.forEach(function (axisOb) {
      visiblerange = axisOb.stack[0];
      if (!visiblerange) {
        return;
      }
      input.chart.state = 'noAnim';
      input._preHookFn(visiblerange.min, visiblerange.max);
      axisOb.axis.setVisibleConfig(visiblerange.min, visiblerange.max);
      // resetting stack
      axisOb.stack.length = 0;
    });
    // Notify canvas for change
    this.canvas.notifyChange(this.getEvent({
      event: 'zoomReset',
      range: visiblerange
    }));
    this.disable();
  };

  ZoomReset.prototype.draw = function draw() {
    // temp code remove it
    var button = this.button;
    if (this.isEnabled()) {
      button.enable();
    } else {
      button.disable();
    }
  };
  /**
   * Listen to zoom events and store them
   * @param {Object} eventOb
   */


  ZoomReset.prototype.onEvent = function onEvent(eventOb) {
    var axesObArr = this.config.axesObArr,
        stackLength = 0;
    if (eventOb.event === 'zoomIn') {
      eventOb.state.forEach(function (state, index) {
        axesObArr[index].stack.push(state.range);
      });
      this.enable();
    }
    if (eventOb.event === 'zoomOut') {
      axesObArr.forEach(function (axisOb) {
        axisOb.stack.pop();
        stackLength += axisOb.stack.length;
      });
      if (!stackLength) {
        this.disable();
      }
    }
  };

  return ZoomReset;
}(_inputBase2['default']);

exports['default'] = ZoomReset;

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _inputBase = __webpack_require__(37);

var _inputBase2 = _interopRequireDefault(_inputBase);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Zoomout Component adds a button to the canvas that zooms out the axis when clicked upon it.
 * ZoomOut listens to zooming events and catches the positions prior to zooming and saves it in a
 * stack. Thus when zoomout is clicked it pops out last view from the stack and makes it the current
 * view. Also fires a zoomOut event so that other component who previously saved te axis config, can
 * pop their stack by one.
 */
var ZoomOut = function (_Base) {
  _inherits(ZoomOut, _Base);

  function ZoomOut() {
    _classCallCheck(this, ZoomOut);

    var _this = _possibleConstructorReturn(this, _Base.call(this));

    _this.tags = [];
    return _this;
  }

  ZoomOut.prototype.configure = function configure() {
    _Base.prototype.configure.call(this);
    var input = this;
    // Creating button for zoomIn
    input.button = input.createButton({
      icon: 'zoomOutIcon',
      handlers: {
        click: function click() {
          input.zoomOut();
        },
        tooltext: input.options.tooltext
      }
    });
    this.fetchZoomableAxes();
    input.disable();
  };

  ZoomOut.prototype.fetchZoomableAxes = function fetchZoomableAxes() {
    var axesObArr = this.config.axesObArr = [];
    this.canvas.getAxes().forEach(function (axisOb) {
      if (axisOb.config.zoomable) {
        axesObArr.push({
          axis: axisOb.axis,
          stack: []
        });
      }
    });
  };
  /**
   * On zoomOut, pop the state from state array and set the axes state to that
   * state. Fire event that zoomOut is done so that other input components could
   * pop their state from state array.
   */


  ZoomOut.prototype.zoomOut = function zoomOut() {
    var input = this,
        visiblerange,
        stackLen = 0;
    this.config.axesObArr.forEach(function (axisOb) {
      visiblerange = axisOb.stack.pop();
      stackLen += axisOb.stack.length;
      if (!visiblerange) {
        return;
      }
      input.chart.state = 'noAnim';
      input._preHookFn(visiblerange.min, visiblerange.max);
      axisOb.axis.setVisibleConfig(visiblerange.min, visiblerange.max);
    });
    // Notify canvas for change
    this.canvas.notifyChange(this.getEvent({
      event: 'zoomOut',
      range: visiblerange
    }));
    if (!stackLen) {
      this.disable();
    }
  };

  ZoomOut.prototype.draw = function draw() {
    // temp code remove it
    var button = this.button;
    if (this.isEnabled()) {
      button.enable();
    } else {
      button.disable();
    }
  };
  /**
   * Listen to zoom events and store the states, sothat on zoomOut those
   * state could be set again
   * @param {Object} eventOb
   */


  ZoomOut.prototype.onEvent = function onEvent(eventOb) {
    var axesObArr = this.config.axesObArr;
    if (eventOb.event === 'zoomIn') {
      eventOb.state.forEach(function (state, index) {
        axesObArr[index].stack.push(state.range);
      });
      this.enable();
    }
    if (eventOb.event === 'zoomReset') {
      axesObArr.forEach(function (axisOb) {
        axisOb.stack.length = 0;
      });
      this.disable();
    }
  };

  return ZoomOut;
}(_inputBase2['default']);

exports['default'] = ZoomOut;

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _inputBase = __webpack_require__(37);

var _inputBase2 = _interopRequireDefault(_inputBase);

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var doubleTapGapTime = 400,
    isSingleFinger = function isSingleFinger(event) {
  return !event.touches || event.touches.length === 1;
},
    zoomOnPoint = function zoomOnPoint(visibleRange, val, zoomTimes) {
  var left = val - visibleRange.min,
      right = visibleRange.max - val;
  return {
    min: val - left / zoomTimes * (zoomTimes - 1),
    max: val + right / zoomTimes * (zoomTimes - 1)
  };
};
/**
 * Input component for Double tap to zoom functionality. Whenever this button is attached to
 * canvas it starts listening to click or touch events. When a double tap or double click occurs
 * the input component finds that point and decreases the visibility length of both the sides by
 * half.
 * For example: Axis range is 0 - 100 and point where double tap occurs is 30, then new visibility
 * range will be 15 - 65
 */

var InputDbTapZoom = function (_Base) {
  _inherits(InputDbTapZoom, _Base);

  function InputDbTapZoom() {
    _classCallCheck(this, InputDbTapZoom);

    var _this = _possibleConstructorReturn(this, _Base.call(this));

    _this.tags = ['tap'];
    return _this;
  }

  InputDbTapZoom.prototype.configure = function configure() {
    _Base.prototype.configure.call(this);
    var input = this;
    // Creating button for zoomIn
    input.fetchZoomableAxes();
    input.callbacks = {
      tap: input.tap.bind(input)
    };
    input.enable();
  };
  /**
   * Get all axes that are zoomable, so that only on those axis zooming
   * is done
   */


  InputDbTapZoom.prototype.fetchZoomableAxes = function fetchZoomableAxes() {
    var axes = this.config.axes = [];
    this.canvas.getAxes().forEach(function (axisOb) {
      if (axisOb.config.zoomable) {
        axes.push({
          axis: axisOb.axis,
          isY: axisOb.isY
        });
      }
    });
  };

  InputDbTapZoom.prototype.draw = function draw() {
    var input = this;
    if (input.isEnabled()) {
      setTimeout(function () {
        input.canvas.removeEventListener('click', input.callbacks.tap);
        input.canvas.addEventListener('click', input.callbacks.tap);
        // input.canvas.addEventListener('touchstart', input.tap.bind(input));
      });
    } else {
      input.canvas.removeEventListener('click', input.callbacks.tap);
    }
  };

  InputDbTapZoom.prototype.tap = function tap(event) {
    var config = this.config;
    if (!isSingleFinger(event.originalEvent)) {
      return;
    }
    if (config.tappedOnce) {
      this.zoom.apply(this, arguments);
      config.tappedOnce = false;
    } else {
      config.tappedOnce = true;
      // 300ms time for double tap expiration
      setTimeout(function () {
        config.tappedOnce = false;
      }, doubleTapGapTime);
    }
  };
  /**
   * Get the point where double tapped and decrease the visible on both
   * side to half. Also notify others that zooming has been applied.
   * @param {Object} event
   * @param {Object} arg
   */


  InputDbTapZoom.prototype.zoom = function zoom(event) {
    var input = this,
        chart = input.chart,
        coord = (0, _lib.getMouseCoordinate)(chart.getLinkedItem('container'), event, chart),
        axis,
        val,
        newRange,
        visiblerange,
        stateArr = [],
        axisZoomed,
        options = input.options,
        zoomed = false;
    chart.state = 'noAnim';
    input.config.axes.forEach(function (axisOb) {
      axis = axisOb.axis;
      val = axis.getValue(axisOb.isY ? coord.chartY : coord.chartX);
      visiblerange = axis.getVisibleConfig();
      newRange = zoomOnPoint(visiblerange, val, options.stepzoom);
      axisZoomed = axis.setVisibleConfig(newRange.min, newRange.max);
      zoomed = zoomed || axisZoomed;
      zoomed && stateArr.push({
        range: visiblerange
      });
    });
    // Notify canvas for change
    zoomed && input.canvas.notifyChange(this.getEvent({
      event: 'zoomIn',
      state: stateArr
    }));
  };

  return InputDbTapZoom;
}(_inputBase2['default']);

exports['default'] = InputDbTapZoom;

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _inputBase = __webpack_require__(37);

var _inputBase2 = _interopRequireDefault(_inputBase);

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var min = Math.min,
    abs = Math.abs,
    getRectDimension = function getRectDimension() {
  var a = arguments[0],
      b = arguments[1],
      isXY = arguments[3],
      res = {
    x: min(a.x, b.x),
    y: min(a.y, b.y),
    width: abs(a.x - b.x),
    height: abs(a.y - b.y)
  },
      width = b.x - a.x,
      height = a.y - b.y;
  // Determining cursor
  if (width > 0 && height > 0) {
    res.cursor = isXY ? 'ne-resize' : 'e-resize';
  } else if (width < 0 && height > 0) {
    res.cursor = isXY ? 'nw-resize' : 'w-resize';
  } else if (width < 0 && height < 0) {
    res.cursor = isXY ? 'sw-resize' : 'w-resize';
  } else if (width > 0 && height < 0) {
    res.cursor = isXY ? 'se-resize' : 'e-resize';
  }
  return res;
},
    isSingleFinger = function isSingleFinger(event) {
  return !event.touches || event.touches.length === 1;
},
    stopDefault = function stopDefault(event) {
  event.preventDefault && event.preventDefault();
  event.stopPropagation && event.stopPropagation();
};

/**
* Drag to zoom input component creates a box when dragged over canvas and zooms according to
* that particular box.
* Working method:
* On dragging draw the box. When mouse key press is released,
* take ratio of box size to canvas size and zoom the axes by same
* ratio.
*
* To define box options use :
* @example
* new DragZoom()
* .setOptions({
* boxStyle: {style to be applied to attr},
* scaleX: true,
* scaleY: false
* })
*/

var InputDragZoom = function (_Base) {
  _inherits(InputDragZoom, _Base);

  function InputDragZoom() {
    _classCallCheck(this, InputDragZoom);

    var _this = _possibleConstructorReturn(this, _Base.call(this));

    _this.tags = ['drag'];
    return _this;
  }

  InputDragZoom.prototype.configure = function configure() {
    _Base.prototype.configure.call(this);
    var input = this;
    input.callbacks = input.callbacks || {
      onDrag: input.onDrag.bind(input),
      onDragEnd: input.onDragEnd.bind(input)
    };
    this.fetchDragableAxis();
    // Creating button for zoomIn
    if (!(this.options.drawButton === false)) {
      input.button = input.createButton({
        icon: 'zoomModeIcon',
        handlers: {
          click: function click() {
            input.toggle();
            // Notify canvas for change
            input.canvas.notifyChange(input.getEvent({
              event: input.isEnabled() ? 'dragEnabled' : 'dragDisabled'
            }));
          },
          tooltext: input.options.tooltext
        }
      });
    }
    input.enable();
    input.options = input.options || {};
    input.options.boxStyle = input.options.boxStyle || {};
  };
  /**
   * Fetch only axis that are draggable. When attaching an axis to canvas we need to mention
   * it is draggable or not. Thus we are picking only suitable axes.
   */


  InputDragZoom.prototype.fetchDragableAxis = function fetchDragableAxis() {
    var axesObArr = this.config.axesObArr = [];
    this.canvas.getAxes().forEach(function (axisOb) {
      if (axisOb.config.zoomable || axisOb.config.pannable) {
        axesObArr.push({
          axis: axisOb.axis,
          isY: axisOb.isY
        });
      }
    });
  };
  /**
   * According to the current element state either attach or detach the listeners on the
   * canvas.
   */


  InputDragZoom.prototype.draw = function draw() {
    var input = this,
        callbacks = this.callbacks,
        canvas = input.canvas,
        removeHandlers = function removeHandlers() {
      canvas.removeEventListener('dragstart', callbacks.onDrag);
      canvas.removeEventListener('dragmove', callbacks.onDrag);
      canvas.removeEventListener('dragend', callbacks.onDragEnd);
      canvas.removeEventListener('touchstart', callbacks.onDrag);
      canvas.removeEventListener('touchmove', callbacks.onDrag);
      canvas.removeEventListener('touchend', callbacks.onDragEnd);
    };

    if (input.isEnabled()) {
      setTimeout(function () {
        canvas.addEventListener('dragstart', callbacks.onDrag);
        canvas.addEventListener('dragmove', callbacks.onDrag);
        canvas.addEventListener('dragend', callbacks.onDragEnd);
        canvas.addEventListener('touchstart', callbacks.onDrag);
        canvas.addEventListener('touchmove', callbacks.onDrag);
        canvas.addEventListener('touchend', callbacks.onDragEnd);
      });
      input.button && input.button.enable();
    } else {
      removeHandlers();
      input.button && input.button.disable();
    }
  };
  /**
   * Use a library function to convert event's x-y to charts coordinates
   * @param {Event} event
   */


  InputDragZoom.prototype.getCoordinates = function getCoordinates(event) {
    var chart = this.chart,
        coord = (0, _lib.getMouseCoordinate)(chart.getLinkedItem('container'), event, chart);
    return {
      x: coord.chartX,
      y: coord.chartY
    };
  };
  /**
   * Function to check if object lies in the limits of canvas
   * @param {Object} attrs
   */


  InputDragZoom.prototype.inCanvasLimit = function inCanvasLimit(attrs) {
    var canvasAttr = this.canvas.getGraphicalElement('canvasElement').attrs,
        minX = canvasAttr.x,
        minY = canvasAttr.y,
        xDiff = attrs.x - canvasAttr.x,
        yDiff = attrs.y - canvasAttr.y,
        maxWidth = canvasAttr.width - xDiff,
        maxHeight = canvasAttr.height - yDiff;
    return attrs.x > minX && attrs.y > minY && attrs.width < maxWidth && attrs.height < maxHeight;
  };
  /**
   * Function to draw box on the basis of style properties and its x-y.
   * In case any of the axis is not draggable the box will take up whole length of that
   * axis
   */


  InputDragZoom.prototype.drawBox = function drawBox() {
    var input = this,
        components = input.components,
        box = components.box,
        paper = input.chart.getFromEnv('paper'),
        options = input.options,
        canvasAttr = input.canvas.getGraphicalElement('canvasElement').attrs,
        dimension;

    if (!box) {
      box = box = components.box = paper.rect();
      box.attr(options.boxStyle);
    }
    dimension = getRectDimension(input.dragBoxConfig.startPos, input.dragBoxConfig.currentPos, box.attrs, input.chart.isXY);
    // set box size
    if (!input.inCanvasLimit(dimension)) {
      return;
    }
    box.attr(dimension);
    box.show();
    if (!options.scaleX) {
      box.attr({
        x: canvasAttr.x,
        width: canvasAttr.width
      });
    }
    if (!options.scaleY) {
      box.attr({
        y: canvasAttr.y,
        height: canvasAttr.height
      });
    }
  };

  InputDragZoom.prototype.setDrag = function setDrag(val) {
    this.config.isDragging = !!val;
  };

  InputDragZoom.prototype.isDragging = function isDragging() {
    return !!this.config.isDragging;
  };
  /**
   * On dragging draw the box. When mouse key press is released,
   * take ratio of box size to canvas size and zoom the axes by same
   * ratio
   * @param {Object} event
   */


  InputDragZoom.prototype.onDragEnd = function onDragEnd(event) {
    var canvasAttr = this.canvas.getGraphicalElement('canvasElement').attrs,
        box = this.components.box || {},
        boxAttr = box.attrs,
        startPosX,
        endPosX,
        startPosY,
        endPosY,
        bBox,
        options = this.options,
        stateArr = [],
        zoomed = true,
        axisZoomed;
    // If not box initialised; return
    if (!boxAttr) {
      return;
    }
    // hide he box
    box.hide();
    this.setDrag(false);
    startPosX = (boxAttr.x - canvasAttr.x) / canvasAttr.width;
    endPosX = (boxAttr.x + boxAttr.width - canvasAttr.x) / canvasAttr.width;
    startPosY = (boxAttr.y - canvasAttr.y) / canvasAttr.height;
    endPosY = (boxAttr.y + boxAttr.height - canvasAttr.y) / canvasAttr.height;
    bBox = box.getBBox();
    options.dragendFn && typeof options.dragendFn === 'function' && options.dragendFn(event, {
      selectionLeft: bBox.x,
      selectionTop: bBox.y,
      selectionHeight: bBox.height,
      selectionWidth: bBox.width,
      originalEvent: event.originalEvent
    });
    if (endPosX - startPosX < 0.01 || endPosY - startPosY < 0.01) {
      return;
    }
    this.config.axesObArr.forEach(function (axisOb) {
      var axis = axisOb.axis,
          visibleRange = axis.getVisibleConfig(),
          startPos = axisOb.isY ? visibleRange.max : visibleRange.min,
          diff = visibleRange.max - visibleRange.min;
      stateArr.push({
        range: visibleRange
      });
      if (axisOb.isY) {
        axisZoomed = axis.setVisibleConfig(startPos - diff * endPosY, startPos - startPosY * diff);
      } else {
        axisZoomed = axis.setVisibleConfig(startPos + startPosX * diff, startPos + diff * endPosX);
      }
      zoomed = zoomed || axisZoomed;
    });
    // Notify canvas for change
    zoomed && this.canvas.notifyChange(this.getEvent({
      event: 'zoomIn',
      state: stateArr
    }));
  };

  InputDragZoom.prototype.onDrag = function onDrag(event) {
    var input = this,
        options = input.options,
        currentXY = input.getCoordinates(event.originalEvent);
    if (!isSingleFinger(event.originalEvent)) {
      return;
    }
    stopDefault(event);
    // no animation for drag
    this.chart.state = 'noAnim';
    if (!this.isDragging()) {
      options.dragstartFn && typeof options.dragstartFn === 'function' && options.dragstartFn(event);
      this.setDrag(true);
      input.dragBoxConfig = {
        startPos: currentXY,
        currentPos: currentXY
      };
    } else {
      options.dragmoveFn && typeof options.dragmoveFn === 'function' && options.dragmoveFn(event);
      input.dragBoxConfig.currentPos = currentXY;
      input.drawBox();
    }
  };
  /**
   * If any other drag component start disable current component
   * @param {Event} eventOb
   */


  InputDragZoom.prototype.onEvent = function onEvent(eventOb) {
    if (eventOb.event === 'dragEnabled' || eventOb.event === 'pinEnabled') {
      this.disable();
    } else if (eventOb.event === 'dragDisabled' || eventOb.event === 'pinDisabled') {
      this.enable();
    }
  };

  return InputDragZoom;
}(_inputBase2['default']);

exports['default'] = InputDragZoom;

/***/ }),
/* 233 */,
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
/* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */
var HUNDREDSTRING = '100',
    COLOR_BLACK = '#000000',
    BLANK = '';

exports.HUNDREDSTRING = HUNDREDSTRING;
exports.BLANK = BLANK;
exports.COLOR_BLACK = COLOR_BLACK;

/***/ }),
/* 235 */,
/* 236 */,
/* 237 */,
/* 238 */,
/* 239 */,
/* 240 */,
/* 241 */,
/* 242 */,
/* 243 */,
/* 244 */,
/* 245 */,
/* 246 */,
/* 247 */,
/* 248 */,
/* 249 */,
/* 250 */,
/* 251 */,
/* 252 */,
/* 253 */,
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _column = __webpack_require__(15);

var _column2 = _interopRequireDefault(_column);

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */


var UNDEF,
    DEFAULTMAXCOLWIDTH = 50;

/**
 * ColumnMultiSeriesgroup basically manages all the position of multiseries columns side by side.
 * suppose multiseries column chart contains 2 dataset now what will be the column width and
 * position to accomodate all the columns. This manager conveys the column width and position
 * for every column plots to its children
 */

var ColumnOverlappedgroup = function (_ColumnMultiSeriesgro) {
  _inherits(ColumnOverlappedgroup, _ColumnMultiSeriesgro);

  function ColumnOverlappedgroup() {
    _classCallCheck(this, ColumnOverlappedgroup);

    return _possibleConstructorReturn(this, _ColumnMultiSeriesgro.apply(this, arguments));
  }

  /**
   * function to calculate column position and width
   */
  ColumnOverlappedgroup.prototype.setColumnPosition = function setColumnPosition() {
    var manager = this,
        chartAttr = manager.getFromEnv('chart-attrib'),
        xAxis = manager.getFromEnv('xAxis'),
        oldNumOfColumns = manager.getFromEnv('numOfColumns'),
        definedGroupPadding = Math.max((0, _lib.pluckNumber)(chartAttr.plotspacepercent), 0),
        plotSpacePercent = Math.max((0, _lib.pluckNumber)(definedGroupPadding, 20) % 100, 0),
        groupPadding = plotSpacePercent / 200,
        xAxisZeroPos = xAxis.getAxisPosition(0),
        xAxisFirstPos = xAxis.getAxisPosition(1),
        maxColWidth = Math.abs((0, _lib.pluckNumber)(chartAttr.maxcolwidth, chartAttr.maxbarheight, DEFAULTMAXCOLWIDTH)),
        groupMaxWidth = Math.abs(xAxisFirstPos - xAxisZeroPos),
        groupNetWidth = void 0,
        columnWidth = void 0,
        xPosFirst = void 0,
        xPosNext = void 0,
        isCrisp = true,
        groupNetHalfWidth = void 0,
        groupNetGapWidth = 4,
        count = 0,
        numOfColumns = 0;

    manager.addToEnv('groupMaxWidth', groupMaxWidth);
    manager._mapChildren(function (child) {
      if (!child.getState('removed') && child.getState('visible') !== false) {
        numOfColumns++;
      }
    });

    manager.addToEnv('numOfColumns', numOfColumns);
    manager.addToEnv('numColDiff', (0, _lib.pluckNumber)(oldNumOfColumns - numOfColumns, 0));

    if ((columnWidth = manager.getFromEnv('plotWidth')) === UNDEF) {
      columnWidth = (1 - definedGroupPadding * 0.01) * groupMaxWidth || Math.min(groupMaxWidth * (1 - groupPadding * 2), maxColWidth * (numOfColumns || 1));
    }

    manager._mapChildren(function (child) {
      if (!child.getState('removed') && child.getState('visible') !== false) {
        child.addToEnv('plotWidth', columnWidth - columnWidth / numOfColumns * count);
        count++;
      }
    });

    groupNetHalfWidth = groupNetWidth / 2;
    xPosFirst = xAxisZeroPos - groupNetHalfWidth;
    xPosNext = xAxisFirstPos - groupNetHalfWidth;
    if (xPosNext - (xPosFirst + groupNetWidth) < groupNetGapWidth) {
      isCrisp = false;
    }

    if (plotSpacePercent === 0) {
      isCrisp = true;
    }

    manager.addToEnv('isCrisp', isCrisp);
  };

  return ColumnOverlappedgroup;
}(_column2['default']);

exports['default'] = ColumnOverlappedgroup;

/***/ }),
/* 255 */,
/* 256 */,
/* 257 */,
/* 258 */,
/* 259 */,
/* 260 */,
/* 261 */,
/* 262 */,
/* 263 */,
/* 264 */,
/* 265 */,
/* 266 */,
/* 267 */,
/* 268 */,
/* 269 */,
/* 270 */,
/* 271 */,
/* 272 */,
/* 273 */,
/* 274 */,
/* 275 */,
/* 276 */,
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(278);
module.exports = __webpack_require__(16);


/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__(9);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(10);

var _symbol2 = _interopRequireDefault(_symbol);

var _assign = __webpack_require__(13);

var _assign2 = _interopRequireDefault(_assign);

var _sign = __webpack_require__(183);

var _sign2 = _interopRequireDefault(_sign);

var _keys = __webpack_require__(78);

var _keys2 = _interopRequireDefault(_keys);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _typeof = typeof _symbol2['default'] === "function" && typeof _iterator2['default'] === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2['default'] === "function" && obj.constructor === _symbol2['default'] && obj !== _symbol2['default'].prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * @private
 * @module fusioncharts.renderer.javascript.polyfill
 */
/* eslint-disable no-extend-native, no-eq-null, new-cap */
var polyfill = function polyfill() {
  /*
  * Polyfills
  * Ofcourse and obviously for IE8
  */
  // Pollyfills for Object.create
  // Ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create
  if (typeof _create2['default'] !== 'function') {
    // Production steps of ECMA-262, Edition 5, 15.2.3.5
    // Reference: http://es5.github.io/#x15.2.3.5
    /* jslint freeze: false */
    Object.create = function () {
      // To save on memory, use a shared constructor
      // eslint-disable-next-line no-empty-function
      // make a safe reference to Object.prototype.hasOwnProperty
      var hasOwn = Object.prototype.hasOwnProperty;
      // eslint-disable-next-line no-empty-function
      function Temp() {}

      return function (O) {
        var Properties, prop, obj;
        // 1. If Type (O) is not Object or Null throw a TypeError exception.
        if ((typeof O === 'undefined' ? 'undefined' : _typeof(O)) !== 'object') {
          throw new TypeError('Object prototype may only be an Object or null');
        }

        // 2. Let obj be the result of creating a new object as if by the
        //    expression new Object () where Object is the standard built-in
        //    constructor with that name
        // 3. Set the [[Prototype]] internal property of obj to O.
        Temp.prototype = O;
        obj = new Temp();
        Temp.prototype = null; // Let's not keep a stray reference to O...

        // 4. If the argument Properties is present and not undefined, add
        //    own properties to obj as if by calling the standard built-in
        //    function Object.defineProperties with arguments obj and
        //    Properties.
        if (arguments.length > 1) {
          // Object.defineProperties does ToObject on its first argument.
          Properties = Object(arguments[1]);
          for (prop in Properties) {
            if (hasOwn.call(Properties, prop)) {
              obj[prop] = Properties[prop];
            }
          }
        }

        // 5. Return obj
        return obj;
      };
    }();
  }

  // Pollyfills for Array indexOf
  // Ref: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf
  if (!Array.prototype.indexOf) {
    /* jslint freeze: false */
    Array.prototype.indexOf = function (searchElement, fromIndex) {
      var k, O, len, n;

      // 1. Let O be the result of calling ToObject passing
      //    the this value as the argument.
      if (this == null) {
        throw new TypeError('"this" is null or not defined');
      }

      O = Object(this);

      // 2. Let lenValue be the result of calling the Get
      //    internal method of O with the argument "length".
      // 3. Let len be ToUint32 (lenValue).
      len = O.length >>> 0;

      // 4. If len is 0, return -1.
      if (len === 0) {
        return -1;
      }

      // 5. If argument fromIndex was passed let n be
      //    ToInteger (fromIndex); else let n be 0.
      n = +fromIndex || 0;

      if (Math.abs(n) === Infinity) {
        n = 0;
      }

      // 6. If n >= len, return -1.
      if (n >= len) {
        return -1;
      }

      // 7. If n >= 0, then Let k be n.
      // 8. Else, n<0, Let k be len - abs (n).
      //    If k is less than 0, then let k be 0.
      k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

      // 9. Repeat, while k < len
      while (k < len) {
        // a. Let Pk be ToString (k).
        //   This is implicit for LHS operands of the in operator
        // b. Let kPresent be the result of calling the
        //    HasProperty internal method of O with argument Pk.
        //   This step can be combined with c
        // c. If kPresent is true, then
        //    i.  Let elementK be the result of calling the Get
        //        internal method of O with the argument ToString (k).
        //   ii.  Let same be the result of applying the
        //        Strict Equality Comparison Algorithm to
        //        searchElement and elementK.
        //  iii.  If same is true, return k.
        if (k in O && O[k] === searchElement) {
          return k;
        }
        k++;
      }
      return -1;
    };
  }

  // Pollyfills for Array forEach
  // Ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
  if (!Array.prototype.forEach) {
    // Production steps of ECMA-262, Edition 5, 15.4.4.18
    // Reference: http://es5.github.io/#x15.4.4.18
    /* jslint freeze: false */
    Array.prototype.forEach = function (callback, thisArg) {
      var T, k, O, len, kValue;

      if (this == null) {
        throw new TypeError(' this is null or not defined');
      }

      // 1. Let O be the result of calling ToObject passing the |this| value as the argument.
      O = Object(this);

      // 2. Let lenValue be the result of calling the Get internal method of O
      // with the argument "length".
      // 3. Let len be ToUint32 (lenValue).
      len = O.length >>> 0;

      // 4. If IsCallable (callback) is false, throw a TypeError exception.
      // See: http://es5.github.com/#x9.11
      if (typeof callback !== 'function') {
        throw new TypeError(callback + ' is not a function');
      }

      // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
      if (arguments.length > 1) {
        T = thisArg;
      }

      // 6. Let k be 0
      k = 0;

      // 7. Repeat, while k < len
      while (k < len) {
        // a. Let Pk be ToString (k).
        //   This is implicit for LHS operands of the in operator
        // b. Let kPresent be the result of calling the HasProperty internal method of O
        // with argument Pk.
        //   This step can be combined with c
        // c. If kPresent is true, then
        if (k in O) {
          // i. Let kValue be the result of calling the Get internal method of O with argument Pk.
          kValue = O[k];

          // ii. Call the Call internal method of callback with T as the this value and
          // argument list containing kValue, k, and O.
          callback.call(T, kValue, k, O);
        }
        // d. Increase k by 1.
        k++;
      }
      // 8. return undefined
    };
  }

  // Guard against the whiny IE
  /* jshint ignore:start */
  // Production steps of ECMA-262, Edition 5, 15.4.4.14
  // Reference: http://es5.github.io/#x15.4.4.14
  if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = function (searchElement, fromIndex) {
      var k, O, n, len;

      // 1. Let O be the result of calling ToObject passing
      //    the this value as the argument.
      if (this == null) {
        throw new TypeError('"this" is null or not defined');
      }

      O = Object(this);

      // 2. Let lenValue be the result of calling the Get
      //    internal method of O with the argument "length".
      // 3. Let len be ToUint32(lenValue).
      len = O.length >>> 0;

      // 4. If len is 0, return -1.
      if (len === 0) {
        return -1;
      }

      // 5. If argument fromIndex was passed let n be
      //    ToInteger(fromIndex); else let n be 0.
      n = +fromIndex || 0;

      if (Math.abs(n) === Infinity) {
        n = 0;
      }

      // 6. If n >= len, return -1.
      if (n >= len) {
        return -1;
      }

      // 7. If n >= 0, then Let k be n.
      // 8. Else, n<0, Let k be len - abs(n).
      //    If k is less than 0, then let k be 0.
      k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

      // 9. Repeat, while k < len
      while (k < len) {
        // a. Let Pk be ToString(k).
        //   This is implicit for LHS operands of the in operator
        // b. Let kPresent be the result of calling the
        //    HasProperty internal method of O with argument Pk.
        //   This step can be combined with c
        // c. If kPresent is true, then
        //    i.  Let elementK be the result of calling the Get
        //        internal method of O with the argument ToString(k).
        //   ii.  Let same be the result of applying the
        //        Strict Equality Comparison Algorithm to
        //        searchElement and elementK.
        //  iii.  If same is true, return k.
        if (k in O && O[k] === searchElement) {
          return k;
        }
        k++;
      }
      return -1;
    };
  }

  // Pollyfill for Object.create
  if (typeof _create2['default'] !== 'function') {
    // Production steps of ECMA-262, Edition 5, 15.2.3.5
    // Reference: http://es5.github.io/#x15.2.3.5
    Object.create = function () {
      // To save on memory, use a shared constructor
      // eslint-disable-next-line no-empty-function
      // make a safe reference to Object.prototype.hasOwnProperty
      var hasOwn = Object.prototype.hasOwnProperty;
      // eslint-disable-next-line no-empty-function
      function Temp() {}

      return function (O) {
        var obj, Properties, prop;

        // 1. If Type(O) is not Object or Null throw a TypeError exception.
        if ((typeof O === 'undefined' ? 'undefined' : _typeof(O)) !== 'object') {
          throw TypeError('Object prototype may only be an Object or null');
        }

        // 2. Let obj be the result of creating a new object as if by the
        //    expression new Object() where Object is the standard built-in
        //    constructor with that name
        // 3. Set the [[Prototype]] internal property of obj to O.
        Temp.prototype = O;
        obj = new Temp();
        Temp.prototype = null; // Let's not keep a stray reference to O...

        // 4. If the argument Properties is present and not undefined, add
        //    own properties to obj as if by calling the standard built-in
        //    function Object.defineProperties with arguments obj and
        //    Properties.
        if (arguments.length > 1) {
          // Object.defineProperties does ToObject on its first argument.
          Properties = Object(arguments[1]);
          for (prop in Properties) {
            if (hasOwn.call(Properties, prop)) {
              obj[prop] = Properties[prop];
            }
          }
        }

        // 5. Return obj
        return obj;
      };
    }();
  }

  // Pollyfill for Function.bind.
  if (!Function.prototype.bind) {
    Function.prototype.bind = function (oThis) {
      var aArgs, fToBind,
      // eslint-disable-next-line no-empty-function
      fNOP, fBound;
      if (typeof this !== 'function') {
        // closest thing possible to the ECMAScript 5
        // internal IsCallable function
        throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
      }

      aArgs = Array.prototype.slice.call(arguments, 1);
      fToBind = this;
      // eslint-disable-next-line no-empty-function
      fNOP = function fNOP() {};
      fBound = function fBound() {
        return fToBind.apply(this instanceof fNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
      };

      if (this.prototype) {
        // native functions don't have a prototype
        fNOP.prototype = this.prototype;
      }
      fBound.prototype = new fNOP();

      return fBound;
    };
  }

  // Production steps of ECMA-262, Edition 5, 15.4.4.21
  // Reference: http://es5.github.io/#x15.4.4.21
  if (!Array.prototype.reduce) {
    Array.prototype.reduce = function (callback /* , initialValue */) {
      'use strict';

      var t = Object(this),
          len = t.length >>> 0,
          k = 0,
          value;
      if (this == null) {
        throw new TypeError('Array.prototype.reduce called on null or undefined');
      }
      if (typeof callback !== 'function') {
        throw new TypeError(callback + ' is not a function');
      }

      if (arguments.length == 2) {
        value = arguments[1];
      } else {
        while (k < len && !(k in t)) {
          k++;
        }
        if (k >= len) {
          throw new TypeError('Reduce of empty array with no initial value');
        }
        value = t[k++];
      }
      for (; k < len; k++) {
        if (k in t) {
          value = callback(value, t[k], k, t);
        }
      }
      return value;
    };
  }

  // Production steps of ECMA-262, Edition 5, 15.4.4.18
  // From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys
  if (!_keys2['default']) {
    Object.keys = function () {
      var hasOwnProperty = Object.prototype.hasOwnProperty,
          hasDontEnumBug = !{ toString: null }.propertyIsEnumerable('toString'),
          dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'],
          dontEnumsLength = dontEnums.length;

      return function (obj) {
        var result = [],
            prop,
            i;
        if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' && (typeof obj !== 'function' || obj === null)) {
          throw new TypeError('Object.keys called on non-object');
        }

        for (prop in obj) {
          if (hasOwnProperty.call(obj, prop)) {
            result.push(prop);
          }
        }

        if (hasDontEnumBug) {
          for (i = 0; i < dontEnumsLength; i++) {
            if (hasOwnProperty.call(obj, dontEnums[i])) {
              result.push(dontEnums[i]);
            }
          }
        }
        return result;
      };
    }();
  }
  /* jshint ignore:end */

  // Pollyfill for Math.sign
  if (!_sign2['default']) {
    Math.sign = function (x) {
      // If x is NaN, the result is NaN.
      // If x is -0, the result is -0.
      // If x is +0, the result is +0.
      // If x is negative and not -0, the result is -1.
      // If x is positive and not +0, the result is +1.
      x = +x; // convert to a number
      if (x === 0 || isNaN(x)) {
        return Number(x);
      }
      return x > 0 ? 1 : -1;
    };
  }

  // Pollyfill for Object.assign
  if (typeof _assign2['default'] !== 'function') {
    Object.assign = function (target) {
      // .length of function is 2
      'use strict';

      var to, index, nextSource, nextKey;

      if (target == null) {
        // TypeError if undefined or null
        throw new TypeError('Cannot convert undefined or null to object');
      }

      to = Object(target);

      for (index = 1; index < arguments.length; index++) {
        nextSource = arguments[index];

        if (nextSource != null) {
          // Skip over if undefined or null
          for (nextKey in nextSource) {
            // Avoid bugs when hasOwnProperty is shadowed
            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
      return to;
    };
  }

  if (!window.getComputedStyle) {
    // eslint-disable-next-line no-global-assign
    window.getComputedStyle = function (el) {
      this.el = el;
      this.getPropertyValue = function (prop) {
        var re = /(\-([a-z]){1})/g;
        if (prop === 'float') {
          prop = 'styleFloat';
        }
        if (re.test(prop)) {
          prop = prop.replace(re, function () {
            return arguments[2].toUpperCase();
          });
        }
        return el.currentStyle[prop] ? el.currentStyle[prop] : null;
      };
      return this;
    };
  }

  return function () {
    // placebo method to appease the importer
  };
};

exports['default'] = polyfill();

/* eslint-enable no-extend-native, no-eq-null, new-cap */

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(280);
__webpack_require__(290);
module.exports = __webpack_require__(121).f('iterator');

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at  = __webpack_require__(281)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(173)(String, 'String', function(iterated){
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , index = this._i
    , point;
  if(index >= O.length)return {value: undefined, done: true};
  point = $at(O, index);
  this._i += point.length;
  return {value: point, done: false};
});

/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(110)
  , defined   = __webpack_require__(111);
// true  -> String#at
// false -> String#codePointAt
module.exports = function(TO_STRING){
  return function(that, pos){
    var s = String(defined(that))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

/***/ }),
/* 282 */
/***/ (function(module, exports) {

module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};

/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create         = __webpack_require__(115)
  , descriptor     = __webpack_require__(75)
  , setToStringTag = __webpack_require__(119)
  , IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(48)(IteratorPrototype, __webpack_require__(51)('iterator'), function(){ return this; });

module.exports = function(Constructor, NAME, next){
  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
};

/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

var dP       = __webpack_require__(38)
  , anObject = __webpack_require__(63)
  , getKeys  = __webpack_require__(50);

module.exports = __webpack_require__(39) ? Object.defineProperties : function defineProperties(O, Properties){
  anObject(O);
  var keys   = getKeys(Properties)
    , length = keys.length
    , i = 0
    , P;
  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(33)
  , toLength  = __webpack_require__(286)
  , toIndex   = __webpack_require__(287);
module.exports = function(IS_INCLUDES){
  return function($this, el, fromIndex){
    var O      = toIObject($this)
      , length = toLength(O.length)
      , index  = toIndex(fromIndex, length)
      , value;
    // Array#includes uses SameValueZero equality algorithm
    if(IS_INCLUDES && el != el)while(length > index){
      value = O[index++];
      if(value != value)return true;
    // Array#toIndex ignores holes, Array#includes - not
    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
      if(O[index] === el)return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(110)
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(110)
  , max       = Math.max
  , min       = Math.min;
module.exports = function(index, length){
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(32).document && document.documentElement;

/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has         = __webpack_require__(40)
  , toObject    = __webpack_require__(120)
  , IE_PROTO    = __webpack_require__(116)('IE_PROTO')
  , ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function(O){
  O = toObject(O);
  if(has(O, IE_PROTO))return O[IE_PROTO];
  if(typeof O.constructor == 'function' && O instanceof O.constructor){
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(291);
var global        = __webpack_require__(32)
  , hide          = __webpack_require__(48)
  , Iterators     = __webpack_require__(114)
  , TO_STRING_TAG = __webpack_require__(51)('toStringTag');

for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
  var NAME       = collections[i]
    , Collection = global[NAME]
    , proto      = Collection && Collection.prototype;
  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}

/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(292)
  , step             = __webpack_require__(293)
  , Iterators        = __webpack_require__(114)
  , toIObject        = __webpack_require__(33);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(173)(Array, 'Array', function(iterated, kind){
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , kind  = this._k
    , index = this._i++;
  if(!O || index >= O.length){
    this._t = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

/***/ }),
/* 292 */
/***/ (function(module, exports) {

module.exports = function(){ /* empty */ };

/***/ }),
/* 293 */
/***/ (function(module, exports) {

module.exports = function(done, value){
  return {value: value, done: !!done};
};

/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(295);
__webpack_require__(300);
__webpack_require__(301);
__webpack_require__(302);
module.exports = __webpack_require__(19).Symbol;

/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global         = __webpack_require__(32)
  , has            = __webpack_require__(40)
  , DESCRIPTORS    = __webpack_require__(39)
  , $export        = __webpack_require__(31)
  , redefine       = __webpack_require__(177)
  , META           = __webpack_require__(296).KEY
  , $fails         = __webpack_require__(49)
  , shared         = __webpack_require__(117)
  , setToStringTag = __webpack_require__(119)
  , uid            = __webpack_require__(76)
  , wks            = __webpack_require__(51)
  , wksExt         = __webpack_require__(121)
  , wksDefine      = __webpack_require__(122)
  , keyOf          = __webpack_require__(297)
  , enumKeys       = __webpack_require__(298)
  , isArray        = __webpack_require__(299)
  , anObject       = __webpack_require__(63)
  , toIObject      = __webpack_require__(33)
  , toPrimitive    = __webpack_require__(113)
  , createDesc     = __webpack_require__(75)
  , _create        = __webpack_require__(115)
  , gOPNExt        = __webpack_require__(181)
  , $GOPD          = __webpack_require__(124)
  , $DP            = __webpack_require__(38)
  , $keys          = __webpack_require__(50)
  , gOPD           = $GOPD.f
  , dP             = $DP.f
  , gOPN           = gOPNExt.f
  , $Symbol        = global.Symbol
  , $JSON          = global.JSON
  , _stringify     = $JSON && $JSON.stringify
  , PROTOTYPE      = 'prototype'
  , HIDDEN         = wks('_hidden')
  , TO_PRIMITIVE   = wks('toPrimitive')
  , isEnum         = {}.propertyIsEnumerable
  , SymbolRegistry = shared('symbol-registry')
  , AllSymbols     = shared('symbols')
  , OPSymbols      = shared('op-symbols')
  , ObjectProto    = Object[PROTOTYPE]
  , USE_NATIVE     = typeof $Symbol == 'function'
  , QObject        = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function(){
  return _create(dP({}, 'a', {
    get: function(){ return dP(this, 'a', {value: 7}).a; }
  })).a != 7;
}) ? function(it, key, D){
  var protoDesc = gOPD(ObjectProto, key);
  if(protoDesc)delete ObjectProto[key];
  dP(it, key, D);
  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function(tag){
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
  return typeof it == 'symbol';
} : function(it){
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D){
  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if(has(AllSymbols, key)){
    if(!D.enumerable){
      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = _create(D, {enumerable: createDesc(0, false)});
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P){
  anObject(it);
  var keys = enumKeys(P = toIObject(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P){
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key){
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
  it  = toIObject(it);
  key = toPrimitive(key, true);
  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
  var D = gOPD(it, key);
  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it){
  var names  = gOPN(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
  var IS_OP  = it === ObjectProto
    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if(!USE_NATIVE){
  $Symbol = function Symbol(){
    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function(value){
      if(this === ObjectProto)$set.call(OPSymbols, value);
      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f   = $defineProperty;
  __webpack_require__(182).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(77).f  = $propertyIsEnumerable;
  __webpack_require__(123).f = $getOwnPropertySymbols;

  if(DESCRIPTORS && !__webpack_require__(112)){
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function(name){
    return wrap(wks(name));
  }
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});

for(var symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);

for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    if(isSymbol(key))return keyOf(SymbolRegistry, key);
    throw TypeError(key + ' is not a symbol!');
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it){
    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
    var args = [it]
      , i    = 1
      , replacer, $replacer;
    while(arguments.length > i)args.push(arguments[i++]);
    replacer = args[1];
    if(typeof replacer == 'function')$replacer = replacer;
    if($replacer || !isArray(replacer))replacer = function(key, value){
      if($replacer)value = $replacer.call(this, key, value);
      if(!isSymbol(value))return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(48)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

var META     = __webpack_require__(76)('meta')
  , isObject = __webpack_require__(64)
  , has      = __webpack_require__(40)
  , setDesc  = __webpack_require__(38).f
  , id       = 0;
var isExtensible = Object.isExtensible || function(){
  return true;
};
var FREEZE = !__webpack_require__(49)(function(){
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function(it){
  setDesc(it, META, {value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  }});
};
var fastKey = function(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add metadata
    if(!create)return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function(it, create){
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return true;
    // not necessary to add metadata
    if(!create)return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function(it){
  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY:      META,
  NEED:     false,
  fastKey:  fastKey,
  getWeak:  getWeak,
  onFreeze: onFreeze
};

/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

var getKeys   = __webpack_require__(50)
  , toIObject = __webpack_require__(33);
module.exports = function(object, el){
  var O      = toIObject(object)
    , keys   = getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};

/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(50)
  , gOPS    = __webpack_require__(123)
  , pIE     = __webpack_require__(77);
module.exports = function(it){
  var result     = getKeys(it)
    , getSymbols = gOPS.f;
  if(getSymbols){
    var symbols = getSymbols(it)
      , isEnum  = pIE.f
      , i       = 0
      , key;
    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
  } return result;
};

/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(180);
module.exports = Array.isArray || function isArray(arg){
  return cof(arg) == 'Array';
};

/***/ }),
/* 300 */
/***/ (function(module, exports) {



/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(122)('asyncIterator');

/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(122)('observable');

/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(304);
module.exports = __webpack_require__(19).Object.assign;

/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(31);

$export($export.S + $export.F, 'Object', {assign: __webpack_require__(305)});

/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var getKeys  = __webpack_require__(50)
  , gOPS     = __webpack_require__(123)
  , pIE      = __webpack_require__(77)
  , toObject = __webpack_require__(120)
  , IObject  = __webpack_require__(179)
  , $assign  = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(49)(function(){
  var A = {}
    , B = {}
    , S = Symbol()
    , K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function(k){ B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
  var T     = toObject(target)
    , aLen  = arguments.length
    , index = 1
    , getSymbols = gOPS.f
    , isEnum     = pIE.f;
  while(aLen > index){
    var S      = IObject(arguments[index++])
      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
  } return T;
} : $assign;

/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(307);
module.exports = __webpack_require__(19).Math.sign;

/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.28 Math.sign(x)
var $export = __webpack_require__(31);

$export($export.S, 'Math', {sign: __webpack_require__(308)});

/***/ }),
/* 308 */
/***/ (function(module, exports) {

// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x){
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(310);
module.exports = __webpack_require__(19).Object.keys;

/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(120)
  , $keys    = __webpack_require__(50);

__webpack_require__(125)('keys', function(){
  return function keys(it){
    return $keys(toObject(it));
  };
});

/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(312);
var $Object = __webpack_require__(19).Object;
module.exports = function create(P, D){
  return $Object.create(P, D);
};

/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(31)
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', {create: __webpack_require__(115)});

/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__(9);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(10);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2['default'] === "function" && typeof _iterator2['default'] === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2['default'] === "function" && obj.constructor === _symbol2['default'] && obj !== _symbol2['default'].prototype ? "symbol" : typeof obj; }; /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */


var _lib = __webpack_require__(5);

var _dependencyManager = __webpack_require__(80);

var _eventApi = __webpack_require__(7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/** Lowercases the input string
 * @param {string} str The string to be converted to lower case
 * @return {string} The lower cased string
 */
var sanitiseFormatStr = function sanitiseFormatStr(str) {
  return str.toString().toLowerCase();
},
    nativeFormat = 'json',
    dataStore = {},
    cache = {},
    isUrl = /url$/i;

/**
 * Handles the calcellation of a data update to the chart
 *
 * @param {Event} event The event obejct
 * @param {Object} args The callback arguments
 */
function onDataUpdateCancel(event, args) {
  /**
   * Cancelling the default behavior of {@link FusionCharts#event:beforeDataUpdate} causes the
   * `dataUpdateCancelled` event to be raised .This event can used to notify the user that the
   * update of data was cancelled.
   * @event FusionCharts#dataUpdateCancelled
   *
   * @param {string|object} data - The data in one of the formats as in
   * {@link FusionCharts~dataFormats}, that was supposed to be passed on to the chart.
   * @param {FusionCharts~dataFormats} format - The format in which the data was to be passed on for
   * rendering.
   * @param {string} dataSource - The original/source data as specified using data setter functions
   * such as {@link FusionCharts#setChartData}.
   * @param {FusionCharts~dataFormats} dataFormat - The data format of the original/source data.
   * @param {string} error During the process of fetching and cancellation of data, if there was
   * any error, the same is passed on for debug purposes.
   */
  (0, _eventApi.triggerEvent)('dataUpdateCancelled', event.sender, args, _lib.UNDEF, args.failurecallback);
}

/**
 * Parses the arguments of the chart data update call
 *
 * @param {Object} data The JSON data taht was supplied
 * @param {string} format The format of teh data given
 * @param {boolean} silent Indicates whether the updation of data whould raise events or not
 * @return {Object} The parsed arguments
 */
function _getParsedArgs(data, format, silent) {
  var parsedArgs = {};
  // Updated the result so that it can be passed as event argument.
  // Closure compiler gives error when using obj.native. Hence using
  // different notation.
  parsedArgs['native'] = format === nativeFormat;
  parsedArgs.format = format;
  // Add additional argument for events in parser result
  parsedArgs.dataSource = data;
  // Save the silent instruction to arguments
  parsedArgs.silent = !!silent;

  return parsedArgs;
}

/**
 * Augments FusionCharts with the ability to transcode data and the ability to accept other data
 * transcoders
 *
 * @param {Object} fcGlobal The global FusionCharts object
 */
function updater(fcGlobal) {
  /**
   * Handles the case of data updating being a success
   *
   * @param {Event} event The event object
   * @param {Object} args The arguments of the success callback
   */
  function onDataUpdateSuccess(event, args) {
    var chart = event.sender,
        state = chart.__state,
        chartId = chart.id;

    // Save data within dataStore
    dataStore[chartId] = args;
    // Clear cache
    if (cache[chartId]) {
      delete cache[chartId];
    }
    cache[chartId] = {};

    // Clear any decision flag whether data is ready for chart to be rendered.
    state.dataReady = _lib.UNDEF;
    state.dataAvailable = true;

    // Raise data updation event if it is not marked as silent data updating.
    if (args.silent !== true) {
      // Stall this update if this is stuck in between a render and loading
      if (chart.options.safeMode === true && state.rendering === true && !chart.isActive()) {
        state.updatePending = args;
        /**
         * This warning is issued when a chart's rendering process and the process of data being
         * fetched from an URL has happened simultaneously. FusionCharts delays the rendering of the
         * chart in anticipation of the arrival of data and in the process reduces redundant
         * re-rendering of the charts.
         *
         * This warning is for information purpose only and does not require any action.
         *
         * @typedef {RuntimeException} Warning-23091255
         * @memberOf FusionCharts.debugger
         * @group debugger-warning
         */
        (0, _eventApi.raiseWarning)(chart, '23091255', 'run', '::DataHandler~update', 'Renderer update was postponed due to async loading.');
      } else {
        delete state.args;
        fcGlobal.renderer.update(chart, args);
      }
    } else {
      chart.args.dataSource = args.dataSource;
    }
    /**
     * On updating the data of a chart, the chart is *re-drawn*. The
     * {@link FusionCharts#event:drawCompleteEvent} gets fired as soon the necessary elements of the
     * chart are re-drawn.This event is followed by the `dataUpdated` event which is raised when the
     * data is loaded into *FusionCharts JavaScript class* and is ready to be passed to the chart to
     * maintain integrity and timing of related codes.
     * @event FusionCharts#dataUpdated
     *
     * @param {string|object} data - The data in one of the formats as in
     * {@link FusionCharts~dataFormats}, that has been passed on to the chart.
     * @param {FusionCharts~dataFormats} format - The format in which the data has been finally
     * passed on to the chart. It is not that the original format in which data has been provided
     * will be the final format passed on to the data. For instance, JavaScript variant of chart
     * when renderer (as can be retrieved from {@link FusionCharts.getCurrentRenderer}) is
     * `javascript`, the data format is `JSON`.
     * @param {string} dataSource - The original/source data as specified using data setter
     * functions such as {@link FusionCharts#setChartData}.
     * @param {FusionCharts~dataFormats} dataFormat - The data format of the original/source data.
     * @param {string} error During the process of fetching and updating data, if there was any
     * error, the same is passed on for debug purposes.
     */
    (0, _eventApi.triggerEvent)('dataUpdated', chart, args, _lib.UNDEF, args.successcallback);
  }

  fcGlobal.core.prototype.setChartDataUrl = function () {
    var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'jsonurl';
    var config = arguments[2];
    var callback = arguments[3];
    var silent = arguments[4];

    var dataFormats = (0, _dependencyManager.getDepsByType)('transcoder');

    this.jsVars.stallLoad = true;

    if (dataFormats[format]) {
      if (dataFormats[format].toJSON) {
        dataFormats[format].toJSON(url, config, callback, silent, this);
      } else {
        return {
          error: new Error('Unable to fetch data.')
        };
      }
    } else {
      return {
        error: new Error('Unable to fetch data.')
      };
    }
  };

  fcGlobal.core.prototype.setChartData = function () {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'json';
    var config = arguments[2];
    var callback = arguments[3];
    var silent = arguments[4];

    var chartObj = this,
        dataFormats = (0, _dependencyManager.getDepsByType)('transcoder'),
        chartOptions = chartObj.options,
        jsonData = void 0,
        parseArgs = void 0;

    format = sanitiseFormatStr(format);

    if (isUrl.test(format)) {
      chartObj.setChartDataUrl(data, format, config, callback, silent);
      return;
    }

    if (dataFormats[format]) {
      if (dataFormats[format].toJSON) {
        jsonData = dataFormats[format].toJSON(data).data;
      } else {
        jsonData = {
          error: new Error('Unable to convert data.')
        };
      }
    } else {
      jsonData = {
        error: new Error('Unable to convert data.')
      };
    }

    chartOptions.dataSource = jsonData;
    chartOptions.dataFormat = format;

    parseArgs = _getParsedArgs(jsonData, format, silent);

    (0, _eventApi.triggerEvent)('beforeDataUpdate', chartObj, parseArgs, _lib.UNDEF, onDataUpdateSuccess, onDataUpdateCancel);
  };

  fcGlobal.core.prototype.getChartData = function () {
    var format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'json';

    // Variable to store a reference to the data-handler.
    var chartObj = this,
        dataFormats = (0, _dependencyManager.getDepsByType)('transcoder'),
        chartData = chartObj.args.dataSource,
        formattedData;

    format = sanitiseFormatStr(format);

    if (dataFormats[format]) {
      if (dataFormats[format].fromJSON) {
        formattedData = dataFormats[format].fromJSON(chartData).data;
      } else {
        formattedData = {
          error: new Error('Unable to convert data.')
        };
      }
    } else {
      formattedData = {
        error: new Error('Data format not recognized.')
      };
    }

    return formattedData;
  };

  fcGlobal.core.prototype.getJSONData = function () {
    return this.getChartData('json');
  };

  fcGlobal.core.prototype.setJSONData = function (data) {
    this.setChartData(data, 'json');
  };

  fcGlobal.core.prototype.getXMLData = function () {
    return this.getChartData('xml');
  };

  fcGlobal.core.prototype.setXMLData = function (data) {
    return this.setChartData(data, 'xml');
  };

  /**
   * This function is used to determine whether a chart will render properly with the data set on
   * it. This includes data that are set using functions like {@link FusionCharts#setChartData} or
   * {@link FusionCharts#setChartDataUrl}.
   *
   * If the function is not able to determine whether the data is ready or not, it returns
   * `undefined`. It will return `true` or `false` only after a chart has completed rendering, that
   * is, the after the `renderComplete` event has fired.
   *
   * The function will return `false` if no data is set on the chart, or the data is faulty. Also,
   * it will return `false` if the data provided is incompatible with the current chart type, for
   * example, if single-series data has been set for multi-series charts.
   *
   * @group data
   *
   * @param {boolean=} [available=false] - Setting the `available` parameter to `true` returns the
   * status of the data irrespective of its compatibility with chart-type. In that case, this
   * function will return `false` if data provided to the chart causes
   * {@link FusionCharts#event:dataLoadError} or {@link FusionCharts#event:dataInvalid} to be fired
   *
   * @return {boolean|undefined} The returned boolean denotes whether data is ready or not. In case
   * the status of data-readiness is unknown, this function returns `undefined`.
   */
  fcGlobal.core.prototype.dataReady = function (available) {
    return available ? this.__state.dataAvailable : this.__state.dataReady;
  };

  (0, _eventApi.addListener)('beforeInitialize', function (event) {
    var obj = event.sender,
        options = obj.options,
        dataSource = obj.args.dataSource,
        dataFormat = obj.args.dataFormat,
        renderer = fcGlobal.renderer && fcGlobal.renderer.getRenderer(options.renderer);

    // Clear the dataStore, cache and xStore when new chart is created.
    delete dataStore[obj.id];
    cache[obj.id] = {};

    // Set intitial data if present
    if (dataSource !== _lib.UNDEF && dataSource !== null) {
      obj.__state.dataSetDuringConstruction = true;

      // If data format was not specified during construction, try auto-detection.
      if (typeof dataFormat !== 'string') {
        switch (typeof dataSource === 'undefined' ? 'undefined' : _typeof(dataSource)) {
          case 'function':
            dataSource = options.dataSource = dataSource.call(obj, options.dataConfiguration);
            obj.args.dataFormat = 'JSON';
            break;
          case 'string':
            obj.args.dataFormat = /^\s*?\{[\s\S]*\}\s*?$/g.test(dataFormat) ? 'JSON' : 'XML';
            break;
          case 'object':
            obj.args.dataFormat = 'JSON';
            break;
        }
      }

      if (dataFormat && dataFormat.toString) {
        obj.__state.dataFetchDuringConstruction = isUrl.test(dataFormat.toString());
      }

      obj.setChartData(dataSource, dataFormat, _lib.UNDEF, _lib.UNDEF, true);
    } else if (renderer) {
      // In case dataSource is not present during construction, we silently set it to rendere's default
      obj.__state.dataSetDuringConstruction = false;
      /**
       * FusionCharts supports construction parameters to have `dataSource` and `dataFormat` to be provided. As
       * such charts render with the data provided during construction. However, if a chart has been rendered by
       * calling {@link FusionCharts#render}, but no data has been provided to the chart, this warning is raised.
       *
       * Unless this is intentionally implemented, try furnishing the chart with data before `.render()` is
       * called.
       *
       * @typedef {ParameterException} Warning-1810131922A
       * @memberOf FusionCharts.debugger
       * @group debugger-warning
       */
      (0, _eventApi.raiseWarning)(obj, '1810131922A', 'param', ':dataHandler~event:beforeInitialize', 'Data source was not defined during construction, hence set to blank renderer default - ' + renderer.dataFormat);
      obj.setChartData('', obj.args.dataFormat, _lib.UNDEF, _lib.UNDEF, true);
      obj.__state.dataAvailable = false;
    }
  });

  (0, _eventApi.addListener)('dataUpdated', function (event, args) {
    var obj = event.sender,
        state = obj.__state;

    if (state.rendering && (state.dataFetchDuringConstruction || state.updatePending)) {
      delete state.dataFetchDuringConstruction; // flags must be unset before update to avoid recursion
      delete state.updatePending;
      fcGlobal.renderer.update(obj, args);
    }
  });
}

exports['default'] = updater;

/***/ }),
/* 314 */
/***/ (function(module, exports) {

module.exports = {
	"name": "xt-edge",
	"description": "JavaScript Data Visualisation Library",
	"homepage": "http://www.fusioncharts.com/",
	"version": "3.12.0",
	"browserslist": [
		"> 0.2%"
	],
	"license": "MIT",
	"author": "FusionCharts, Inc.  <support@fusioncharts.com>",
	"main": "./lib/fusioncharts.js",
	"src": "./develop/src",
	"build": {
		"dist": "./out/build/",
		"name": "fusioncharts"
	},
	"lib": "./lib",
	"samples": {
		"root": "samples",
		"dist": "dist",
		"src": "src",
		"port": "8080"
	},
	"keywords": [
		"fusioncharts",
		"charts",
		"gauges",
		"maps"
	],
	"preferGlobal": false,
	"repository": {
		"type": "git",
		"url": "https://bitbucket.org/fusioncharts/xt-edge.git"
	},
	"dependencies": {
		"babel-runtime": "^6.23.0",
		"browser-sync": "^2.18.6",
		"documentation": "^4.0.0-beta.18",
		"dotenv": "^4.0.0",
		"gulp-wrap": "^0.13.0",
		"jest": "^19.0.2",
		"jquery-fusioncharts": "^1.0.5",
		"redraphael": "^1.1.26",
		"svgdecanvo": "^1.0.1",
		"svgdom": "0.0.8"
	},
	"devDependencies": {
		"babel": "^6.23.0",
		"babel-cli": "^6.24.1",
		"babel-core": "^6.25.0",
		"babel-loader": "^7.1.1",
		"babel-plugin-add-module-exports": "^0.2.1",
		"babel-plugin-transform-es2015-classes": "^6.24.1",
		"babel-plugin-transform-es3-member-expression-literals": "^6.22.0",
		"babel-plugin-transform-es3-property-literals": "^6.22.0",
		"babel-plugin-transform-proto-to-assign": "^6.23.0",
		"babel-plugin-transform-runtime": "^6.23.0",
		"babel-polyfill": "^6.23.0",
		"babel-preset-env": "^1.4.0",
		"babel-preset-es2015-rollup": "^3.0.0",
		"body-parser": "1.17.2",
		"chai": "3.5.0",
		"chalk": "1.1.3",
		"chrome-launcher": "^0.6.0",
		"chrome-remote-interface": "^0.24.4",
		"cors": "2.8.4",
		"del": "2.2.1",
		"es3ify-loader": "^0.2.0",
		"esdoc": "^1.0.2",
		"esdoc-standard-plugin": "^1.0.0",
		"eslint": "^3.17.1",
		"eslint-config-google": "^0.7.1",
		"eslint-config-standard": "^7.0.1",
		"eslint-plugin-compat": "^1.0.2",
		"eslint-plugin-promise": "^3.5.0",
		"eslint-plugin-standard": "^2.1.1",
		"express": "4.15.4",
		"google-closure-compiler": "20160208.4.0",
		"gulp": "3.9.1",
		"gulp-babel": "^6.1.2",
		"gulp-concat": "2.6.0",
		"gulp-header": "^1.8.8",
		"gulp-metascript": "^0.0.3",
		"gulp-mocha": "3.0.1",
		"gulp-preprocess": "2.0.0",
		"gulp-rename": "^1.2.2",
		"gulp-streamify": "^1.0.2",
		"gulp-uglify": "^2.1.2",
		"gulp-unzip": "^0.2.0",
		"gulp-util": "3.0.7",
		"jasmine": "^2.5.3",
		"jasmine-node": "1.13.0",
		"jsdoc": "^3.4.3",
		"jsdom": "9.5.0",
		"jsinspect": "^0.12.7",
		"jslink": "1.1.3",
		"karma": "^1.7.0",
		"karma-allure-reporter": "^1.4.4",
		"karma-chai": "^0.1.0",
		"karma-chrome-launcher": "^2.2.0",
		"karma-jasmine": "^1.1.0",
		"karma-json-result-reporter": "^1.0.0",
		"karma-mocha": "^1.3.0",
		"karma-mocha-reporter": "^2.2.3",
		"karma-sinon": "^1.0.5",
		"karma-webpack": "^1.8.1",
		"larry": "0.0.3-beta",
		"lodash": "^4.17.4",
		"metascript": "0.18.0",
		"mkdirp": "^0.5.1",
		"mocha": "^3.1.2",
		"path": "0.12.7",
		"phantomjs": "2.1.7",
		"pre-commit": "1.1.2",
		"pump": "^1.0.2",
		"rollup": "^0.43.0",
		"rollup-plugin-babel": "^2.7.1",
		"rollup-plugin-commonjs": "^8.0.2",
		"rollup-plugin-hypothetical": "^1.2.1",
		"rollup-plugin-json": "^2.3.0",
		"rollup-plugin-multi-entry": "^2.0.1",
		"rollup-plugin-node-resolve": "^3.0.0",
		"rollup-plugin-uglify": "^2.0.1",
		"rollup-watch": "^4.0.0",
		"run-sequence": "^1.2.2",
		"sinon": "^2.3.6",
		"webpack": "^3.0.0",
		"webpack-bundle-analyzer": "^2.8.2",
		"webpack-dev-server": "^2.5.0",
		"webpack-merge": "^4.1.0",
		"webpack-stream": "^3.2.0"
	},
	"scripts": {
		"component": "sh develop/test/extra/component/bash.sh",
		"karma": "./node_modules/karma/bin/karma start",
		"unit-test": "develop/ci/karma/karma",
		"inspect-code": "jsinspect ./develop/src > develop/test/extra/jsinspect/jsinspect.txt || true",
		"unit": "./node_modules/karma/bin/karma start --browsers='ChromeHeadless'",
		"_build": "node rollup.config.js && echo 'Build completed'",
		"start": "webpack-dev-server --host 0.0.0.0 --env.production=true",
		"test": "develop/ci/test/test",
		"jest": "develop/ci/jest/jest",
		"jsunit": "develop/ci/jsunit/jsunit",
		"drone": "develop/ci/drone/drone",
		"lint": "develop/ci/lint/lint $file",
		"jscs": "develop/ci/jscs/jscs $file",
		"lint-errors": "develop/ci/lint/lint-errors $file",
		"docs": "develop/ci/docs/docs",
		"docs-api": "develop/ci/docs/docs-api",
		"docs-esdoc": "develop/ci/docs/docs-esdoc",
		"analyse:bundle": "rm -rf out/_build && mkdirp webpack-analyser/data && babel-node develop/ci/build/modular-build.js --analyse",
		"custom:bundle": "rm -rf out/_build && babel-node develop/ci/build/modular-build.js --charts MSColumn2D --filename fc.mscol.js",
		"dev:bundle": "rm -rf out/_build && webpack --progress --display-modules --display-used-exports",
		"build": "rm -rf out/ && webpack && gulp create:build && gulp compress:licensed && gulp compress:eval && gulp compress:resellereval",
		"build-source": "rm -rf out/build/source && webpack && gulp create:source",
		"build-eval": "rm -rf out/build/eval && webpack && gulp create:eval && gulp compress:eval",
		"verify": "develop/ci/verify/verify",
		"package-release": "develop/ci/package/package-release",
		"package": "develop/ci/package/package"
	},
	"pre-commit": {
		"run": [
			"lint",
			"unit-test",
			"build-eval",
			"docs",
			"verify"
		]
	}
};

/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__(9);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(10);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2['default'] === "function" && typeof _iterator2['default'] === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2['default'] === "function" && obj.constructor === _symbol2['default'] && obj !== _symbol2['default'].prototype ? "symbol" : typeof obj; }; /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */


var _eventApi = __webpack_require__(7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * Adds the setChartAttribute and the getChartAttribute APIs to the chart
 */
exports['default'] = {
  /**
   * Updates a chart's data attributes with the new attribute-value pair. In other words, it
   * updates a chart's data definition root. That would be `<chart>` node in case data is in `XML`
   * format or the `chart {}` object in case it is in `JSON` format. You must have the chart's
   * data being set for these attributes to take effect.
   *
   * This function is useful when updating a chart's configuration after it has been rendered
   * once. The function internally retrieves the last data set on the chart
   * (using {@link FusionCharts#getJSONData}). It then updates the `{ chart: {} }` object of the
   * data using the new attributes provided and then sets this data back to the chart.
   *
   * > Setting the value of a parameter to `null` causes the attribute to be removed (unset) and
   * > restored to it's default value.
   *
   * @group data
   *
   * @param {Object|string} attributes - The set of attributes to be is passed on as key-value
   * pair of an object. In case of updating a single attribute, the key can be passed as a
   * `string` and the value as the second parameter.
   *
   * @param {?string=} [value] - In case the first parameter is a single attribute as string, the
   * second parameter (i.e. this parameter) must be provided as the value of that key.
   *
   * @example
   * // Here we would render a chart in a DOM element with an id, say "chart-container", and upon
   * // clicking the chart, we would toggle the visibility of its legend.
   * FusionCharts.ready(function () {
   *     FusionCharts.render({
   *         id: 'salesChart',
   *         type: 'pie2d',
   *         renderAt: 'chart-container',
   *
   *         dataSource: {
   *             chart: {
   *                 caption: 'Revenue distribution'
   *             },
   *             data: [
   *                 { value: '22', label: 'Redistribution' },
   *                 { value: '54', label: 'Internal Circulation' },
   *                 { value: '24', label: 'Sale' },
   *             ]
   *         },
   *
   *         events: {
   *             chartClick: function (event) {
   *                 var chart = event.sender,
   *                     // Check whether legend is currently visible by fetching the showLegend
   *                     // attribute
   *                     legendVisible = !!+chart.getChartAttribute('showLegend');
   *
   *                 // Set the opposite of the current state of the legend's visibility.
   *                 chart.setChartAttribute('showLegend', legendVisible ? '0' : '1');
   *             }
   *         }
   *     });
   * });
   */
  setChartAttribute: function setChartAttribute(attributes, value) {
    var json, prop, attList, temp, i;

    // In case attribute is sent as separate arguments, combine them to one object.
    if (typeof attributes === 'string') {
      temp = arguments[0];
      attributes = {};
      attributes[temp] = value;
    } else if (attributes === null || (typeof attributes === 'undefined' ? 'undefined' : _typeof(attributes)) !== 'object') {
      // In case user sends invalid parameters for attributes.
      return;
    }

    i = 0;
    json = this.getChartData('json');
    attList = json && (json.chart || json.graph || json.map);

    if (!attList) {
      /**
       * {@link FusionCharts#setChartAttribute} was called while chart data was not set or while
       * chart data had an error. Check whether {@link FusionCharts.event:dataLoaded} had been
       * successfully fired before {@link FusionCharts.event:renderComplete} and that none of the
       * data load error events such as {@link FusionCharts.event:dataLoadError} or
       * {@link FusionCharts.event:invalidData} has been fired.
       *
       * @typedef {RuntimeException} Error-2105141421
       * @memberOf FusionCharts.debugger
       * @group debugger-error
       */
      (0, _eventApi.raiseError)(this, '2105141421', 'run', '#setChartAttribute()', 'Could not retrieve attribute list. Is data ready?');
      return;
    }

    // Iterate through attributes and update them.
    for (prop in attributes) {
      i += 1;
      if (attributes[prop] === null) {
        delete attList[prop.toLowerCase()];
        continue;
      }
      attList[prop.toLowerCase()] = attributes[prop];
    }
    // Update chart's XML.
    if (i > 0) {
      // In case animation is not specified, then turn it off.
      if (typeof attList.animation === 'undefined') {
        attList.animation = '0';
      }
      this.setChartData(json, 'json');
    }
  },

  /**
   * Fetch value of chart attributes (configurations) that have been explicitly applied to root
   * level `chart`. This function can be used to return value of a single attribute or a list of
   * attributes or all attributes have been applied to the chart.
   *
   * - To fetch a single attribute, pass the name of the attribute as a string.
   * - To fetch a list of selected attributes, pass an array of attribute names. This will return
   * an object with items in the order in which they are provided in the array.
   * - To fetch a list of all attributes, do not pass a parameter to this function.
   *
   * If any attribute requested is not set on the chart, the value for that attribute is returned
   * as `undefined`. This will be `undefined` even for values that are internally computed but not
   * explicitly set. For example, for Multi-series Column2D charts, `showLegend` defaults to
   * `"1"`. But, if `showLegend` is not provided as part of chart configuration, requesting the
   * value of `showLegend` through this function will return `undefined`.
   *
   * @group data
   *
   * @param {string|string[]} [attribute] - The attribute or an array of attributes that is to be
   * fetched. If this parameter is not provided, then all available chart attributes are returned.
   *
   * @return {string|Object} The value of the attribute in form of a string in case a single
   * attribute was requested. Otherwise, an object containing a set of key value pairs.
   */
  getChartAttribute: function getChartAttribute(attribute) {
    // Get chart attributes.
    var json = this.getChartData('json'),
        attList = json && (json.chart || json.graph || json.map),

    // Create a variable that will store reference to the parameter that
    // contains attributes. This helps in case user sends one attribute
    // as string, we covert it to an array witj one element.
    value,
        i;

    // In case no argument is passed, we return the entire set of
    // chart attributes object.
    if (arguments.length === 0 || typeof attribute === 'undefined' || typeof attList === 'undefined') {
      return attList;
    }

    // Convert single attribute to array with one element or directly
    // send the value as return.
    if (typeof attribute === 'string') {
      value = attList[attribute.toString().toLowerCase()];
    } else if (attribute instanceof Array) {
      // In case user sends an array of attributes, we compile an object
      // for the same and return.
      value = {};
      for (i = 0; i < attribute.length; i += 1) {
        value[attribute[i]] = attList[attribute[i].toString().toLowerCase()];
      }
    } else {
      // If all above conditions fail, there must be some issue with the
      // parameters.
      /**
       * {@link FusionCharts#getChartAttribute} accepts only a string or an array of attribute
       * names as its paramater. Check whether your call to the function involved passing some
       * other type of parameter.
       *
       * @typedef {RuntimeException} Error-25081429
       * @memberOf FusionCharts.debugger
       * @group debugger-error
       */
      (0, _eventApi.raiseError)(this, '25081429', 'param', '~getChartAttribute()', 'Unexpected value of "attribute"');
    }

    // We return 'value' variable here as because it is equivalent to
    // sending '{}' in case above conditions fail.
    return value;
  }
};

/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__(9);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(10);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2['default'] === "function" && typeof _iterator2['default'] === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2['default'] === "function" && obj.constructor === _symbol2['default'] && obj !== _symbol2['default'].prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                                                                                         * Generic Runtime Module
                                                                                                                                                                                                                                                                                                                                         * @private
                                                                                                                                                                                                                                                                                                                                         *
                                                                                                                                                                                                                                                                                                                                         * @module fusioncharts.runtime
                                                                                                                                                                                                                                                                                                                                         * @requires fusioncharts.constructor
                                                                                                                                                                                                                                                                                                                                         * @requires fusioncharts.events
                                                                                                                                                                                                                                                                                                                                         * @requires fusioncharts.debugger
                                                                                                                                                                                                                                                                                                                                         */

var _lib = __webpack_require__(5);

var _eventApi = __webpack_require__(7);

var _schedular = __webpack_require__(41);

var _schedular2 = _interopRequireDefault(_schedular);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

// import { _global } from '../constructor/constructor';

function runtime(_global) {
  var UNDEF,
      win = window,


  // Set the FusionCharts filename possibilities as regular expression.
  SCRIPT_NAME_REGEX = /(^|[\/\\])(fusioncharts\.js)([\?#].*)?$/ig,
      // jshint ignore:line
  BLOCK_EXTERNAL_SCRIPT_LOADING = false,
      DISALLOW_CROSSDOMAIN_RESOURCE = false,
      SCRIPT_LOAD_TIMEOUTMS = 15000,
      checkBadChars = /[\\\"<>;&]/,
      hasProtocolDef = /^[^\S]*?(sf|f|ht)(tp|tps):\/\//i,
      FUNCTION = 'function',


  /**
   * Regular Expressions that helps to check XSS security loops.
   */
  LOAD_EVENTNAME = 'externalresourceload',


  /**
   * To keep a track of scripts requested.
   * @type Object
   */
  scriptsRequested = {},


  /**
   * To keep a track of loaded script tags
   */
  scriptTags = {},


  /**
   * To keep a track of scripts loaded.
   * @type Object
   */
  scriptsLoaded = {},


  /**
   * Keep a track of load failure check
   * @type object
   */
  scriptLoadFailureTimeout = {},


  /**
   * Function that safely deletes all items in a DOM element.
   */
  purgeDOM = _global.purgeDOM = function (d) {
    var a = d.attributes,
        i,
        l,
        n;
    if (a) {
      for (i = a.length - 1; i >= 0; i -= 1) {
        n = a[i].name;
        if (typeof d[n] === 'function') {
          d[n] = null;
        }
      }
    }
    a = d.childNodes;
    if (a) {
      l = a.length;
      for (i = 0; i < l; i += 1) {
        purgeDOM(d.childNodes[i]);
      }
    }
  },


  // Deconstruct policies.
  // Update the arguments with latest copy of all variables by
  // reverse engineering the policies.
  deconstructPolicySet = function deconstructPolicySet(policies, options, obj) {
    var policy, prop;

    for (policy in policies) {
      // Set just the policy object in case of single-level policy.
      if (policies[policy] instanceof Array) {
        options[policies[policy][0]] = obj[policy];
      } else {
        // Copy the source of multi-level policies
        for (prop in policies[policy]) {
          options[policies[policy][prop][0]] = obj[policy][prop];
        }
      }
    }
  },
      signatureMatchRegex = /^(FusionCharts|FusionWidgets|FusionMaps)/;

  /**
   * Function to determine the script base uri for a script name
   */
  _global.getScriptBaseUri = function (scriptNameRegex) {
    // Get a collection of all script nodes.
    var scripts = win.document.getElementsByTagName('script'),
        l = scripts.length,
        src,
        i;

    // Iterate through the script node collection and match whether its
    // 'src' attribute contains fusioncharts file name.
    for (i = 0; i < l; i += 1) {
      src = scripts[i].getAttribute('src');
      if (!(src === UNDEF || src === null || src.match(scriptNameRegex) === null)) {
        return src.replace(scriptNameRegex, '$1');
      }
    }
    return UNDEF;
  };

  // Get the script base uri. (Regexp has been updated)
  _global.core.options.scriptBaseUri = function () {
    var baseUri = _global.getScriptBaseUri(SCRIPT_NAME_REGEX);

    if (baseUri === UNDEF) {
      /**
       * FusionCharts JavaScript Library automatically determines the location where it was loaded from within
       * the server. This it does by probing the `<script>` tag that has `fusioncharts.js` as a part of its `src`
       * attribute. In case, this `baseUri` cannot be determined, this error is raised. Usually, this occurs when
       *
       * 1. `fusioncharts.js` has been loaded by a script / resource loader like requireJS or jQuery
       * 2. `fusioncharts.js` has been renamed to something else and then loaded
       * 3. `fusioncharts.js` is loaded from an external domain and as search browser has enforced cross-domain
       *    security restrictions.
       *
       * @typedef {RuntimeException} Error-1603111624
       * @memberOf FusionCharts.debugger
       * @group debugger-error
       */
      (0, _eventApi.raiseError)(_global.core, '1603111624', 'run', '>GenericRuntime~scriptBaseUri', 'Unable to locate FusionCharts script source location (URL).');
      return '';
    }
    return baseUri;
  }();

  /**
   * Function that allows users to verify whether a string contains any XSS
   * unsafe code. This is used while setting various urls.
   * @param {string} str The string that has to be checked for XSS
   * @param {boolean} proto Specify whether to test any protocol definition
   */
  _global.isXSSSafe = function (str, proto) {
    if (proto && hasProtocolDef.exec(str) !== null) {
      return false;
    }
    return checkBadChars.exec(str) === null;
  };

  _global.xssEncode = function (s) {
    if (s === null || s === UNDEF || _typeof(s.toString) !== FUNCTION) {
      return '';
    }

    // do we convert to numerical or html entity?
    s = s.toString().replace(/&/g, '&amp;').replace(/\'/g, '&#39;') // no HTML equivalent as &apos is not cross browser supported
    .replace(/\"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

    return s;
  };

  /**
   * Loads a JS using head script attach method
   */
  _global.loadScript = function (file, callback, scriptText, includeOnce, pathInFile) {
    var script, success, failure, path, src,
    // lib,
    addJob, eventArgs, notify;

    // If file is not specified, we exit
    if (!file) {
      return false;
    }

    // Check security block.
    if (BLOCK_EXTERNAL_SCRIPT_LOADING === true) {
      /**
       * FusionCharts can be configured to block loading of external JavaScript files by setting the internal
       * constant `BLOCK_EXTERNAL_SCRIPT_LOADING=true;`. When this has been done, and some chart still needs
       * external resource (script) that has not been manually loaded, this warning is issued. Ensure that the
       * relevant files, such as, `fusioncharts.charts.js`, `fusioncharts.widgets.js` or other such files are
       * already included in page before rendering the chart.
       *
       * @typedef {RuntimeException} Warning-04031935
       * @memberOf FusionCharts.debugger
       * @group debugger-warning
       */
      (0, _eventApi.raiseWarning)(_global.core, '04031935', 'run', '>genericRuntime~loadScript', 'External Script loading has been blocked');
      return false;
    }

    success = callback && callback.success || callback;
    failure = callback && callback.failure;
    // lib = global.hcLib;
    addJob = _schedular2['default'].addJob;
    eventArgs = {
      type: 'script',
      success: false
    };
    notify = function notify() {
      // clear stalled 404 check
      scriptLoadFailureTimeout[src] = clearTimeout(scriptLoadFailureTimeout[src]);

      // execute callbacks
      eventArgs.success ? success && success(file, src) : failure && failure(file, src);
      /**
       * This event is fired when other dependencies like jquery are being
       * loaded via HTTP GET along with the chart library.
       * @event FusionCharts#externalResourceLoad
       * @private
       *
       * @param {string} file Contains the name of the external file that is
       * being included on runtime. Example: "jquery.min.js".
       * @param {string} path Contains relative directory location of the external file.
       * Example: "../FusionCharts/Charts/"
       * @param {string} src Contains the relative path of the location of the external
       * file. Example:"../FusionCharts/Charts/jquery.min.js"
       * @param {boolean} success Is set to true if the file is found otherwise false.
       */
      (0, _eventApi.triggerEvent)(LOAD_EVENTNAME, _global.core, eventArgs);
    };

    // Prepare path.
    if (pathInFile) {
      path = '';
    } else {
      path = _global.core.options.scriptBaseUri;
    }

    // Prepare the full src
    src = path + file;

    // we do not allow XSS unsafe string
    if (!_global.isXSSSafe(src, DISALLOW_CROSSDOMAIN_RESOURCE)) {
      src = typeof win.encodeURIComponent === 'function' ? win.encodeURIComponent(src) : win.escape(src);
    }

    // Update event arguments
    eventArgs.path = path;
    eventArgs.src = src;
    eventArgs.file = file;

    // Do not reload the script once loaded.
    if (scriptsLoaded[src] === true && includeOnce) {
      eventArgs.success = true;
      eventArgs.notReloaded = true;
      if (typeof callback === 'function') {
        callback();
        (0, _eventApi.triggerEvent)(LOAD_EVENTNAME, _global.core, eventArgs);
      }
      return true;
    }

    // Check whether this script has been already loaded once and whether
    // multiple inclusion is prevented.
    if (scriptsRequested[src] && includeOnce) {
      return false;
    }
    // Add the src to the lists of scripts loaded.
    scriptsRequested[src] = true;

    // If a script tag with same src exists, then we need to delete the
    // previous one
    if (scriptTags[src] && scriptTags[src].parentNode) {
      scriptTags[src].parentNode.removeChild(scriptTags[src]);
    }

    // Create the script element with its attributes.
    script = scriptTags[src] = win.document.createElement('script');
    // Set the script type to javaScript
    script.type = 'text/javascript';
    // Set the prepared src as the script's src.
    script.src = src;
    // Set script inner text to what user passed as parameter.
    if (scriptText) {
      // eslint-disable-next-line no-constant-condition
      script[ false ? 'text' : 'innerHTML'] = scriptText;
    }

    // Execute callback function when the script was loaded.
    if (typeof success === 'function') {
      scriptsLoaded[src] = false;
      scriptLoadFailureTimeout[src] = clearTimeout(scriptLoadFailureTimeout[src]);

      script.onload = function () {
        scriptsLoaded[src] = true;
        eventArgs.success = true;

        addJob(notify, _lib.priorityList.render);
      };

      script.onerror = function () {
        scriptsLoaded[src] = false;
        scriptsRequested[src] = false; // in case of error cancel request
        addJob(notify, _lib.priorityList.render);
      };

      script.onreadystatechange = function () {
        if (this.readyState === 'complete' || this.readyState === 'loaded') {
          scriptsLoaded[src] = true;
          eventArgs.success = true;
          addJob(notify, _lib.priorityList.render);
        }
      };
    }

    // TODO: Need to visit this appendChild script
    // Append the script to the head of this page.
    window.document.getElementsByTagName('head')[0].appendChild(script);
    // Prepare the timeout check for script load failure
    if (typeof failure === 'function') {
      scriptLoadFailureTimeout[src] = setTimeout(function () {
        if (scriptsLoaded[src]) {
          return;
        }
        notify();
      }, _global.core.options.html5ResourceLoadTimeout || SCRIPT_LOAD_TIMEOUTMS);
    }

    return true;
  };

  (0, _lib.extend2)(_global.core.prototype, /** @lends FusionCharts# */{
    /**
     * Use this function to create a copy of a chart instance. Cloning a chart object results in creation of a new
     * chart with identical construction properties of the chart being cloned. A cloned chart is not rendered by
     * default and needs to be provided a container DOM element to be rendered into. A cloned chart gets one
     * auto-generated chart Id assigned.
     *
     * @group chart
     *
     * @param {?object=} [overrides] - This parameter can be very useful in instructing what changes needs to be
     * done while cloning a chart. It accepts all the construction parameters of a new {@link FusionCharts}
     * instance.
     *
     * For example, passing `pieChart.clone({type: 'column2d'});` will clone the pie chart, but set its chart-type
     * as `column2d`.
     * @param {boolean=} [argsOnly=false] - Setting this to `true` does not return a new FusionCharts object.
     * Instead, it causes the function to return a serializable object that can be later passed on while creating a
     * new FusionCharts and as such create a clone.
     *
     * @return {FusionCharts|object}
     */
    clone: function clone(overrides, argsOnly) {
      // Create a copy of arguments of this object.
      var typeofParams = typeof overrides === 'undefined' ? 'undefined' : _typeof(overrides),
          crcObjects = {},
          options = (0, _lib.extend2)({}, this.args, false, false);

      // Recreate construction parameters by reverse calculating the global
      // policies.
      deconstructPolicySet(_global.policies, options, this);
      // Also deconstruct the rendere specific policies.
      deconstructPolicySet(_global.renderer.getRendererPolicy(this.options.renderer), options, this);

      // Remove any specific parameters that if cloned will create issues.
      delete options.id;
      delete options.animate;
      delete options.stallLoad;
      crcObjects.link = options.link; // link was removed as it prevents deep cloning

      // Now, deep clone the entire object to separate both instances
      options = (0, _lib.extend2)({}, options, false, false);

      // restore crc Objects
      options.link = crcObjects.link;

      switch (typeofParams) {
        // Override any of the options by parameters sent by user
        case 'object':
          (0, _lib.extend2)(options, overrides);
          break;

        // In case user sends only one boolean param marking not to
        // create new chart.
        case 'boolean':
          argsOnly = overrides;
          break;
      }

      // Create new FusionCharts object from the computed options
      // eslint-disable-next-line new-cap
      return argsOnly ? options : new _global.core(options);
    },

    /**
     * Denotes whether a chart is "active" or not after being rendered. This is primarily relevant for Flash variant
     * of the charts since they tend to loose functionality when hidden or scrolled away as a measure to save system
     * resources.
     *
     * For JavaScript charts, this returns `false` when a chart has not been rendered. As such, using the function
     * {@linkFusionCharts#hasRendered} is more relevant.
     *
     * @group chart
     * @deprecated 3.4.0 - The removal of Flash variant of the charts discards the use of this function since
     * JavaScript are always "active" and does not loose its functionalities when out of viewport of the browser.
     *
     * @return {boolean} - Returns `true` if a Flash chart is visible and can communicate with the rest of the
     * page using its internal JavaScript API. For JavaScript charts, this returns `false` when a chart has not been
     * rendered.
     */
    isActive: function isActive() {
      if (!this.ref || win.document.getElementById(this.id) !== this.ref) {
        return false;
      }

      try {
        return signatureMatchRegex.test(this.ref.signature());
      } catch (e) {
        return false;
      }
    },

    /**
     * Gets or sets the chart type of an instance of FusionCharts.
     *
     * To change the chart type, pass the new chart type as the first parameter to this function. The chart is
     * automatically re-rendered when a new chart type is set. To get the current
     * chart type, call this function without any parameters.
     *
     * When the chart type is changed using this method, the chart is re-rendered and the
     * {@link FusionCharts#event:chartTypeChanged} event is fired.
     *
     * @since 3.4.0
     * @group chart
     *
     * @param {string=} value - Sets the new chart type.
     *
     * @param {object=} options - During modifying the chart type using this method, additional options can be
     * passed on to update chart data and re-render the chart at the same time. Note that these options are ignored
     * if you do not provide a `value` (first) parameter.
     *
     * @param {string|object=} options.dataSource - Provide a new source of data during the change of chart type.
     * @param {FusionCharts~dataFormats=} options.dataFormat - Specify the data format of the new `dataSource`
     * provided during chart-type update. If this is not provded, then it is assumed that the `dataSource` provided
     * is same as the existing or default `dataFormat`. If `dataSource` is not provided, this parameter is ignored.
     *
     * @return {string} The current chart type is returned.
     *
     * @fires FusionCharts#chartTypeChanged
     * @see FusionCharts.render
     *
     * @example
     * // Render a column chart and on click of a button toggle it from column to pie and vice versa.
     * FusionCharts.ready(function () {
     *     var chart = new FusionCharts({
     *         type: 'column2d',
     *         renderAt: 'chart-container',
     *         dataSource: 'weekly-sales.json',
     *         dataFormat: 'jsonurl'
     *     }).render();
     *
     *     // Assign the functionality of toggling chart type when clicked on
     *     // a button (with an id toggle-chart-type).
     *     document.getElementById('toggle-chart-type').onclick = function () {
     *         if (chart.chartType() === 'column2d') {
     *             chart.chartType('pie2d');
     *         }
     *         else {
     *             chart.chartType('column2d');
     *         }
     *     };
     * });
     */
    chartType: function chartType(value, options) {
      var chartObj = this,
          src = chartObj.src,
          silent = options === true,
          opts = chartObj.options,
          legacy;

      if (typeof value === 'string') {
        options = (typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object' ? options : {};

        // We remove query string from `src` and also possible .swf (legacy) extension
        // Similar processing is in core
        src = value.replace(/[\?\#][\s\S]*$/g, '');

        // Before replacing legacy swf extension, keep a flag to note its existence.
        legacy = src.match(/\.swf\s*?$/ig) !== null;

        // Replace legacy swf extension.
        src = src.replace(/\.swf\s*?$/ig, '');

        // remove path for type and remove fcMap (legacy)
        opts.chartType = src.replace(/^[\s\S]*\//ig, '').replace(/^fcmap_/i, '');
        opts.chartTypeSourcePath = src.indexOf('/') === -1 ? options.chartTypeSourcePath || chartObj.options.chartTypeSourcePath || _global.core.options.chartTypeSourcePath || '' : src.replace(/[^\/]*?$/ig, '');

        // Handling for legacy flash.
        chartObj.src = ((_global.core.options.scriptBaseUri || '') + (opts.chartTypeSourcePath || _global.core.options.chartTypeSourcePath || '')).replace(/\/\s*$/g, '') + '/' + opts.chartType.replace(/\.swf\s*?$/ig, '') + '.swf';

        // In case chart type has .swf the drop the sourcepath calculation for legacy
        if (legacy) {
          /**
           * Since FusionCharts 3.4.0, the use of `.swf` suffix in chart types is deprecated since, Flash
           * variant of charts are no longer supported. As such, a warning message is issued to notify
           * developers to follow steps specified in '3.4.0 Migration Guide" to upgrade to the newest API.
           *
           * @typedef {DesignTimeException} Warning-08101320181
           * @memberOf FusionCharts.debugger
           * @group debugger-warning
           *
           * @since 3.4.0
           */
          (0, _eventApi.raiseWarning)(chartObj, '08101320181', 'comp', 'FusionCharts#chartType', 'Chart type has ".swf" in alias and as such has been deprecated. Please use chart type alias.');
          opts.chartTypeSourcePath = _global.core.options.chartTypeSourcePath || '';
        }

        // handle special internal case of setting chart type without rendering.
        if (options.dataSource !== UNDEF && options.dataSource !== null) {
          chartObj.setChartData(options.dataSource, options.dataFormat, options.dataConfiguration);
        } else if (chartObj.isActive() && !silent) {
          chartObj.render();
        }
      }

      return (opts.chartType || '').toLowerCase();
    }

  });

  /**
   * This function gives access to the HTMLDOMElement that has been created inside the chart container by
   * FusionCharts. Note that this does not return the container element specified during FusionCharts#render of the
   * chart. It is rather the element inside the container element that is created by FusionCharts to hold a chart.
   * @global
   *
   * @deprecated Since 3.2.0 there is no need to directly interact with charts' DOM element. As such, this becomes
   * redundant.
   *
   * @param {string} id The chart Id whose internal DOM element is needed.
   * @return {FusionCharts}
   */
  win.getChartFromId = function (id) {
    /**
     * Use of deprecated getChartFromId() or getMapFromId() global objects detected. Developer needs to upgrade
     * to usage of the latest API and access chart instances using {@link FusionCharts.items} or
     * `FusionCharts("chart-id")`.
     *
     * @typedef {DesignTimeException} Warning-11133001041
     * @memberOf FusionCharts.debugger
     * @group debugger-warning
     *
     * @since 3.4.0
     */
    (0, _eventApi.raiseWarning)(this, '11133001041', 'comp', 'GenericRuntime~getObjectFromId()', 'Use of deprecated getChartFromId() or getMapFromId(). Replace ' + 'with "FusionCharts()" or FusionCharts.items[].');
    return _global.core.items[id] instanceof _global.core ? _global.core.items[id].ref : win.swfobject && win.swfobject.getObjectById(id);
  };

  /**
   * This function gives access to the HTMLDOMElement that has been created inside the chart container by
   * FusionCharts. Note that this does not return the container element specified during FusionCharts#render of the
   * chart. It is rather the element inside the container element that is created by FusionCharts to hold a chart.
   * @global
   * @function
   *
   * @deprecated Since 3.2.0 there is no need to directly interact with charts' DOM element. As such, this becomes
   * redundant.
   *
   * @param {string} id The chart Id whose internal DOM element is needed.
   * @return {FusionCharts}
   */
  win.getMapFromId = win.getChartFromId;
}

exports['default'] = runtime;

/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _lib = __webpack_require__(5);

var _eventApi = __webpack_require__(7);

var _dependencyManager = __webpack_require__(80);

var _rendererLib = __webpack_require__(126);

/**
 * @private
 *
 * @module fusioncharts.renderer.javascript.interface
 * @requires fusioncharts.renderer.javascript
 * @requires fusioncharts.renderer.javascript.visualizer
 */

var BEFOREPRINT = 'BeforePrint',
    PRINTCANCELLED = 'PrintCancelled',
    PRINTCOMPLETE = 'PrintComplete',
    visibleStr = 'visible',
    noneStr = 'NONE',
    dropHash = _lib.regex.dropHash,
    createChart = void 0;

function rendererInterface(fcGlobal) {
  var renderer = fcGlobal.renderer.getRenderer('javascript'),
      privateAPIMethods = /** @lends FusionCharts# */{
    getExternalInterfaceMethods: function getExternalInterfaceMethods() {
      var vars = this.jsVars,
          api = fcGlobal.core.getDep(vars.type, 'chart'),
          eiMethods = api && api.eiMethods,
          eiMethodString = 'saveAsImage,print,exportChart,getXML,hasRendered,signature,cancelExport,getSVGString,lockResize,' + 'showChartMessage,drawCrossLine,',
          method;

      if (typeof eiMethods === 'string') {
        eiMethodString += eiMethods + _lib.COMMASTRING;
      } else if (eiMethods !== _lib.UNDEF || eiMethods !== null) {
        for (method in eiMethods) {
          eiMethodString += method + _lib.COMMASTRING;
        }
      }

      return eiMethodString.substr(0, eiMethodString.length - 1);
    },

    drawOverlayButton: function drawOverlayButton(args) {
      var vars = this.jsVars,
          backBtn = vars.overlayButton,
          cssObj,
          item,
          text;

      if (args && args.show) {
        if (!backBtn) {
          backBtn = vars.overlayButton = document.createElement('span');

          // lib.dem.listen(backBtn, 'click', function () {
          //                 /**
          //                  * On clicking the data plot items of a parent chart, the associated linked chart is opened.
          //                  * To go back to the parent chart, the overlay *back* button is used.
          //                  * `OverlayButtonClick` is fired when the overlay *back* button of the linked chart is
          //                  * clicked.
          //                  * This will close the child linked chart and reload the parent chart.
          //                  *
          //                  * @event FusionCharts#overlayButtonClick
          //                  * @param { string } id Id of the button
          //                  * @param { boolean } show `True` if we want to show the overlay button in the parent chart.
          //                  * `False` if we want to disable the overlay button.
          //                  */
          //   global.raiseEvent('OverlayButtonClick', args, vars.fcObj);
          // });
        }

        text = args.message ? args.message : 'Back';
        // Remove all child nodes of the overlay button, before appending new child nodes
        while (backBtn.firstChild) {
          backBtn.removeChild(backBtn.firstChild);
        }
        backBtn.appendChild(document.createTextNode(text));
        vars.overlayButtonMessage = text; // #FCXT-217

        // Create the visual layout of the element.
        cssObj = {
          border: '1px solid ' + (args.borderColor ? args.borderColor.replace(dropHash, _lib.HASHSTRING) : '#7f8975'),
          backgroundColor: args.bgColor ? args.bgColor.replace(dropHash, _lib.HASHSTRING) : '#edefec',
          fontFamily: args.font ? args.font : 'Verdana,sans',
          color:  true ? args.fontColor : '49563a',
          fontSize: (args.fontSize ? args.fontSize : '10') + _lib.PXSTRING,
          padding: (args.padding ? args.padding : '3') + _lib.PXSTRING,
          fontWeight: parseInt(args.bold, 10) === 0 ? _lib.NORMAL : _lib.BOLD,
          position: 'absolute',
          top: '0',
          right: '0',
          cursor: _lib.POINTER
        };

        for (item in cssObj) {
          backBtn.style[item] = cssObj[item];
        }

        vars.hcObj.container.appendChild(backBtn);
        vars.overlayButtonActive = true;
      } else if (backBtn) {
        vars.overlayButton = backBtn.parentNode.removeChild(backBtn);
        vars.overlayButtonActive = false;
        delete vars.overlayButtonMessage;
      }
    },

    /**
     * You can use this function to print individual charts. This function hides all elements on the page except
     * the chart in concern and then invokes the page printing function (`window.print ()`).
     *
     * > This function works only for charts that have rendered completely, i.e. after
     * { @link FusionCharts#event:renderComplete } event has fired.
     *
     * @param { object= } [options] - Printing options
     * @param { boolean= } [options.hideButtons=true] - Hides all buttons on the chart.
     * @group export
     * @example
     * // In this snippet of code, we will render a chart on a page and
     * // call the print method on the chart on click of a button.
     * FusionCharts.ready (function () {
     *    FusionCharts.render ( {
     *        type: 'column2d',
     *        dataFormat: 'jsonurl',
     *        dataSource: 'data.json',
     *
     *        // assuming an HTML div element exists on the page
     *        renderAt: 'chart-container-div'
     *
     *        events: {
     *            renderComplete: function (event) {
     *                // assuming a button exists on page with a specific id
     *                var button = document.getElementById ('print-button');
     *                button.onclick = function () {
     *                    event.sender.print ();
     *                };
     *            }
     *        }
     *
     *    });
     * });
     *
     * @fires FusionCharts#beforePrint
     * @fires FusionCharts#printComplete
     * @fires FusionCharts#printCancelled
     */
    print: function print(options) {
      var chart = this.apiInstance,
          args = (0, _lib.extend2)({}, options);

      // Block the button while in printing mode
      if (chart.config.isPrinting || !chart.config.hasRendered) {
        return false;
      }

      /**
       * This event is fired before printing has started after calling {@link FusionCharts#print} on a chart.
       * The {@link FusionCharts#print} method is used to print individual charts on a page.
       * @see FusionCharts#event:printComplete
       * @see FusionCharts#event:printCancelled
       * @see FusionCharts#print
       * @event FusionCharts#beforePrint
       * @group export
       */
      (0, _eventApi.triggerEvent)(BEFOREPRINT, chart.chartInstance, args, _lib.UNDEF, function () {
        var container = chart.linkedItems.container,

        // Temp code to be changed latter.
        origDisplay = [],
            origParent = container.parentNode,
            body = document.body || document.getElementsByTagName('body')[0],
            childNodes = body.childNodes,
            length,
            lists,
            list,
            i;

        chart.config.isPrinting = true;

        // hide all body content
        (0, _lib.fcEach)(childNodes, function (node, i) {
          if (node.nodeType == 1) {
            origDisplay[i] = node.style.display;
            node.style.display = noneStr;
          }
        });

        // hide print and export buttons before capturing export data
        if (args.hideButtons !== false) {
          // todo
          lists = chart.getChildren('chartMenuBar').componentGroups[0].symbolList;

          for (i = 0, length = lists.length; i < length; i++) {
            if ((list = lists[i]) instanceof chart.getFromEnv('toolBoxAPI').SymbolWithContext) {
              list = list.getListRefernce().getFirstContainer();
              break;
            }
          }

          list.container.style.display = noneStr;
        }

        // pull out the chart
        body.appendChild(chart.linkedItems.container);

        // print
        window.print();

        // allow the browser to prepare before reverting
        setTimeout(function () {
          // todo
          // show print and export buttons before capturing export data
          list.container.style.display = visibleStr;
          // put the chart back in
          origParent.appendChild(container);

          // restore all body content
          (0, _lib.fcEach)(childNodes, function (node, i) {
            if (node.nodeType == 1) {
              node.style.display = origDisplay[i];
            }
          });

          if (args.hideButtons !== false) {
            // todo
            list.container.style.display = visibleStr;
          }

          chart.config.isPrinting = false;
          /**
           * This event is fired after user accepts or cancels the browser's print dialog box that was
           * originally triggered by calling {@link FusionCharts#print} on the chart. The
           * {@link FusionCharts#print} method is used to print individual charts on a page.
           * @see FusionCharts#event:beforePrint
           * @see FusionCharts#event:printCancelled
           * @see FusionCharts#print
           * @event FusionCharts#printComplete
           * @group export
           */
          (0, _eventApi.triggerEvent)(PRINTCOMPLETE, chart.chartInstance, args);
        }, 1000);
      }, function () {
        /**
         * This  event is fired when the printing request from a chart has been  __programmatically__
         * cancelled by calling `eventObject.preventDefault()` from the
         * {@link FusionCharts#events:beforePrint} event.
         *
         * > Note that this event is not fired when user clicks on the "cancel" button of the
         * browser-triggered print dialog box resulting from calling the {@link FusionCharts#print}
         * function.
         * @see FusionCharts#event:beforePrint
         * @see FusionCharts#event:printComplete
         * @see FusionCharts#print
         * @event FusionCharts#printCancelled
         * @group export
         */
        (0, _eventApi.triggerEvent)(PRINTCANCELLED, chart.chartInstance, args);
      });
    },

    // Old architecture documentation
    /**
     * Exports a chart to image or PDF document using this function. The function can be configured to export
     * a chart and present it as a file download. Exporting of a chart is not enabled by default. The chart's
     * data must have the `exportEnabled` chart attribute explicitly set to `1`.
     *
     * When exporting of a chart is enabled, it is exported using a set of default options. These options can be
     * overridden by configuring the chart data. That would allow you to configure the behavior of the export
     * related context-menu drawn on the chart. However, in the event that exporting is done programmatically,
     * the export parameters can be customized using this function.
     *
     * > The exporting process can only be initiated after the { @link FusionCharts#event:renderComplete } event
     * > has been fired. The function itself remains UNDEF until the { @link FusionCharts#event:loaded }
     * > event is raised by the chart.
     *
     * @group export
     * @see FusionCharts#event:beforeExport
     * @see FusionCharts#event:exported
     * @see FusionCharts#event:exportCancelled
     * @tutorial interactivity-export-to-image-or-pdf-configuring-for-export
     * @tutorial interactivity-export-to-image-or-pdf-set-your-export-server
     *
     * @param { object= } [options] -
     * @param { string= } [options.exportFormat=png] - A chart can be exported in one of the following formats:
     *
     * | Export Format  | Description                                               |
     * |----------------|-----------------------------------------------------------|
     * | `png`          | Exports the charts in high quality lossless PNG format    |
     * | `jpg`          | Exports the chart as high quality JPEG image format       |
     * | `pdf`          | Exports the chart as a PDF document                       |
     *
     * @param { string= } [options.exportFileName=FusionCharts] - Using this attribute you can specify the name
     * (excluding the extension) of the file to be exported. The extension is automatically appended depending
     * on the `exportFormat` specified.
     * @param { string= } [options.exportTargetWindow=_self] - When using `download` as `exportAction`,
     * this lets you configure whether the return image or PDF will open in same
     * window (as an attachment for download),
     * or whether it will open in a new browser window (`_blank`).
     * @param { string= } [options.exportHandler] - URL of the export server.
     * @param { string= } [options.exportAction=download] - Specifies whether the exported image will be sent
     * back to the browser as download, or whether it will be saved on to the server.
     *
     * | Action Value    | Description                                                      |
     * |-----------------|------------------------------------------------------------------|
     * | `download`      | Causes the exported chart image or PDF to be downloaded as file. |
     * | `save`          | Causes the exported chart to be saved on server.                 |
     *
     * For the charts to be saved on server, you would need to setup your own export handling server.
     *
     * @param { function= } [options.exportCallback=FC_Exported] - This attribute specifies the name of the
     * callback JavaScript function which will be called when the export event is complete. The function
     * `window.FC_Exported` is the default method that will be called when no value specified.
     *
     * @return { boolean } The function returns `true` if export process of the chart
     * was successfully triggered, otherwise it returns `false`.
     */
    exportChart: function exportChart() {
      // export the chart
      throw Error('Need to modularize exports');
      // return lib.exportChart.call(this.apiInstance, exportOption);
    },

    /**
     * Fetch the SVG of a chart as a string. This function returns the SVG that has been created by FusionCharts
     * when rendering the chart.
     * > Note that this function is only available for a chart that has already been rendered.
     *
     * @group export
     *
     * @return { string } - SVG string
     */
    getSVGString: function getSVGString(callback) {
      var chartContainer = this,
          chart = chartContainer.apiInstance,
          asyncRender = chart.chartInstance.args.asyncRender;

      if (typeof callback === 'function') {
        chart.addJob('getSVG', function () {
          callback(chartContainer.jsVars && chartContainer.jsVars.instanceAPI && chartContainer.jsVars.instanceAPI.components && chartContainer.jsVars.instanceAPI.components.paper && chartContainer.jsVars.instanceAPI.components.paper.toSVG());
        }, _lib.priorityList.postRender);
      } else {
        if (asyncRender) {
          return '<svg></svg>';
        }
        return chartContainer.jsVars && chartContainer.jsVars.instanceAPI && chartContainer.jsVars.instanceAPI.components && chartContainer.jsVars.instanceAPI.components.paper && chartContainer.jsVars.instanceAPI.components.paper.toSVG();
      }
    },

    resize: function resize() {
      var vars = this.jsVars,
          container = vars.container;

      if (vars.instanceAPI && vars.instanceAPI.redraw) {
        vars.instanceAPI.state = 'resize';
        vars.instanceAPI.redraw();
      } else {
        // todo: remove this legacy code
        createChart(vars.fcObj, container, vars.type, _lib.UNDEF, _lib.UNDEF, false, true);
      }

      delete vars.isResizing;
    },

    /**
     * Controls a chart's automatic resizing ability when its dimension is in percentage.
     *
     * This function has to be called before a chart has rendered.
     * Using { @link FusionCharts#hasRendered } can be useful here.
     *
     * If this function is called without parameter, it returns the current state of resize lock.
     *
     * @group chart:resize
     *
     * @param { boolean= } [state] - Sending `true` for this parameter causes the automatic percentage based
     * resize to be turned off. If resize is already locked, sending `false` unlocks it.
     *
     * @return { boolean } - Returns whether the chart's automatic resize feature has been locked or not.
     */
    lockResize: function lockResize(state) {
      if (typeof state !== 'boolean') {
        return !!this.jsVars.resizeLocked;
      }

      return this.jsVars.resizeLocked = state;
    },

    /**
     * Shows a text message on a chart.
     *
     * @param { string } text The text message that needs to be displayed.
     * @param { boolean= } [modal=false] Boolean value whether to show the
     * message on an overlay or on the chart. Defaults to `false`.
     * @param { boolean= } [cancelable=false] Boolean value applicable only if modal is `true`. If set to true
     * the modal can be closable on click. Defaults to `false`.
     * @param { object } [customAttrs] For styling the message text. It takes font, fontSize, color and alpha
     * as object keys.
     */
    showChartMessage: function showChartMessage(text, modal, cancelable, customAttrs) {
      var chartContainer = this,
          vars = chartContainer.jsVars,
          chart = chartContainer.apiInstance,
          chartInstance = chart.chartInstance,
          asyncRender = chartInstance.args.asyncRender,
          options = chartInstance.options,
          attrs,
          _helperFn = function _helperFn() {
        if (modal && chart && chart.config.hasRendered) {
          chart._show();
          chartContainer.showMessage(text, attrs, cancelable);
        } else {
          chart._hide();
          chart.setChartMessage(text, { _chartMessageStyle: attrs });
          chart.drawChartMessage();
        }
      };

      !customAttrs && (customAttrs = {});
      attrs = {
        'fontFamily': (0, _lib.pluck)(customAttrs.font, options.baseChartMessageFont, 'Verdana,sans'),
        'fontSize': (0, _lib.pluckNumber)(customAttrs.fontSize, options.baseChartMessageFontSize, 10),
        color: (0, _lib.pluck)(customAttrs.color && (0, _lib.convertColor)(customAttrs.color, customAttrs.alpha), options.baseChartMessageColor)
      };

      if (vars.msgStore[text]) {
        text = vars.msgStore[text];
      }

      asyncRender ? chart.addJob('showMsg', _helperFn, _lib.priorityList.postRender) : _helperFn();

      return text;
    },

    showMessage: function showMessage(msg, attrs, cancelable) {
      var chart = this.apiInstance,
          config = chart.config,
          components = chart.components,
          messageLayer,
          chartMessage = components.chartMessage || (components.chartMessage = {}),
          graphics = chartMessage.graphics || (chartMessage.graphics = {}),
          paper = components.paper,
          smartLabel = chart.linkedItems.smartLabel,
          messageText = graphics.messageText,
          messageVeil = graphics.messageVeil,
          message = graphics.message,
          w = paper.width,
          h = paper.height,
          text;

      // if (!messageLayer) {
      //   chart.graphics.messageGroup = messageLayer = paper.group('messageGroup');
      // } else {
      //   messageLayer.toFront();
      // }
      messageLayer = chart.getChildContainer('messageGroup') || chart.addChildContainer('messageGroup', paper.group('messageGroup')).toFront();

      // create the layer at the first call
      if (!messageVeil) {
        messageVeil = graphics.messageVeil = paper.rect(0, 0, w, h, messageLayer).attr({
          fill: 'rgba(0,0,0,0.2)',
          stroke: noneStr
        });
      }

      messageVeil.show().toFront().attr('cursor', cancelable ? _lib.POINTER : 'default')[cancelable ? 'click' : 'unclick'](chart._hideChartMessage, chart);

      if (!messageText) {
        messageText = graphics.messageText = paper.text(w / 2, h / 2, _lib.BLANK, messageLayer);
      }

      message && message.hide();
      msg = msg || _lib.BLANK;
      smartLabel.setStyle(attrs);

      text = smartLabel.getSmartText(msg, w - (config.marginRight || 0) - (config.marginLeft || 0), h - (config.marginTop || 0) - (config.marginBotton || 0));

      messageText.attr({
        'font-size': attrs.fontSize,
        'font-family': attrs.fontFamily,
        fill: attrs.color,
        text: text.text,
        ishot: true,
        cursor: cancelable ? _lib.POINTER : 'default',
        'line-height': 14
      })[cancelable ? 'click' : 'unclick'](chart._hideChartMessage, chart).show().toFront();
    },

    signature: function signature() {
      return 'FusionCharts/3.4.0 (XT)';
    },

    drawCrossLine: function drawCrossLine(index) {
      var iapi = this.apiInstance,
          components = iapi.components,
          dataset = components.dataset,
          manager = components['datasetGroup_' + dataset[0].type];

      manager.config.customHighlightFlag = true;
      manager.drawTrendRegion && manager.drawTrendRegion();
      manager._moveTrendRegion && manager._moveTrendRegion(index, _lib.UNDEF, false);
    }
  };

  createChart = function createChart(chartObj, container, type, notify, message, suppressDataEvents) {
    var vars = chartObj.jsVars,

    // dataComp,
    dataObj,
        instanceAPI = chartObj.apiInstance,
        hasNativeMessage = vars.hasNativeMessage,
        chartOptions = chartObj.options,
        args = chartObj.args,
        secondTimeRender = vars.secondTimeRender,
        Api,
        eiMethods,
        method,
        callback;

    type = type || chartObj.chartType();
    Api = fcGlobal.core.getDep(type, 'chart');

    if (!container.offsetWidth || !container.offsetHeight) {
      return;
    }

    // Storing the fusionCharts reference in the span element
    container.FusionCharts = fcGlobal.core.items[chartObj.id];

    args.asyncRender = (0, _lib.pluckNumber)(args.asyncRender, 1);

    callback = function callback(obj) {
      var eventArgs = {
        renderer: 'javascript'
      },
          fcObj = vars.fcObj,
          w = fcObj.width,
          h = fcObj.height,
          backEle = vars.overlayButton;

      hasNativeMessage = vars.hasNativeMessage;
      vars.container = container;
      vars.hcObj = obj;
      vars.width = container.offsetWidth;
      vars.height = container.offsetHeight;
      vars.instanceAPI = instanceAPI;

      if (obj.hasRendered) {
        // if overlaybutton was there, make it persistent.
        if (vars.overlayButtonActive && backEle) {
          backEle.innerHTML = _lib.BLANK;
          backEle.appendChild(document.createTextNode(vars.overlayButtonMessage)); // #FCXT-217
          obj.container.appendChild(backEle);
        }
      }

      // In case of percentage dimension, perform interval based tracking
      if ((/\%/g.test(w) || /\%/g.test(h)) && container && container.parentNode && !fcGlobal.core.options.preventTrackResize) {
        (0, _lib.handleContainerResize)(fcObj, container);
      }
      if (notify) {
        notify({
          success: obj.hasRendered,
          ref: container,
          id: chartObj.id
        });

        if (obj.hasRendered) {
          instanceAPI.config.hasRendered = true;

          if (chartObj.disposed === true) {
            return;
          }

          if (!hasNativeMessage) {
            fcObj.__state.firstRenderNotified = true;

            instanceAPI.addJob('postRender-fire-rendered', function () {
              /**
               * This event is fired when the chart completes drawing after { @link FusionCharts#render }
               * is called. If the data provided to the chart is appropriate, the chart would be rendered.
               * Otherwise it will show a message from the list { @link FusionCharts~chartMessages }
               * depending on the error.
               *
               * This call is made only once (even if new data is supplied to it). It can be used to
               * invoke any further JavaScript methods on the chart or change the data of chart.
               *
               * > If chart animation is enabled, this event is fired before the animation process is
               * triggered. In case you need to perform any action after animation has completed, you will
               * need to add appropriate time delay in this event handler using `setTimeout`.
               * > The default animation duration is `1000ms` (1 second). The animation duration can be
               * customized using `animationDuration` chart attribute.
               * @see FusionCharts#render
               * @see FusionCharts#hasRendered
               * @see FusionCharts#event:beforeRender
               * @see FusionCharts#event:renderComplete
               * @see FusionCharts#event:renderCancelled
               * @event FusionCharts#rendered
               */
              (0, _eventApi.triggerEvent)('rendered', fcObj, {
                renderer: 'javascript'
              }, [fcObj.id]);
            }, _lib.priorityList.postRender);
          }
        }
      }

      // Fire draw complete irrespective whether rendering was a chart or
      // a message. But do it after rendered event
      if (obj.hasRendered && vars.previousDrawCount < vars.drawCount) {
        eventArgs.width = vars.width;
        eventArgs.height = vars.height;
        eventArgs.drawCount = vars.drawCount;
        eventArgs.displayingMessage = hasNativeMessage;
        eventArgs.renderer = fcObj.options.renderer;
        /**
         * This event is fired whenever an entire redraw of the chart is caused by data update, change of chart
         * message, change of chart type or resize.
         * @event FusionCharts#drawComplete
         * @param { number } drawCount Number specifying the number of times the chart is (re)drawn.
         * @param { number } drawLatency Number specifying the draw latency.
         * @param { number } height Height of the chart object in pixels or percent.
         * @param { number } width Width of the chart object in pixels or percent.
         */
        (0, _eventApi.triggerEvent)('drawcomplete', fcObj, eventArgs, [fcObj.id]);

        if (!hasNativeMessage && !suppressDataEvents) {
          instanceAPI.addJob('postRender-fire-rendered', function () {
            if (fcObj.__state && !fcObj.__state.firstRenderNotified) {
              (0, _eventApi.triggerEvent)('rendered', fcObj, {
                renderer: 'javascript'
              }, [fcObj.id]);
            }
            /**
             * This event is fired every-time a chart is rendered either by { @link FusionCharts#render },
             * { @link FusionCharts#chartType } or { @link FusionCharts#setChartData }. So, this event
             * is fired any time `.render ()` is called on the chart or the chart data is successfully
             * updated, triggering a re-render internally.
             *
             * > This event is not fired when chart is resized.
             *
             * The difference between this event and { @link FusionCharts#event:rendered } event is that
             * { @link FusionCharts#event:rendered } is fired only when `.render ()` is called.
             *
             * `renderComplete` is not always preceded by { @link FusionCharts#event:beforeRender }. It is
             * triggered even without firing { @link FusionCharts#event:beforeRender } during data update.
             *
             * > If chart animation is enabled, this event is fired before the animation process is
             * triggered. In case you need to perform any action after  animation has completed, you will
             * need to add appropriate time delay in  this event handler using `setTimeout`.
             * > The default animation duration is `1000ms` (1 second). The animation duration can be
             * customized using `animationDuration` chart attribute.
             * @event FusionCharts#renderComplete
             * @see FusionCharts#render
             * @see FusionCharts#hasRendered
             * @see FusionCharts#event:beforeRender
             * @see FusionCharts#event:renderCancelled
             * @see FusionCharts#event:rendered
             */
            (0, _eventApi.triggerEvent)('renderComplete', fcObj, eventArgs);
          }, _lib.priorityList.postRender);
        }
      }
    };

    // If Api exists then redraw the chart after updating the configurations of each components.
    if (instanceAPI && instanceAPI.inited) {
      (0, _eventApi.triggerEvent)('internal.drawStart', chartObj, {
        chartType: type,
        logicName: instanceAPI.name,
        logicBase: instanceAPI.base && instanceAPI.base.name,
        defaultSeriesType: instanceAPI.defaultSeriesType
      });

      instanceAPI.state = 'update';

      // Get the chart JSON from the theme instance if it is defined on the chart else
      // fetch it from the transcoder.
      // dataComp = (chartObj.jsVars && chartObj.jsVars.themeObject &&
      //           chartObj.jsVars.themeObject.getThemedJSONData()) ||
      //           chartObj.getChartData(fcGlobal.dataFormats.JSON, true);
      // dataObj = dataComp.data;
      dataObj = chartObj.jsVars && chartObj.jsVars.themeObject && chartObj.jsVars.themeObject.getThemedJSONData().data || chartObj.getChartData((0, _dependencyManager.getDepsByType)('transcoder').JSON, true);
      // dataObj = chartObj.args.dataSource;

      instanceAPI.config && instanceAPI.config.hasChartMessage && instanceAPI._hideChartMessage();

      instanceAPI.jsonData = dataObj;

      if (!suppressDataEvents) {
        (0, _eventApi.triggerEvent)('dataloaded', chartObj, {}, [chartObj.id]);
      }

      // Removing any previous jobs
      instanceAPI._removeWaitingJobs();

      instanceAPI.configure(dataObj);

      // instanceAPI._feedAxesRawData();
      // // instanceAPI._setToolTipOptions ();
      // instanceAPI._setCategories();
      // @todo, this function should be called inside configure
      // componentConfigurer(instanceAPI);
      instanceAPI.syncDraw();

      if (!chartObj.hasRendered()) {
        instanceAPI.setChartEvents();
      }
      // else {
      //     // Stopping any previous animations
      //     instanceAPI.graphics.dummyObj && instanceAPI.graphics.dummyObj.stop(UNDEF, true, true);
      // }
      callback({
        hasRendered: true,
        container: container
      });
    } else if (instanceAPI && type === 'base') {
      // If the instance API exists the the type is base then just print the message
      instanceAPI.setChartMessage(message, chartObj, container);
      instanceAPI.drawChartMessage();
    } else {
      // If the previous instance API was base and now it is not base then dispose the base class.
      if (instanceAPI && instanceAPI.name === 'base' && type !== 'base') {
        instanceAPI.dispose();
        instanceAPI = _lib.UNDEF;
      }

      if (!instanceAPI) {
        // instanceAPI = chartObj.apiInstance = api ? new ChartAPI(type) : new ChartAPI('base');
        // TODO: Remove below try catch after the chart type not supported is done!
        try {
          instanceAPI = chartObj.apiInstance = new Api();
        } catch (e) {
          container.innerHTML = 'Chart type not supported';
          // eslint-disable-next-line
          console.log('Check whether chart type is added as dependency');
          return true;
        }

        instanceAPI.addToEnv('core-options', fcGlobal.core.options);
      } else {
        // If any previous message then remove it
        instanceAPI.config && instanceAPI.config.hasChartMessage && instanceAPI._hideChartMessage();
      }
      instanceAPI.chartInstance = chartObj;
      // borrow initial render-time width and height from state
      instanceAPI.origRenderWidth = chartObj.__state.renderedWidth;
      instanceAPI.origRenderHeight = chartObj.__state.renderedHeight;

      if (type !== 'base') {
        container.jsVars = chartObj.jsVars;
        eiMethods = instanceAPI.eiMethods;
        chartObj.ref = container;
        vars.type = type;
        // Add private ExternalInterface API
        (0, _lib.extend2)(container, privateAPIMethods);

        // Add Public externalInteface API
        if (eiMethods && typeof eiMethods !== 'string') {
          for (method in eiMethods) {
            container[method] = eiMethods[method];
          }
        }
        // Call render completion events.
        /**
         * The `loaded` event is raised when the chart has finished downloading itself in the client
         * environment.
         * This event indicates that the all the resources required to render the chart are ready and the
         * chart can be drawn.
         * You can use this event to hide any loader components that you might have on your page.
         * @event FusionCharts#loaded
         * @param { string } type This is the type of chart that is being rendered.
         */
        (0, _eventApi.triggerEvent)('loaded', chartObj, {
          type: type,
          renderer: 'javascript'
        }, [chartObj.id]);
      }

      if (type === 'base') {
        instanceAPI.setChartMessage(message, chartObj, container);
        instanceAPI.drawChartMessage();
      } else if (message !== _lib.UNDEF) {
        // if a JSON is already provided
        if (typeof message === 'string') {
          instanceAPI.setChartMessage(message, chartObj, container);
          instanceAPI.drawChartMessage();
          hasNativeMessage = vars.hasNativeMessage = true;
        }
      } else if (!(instanceAPI && instanceAPI.init) || instanceAPI && instanceAPI.name === 'base') {
        // check verious condition where the chart shows an message
        // chart not supported
        // Set image as chart message styling
        chartObj._chartMessageImageStyle = {
          imageHAlign: (0, _lib.pluck)(args.typeNotSupportedMessageImageHAlign, chartOptions.baseChartMessageImageHAlign).toLowerCase(),
          imageVAlign: (0, _lib.pluck)(args.typeNotSupportedMessageImageVAlign, chartOptions.baseChartMessageImageVAlign).toLowerCase(),
          imageAlpha: (0, _lib.pluckNumber)(args.typeNotSupportedMessageImageAlpha, chartOptions.baseChartMessageImageAlpha),
          imageScale: (0, _lib.pluckNumber)(args.typeNotSupportedMessageImageScale, chartOptions.baseChartMessageImageScale)
        };
        chartObj._chartMessageStyle = {
          color: args.typeNotSupportedMessageColor || chartOptions.baseChartMessageColor,
          fontFamily: args.typeNotSupportedMessageFont || chartOptions.baseChartMessageFont,
          fontSize: args.typeNotSupportedMessageFontSize || chartOptions.baseChartMessageFontSize
        };
        instanceAPI.setChartMessage(chartOptions.typeNotSupportedMessage, chartObj, container);
        instanceAPI.drawChartMessage();
        hasNativeMessage = vars.hasNativeMessage = true;
      } else if (vars.message) {
        // if chart has any msg to show
        instanceAPI.setChartMessage(vars.message, chartObj, container);
        instanceAPI.drawChartMessage();
        hasNativeMessage = vars.hasNativeMessage = true;
      } else if (vars.loadError) {
        // if chart has data loading error
        // Set image as chart message styling
        chartObj._chartMessageImageStyle = {
          imageHAlign: (0, _lib.pluck)(args.dataLoadErrorMessageImageHAlign, chartOptions.baseChartMessageImageHAlign).toLowerCase(),
          imageVAlign: (0, _lib.pluck)(args.dataLoadErrorMessageImageVAlign, chartOptions.baseChartMessageImageVAlign).toLowerCase(),
          imageAlpha: (0, _lib.pluckNumber)(args.dataLoadErrorMessageImageAlpha, chartOptions.baseChartMessageImageAlpha),
          imageScale: (0, _lib.pluckNumber)(args.dataLoadErrorMessageImageScale, chartOptions.baseChartMessageImageScale)
        };
        chartObj._chartMessageStyle = {
          color: args.dataLoadErrorMessageColor || chartOptions.baseChartMessageColor,
          fontFamily: args.dataLoadErrorMessageFont || chartOptions.baseChartMessageFont,
          fontSize: args.dataLoadErrorMessageFontSize || chartOptions.baseChartMessageFontSize
        };
        instanceAPI.setChartMessage(chartOptions.dataLoadErrorMessage, chartObj, container);
        instanceAPI.drawChartMessage();
        hasNativeMessage = vars.hasNativeMessage = true;
      } else if (vars.stallLoad) {
        // //if chart is retriving data
        // Set image as chart message styling
        chartObj._chartMessageImageStyle = {
          imageHAlign: (0, _lib.pluck)(args.dataLoadStartMessageImageHAlign, chartOptions.baseChartMessageImageHAlign).toLowerCase(),
          imageVAlign: (0, _lib.pluck)(args.dataLoadStartMessageImageVAlign, chartOptions.baseChartMessageImageVAlign).toLowerCase(),
          imageAlpha: (0, _lib.pluckNumber)(args.dataLoadStartMessageImageAlpha, chartOptions.baseChartMessageImageAlpha),
          imageScale: (0, _lib.pluckNumber)(args.dataLoadStartMessageImageScale, chartOptions.baseChartMessageImageScale)
        };
        chartObj._chartMessageStyle = {
          fontFamily: args.dataLoadStartMessageFont || chartOptions.baseChartMessageFont,
          fontSize: args.dataLoadStartMessageFontSize || chartOptions.baseChartMessageFontSize,
          color: args.dataLoadStartMessageColor || chartOptions.baseChartMessageColor
        };
        instanceAPI.setChartMessage(chartOptions.dataLoadStartMessage, chartObj, container);
        instanceAPI.drawChartMessage();
        hasNativeMessage = vars.hasNativeMessage = true;
        callback({
          hasRendered: true,
          container: container
        });
      } else if (type === 'zoomscatter' && !document.createElement('canvas').getContext) {
        // Set image as chart message styling
        chartObj._chartMessageImageStyle = {
          imageHAlign: (0, _lib.pluck)(args.browserNotSupportedMessageImageHAlign, chartOptions.baseChartMessageImageHAlign).toLowerCase(),
          imageVAlign: (0, _lib.pluck)(args.browserNotSupportedMessageImageVAlign, chartOptions.baseChartMessageImageVAlign).toLowerCase(),
          imageAlpha: (0, _lib.pluckNumber)(args.browserNotSupportedMessageImageAlpha, chartOptions.baseChartMessageImageAlpha),
          imageScale: (0, _lib.pluckNumber)(args.browserNotSupportedMessageImageScale, chartOptions.baseChartMessageImageScale)
        };
        chartObj._chartMessageStyle = {
          color: args.browserNotSupportedMessageColor || chartOptions.baseChartMessageColor,
          fontFamily: args.browserNotSupportedMessageFont || chartOptions.baseChartMessageFont,
          fontSize: args.browserNotSupportedMessageFontSize || chartOptions.baseChartMessageFontSize
        };
        // if the browser is not supported, show a messege
        instanceAPI.setChartMessage((0, _lib.pluck)(args.browserNotSupportedMessage, chartOptions.browserNotSupportedMessage), chartObj, container);
        instanceAPI.drawChartMessage();
        hasNativeMessage = vars.hasNativeMessage = true;
      } else {
        /**
         * @private
         * @event FusionCharts#internal.drawStart
         */
        (0, _eventApi.triggerEvent)('internal.drawStart', chartObj, {
          chartType: type,
          logicName: instanceAPI.name,
          logicBase: instanceAPI.base && instanceAPI.base.name,
          defaultSeriesType: instanceAPI.defaultSeriesType
        });

        // Get the chart JSON from the theme instance if it is defined on the chart else
        // fetch it from the transcoder.
        // TODO: Revisit. Usage of transcoder methods removed.
        // dataComp = (chartObj.jsVars && chartObj.jsVars.themeObject &&
        //             chartObj.jsVars.themeObject.getThemedJSONData()) ||
        //             chartObj.getChartData(fcGlobal.dataFormats.JSON, true);
        dataObj = chartObj.jsVars && chartObj.jsVars.themeObject && chartObj.jsVars.themeObject.getThemedJSONData().data || chartObj.getChartData((0, _dependencyManager.getDepsByType)('transcoder').JSON, true);
        // dataObj = chartObj.args.dataSource;

        instanceAPI.state = 'initial';
        // if chart will show data parse error
        // if (dataComp.error instanceof Error) {
        //   // Set image as chart message styling
        //   chartObj._chartMessageImageStyle = {
        //     imageHAlign: pluck(args.dataInvalidMessageImageHAlign,
        //                         chartOptions.baseChartMessageImageHAlign).toLowerCase(),
        //     imageVAlign: pluck(args.dataInvalidMessageImageVAlign,
        //                         chartOptions.baseChartMessageImageVAlign).toLowerCase(),
        //     imageAlpha: pluckNumber(args.dataInvalidMessageImageAlpha,
        //                     chartOptions.baseChartMessageImageAlpha),
        //     imageScale: pluckNumber(args.dataInvalidMessageImageScale,
        //                     chartOptions.baseChartMessageImageScale)
        //   };
        //   chartObj._chartMessageStyle = {
        //     fontFamily: args.dataInvalidMessageFont || chartOptions.baseChartMessageFont,
        //     fontSize: args.dataInvalidMessageFontSize || chartOptions.baseChartMessageFontSize,
        //     color: args.dataInvalidMessageColor || chartOptions.baseChartMessageColor
        //   };
        //   instanceAPI.setChartMessage(chartOptions.dataInvalidMessage, chartObj, container);
        //   instanceAPI.drawChartMessage();
        //   hasNativeMessage = vars.hasNativeMessage = true;
        //   // set the data-ready flag to false.
        //   chartObj.__state.dataReady = false;
        //   if (!suppressDataEvents) {
        //     /**
        //      * When a chart attempts to render, it fetches data that has been set on it. In case no data was
        //      * provided prior to rendering, or in case the data provided had errors in parsing or fetching
        //      * from server, this event is raised.
        //      *
        //      * Maps, realtime charts and some gauges do not require initial data to begin with. Those charts
        //      * will not raise this event if no data was set.
        //      * @event FusionCharts#dataInvalid
        //      *
        //      * @param { Error } error - The error that caused the rendering to stop.
        //      * @since 3.4.0
        //      */
        //     triggerEvent('dataInvalid', vars.fcObj, {
        //       error: dataComp.error
        //     }, UNDEF, function () {
        //       /**
        //        * DataXMLInvalid is fired if the data passed either by url or string to the chart object is
        //        * not in an usable format.
        //        * @event FusionCharts#dataXMLInvalid
        //        * @deprecated Since 3.4. Use alternative 'dataInvalid' event.
        //        */
        //       triggerEvent('dataxmlinvalid', chartObj, { }, [chartObj.id]);
        //     });
        //   }
        // } else {
        // convert the chart's JSON into HC compatable data
        if (!suppressDataEvents) {
          /**
           * Before a chart is rendered, the data needs to be loaded to plot the data on the chart.
           * `DataLoaded` event is fired after the data passed either by url or string is loaded to the
           * chart object. This event assures that the data passed is valid and the chart can
           * now be rendered.
           * It can be used to further process data in any other components in your page.
           * @event FusionCharts#dataLoaded
           */
          (0, _eventApi.triggerEvent)('dataloaded', chartObj, {}, [chartObj.id]);
        }

        if (instanceAPI.chartInstance.disposed === true) {
          return;
        }
        // Always show chart message if async render is on
        if (args.asyncRender && !secondTimeRender && type !== 'base') {
          instanceAPI.setChartMessage(instanceAPI.chartInstance.options.loadMessage, _lib.UNDEF, container);
          instanceAPI.drawChartMessage();
          instanceAPI.config.hasChartMessage = false;
        }

        instanceAPI.init(container, dataObj, chartObj, callback);
        // }
      }
    }
    vars.secondTimeRender = true;
  };

  /**
   * Function to check charts that are pending render process and are marked
   * as error in loading.
   */
  function probeLoadErrorMessage(key) {
    var item,
        vars,
        type,
        typeComposite,
        modules,
        terminalModule,
        affectedModules = {},
        module;

    key = (0, _rendererLib.getMetaSentence)(key);

    for (item in fcGlobal.core.items) {
      item = fcGlobal.core.items[item];
      type = item.chartType();
      typeComposite = item.options.chartTypeSourcePath + type;
      vars = item.jsVars;

      if (vars && vars.waitingModule && item.__state.rendering && (0, _rendererLib.needsModule)(key.predicate, typeComposite)) {
        // ^ will it be typecomposite or predicate
        vars.waitingModuleError = true;
        modules = (0, _rendererLib.getDependentFileName)(typeComposite).concat(vars.userModules);
        if (modules.length) {
          terminalModule = modules[modules.length - 1];
          affectedModules[terminalModule] = _rendererLib.moduleCmdQueue[terminalModule];
        }
      }
    }

    // Execute all the waiting queues that are affected due to lack of one
    // module.
    for (module in affectedModules) {
      fcGlobal.executeWaitingCommands(affectedModules[module]);
    }

    // raise a global event
    (0, _eventApi.raiseError)(fcGlobal.core, '11171116151', 'run', 'HC-interface~renderer.load', 'Unable to load required modules and resources: ' + key.key);
  }

  /**
   * Function to display chart not supported message
   */
  function showUnsupportedChartMessage(chartObj, container, callback) {
    var args = chartObj.args,
        options = chartObj.options;

    // Set image as chart message styling
    chartObj._chartMessageImageStyle = {
      imageHAlign: args.typeNotSupportedMessageImageHAlign || options.baseChartMessageImageHAlign,
      imageVAlign: args.typeNotSupportedMessageImageVAlign || options.baseChartMessageImageVAlign,
      imageAlpha: args.typeNotSupportedMessageImageAlpha || options.baseChartMessageImageAlpha,
      imageScale: args.typeNotSupportedMessageImageScale || options.baseChartMessageImageScale
    };

    // Set chart message styling for chart type not supported
    chartObj._chartMessageStyle = {
      color: args.typeNotSupportedMessageColor || options.baseChartMessageColor,
      fontFamily: args.typeNotSupportedMessageFont || options.baseChartMessageFont,
      fontSize: args.typeNotSupportedMessageFontSize || options.baseChartMessageFontSize
    };
    createChart(chartObj, container, 'base', callback, options.typeNotSupportedMessage);
  }

  /**
   * List of chart types for individual modules with corresponding load order
   * for the resource.
   * This is the default chart types under the "charts" group.
   *
   * @type object
   */
  _rendererLib.moduleDependencies.charts = (0, _lib.extend2)(_rendererLib.moduleDependencies.charts || {}, {
    column2d: 0,
    column3d: 0,
    bar2d: 0,
    bar3d: 0,
    pie2d: 0,
    pie3d: 0,
    line: 0,
    area2d: 0,
    doughnut2d: 0,
    doughnut3d: 0,
    pareto2d: 0,
    pareto3d: 0,
    mscolumn2d: 0,
    mscolumn3d: 0,
    msline: 0,
    msarea: 0,
    msbar2d: 0,
    msbar3d: 0,
    stackedcolumn2d: 0,
    marimekko: 0,
    stackedcolumn3d: 0,
    stackedarea2d: 0,
    stackedcolumn2dline: 0,
    stackedcolumn3dline: 0,
    stackedbar2d: 0,
    stackedbar3d: 0,
    msstackedcolumn2d: 0,
    mscombi2d: 0,
    mscombi3d: 0,
    mscolumnline3d: 0,
    mscombidy2d: 0,
    mscolumn3dlinedy: 0,
    stackedcolumn3dlinedy: 0,
    msstackedcolumn2dlinedy: 0,
    scatter: 0,
    bubble: 0,
    ssgrid: 0,
    scrollcolumn2d: 0,
    scrollcolumn3d: 0,
    scrollline2d: 0,
    scrollarea2d: 0,
    scrollstackedcolumn2d: 0,
    scrollcombi2d: 0,
    scrollcombidy2d: 0,
    zoomline: 0,
    zoomlinedy: 0,
    zoomscatter: 0
  });

  /**
   * List of chart types for individual modules with corresponding load order
   * for the resource.
   * This is the default chart types under the "powercharts" group.
   *
   * @type object
   */
  _rendererLib.moduleDependencies.powercharts = (0, _lib.extend2)(_rendererLib.moduleDependencies.powercharts || {}, {
    spline: 0,
    splinearea: 0,
    msspline: 0,
    mssplinearea: 0,
    mssplinedy: 0,
    multiaxisline: 0,
    multilevelpie: 0,
    waterfall2d: 0,
    msstepline: 0,
    inversemsline: 0,
    inversemscolumn2d: 0,
    inversemsarea: 0,
    errorbar2d: 0,
    errorscatter: 0,
    errorline: 0,
    logmsline: 0,
    logmscolumn2d: 0,
    logstackedcolumn2d: 0,
    radar: 0,
    dragnode: 0,
    candlestick: 0,
    selectscatter: 0,
    dragcolumn2d: 0,
    dragline: 0,
    dragarea: 0,
    boxandwhisker2d: 0,
    kagi: 0,
    heatmap: 0,
    treemap: 0
  });

  /**
   * List of chart types for individual modules with corresponding load order
   * for the resource.
   * This is the default chart types under the "widgets" group.
   *
   * @type object
   */
  _rendererLib.moduleDependencies.widgets = (0, _lib.extend2)(_rendererLib.moduleDependencies.widgets || {}, {
    angulargauge: 0,
    bulb: 0,
    cylinder: 0,
    drawingpad: 0,
    funnel: 0,
    hbullet: 0,
    hled: 0,
    hlineargauge: 0,
    vlineargauge: 0,
    pyramid: 0,
    realtimearea: 0,
    realtimecolumn: 0,
    realtimeline: 0,
    realtimelinedy: 0,
    realtimestackedarea: 0,
    realtimestackedcolumn: 0,
    sparkcolumn: 0,
    sparkline: 0,
    sparkwinloss: 0,
    thermometer: 0,
    vbullet: 0,
    gantt: 0,
    vled: 0
  });

  /**
   * List of chart types for individual modules with corresponding load order
   * for the resource.
   * This is the default chart types under the "maps" group.
   *
   * @type object
   */
  _rendererLib.moduleDependencies.maps = (0, _lib.extend2)(_rendererLib.moduleDependencies.maps || {}, {});

  (0, _lib.extend2)(renderer, {
    render: function render(container, callback) {
      /* algorithm:
       * 1. If JS Renderer is not ready then queue the chart.
       * 2. Prepare the chart DOM element
       * 3. Send the chart for rendering if JS Renderer is ready
       */
      var chartObj = this,
          chartType = chartObj.chartType(),
          typeComposite = chartObj.options.chartTypeSourcePath + chartType,
          vars = chartObj.jsVars,
          state = chartObj.__state,
          options = chartObj.options,
          args = chartObj.args,
          showChartLoadingMessage = chartObj.options.showChartLoadingMessage,
          lastRenderedChart,
          loadMessage,
          objModuleNames,
          terminalModule,
          cmdQueue,
          eiMethod;

      // vars.userModules has been validated from renderer's
      // BeforeInitialize event and is also part of policy
      objModuleNames = (0, _rendererLib.getDependentFileName)(typeComposite).concat(vars.userModules);

      // If chart is resizing... prevent it.
      vars.isResizing && (vars.isResizing = clearTimeout(vars.isResizing));

      // Destroy old chart if needed during update.
      vars.hcObj && vars.hcObj.destroy && vars.hcObj.destroy();

      if (!fcGlobal.core.getDep(chartType, 'chart')) {
        // check presence of API
        // Set command queue based on stock modules or dynamic modules
        // In case of blank chart-type, we should not attempt loading
        // module.
        if (chartType && (0, _rendererLib.hasFileLoaded)(objModuleNames)) {
          // Try loading the filename and see if that works!
          if (!vars.drLoadAttempted) {
            // Add a commandqueue and corresponding dummy dynamic
            // dependency definition for this chart.
            if ((0, _rendererLib.injectModuleDependency)(typeComposite, fcGlobal.core.options)) {
              // since injection took place for first time, we
              // need to correct the present dependency list.
              objModuleNames = (0, _rendererLib.getDependentFileName)(typeComposite).concat(vars.userModules);
            }

            vars.drLoadAttempted = true;
          } else {
            // If chart api is absent but all modules are present, we
            // assume charts are not supported, provided a dynamic load
            // has been attempted.
            (0, _eventApi.raiseError)(chartObj, 11112822001, 'run', 'HC-interface~renderer.render', 'Chart runtimes not loaded even when resource is present');
            showUnsupportedChartMessage(chartObj, container, callback);
            return;
          }
        } else if (!objModuleNames.length) {
          // Check whether this is a valid chart type as per static
          // dependency list (this block will be executed when dynamic
          // resource load is not attempted)
          showUnsupportedChartMessage(chartObj, container, callback);
          return;
        } else if (vars.waitingModuleError) {
          showUnsupportedChartMessage(chartObj, container, callback);
          // If error is displayed wrt module absence, clear all
          // flags wrt module load wait. This is done so that next
          // re-render tries to execute the same load algo.
          delete vars.waitingModule;
          delete vars.waitingModuleError;
          return;
        }

        terminalModule = objModuleNames[objModuleNames.length - 1].replace(/.js?$/, '');

        // Pushing dependancy of build files from custom build
        if (fcGlobal.core.getDep('dependency') && !_rendererLib.moduleCmdQueue[terminalModule]) {
          _rendererLib.moduleCmdQueue[terminalModule] = [];
        }

        // Get reference to the command queue for the terminal module.
        cmdQueue = _rendererLib.moduleCmdQueue[terminalModule];

        if (cmdQueue) {
          cmdQueue.push({
            cmd: 'render',
            obj: chartObj,
            args: arguments
          });
        } else {
          // In case a reference to the command queue has not been found,
          // raise an error.
          (0, _eventApi.raiseError)(chartObj, 12080515551, 'run', 'HC-interface~renderer.render', 'Unregistered module in dependentModule definition.');

          // Set image as chart message styling
          chartObj._chartMessageImageStyle = {
            imageHAlign: args.renderErrorMessageImageHAlign || options.baseChartMessageImageHAlign,
            imageVAlign: args.renderErrorMessageImageVAlign || options.baseChartMessageImageVAlign,
            imageAlpha: args.renderErrorMessageImageAlpha || options.baseChartMessageImageAlpha,
            imageScale: args.renderErrorMessageImageScale || options.baseChartMessageImageScale
          };
          // Set chart message styling for render error message
          chartObj._chartMessageStyle = {
            color: args.renderErrorMessageColor || options.baseChartMessageColor,
            fontFamily: args.renderErrorMessageFont || options.baseChartMessageFont,
            fontSize: args.renderErrorMessageFontSize || options.baseChartMessageFontSize
          };
          createChart(chartObj, container, 'base', _lib.UNDEF, options.renderErrorMessage);
          return;
        }

        if (!vars.waitingModule) {
          // Get chart loading message
          loadMessage = showChartLoadingMessage ? options.PBarLoadingText || options.loadMessage : '';

          // Set image as chart message styling
          chartObj._chartMessageImageStyle = {
            imageHAlign: args.loadMessageImageHAlign || options.baseChartMessageImageHAlign,
            imageVAlign: args.loadMessageImageVAlign || options.baseChartMessageImageVAlign,
            imageAlpha: args.loadMessageImageAlpha || options.baseChartMessageImageAlpha,
            imageScale: args.loadMessageImageScale || options.baseChartMessageImageScale
          };

          // Set chart message styling for loading message
          chartObj._chartMessageStyle = {
            color: args.loadMessageColor || options.baseChartMessageColor,
            fontFamily: args.loadMessageFont || options.baseChartMessageFont,
            fontSize: args.loadMessageFontSize || options.baseChartMessageFontSize
          };
          // Show loading message if not already shown
          createChart(chartObj, container, 'base', _lib.UNDEF, loadMessage);
          renderer.load.call(chartObj, container, callback);
        }
        return;
      }

      // Need to delete earlier eiMethods.
      if (fcGlobal.core.getDep(state.lastRenderedType, 'chart') && state.lastRenderedType !== chartType) {
        /**
         * This event is fired when a change in chart type is triggered by calling
         * {@link FusionCharts#chartType} on a chart. The event is raised only when the chart type has been
         * explicitly changed from what was set earlier.
         *
         * This event is *not* fired when:
         *
         *  - A chart is rendered using {@link FusionCharts.render}.
         *  - A chart type is set for the first time on a chart, even using {@link FusionCharts#chartType}. For
         * example, if no `type` option is provided to the FusionCharts constructor when creating the chart, and
         * later on {@link FusionCharts#chartType} is called on that chart instance for the first time, this
         * event is not triggered.
         *  - If the chart type parameter sent to {@link FusionCharts#chartType} is the same as the current
         * chart type.
         *  - If the new chart type provided is invalid.
         *
         * @see FusionCharts#chartType
         *
         * @event FusionCharts#chartTypeChanged
         * @group chart
         *
         * @param {string} previousType - The previously assigned chart type of the chart.
         * @param {string} newType - The new chart type that has been set on the chart.
         */
        (0, _eventApi.triggerEvent)('chartTypeChanged', chartObj, {
          previousType: state.lastRenderedType,
          newType: chartType
        });

        lastRenderedChart = fcGlobal.core.getDep(state.lastRenderedType, 'chart');
        if (lastRenderedChart) {
          for (eiMethod in lastRenderedChart) {
            delete chartObj[eiMethod];
          }
        }
      }
      // Updated last-rendererd type to current type.
      state.lastRenderedType = chartType;

      // Store a copy of the currently rendered src value for later
      // use while comparing during update.
      state.lastRenderedSrc = chartObj.src;

      /**
       * Fired when all modules for a chart is available.
       *
       * Internal Note: This should be the actual location of firing the loaded method with its true meaning. The
       * current flash mimic loaded event needs to be phased out.
       * @private
       *
       * @event FusionCharts#internal.loaded
       * @param {string} type This is the type of chart that is being rendered.
       */
      !vars.waitingModuleError && (0, _eventApi.triggerEvent)('internal.loaded', chartObj, {
        type: chartType,
        triggeredModuleLoad: vars.drLoadAttempted || vars.waitingModule
      }, [chartObj.id]);

      delete vars.waitingModule;
      delete vars.waitingModuleError;
      delete vars.drLoadAttempted; // remove flag for next.

      // Call renderer to generate FusionCharts.
      createChart(chartObj, container, chartType, callback);
    },

    update: function update(param) {
      var chartObj = this,
          chart = chartObj.ref,
          vars = chartObj.jsVars,
          notify,

      /* RED-1754: When we invoke drill down on the same entity twice on any
       *           FusionMaps, the container is not found on the jsVars object.
       *           This fix fetched the container from a diff object.
       */
      fcObj = vars && vars.fcObj,
          container = vars.container || fcObj && fcObj.options && fcObj.options.containerElement && fcObj.options.containerElement.childNodes[0];

      // Destroy old chart if needed during update.
      vars.hcObj && vars.hcObj.destroy && vars.hcObj.destroy();

      chartObj.args.dataSource = param.dataSource;

      if (vars.isResizing) {
        vars.isResizing = clearTimeout(vars.isResizing);
      }

      // Check whether there was an error or not.
      if (param.error === _lib.UNDEF) {
        delete vars.stallLoad;
        delete vars.loadError;
        // Setting the 1st time rendering flag to true if not set if setJSON is called just after render
        if (!chartObj.__state.firstRenderNotified && chartObj.jsVars.secondTimeRender) {
          chartObj.__state.firstRenderNotified = true;
          notify = fcGlobal.renderer.notifyRender;
        }
        // Call ExternalInterface method and update the data
        if (this.isActive()) {
          if (chartObj.src !== chartObj.__state.lastRenderedSrc) {
            chartObj.render();
          } else {
            // Call renderer to generate FusionCharts.
            createChart(chartObj, container, _lib.UNDEF, notify);
          }
        } else if (chartObj.__state.rendering && !vars.waitingModule) {
          createChart(chartObj, container, _lib.UNDEF, notify);
        }
      } else {
        // Show error message.
        // Call ExternalInterface method to show message
        if (this.isActive() && typeof chart.showChartMessage === 'function') {
          chart.showChartMessage('InvalidXMLText');
        }
        delete vars.loadError;
      }
    },

    resize: function resize(size) {
      var container = this.ref,
          cssSize,
          vars = this.jsVars;

      // Set the sizes of the DOM elements for the resize and fire related
      // commands needed for resize.
      if (!(container && container.resize)) {
        return;
      }

      if (vars.isResizing) {
        // need to be cleared on other interface fns
        vars.isResizing = clearTimeout(vars.isResizing);
      }

      // resize chart async so that consecutive resizes can be blocked
      vars.isResizing = setTimeout(function () {
        cssSize = fcGlobal.normalizeCSSDimension(size.width, size.height, container);
        if (size.width !== _lib.UNDEF) {
          container.style.width = cssSize.width;
        }
        if (size.height !== _lib.UNDEF) {
          container.style.height = cssSize.height;
        }

        container.resize();
        delete vars.isResizing;
      }, 0);
    },

    dispose: function dispose() {
      var chartObj = this,
          container,
          vars = chartObj.jsVars;

      if (vars.isResizing) {
        vars.isResizing = clearTimeout(vars.isResizing);
      }

      // do chartAPI instance cleanup
      if (chartObj.apiInstance) {
        chartObj.apiInstance.remove({ instant: true });
        delete chartObj.apiInstance;
        delete vars.instanceAPI;
      }

      // Proceed with disposal only when the HTML element exists.
      if (container = chartObj.ref) {
        fcGlobal.purgeDOM(container);
        // Delete DOM element
        if (container.parentNode) {
          container.parentNode.removeChild(container);
        }
      }
      vars.container = null;
      // On dispose remove any waiting commands.
      (0, _rendererLib.cleanupWaitingCommands)(chartObj);
    },

    load: function load(_container, _callback) {
      var chart = this,
          vars = chart.jsVars,
          type = chart.chartType(),
          api = fcGlobal.core.getDep(type, 'chart'),

      // merge with user modules while loading dependencies
      modules = (0, _rendererLib.getDependentFileName)(type).concat(vars.userModules),
          terminalModule = modules[modules.length - 1].replace(/.js?$/, '');

      if (api || !modules || modules && modules.length === 0) {
        delete vars.waitingModule;
        _container && showUnsupportedChartMessage(chart, _container || chart.ref, _callback);
        return;
      }

      // Request load of the specific chart module
      if (!vars.waitingModule) {
        // Mark the object that it is waiting for module load.
        vars.waitingModule = true;
        delete vars.waitingModuleError;

        (0, _rendererLib.loadModule)(modules, function () {
          delete vars.waitingModule;
          fcGlobal.executeWaitingCommands(_rendererLib.moduleCmdQueue[terminalModule]);
        }, probeLoadErrorMessage);
        // Above: Since this may not be the terminal module for all
        // charts, we need to check and raise error on all modules.
      }
    }
  });
}

exports['default'] = rendererInterface;

/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.normalizeCSSDimension = exports.executeWaitingCommands = undefined;

var _iterator = __webpack_require__(9);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(10);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2['default'] === "function" && typeof _iterator2['default'] === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2['default'] === "function" && obj.constructor === _symbol2['default'] && obj !== _symbol2['default'].prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                                                                                         * Renderer Abstraction Framework
                                                                                                                                                                                                                                                                                                                                         * This module allows developers to abstract the entire rendering engine. This helps in multiple
                                                                                                                                                                                                                                                                                                                                         * implementations of FusionCharts in various technologies such as flash, HTML5, etc.
                                                                                                                                                                                                                                                                                                                                         * @private
                                                                                                                                                                                                                                                                                                                                         *
                                                                                                                                                                                                                                                                                                                                         * @module fusioncharts.renderer
                                                                                                                                                                                                                                                                                                                                         * @requires fusioncharts.events
                                                                                                                                                                                                                                                                                                                                         * @requires fusioncharts.runtime
                                                                                                                                                                                                                                                                                                                                         * @requires fusioncharts.managedprint
                                                                                                                                                                                                                                                                                                                                         */


var _lib = __webpack_require__(5);

var _smartlabel = __webpack_require__(319);

var _smartlabel2 = _interopRequireDefault(_smartlabel);

var _eventApi = __webpack_require__(7);

var _rendererLib = __webpack_require__(126);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

// import {fcGlobal} from '../../core/constructor/constructor';

var UNDEF = void 0,
    jsRenderer = function jsRenderer() {
  // jsRenderer constructor
},

/**
 * Execute renderer interface commands that are queued due to renderer
 * not being ready.
 */
executeWaitingCommands = function executeWaitingCommands(queue) {
  if (!queue) {
    return;
  }
  var item;

  // Iterate through all FusionCharts objects
  while (item = queue.shift()) {
    // Now we execute 'command' on all charts that are waiting
    // for the renderer to get ready.
    if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object') {
      jsRenderer[item.cmd].apply(item.obj, item.args);
    }
  }
},


// Function to normalize dimension for style setting
normalizeCSSDimension = function normalizeCSSDimension(width, height, container) {
  // optimize dimensions
  var w = width === UNDEF ? container.offsetWidth || parseFloat(container.style.width) : width,
      h = height === UNDEF ? container.offsetHeight || parseFloat(container.style.height) : height,
      o = {},
      s = container.style,
      p;

  // Do initial testing by setting dimensions
  s.width = w = w.toString ? w.toString() : '0';
  s.height = h = h.toString ? h.toString() : '0';

  if ((o.widthIsRelative = w.match(/^\s*\d*\.?\d*\%\s*$/) && !w.match(/^\s*0\%\s*$/)) && container.offsetWidth === 0) {
    p = container;
    while (p = p.offsetParent) {
      if (p.offsetWidth > 0) {
        w = (p.offsetWidth * parseFloat(w.match(/\d*/)[0]) / 100).toString();
        break;
      }
    }
  }

  if ((o.heightIsRelative = h.match(/^\s*\d*\.?\d*\%\s*$/) && !h.match(/^\s*0\%\s*$/)) && container.offsetHeight <= 20) {
    p = container;
    while (p = p.offsetParent) {
      if (p.offsetHeight > 0) {
        h = (p.offsetHeight * parseFloat(h.match(/\d*/)[0]) / 100).toString();
        break;
      }
    }
  }

  o.width = w.replace ? w.replace(/^\s*(\d*\.?\d*)\s*$/ig, '$1px') : w;
  o.height = h.replace ? h.replace(/^\s*(\d*\.?\d*)\s*$/ig, '$1px') : h;

  // Finally apply the dimensions
  s.width = o.width;
  s.height = o.height;

  o.pixelWidth = o.widthIsRelative ? container.offsetWidth : parseInt(o.width, 10) || 0;
  o.pixelHeight = o.heightIsRelative ? container.offsetHeight : parseInt(o.height, 10) || 0;

  return o;
};

function javascriptRenderer(fcGlobal) {
  var func = 'function',
      win = window,
      doc = document,
      FusionChartsDOMInsertModes = void 0,
      renderers = {
    'undefined': {
      render: notDefined,
      remove: notDefined,
      update: notDefined,
      resize: notDefined,
      config: notDefined,
      policies: {}
    },
    'javascript': jsRenderer
  },
      store = {},
      // store which chart has what renderer
  lengthCleanupRegex = /[^\%\d]*$/ig,

  // Checks the container visibility in the page
  isHidden = function isHidden() {
    var DISPLAY = 'display',
        NONE = 'none',
        getStyle = function getStyle(el, style) {
      if (win.getComputedStyle) {
        style = win.getComputedStyle(el)[style];
      } else if (el.currentStyle) {
        style = el.currentStyle[style];
      }
      return style;
    },
        hidden = function hidden(el) {
      var parentEl = el.parentNode;

      if (parentEl.nodeType === 9) {
        return false;
      }
      if (getStyle(el, DISPLAY) === NONE) {
        return true;
      }
      if (parentEl) {
        return hidden(parentEl);
      }
      return false;
    };

    return hidden;
  }(),

  // Checks the container visibility every 300 ms time interval only if the container is hidden.
  // As soon as the container gets visible this calls the actual render function with all
  // required parameters
  handleContainerVisibility = function () {
    var store = {},
        fcGlobal = this,
        intervalId,
        trackVisibility = function trackVisibility() {
      var count = 0,
          INTERVALMS = parseInt(fcGlobal.core.options.visibilityTrackingInterval, 10) || 300,
          item,
          itemObj,
          container,
          insertMode,
          callback;

      for (item in store) {
        count += 1;
        itemObj = store[item].chart;
        container = store[item].container;
        insertMode = store[item].insertMode;
        callback = store[item].callback;

        if (itemObj.disposed || !isHidden(container)) {
          delete store[item];
          count -= 1;
          !itemObj.disposed && itemObj.renderChart(container, insertMode, callback);
        }
      }

      if (!count) {
        intervalId = clearTimeout(intervalId);
      } else {
        intervalId = setTimeout(trackVisibility, INTERVALMS);
      }
    };

    return function (sender, container, insertMode, callback) {
      store[sender.id] = {
        chart: sender,
        container: container,
        insertMode: insertMode,
        callback: callback
      };

      if (!intervalId) {
        intervalId = setTimeout(trackVisibility, parseInt(fcGlobal.core.options.visibilityTrackingInterval, 10) || 300);
      }
    };
  }(),

  // API to add renderer and also to set/get the current renderer.
  renderer = void 0,
      UNDEF = void 0,
      ChartMessage = function () {
    var api = function api() {
      // constructor function for ChartMessage
    };
    /**
     * @name FusionCharts~chartStatusMessages
     * @enum
     * @type {string}
     */
    api.prototype = {
      'LoadDataErrorText': 'Error in loading data.',
      'XMLLoadingText': 'Retrieving data. Please wait',
      'InvalidXMLText': 'Invalid data.',
      'ChartNoDataText': 'No data to display.',
      'ReadingDataText': 'Reading data. Please wait',
      'ChartNotSupported': 'Chart type not supported.',
      'PBarLoadingText': '',
      'LoadingText': 'Loading chart. Please wait',
      'RenderChartErrorText': 'Unable to render chart.'
    };
    return api.prototype.constructor = api;
  }(),
      LOADER_CSS_TEXT = 'display: inline-block; *zoom:1; *display:inline; width: 100%; ' + 'font-family: Verdana,sans; font-size: 10px; color: #666666; text-align: center;';

  function clearStateEventHandler(event) {
    delete event.sender.jsVars._reflowData;
    event.sender.jsVars._reflowData = {};
    // delete reflowclean
    delete event.sender.jsVars._reflowClean;
  }

  function showLoadingMessage(chart, container) {
    var vars = chart.jsVars ? chart.jsVars : {},
        msgs = vars.msgStore;

    if (container && chart.options.showChartLoadingMessage) {
      // Show loading message as HTML block since HTML5 renderer is not
      // loaded yet.
      container.innerHTML = '<small style="' + LOADER_CSS_TEXT + ' padding-top: ' + (parseInt(container.style.height, 10) / 2 - 5) + 'px">' + (msgs.PBarLoadingText || msgs.LoadingText) + '</small>';

      // Set the container's background color only when transparent mode is not set.
      container.style.backgroundColor = (0, _lib.getContainerBackgroundColor)(chart);
    }
  }

  /**
   * Gets the HTML of SWF
   * @deprecated 3.4.0 - This has been deprecated since JavaScript variant is the only renderer supported.
   * @group others
   */
  jsRenderer.prototype.getSWFHTML = function () {
    (0, _eventApi.raiseWarning)(this, '11090611381', 'run', 'JavaScriptRenderer~getSWFHTML()', 'getSWFHTML() is not supported for JavaScript charts.');
  };

  /**
   * Adds variable to Flash chart. Equivalent to {@link FusionCharts#configure} for JavaScript charts
   * @deprecated 3.4.0 - Use the alternate function {@link FusionCharts#configure}
   * @group others
   * @see FusionCharts#configure
   */
  jsRenderer.prototype.addVariable = function () {
    (0, _eventApi.raiseWarning)(this, '11090611381', 'run', 'JavaScriptRenderer~addVariable()', 'Use of deprecated "addVariable()". Replace with "configure()".');

    fcGlobal.core.prototype.configure.apply(this, arguments);
  };

  /**
   * This function returns the data and and configuration set on a chart in `XML` format. The function is
   * usable after the {@link FusionCharts#event:loaded} event of a chart has been fired. As such, it is
   * recommended to use the alternate function {@link FusionCharts#getXMLData}, which does not have this
   * limitation of being available only after the `loaded` event has been fired.
   *
   * @deprecated 3.2.0 - It is recommended that the alternate functions {@link FusionCharts#getXMLData} or
   * {@link FusionCharts#getChartData} be used instead of this.
   * @group data
   * @see FusionCharts#getXMLData
   *
   * @return {string}
   */
  jsRenderer.prototype.getXML = function () {
    (0, _eventApi.raiseWarning)(this, '11171116291', 'run', 'JavaScriptRenderer~getXML()', 'Use of deprecated "getXML()". Replace with "getXMLData()".');
    return this.getXMLData.apply(this, arguments);
  };

  /**
   * Sets XML data set on chart. Equivalent to {@link FusionCharts#setXMLData} or
   * {@link FusionCharts#setChartData}. The function is
   * usable after the {@link FusionCharts#event:loaded} event of a chart has been fired. As such, it is
   * recommended to use the alternate function {@link FusionCharts#setXMLData}, which does not have this
   * limitation of being available only after the `loaded` event has been fired.
   *
   * @deprecated 3.2.0 - It is recommended that the alternate functions {@link FusionCharts#setXMLData} or
   * {@link FusionCharts#setChartData} be used instead of this.
   * @group data
   * @see FusionCharts#setXMLData
   */
  jsRenderer.prototype.setDataXML = function () {
    (0, _eventApi.raiseWarning)(this, '11171116292', 'run', 'JavaScriptRenderer~setDataXML()', 'Use of deprecated "setDataXML()". Replace with "setXMLData()".');
    return this.setXMLData.apply(this, arguments);
  };

  /**
   * Sets XML data URL set on chart. The function is
   * usable after the {@link FusionCharts#event:loaded} event of a chart has been fired. As such, it is
   * recommended to use the alternate function {@link FusionCharts#setXMLUrl}, which does not have this
   * limitation of being available only after the `loaded` event has been fired.
   *
   * @deprecated 3.2.0 - It is recommended that the alternate functions {@link FusionCharts#setXMLUrl} or
   * {@link FusionCharts#setChartDataUrl} be used instead of this.
   * @group data
   * @see  FusionCharts#setXMLUrl
   */
  jsRenderer.prototype.setDataURL = function () {
    (0, _eventApi.raiseWarning)(this, '11171116293', 'run', 'JavaScriptRenderer~setDataURL()', 'Use of deprecated "SetDataURL()". Replace with "setXMLUrl()".');
    return this.setXMLUrl.apply(this, arguments);
  };

  /**
   * Returns whether a chart has been successfully rendered or not.
   * @group chart
   * @see FusionCharts#render
   * @see FusionCharts#event:beforeRender
   * @see FusionCharts#event:renderComplete
   * @see FusionCharts#event:renderCancelled
   * @see FusionCharts#event:rendered
   * @return {boolean}
   */
  jsRenderer.prototype.hasRendered = function () {
    return !!(this.jsVars.hcObj && this.jsVars.hcObj.hasRendered);
  };

  /**
   * Sets the chart's container background color as transparent. This is not the chart's background. It is the
   * background of the container DOM element within which the chart has been rendered.
   *
   * @group chart
   * @deprecated 3.4.0 - The container transparency can now be controlled using the `containerBackgroundOpacity`
   * parameter while creating a new instance of {@link FusionCharts}.
   *
   * @param {boolean} transparency - Passing `true` implies that the chart is transparent.
   * @return {boolean}
   */
  jsRenderer.prototype.setTransparent = function (transparency) {
    var vars;

    if (!(vars = this.jsVars)) {
      return;
    }

    // Sets chart to transparent mode when isTransparent (wMode) is true
    // (default). When no parameter is passed, we assume transparent to
    // be true.
    if (typeof transparency !== 'boolean' && transparency !== null) {
      transparency = true;
    }

    // Set the property.
    vars.transparent = transparency === null ? false : transparency === true;
  };

  jsRenderer.dataFormat = 'json';

  jsRenderer.ready = false;

  jsRenderer.policies = {
    jsVars: {
      // userModules: ['dependentModules', []] // enable if needed
    },
    options: {
      // Shows messages while chart is loading JS files.
      showChartLoadingMessage: ['showChartLoadingMessage', true]
    }
  };

  jsRenderer.protectedMethods = {};

  jsRenderer.init = function () {
    // Now 'base' has to be loaded. Had
    // base been loaded, this function would not have had existed.
    /* if (!hasModule.call(this, 'base', fcGlobal)) {
      loadModule('base', function () {
        // All scripts are loaded, hence renderer is ready
        renderer.ready = true;
         // Clear any object that has been waiting for render
        executeWaitingCommands(cmdQueue);
      }, UNDEF, fcGlobal);
      return;
    } */

    // If code is here, implies renderer is ready
    renderer.ready = true;
  };

  // This is almost a stub render function as its job is to queue objects.
  jsRenderer.render = function (container) {
    // Show message in HTML form
    showLoadingMessage(this, container);

    // As renderer is not ready, push it to queue
    _rendererLib.cmdQueue.push({
      cmd: 'render',
      obj: this,
      args: arguments
    });
  };

  jsRenderer.update = function () {
    // As renderer is not ready, push it to queue
    _rendererLib.cmdQueue.push({
      cmd: 'update',
      obj: this,
      args: arguments
    });
  };

  jsRenderer.resize = function () {
    _rendererLib.cmdQueue.push({
      cmd: 'resize',
      obj: this,
      args: arguments
    });
  };

  jsRenderer.dispose = function () {
    var queue = _rendererLib.cmdQueue,
        i,
        l;
    // Since renderer is not ready, we clear the command queue
    for (i = 0, l = queue.length; i < l; i += 1) {
      // We remove commands specific to this particular object.
      if (queue[i].obj === this) {
        queue.splice(i, 1);
        l -= 1; // subtract length as item was removed
        i -= 1;
      }
    }
  };

  jsRenderer.load = function () {
    _rendererLib.cmdQueue.push({
      cmd: 'load',
      obj: this,
      args: arguments
    });
  };

  jsRenderer.config = function (items, optionalValue) {
    var item,
        chart = this,
        vars = chart.jsVars,
        msgs = vars.msgStore,
        cfg = vars.cfgStore,
        options = chart.options,
        chartMessageOldNewMap;

    chartMessageOldNewMap = {
      LoadingText: 'loadMessage',
      ChartNotSupported: 'typeNotSupportedMessage',
      RenderChartErrorText: 'renderErrorMessage',
      XMLLoadingText: 'dataLoadStartMessage',
      ChartNoDataText: 'dataEmptyMessage',
      LoadDataErrorText: 'dataLoadErrorMessage',
      InvalidXMLText: 'dataInvalidMessage'
    };

    // If 'items' is not an object, convert it to object.
    if (typeof items === 'string' && arguments.length > 1) {
      item = items;
      items = {};
      items[item] = optionalValue;
    }

    // store data at respective places.
    for (item in items) {
      // if the config is part of chart messages, we store it there.
      if (msgs[item] !== UNDEF) {
        msgs[item] = items[item];
      } else {
        // otherwise we store it to the config store.
        cfg[item.toLowerCase()] = items[item];
      }

      // Update message in constructor parameter.
      if (chartMessageOldNewMap[item]) {
        options[chartMessageOldNewMap[item]] = items[item];
      } else {
        options[item] = items[item];
      }
    }
  };

  // Not required for interface, but needed for runtime definition of
  // chartAPI
  jsRenderer._call = function (fn, args, scope) {
    fn.apply(scope || window, args || []);
  };

  jsRenderer.events = {
    beforeInitialize: function beforeInitialize(event) {
      var sender = event.sender,
          vars = sender.jsVars,
          chartType,
          // set first time
      userArg;

      vars.fcObj = sender;
      vars.msgStore = vars.msgStore || new ChartMessage();
      vars.cfgStore = vars.cfgStore || {};
      vars.previousDrawCount = -1;
      vars.drawCount = 0;
      vars._reflowData = {};

      // add one-time event listener for before-render to perform initialization actions
      sender.addEventListener('beforeRender', function (event) {
        event.sender.jsVars.smartLabel = new _smartlabel2['default'](sender.id, document.body || document.getElementsByTagName('body')[0]);

        event.detachHandler();
      });

      // validate user-defined dependent module names
      if (!(vars.userModules instanceof Array)) {
        userArg = vars.userModules;
        vars.userModules = [];
        if (typeof userArg === 'string') {
          vars.userModules = vars.userModules.concat(userArg.split(','));
        }
      }

      // check presence of API
      if (!fcGlobal.core.getDep(chartType)) {
        vars.needsLoaderCall = true;
      }
    },

    initialized: function initialized(event) {
      var chart = event.sender,
          vars = chart.jsVars;

      if (vars.needsLoaderCall) {
        delete vars.needsLoaderCall;
        // Request load of the specific chart module
        jsRenderer.load.call(chart);
      }
    },

    beforeDataUpdate: clearStateEventHandler,

    beforeDispose: function beforeDispose(event) {
      var chart = event.sender,
          vars = chart.jsVars;

      vars.smartLabel && !vars.smartLabel.disposed && vars.smartLabel.dispose();

      clearStateEventHandler.apply(this, arguments);
      /** @todo paper-reuse */
      // vars.paper && (vars.paper.remove(), delete vars.paper);
    },

    beforeRender: function beforeRender(event) {
      var chart = event.sender,
          vars = chart.jsVars;

      delete vars.drLoadAttempted;
      delete vars.waitingModule;
      delete vars.waitingModuleError;
      /** @todo paper-reuse */
      // vars.paper && (vars.paper.remove(), delete vars.paper);

      clearStateEventHandler.apply(this, arguments);
    },

    dataLoadRequested: function dataLoadRequested(event) {
      // Reference to event sender.
      var obj = event.sender,
          vars = obj.jsVars;

      delete vars.loadError;

      // In case we have an active chart, we show the loading
      // message in chart itself.
      if (obj.ref && obj.options.showDataLoadingMessage) {
        if (vars.hcObj && !vars.hasNativeMessage && vars.hcObj.showLoading) {
          vars.hcObj.showMessage(vars.msgStore.XMLLoadingText);
        } else if (obj.ref.showChartMessage) {
          obj.ref.showChartMessage('XMLLoadingText');
        } else {
          vars.stallLoad = true;
        }
      } else {
        vars.stallLoad = true;
      }
    },

    dataLoadRequestCompleted: function dataLoadRequestCompleted(event) {
      // Reference to event sender.
      var obj = event.sender,
          vars = obj.jsVars;

      // Clear load prevention flags.
      delete vars.stallLoad;
    },

    dataLoadError: function dataLoadError(event) {
      // Reference to event sender.
      var obj = event.sender,
          vars = obj.jsVars,
          args = obj.args,
          options = obj.options;

      // On data load error, one needs to display 'No Data To Display'
      // on charts.
      delete vars.stallLoad;
      vars.loadError = true;

      obj._chartMessageImageStyle = {
        imageHAlign: args.dataLoadErrorMessageImageHAlign || options.baseChartMessageImageHAlign,
        imageVAlign: args.dataLoadErrorMessageImageVAlign || options.baseChartMessageImageVAlign,
        imageAlpha: args.dataLoadErrorMessageImageAlpha || options.baseChartMessageImageAlpha,
        imageScale: args.dataLoadErrorMessageImageScale || options.baseChartMessageImageScale
      };

      // Set chart message styling for chart type not supported
      obj._chartMessageStyle = {
        color: args.dataLoadErrorMessageColor || options.baseChartMessageColor,
        fontFamily: args.dataLoadErrorMessageFont || options.baseChartMessageFont,
        fontSize: args.dataLoadErrorMessageFontSize || options.baseChartMessageFontSize
      };
      if (obj.apiInstance.setChartMessage) {
        obj.apiInstance.setChartMessage(options.dataLoadErrorMessage, obj);
        obj.apiInstance.drawChartMessage();
      }

      if (obj.__state.dataFetchDuringConstruction) {
        delete obj.__state.dataFetchDuringConstruction;
      }

      clearStateEventHandler.apply(this, arguments);
    }

  };

  // Define default configuration options pertaining to HTML5 renderer.
  // fcGlobal.extend(fcGlobal.core.options, extendedCoreOptions);

  function notDefined() {
    /**
     * @private
     *
     * @typedef {RuntimeException} Error-25081845
     * @memberOf FusionCharts.debugger
     * @group debugger-error
     */
    (0, _eventApi.raiseError)(this, '25081845', 'run', '::RendererManager', new Error('No active renderer'));
  }

  // This function allows users to make a generic call to external interface
  // of the chart via the FusionCharts object
  function eiCall(method) {
    return function () {
      var callee = this,
          ref = callee.ref;
      // Verify whether the chart is valid object and then proceed.
      if (typeof ref === 'undefined' || ref === null || _typeof(ref[method]) !== func) {
        /**
         * Every instance of FusionCharts has a set of functions that are specific to a chart type and set
         * of functions that are available only after a chart has been rendered. In case a call to such
         * functions are made before the chart has been completely rendered, this error is raised. The error
         * message includes the name of the function in question.
         *
         * Ensure you programmatically interact with a chart (with respect to the function involved,) after
         * the {@link FusionCharts#event:renderComplete} event has been fired.
         *
         * @typedef {RuntimeException} Error-25081617
         * @memberOf FusionCharts.debugger
         * @group debugger-error
         */
        (0, _eventApi.raiseError)(this, '25081617', 'run', '#' + method + '()', 'ExternalInterface call failed. Check whether chart has been rendered.');

        return;
      }

      return ref[method].apply(ref, arguments);
    };
  }

  // This function allows users to make a generic call from renderer
  // of the chart to main FusionCharts object.
  function jsCall(obj, prop) {
    // Check whether me
    if (_typeof(obj[prop]) === func) {
      return function () {
        return obj[prop].apply(obj, arguments);
      };
    }
    return obj[prop];
  }

  // Function that checks duplicate id in page.
  function isDuplicateId(lookupId, container) {
    // Get the lookup element from the ID sent via parameter.
    var lookupElement = doc.getElementById(lookupId),

    // Get the ID of the container element.
    containerId = container.id || container.getAttribute('id'),
        children,
        i,
        ii;

    // Check whether the element exists or not. If it does not exist, it
    // implies that there cannot be any duplicate.
    if (lookupElement === null) {
      return false;
    }

    // In case chart's Id and container's Id is same then is duplicate.
    if (lookupId === containerId) {
      return true;
    }

    // Check whether the lookup element returned before is actually
    // inside container or not.
    children = container.getElementsByTagName('*');
    for (i = 0, ii = children.length; i < ii; i++) {
      if (children[i] === lookupElement) {
        return false;
      }
    }
    // If the lookupElement is outside/before the container, it implies
    // that it is a duplicate.
    return true;
  }

  /**
   * When a chart is rendered within a DOM element on a page, the chart by default clears its contents and
   * replaces them with the chart. However, this behavior can be changed by specifying the `insertMode` of the
   * chart during construction of a chart or while calling {@link FusionCharts#render}.
   * @memberOf FusionCharts~
   * @group framework
   *
   * @alias DOMInsertModes
   * @enum {string}
   */
  FusionChartsDOMInsertModes = fcGlobal.FusionChartsDOMInsertModes = {
    /**
     * Replaces - default.
     */
    REPLACE: 'replace',
    /**
     * Appends
     */
    APPEND: 'append',
    /**
     * prepends
     */
    PREPEND: 'prepend'
  };

  // Collection of renderers.
  renderer = fcGlobal.renderer = {
    register: function register(name, obj) {
      // Validate parameters
      if (!name || _typeof(name.toString) !== func) {
        throw new Error('#03091436 ~renderer.register() Invalid value for renderer name.');
      }

      // Desensitize character case for renderer name
      name = name.toString().toLowerCase();

      // Prevent addition of duplicate renderer
      if (renderers[name] !== UNDEF) {
        /**
         * @private
         *
         * @typedef {ParameterException} Error-03091438
         * @memberOf FusionCharts.debugger
         * @group debugger-error
         */
        (0, _eventApi.raiseError)(fcGlobal.core, '03091438', 'param', '::RendererManager>register', 'Duplicate renderer name specified in "name"');
        return false;
      }

      // Add renderer to the collection of renderers.
      renderers[name] = obj;
      // Return true when a new renderer is successfully added.
      return true;
    },

    // Flag that tracks whether user has updated the default value.
    userSetDefault: false,

    // Set the current renderer
    setDefault: function setDefault(name) {
      // Validate parameters
      if (!name || _typeof(name.toString) !== func) {
        /**
         * @private
         *
         * @typedef {ParameterException} Error-25081731
         * @memberOf FusionCharts.debugger
         * @group debugger-error
         */
        (0, _eventApi.raiseError)(fcGlobal.core, '25081731', 'param', '::RendererManager>setDefault', 'Invalid renderer name specified in "name"');
        return false;
      }

      // Validate the renderer name and see whether the parameter refers to a valid renderer.
      // ALSO: Desensitize character case for renderer name.
      if (renderers[name = name.toString().toLowerCase()] === UNDEF) {
        /**
         * @private
         *
         * @typedef {RangeException} Error-25081733
         * @memberOf FusionCharts.debugger
         * @group debugger-error
         */
        (0, _eventApi.raiseError)(fcGlobal.core, '25081733', 'range', '::RendererManager>setDefault', 'The specified renderer does not exist.');
        return false;
      }

      // Mark auto-set default renderer. When user specifically sets
      // renderer, this flag needs to be overwritten.
      this.userSetDefault = false;

      // Set reference to the current renderer.
      fcGlobal.policies.options.renderer = ['renderer', name];
      return true;
    },

    // Define a function that saves the reference to the embedded object
    // after it has been rendered.
    notifyRender: function notifyRender(status) {
      // Lookup corresponding chartObject for the renderer notif.
      var chartObj = fcGlobal.core.items[status && status.id];

      // Check whether the render was successful.
      if (!chartObj || status.success === false && !status.silent) {
        /**
         * This is an error that occurs when FusionCharts failed to render the chart. When
         * {@link FusionCharts#render} is called, it expects the rendering process to complete and a
         * corresponding chart be available on the browser `DOM` having the same `id` as the chart id.
         *
         * - Check whether the chart being rendered has a unique ID.
         * - Ensure that the chart container being rendered in is not within a `frame` or `iframe`.
         * - Ensure that the container being rendered in is not deleted or manipulated during the rendering
         *   process. Avoid updating the `innerHTML` of the container once a chart has been rendered within it;
         *   use standard DOM append, prepend, insert, remove functions.
         * - Check whether any third-party JavaScript or JavaScript UI library is not interfering with the
         *   rendering process.
         *
         * @typedef {RuntimeException} Error-25081850
         * @memberOf FusionCharts.debugger
         * @group debugger-error
         */
        (0, _eventApi.raiseError)(fcGlobal.core.items[status.id], '25081850', 'run', '::RendererManager', new Error('There was an error rendering the chart. ' + 'Enable FusionCharts JS debugger for more information.'));
      }

      /**
       * Every instance of FusionCharts, when rendered within a container element (provided by the `renderAt`
       * parameter,) creates a `<span>` element within which a chart is rendered. As such, the user-provided
       * container element is not polluted by the DOM elements created by a chart.
       *
       * @deprecated 3.4.0 - This method has been deprecated as direct access to `DOMElement` of the chart has
       * become redundant.
       *
       * @group chart
       * @since 3.2.0
       * @type {DOMElement}
       * @name ref
       * @memberOf FusionCharts.prototype
       *
       * @example
       * // Iterate on all charts rendered on a page and move them to a common location
       * var sidebar = document.getElementById('sidebar-html-div'), // assuming that your common container is this
       *     chart;
       *
       * for (chart in FusionCharts.items) {
       *     chart = FusionCharts.items[chart];
       *     chart.ref && sidebar.appendChild(chart.ref.parentNode);
       * }
       */
      chartObj.ref = status.ref;

      // If the ref has been created, create a reverse reference.
      // if (status.ref) {
      //     status.ref.FusionCharts = fcGlobal.core.items[status.id];
      // }

      /**
       * This event is fired when the `HTMLDOMElement` (generally a <span>) is created within which the chart is
       * rendered.
       * @event FusionCharts#internal\.DOMElementCreated
       * @group chart
       * @private
       */
      (0, _eventApi.triggerEvent)('internal.DOMElementCreated', chartObj, {});
    },

    protectedMethods: {
      options: true,
      attributes: true,
      src: true,
      ref: true,
      constructor: true,
      signature: true,
      link: true,
      addEventListener: true,
      removeEventListener: true
    },

    getRenderer: function getRenderer(name) {
      return renderers[name];
    },

    getRendererPolicy: function getRendererPolicy(name) {
      var policies = renderers[name].policies;
      return (typeof policies === 'undefined' ? 'undefined' : _typeof(policies)) === 'object' ? policies : {};
    },

    currentRendererName: function currentRendererName() {
      return fcGlobal.policies.options.renderer[1];
    },

    update: function update(obj) {
      store[obj.id].update.apply(obj, Array.prototype.slice.call(arguments, 1));
    },

    render: function render(obj) {
      var rdr = jsRenderer;
      rdr.render.apply(obj, Array.prototype.slice.call(arguments, 1));
    },

    remove: function remove(obj) {
      store[obj.id].remove.apply(obj, Array.prototype.slice.call(arguments, 1));
    },

    resize: function resize(obj) {
      store[obj.id].resize.apply(obj, Array.prototype.slice.call(arguments, 1));
    },

    config: function config(obj) {
      store[obj.id].config.apply(obj, Array.prototype.slice.call(arguments, 1));
    },

    dispose: function dispose(obj) {
      store[obj.id].dispose.apply(obj, Array.prototype.slice.call(arguments, 1));
    }
  };

  // Constructor to add renderer functions
  (0, _eventApi.addListener)('beforeInitialize', function (event) {
    // Reference to event sender.
    var obj = event.sender,
        rendererName = 'javascript',
        item;

    // Check if construction has the default renderer name saved.
    if (typeof obj.options.renderer === 'string' && renderers[rendererName] === UNDEF) {
      obj.options.renderer = fcGlobal.policies.options.renderer[1];
    }
    // Desensitize the case of the parameter.
    obj.options.renderer = rendererName;

    // Keep a reference
    store[obj.id] = renderers[obj.options.renderer];

    // Check whether this particular renderer has been rendered.
    if (store[obj.id].initialized !== true && _typeof(store[obj.id].init) === func) {
      // Call the 'init' function on the renderer and set a flag.
      store[obj.id].init();
      store[obj.id].initialized = true;
    }

    // Parse construction policies specific to this renderer.
    fcGlobal.parsePolicies(obj, store[obj.id].policies || {}, obj.args);

    // Copy the prototype of the renderer specified in constructor to the
    // main object.
    for (item in store[obj.id].prototype) {
      obj[item] = store[obj.id].prototype[item];
    }

    // Attach event liseners of the renderer to this object.
    for (item in store[obj.id].events) {
      obj.addEventListener(item, store[obj.id].events[item]);
    }
  });

  (0, _eventApi.addListener)(['rendered', 'dataloaderror', 'nodatatodisplay', 'rendercancelled'], function (e, a) {
    var sender = e.sender;
    // Clear the flag that keeps a track whether the chart is presently
    // in a 'rendering' state
    if (sender instanceof fcGlobal.core && sender.__state && sender.__state.rendering) {
      (0, _eventApi.triggerEvent)('internal.rendered', sender, a);
      delete sender.__state.rendering;
    }
  });

  (0, _eventApi.addListener)('loaded', function (e) {
    // Store a reference to the chart swf HTML Node.
    var obj = e.sender,
        chartObj = e.sender.ref,
        eiItems,
        ignore1,
        ignore2,
        item,
        i;

    // Validate whether the chart swf node exists and that it has
    // the prerequisite externalInterface functions.
    if (chartObj === UNDEF || chartObj === null || _typeof(chartObj.getExternalInterfaceMethods) !== func) {
      return;
    }

    // The externalInterfaceMethods names are parsed from CSV to
    // Array.
    // Check whether the external interface methods are being called or not.
    // If not, then there is an error (probably cross-domain).
    try {
      eiItems = chartObj.getExternalInterfaceMethods();
      eiItems = typeof eiItems === 'string' ? eiItems.split(',') : [];
    } catch (err) {
      eiItems = [];
      /**
       * This error is raised when the chart cannot internally access the DOM functions of the rendered chart.
       * The likely cause of this issue is an internal failure to enumerate the basic DOM functions that are
       * needed for the chart to render. Ensure that your browser has not enforced cross-domain script security
       * restrictions that was intended.
       *
       * @typedef {RuntimeException} Error-13111126041
       * @memberOf FusionCharts.debugger
       * @group debugger-error
       */
      (0, _eventApi.raiseError)(obj, '13111126041', 'run', 'RendererManager^Loaded', new Error('Error while retrieving data from the chart-object.' + (err.message && err.message.indexOf('NPObject') >= 0 ? ' Possible cross-domain security restriction.' : '')));
    }

    // We iterate through all the externalInterface method names and
    // create an extensible API object that is added to main
    // FusionCharts object as reference.
    for (i = 0; i < eiItems.length; i += 1) {
      item = eiItems[i];
      // Copy method from renderer only when a local method does not exist
      if (obj[item] === UNDEF) {
        obj[item] = eiCall(item);
      }
    }

    // Extend FusionCharts capabilities to swf HTMLNode object
    // Check whether the object was added to DOM or not.
    if (obj.ref) {
      ignore1 = renderer.protectedMethods;
      ignore2 = renderer.getRenderer(obj.options.renderer).protectedMethods;
      // Iterate through the FusionCharts object and add its variables to the
      // HTMLNode object.
      for (item in obj) {
        // Discontinue adding this object in case the property is marked to
        // be ignored.
        if (ignore2 && !(ignore1[item] || ignore2[item] || obj.ref[item] !== UNDEF)) {
          try {
            obj.ref[item] = jsCall(obj, item);
          } catch (err) {
            throw err;
          }
        }
      }
    }
  });

  // Add resize in the legacy event list.
  fcGlobal.legacyEventList.resized = 'FC_Resized';

  (0, _lib.extend2)(fcGlobal.core.prototype, /** @lends FusionCharts# */{
    /**
     * Creating a chart using `new FusionCharts()` merely creates a JavaScript instance of the chart. The chart is
     * not yet made visible on the page. In order to render it in a location on the page, this function needs to be
     * called. Usually, when the chart is instantiated, the `renderAt` construction parameter specifies the element
     * on the page inside which the chart will be rendered. If the `renderAt` parameter is not provided during
     * construction of the page, then the same can be provided as the first parameter of this function.
     *
     * This function renders a chart inside a container element on a page. If a chart is already rendered, it can be
     * re-rendered inside the same container DOM element or some other element.
     *
     * @group chart
     *
     * @param {string|DOMElement=} [containerElement] - A reference or `id` of the `DOMElement` inside which the
     * chart is to be rendered. If this argument is not provided, it is assumed that the `renderAt` option is
     * provided during creation of the chart.
     *
     * @param {FusionCharts~DOMInsertModes} [insertMode=replace] - This parameter specifies the method using which
     * the chart's DOM element will be inserted within the `containerElement`. For more information regarding DOM
     * insert modes, see {@link FusionCharts~DOMInsertModes}
     *
     * @param {FusionCharts~renderCallback=} [callback] - This parameter is a callback function that is called after
     * the chart is successfully rendered. The last parameter to `render()` is always treated as a callback if it is
     * a function.
     *
     * @fires FusionCharts#beforeRender
     * @fires FusionCharts#rendered
     * @fires FusionCharts#renderComplete
     * @fires FusionCharts#renderCancelled
     */
    render: function render(containerElement, insertMode, callback) {
      var renderer = this;

      if (!callback) {
        if (typeof insertMode === 'function') {
          callback = insertMode;
          insertMode = UNDEF;
        } else if (!insertMode && typeof containerElement === 'function') {
          callback = containerElement;
          containerElement = UNDEF;
        }
      } else if (typeof callback !== 'function') {
        callback = UNDEF;
      }

      // Procure containerElement from internal object options that has
      // been passed via parameters.
      if (containerElement === UNDEF) {
        containerElement = this.options.containerElementId;
      }

      // In case user sends the element id, we get the object from it
      if (typeof containerElement === 'string') {
        containerElement = doc.getElementById(containerElement);
      }

      if (containerElement === UNDEF || containerElement === null) {
        /**
         * FusionCharts could not find the container DOM element while rendering chart. Ensure that a DOM
         * element exists which has an `id` attribute same as the one provided in `renderAt` construction
         * parameter or when passed to the {@link FusionCharts#render} function.
         *
         * @typedef {CompilationException} Error-03091456
         * @memberOf FusionCharts.debugger
         * @group debugger-error
         */
        (0, _eventApi.raiseError)(this, '03091456', 'run', '.render()', new Error('Unable to find the container DOM element.'));
        return this;
      }

      // In case of chart container is hidden, perform interval based tracking
      // And call the render function as soon as container gets visible
      if (isHidden(containerElement)) {
        handleContainerVisibility(renderer, containerElement, insertMode, callback);
      } else {
        // If the container is visible call the render function
        renderer.renderChart(containerElement, insertMode, callback);
      }

      return renderer;
    },

    renderChart: function renderChart(containerElement, insertMode, callback) {
      // Dispose the renderer in case of re-render. This checks whether there
      // is any previous DOM element in case the chart is re-rendered and
      // correspondingly deletes it. (B#565)
      var that = this,
          alt,
          eventArgs,
          ref,
          size,
          s;

      if (this.disposed) {
        return;
      }

      if ((ref = win[this.id]) && ref.FusionCharts && ref.FusionCharts === this || (ref = this.ref) && ref.FusionCharts && ref.FusionCharts === this) {
        fcGlobal.renderer.dispose(this);
        // For some browsers, the DOM element reference is still retained
        // in window scope and that has to be cleared.
        if (ref === win[this.id]) {
          win[this.id] = UNDEF;
        }
      }

      // Check IE-Safe variable name collision within Global Scope
      if (win[this.id] !== UNDEF) {
        /**
         * FusionCharts raises this error to ensure that the charts function reliably on older Internet Explorer
         * browsers (IE 8 and below.) Ensure that you have unique name for your chart id and that it does not
         * correspond to any global variable, DOM element id or frame name.
         *
         * @typedef {CompilationException} Error-25081843
         * @memberOf FusionCharts.debugger
         * @group debugger-error
         */
        (0, _eventApi.raiseError)(this, '25081843', 'comp', '.render', new Error('#25081843:IECompatibility() Chart ' + 'Id is same as a JavaScript variable name. Variable naming error. Please use unique name for' + 'chart JS variable, chart-id and container id.'));
      }

      // Validate parameters for retrieving callback. The last parameter can be a callback
      if (!callback) {
        if (typeof insertMode === 'function') {
          callback = insertMode;
          insertMode = UNDEF;
        } else if (!insertMode && typeof containerElement === 'function') {
          callback = containerElement;
          containerElement = UNDEF;
        }
      } else if (typeof callback !== 'function') {
        callback = UNDEF;
      }

      // Create a blank element inside to mimic alternativecontent
      insertMode = (insertMode || this.options.insertMode).toLowerCase() || FusionChartsDOMInsertModes.REPLACE;

      // Procure containerElement from internal object options that has
      // been passed via parameters.
      if (containerElement === UNDEF) {
        containerElement = this.options.containerElementId;
      }

      // In case user sends the element id, we get the object from it
      if (typeof containerElement === 'string') {
        containerElement = doc.getElementById(containerElement);
      }
      if (containerElement === UNDEF || containerElement === null) {
        /**
         * FusionCharts could not find the container DOM element while rendering chart. Ensure that a DOM
         * element exists which has an `id` attribute same as the one provided in `renderAt` construction
         * parameter or when passed to the {@link FusionCharts#render} function.
         *
         * @typedef {CompilationException} Error-03091456
         * @memberOf FusionCharts.debugger
         * @group debugger-error
         */
        (0, _eventApi.raiseError)(this, '03091456', 'run', '.render()', new Error('Unable to find the container DOM element.'));
        return this;
      }

      // Check duplicate rendering with same id
      if (isDuplicateId(this.id, containerElement)) {
        /**
         * The `id` of the container element provided has more than one element with the same id. This would
         * cause problems in referring to the correct chart during its operation.
         *
         * Ensure that no other DOM element exists on the page with the same `id` attribute as of the container
         * element where the chart is supposed to be rendered.
         *
         * @typedef {CompilationException} Error-05102109
         * @memberOf FusionCharts.debugger
         * @group debugger-error
         */
        (0, _eventApi.raiseError)(this, '05102109', 'run', '.render()', new Error('A duplicate object already exists with the specific Id: ' + this.id));
        return this;
      }

      // Set the attribute of this element that will be replaced by swfobject
      alt = doc.createElement(this.options.containerElementType || 'span');
      alt.setAttribute('id', this.id);

      // Clear the contents of the containerElement and subsequently
      // append the new alt content.
      if (insertMode !== 'append' && insertMode !== 'prepend') {
        while (containerElement.hasChildNodes()) {
          containerElement.removeChild(containerElement.firstChild);
        }
      }
      // Check whether we are to prepend this item or append.
      if (insertMode === 'prepend' && containerElement.firstChild) {
        containerElement.insertBefore(alt, containerElement.firstChild);
      } else {
        containerElement.appendChild(alt);
      }

      // Update the present container details in object.
      this.options.containerElement = containerElement;
      this.options.containerElementId = containerElement.id;

      // Set the chart element style property to make it display as an
      // inline-block element.
      if (s = alt.style) {
        s.position = 'relative';
        s.textAlign = 'left';
        s.lineHeight = 'normal';
        s.display = 'inline-block';
        s.zoom = '1';
        s['vertical-align'] = 'middle';
        s.fontWeight = 'normal';
        s.fontVariant = 'normal';
        s.fontStyle = 'normal';
        s.textDecoration = 'none';
        s['*DISPLAY'] = 'inline';
        s.padding = '0';
        s.margin = '0';
        s.border = 'none';
        s.direction = 'ltr';
      }
      this.options.containerClassName && (alt.className = this.options.containerClassName);

      // Fix percentage width issues
      size = normalizeCSSDimension(this.width, this.height, alt);

      // Record the render-time dimensions within state. This will be used
      // for reference calculations wrt original render-time dimensions in
      // other modules (such as annotations.)
      this.__state.renderedWidth = size.pixelWidth;
      this.__state.renderedHeight = size.pixelHeight;

      // Set state that the chart is rendering
      this.__state.rendering = true;

      /**
       * This event is raised before a chart is to be rendered. Doing an `eventObject.preventDefault()` on this
       * event will cancel the rendering process. The rendering process is triggered when
       * {@link FusionCharts#render} is called on the chart instance.
       *
       * @param {DOMElement} container - This contains the reference to the container `HTMLDOMElement` within
       * which the chart is to be rendered.
       * @param {numeric|percent} width - Width of the chart in percent or pixels.
       * @param {numeric|percent} height - Height of the chart in percent or pixels.
       *
       * @event FusionCharts#beforeRender
       * @group chart
       * @see FusionCharts#render
       * @see FusionCharts#hasRendered
       * @see FusionCharts#event:renderComplete
       * @see FusionCharts#event:renderCancelled
       * @see FusionCharts#event:rendered
       *
       * @example
       * // Listening using global events
       * FusionCharts.addEventListener('beforeRender', function (eventObj, argsObj) {
       *     // Prints id of the chart being rendered
       *     console.log("Chart with id " + eventObj.sender.id + " is about to be rendered.");
       *  });
       *
       * // Pass event listener in the FusionCharts constructor
       * var mychart = new FusionCharts({
       *     "type": "column2d",
       *     "dataFormat": "json",
       *     "dataSource": {
       *          ...
       *     },
       *     // Attach event handlers
       *     "events": {
       *         // Attach to beforeRender
       *         "beforeRender": function (eventObj, argsObj) {
       *             console.log("Beginning render of " + eventObj.sender.id);
       *         }
       *     }
       * });
       */
      (0, _eventApi.triggerEvent)('beforeRender', this, eventArgs = {
        container: containerElement,
        width: this.width,
        height: this.height,
        renderer: this.options.renderer
      }, UNDEF, function (event, args) {
        if (this.disposed === true) {
          return;
        }
        // Call the current renderer.
        fcGlobal.renderer.render(that, alt, function () /* status */{
          fcGlobal.renderer.notifyRender.apply(this, arguments);

          // Sandbox the error from causing script to break. Throw error on a different thread.
          if (callback) {
            try {
              /**
               * This callback is part of {@link FusionCharts#render} function. When a function is passed
               * as a parameter of {@link FusionCharts#render}, it is executed when the rendering process
               * is complete (along with {@link FusionCharts#event:renderComplete} event.) This callback
               * is executed with the scope of the instance of `FusionCharts` and as such the `this`
               * variable within this function refers to the chart whose rendering process is complete.
               *
               * @callback FusionCharts~renderCallback
               *
               * @this FusionCharts
               *
               * @param {DOMElement} container - This parameter returns a reference to the container
               * element within which the chart, gauge or map has been rendered.
               *
               * @example
               * // In this example, we are going to use the render callback
               * // function to activate a set of buttons that are needed only
               * // after a chart has been rendered (say, exporting the chart.)
               * FusionCharts.ready(function () {
               *     var chart = new FusionCharts({
               *         type: "Column2D",
               *         dataFormat: "jsonurl",
               *         dataSource: "sample-data-source.json",
               *         renderAt: "chart-container" // assuming an element with this id exists
               *     }).render(function () {
               *         // Assuming a disabled button with a specific id already exists.
               *         var button = document.getElementById("export-button");
               *         button.removeAttribute("disabled");
               *     });
               * });
               */
              callback.call(event.sender, args.container);
            } catch (e) {
              setTimeout(function () {
                throw e;
              });
            }
          }
        });
      }, function () {
        /**
         * This event as a result of cancellation of default behavior of
         * {@link FusionCharts#event:beforeRender} event via it's `eventObject.preventDefault()` method.
         *
         * @see FusionCharts#render
         * @see FusionCharts#hasRendered
         * @see FusionCharts#event:beforeRender
         * @see FusionCharts#event:renderComplete
         * @see FusionCharts#event:rendered
         *
         * @event FusionCharts#renderCancelled
         * @group chart
         *
         * @example
         * // Listening using global events
         * FusionCharts.addEventListener('renderCancelled', function (eventObj, argsObj) {
         *     // Prints id of the chart whose rendering was cancelled
         *     console.log("Rendering of chart with id " + eventObj.sender.id + " was cancelled.");
         *  });
         *
         * // Pass event listener in the FusionCharts constructor
         * var mychart = new FusionCharts({
         *     "type": "column2d",
         *     "dataFormat": "json",
         *     "dataSource": {
         *          ...
         *     },
         *     // Attach event handlers
         *     "events": {
         *         // Attach to renderCancelled
         *         "renderCancelled": function (eventObj, argsObj) {
         *             console.log("Cancelled rendering of " + eventObj.sender.id);
         *         }
         *     }
         * });
         *
         * @param {DOMElement} container - This contains the refernce to the container `HTMLDOMElement` whithin
         * which the chart is to be rendered.
         * @param {numeric|percent} width - Width of the chart in percent or pixels.
         * @param {numeric|percent} height - Height of the chart in percent or pixels.
         */
        (0, _eventApi.triggerEvent)('renderCancelled', that, eventArgs);
      });

      return this;
    },

    /**
     * Removes a chart from the DOM where it was previously rendered. This retains the chart object and as such it
     * can be re-rendered inside the same DOM element or be rendered in some other element by calling
     * {@link FusionCharts#render}.
     *
     * @group chart
     * @since  3.4.0
     * @private
     */
    remove: function remove() {
      fcGlobal.renderer.remove(this);
      return this; // chain
    },

    /**
     * Calling this function on a chart instance resizes the chart to the specified width or height. This function
     * is only available for charts that have already rendered.
     *
     * Similar to setting the width and height of a chart through the `new FusionCharts()` constructor, the values
     * for width and height can be passed in number or percentage for this function. Setting a percentage causes the
     * chart to partially redraw itself when chart container is resized.
     *
     * Calling this function without a value for either width or height will return the current value of the width
     * or height respectively.
     *
     * For example, this function is useful in controlling the dimension of chart based on the change in dimension
     * of a resizable dialog box. It is also useful in resizing charts for responsive layouts, based on device
     * orientation change.
     *
     * > When dimension is set in percentage, the charts use a very low-profile polling at an interval of `300ms` to
     * check whether the chart container has effectively resized. It ignores repeated resizes.
     *
     * @group chart:resize
     *
     * @param {numeric|percent=} [width] - Set the width of the chart in pixels or percent.
     * @param {numeric|percent=} [height] - Set the height of the chart in pixels or percent.
     *
     * @fires FusionCharts#beforeResize
     * @fires FusionCharts#resized
     * @fires FusionCharts#resizeCancelled
     */
    resizeTo: function resizeTo(width, height, silent) {
      var chart = this,
          prevW = chart.width,
          prevH = chart.height,
          state = chart.__state,
          config = chart.apiInstance && chart.apiInstance.config || {};

      config.resize = true;
      if ((typeof width === 'undefined' ? 'undefined' : _typeof(width)) === 'object') {
        silent = height;
        height = width.h;
        width = width.w;
      }

      width = width === null || width === UNDEF ? prevW : width.toString().replace(lengthCleanupRegex, '');
      height = height === null || height === UNDEF ? prevH : height.toString().replace(lengthCleanupRegex, '');

      if (silent !== true) {
        /**
         * This event is fired before a chart is to be resized. It is fired either from
         * {@link FusionCharts#resizeTo} or fired due to change in dimension of the chart's container element
         * while the dimensions were in percentage format.
         *
         * @see FusionCharts#event:resized
         * @see FusionCharts#resizeTo
         * @see FusionCharts#event:resizeCancelled
         * @event FusionCharts#beforeResize
         * @group chart:resize
         *
         * @param {numeric|percent} currentWidth - Current width of the chart in pixels or percentage
         * @param {numeric|percent} currentHeight Current height of the chart in pixels or percentage
         * @param {numeric|percent} newWidth - new width of the chart in pixels or percentage
         * @param {numeric|percent} newHeight - new height of the chart in pixels or percentage
         */
        (0, _eventApi.triggerEvent)('beforeresize', chart, {
          currentWidth: prevW,
          currentHeight: prevH,
          newWidth: width,
          newHeight: height
        }, UNDEF, function () {
          chart.width = width;
          chart.height = height;
          fcGlobal.renderer.resize(chart, { width: width, height: height });
          /**
           * Denotes when the chart has been resized either from calling {@link FusionCharts#resizeTo} or
           * caused due to change in dimension of the chart's container element while the dimensions were in
           * percentage format.
           *
           * @see FusionCharts#event:beforeResize
           * @see FusionCharts#resizeTo
           * @event FusionCharts#resized
           * @group chart:resize
           *
           * @param {numeric|percent} width - Width of the chart after being resized
           * @param {numeric|percent} height - Height of the chart after being resized
           * @param {numeric|percent} prevWidth - The width of the chart previous to being resized
           * @param {numeric|percent} prevHeight - The height of the chart previous to being resized
           * @param {number} originalWidth - Width of the chart in pixels provided when chart was rendered
           * using {@link FusionCharts#render}.
           * @param {number} originalHeight - Original render-time height of the chart in pixels.
           */
          fcGlobal.raiseEventWithLegacy('resized', {
            width: chart.width,
            height: chart.height,
            prevWidth: prevW,
            prevHeight: prevH,
            pixelWidth: chart.ref && chart.ref.offsetWidth || 0,
            pixelHeight: chart.ref && chart.ref.offsetHeight || 0,
            originalWidth: state.renderedWidth,
            originalHeight: state.renderedHeight
          }, chart, [chart.id, chart.width, chart.height]);
        }, function () {
          /**
           * This event is triggered when `event.preventDefault()` is called from
           * {@link FusionCharts#event:beforeResize}. This resuls in cancelling of instructions received from
           * the {@link FusionCharts#resizeTo} function.
           *
           * @see FusionCharts#event:beforeResize
           * @see FusionCharts#resizeTo
           * @event FusionCharts#resizeCancelled
           * @group chart:resize
           *
           * @param {numeric|percent} currentWidth - Current width of the chart in pixels or percentage.
           * @param {numeric|percent} currentHeight - Current height of the chart in pixels or percentage.
           * @param {numeric|percent} cancelledTargetWidth - The width of the chart that was requested to be
           * set, but was cancelled.
           * @param {numeric|percent} cancelledTargetHeight - The height of the chart that was requested to be
           * set, but was cancelled.
           */
          (0, _eventApi.triggerEvent)('resizecancelled', chart, {
            currentWidth: prevW,
            currentHeight: prevH,
            cancelledTargetWidth: width,
            cancelledTargetHeight: height
          });
        });
      } else {
        chart.width = width;
        chart.height = height;
      }
      return this; // chain
    },

    /**
     * Calling this function on an instance of FusionCharts disposes the chart completely. This removes it from the
     * DOM tree and also clears the entire chart object. Upon successful disposal, `chartInstance.disposed` is set
     * to `true`.
     *
     * > It is recommended that you dispose unused charts to save memory and avoid memory leaks in your application
     * or dashboard.
     * @group chart:dispose
     *
     * @fires FusionCharts#beforeDispose
     * @fires FusionCharts#disposed
     * @fires FusionCharts#disposeCancelled
     */
    dispose: function dispose() {
      var chart = this,
          eventArgs = {};

      /**
       * This event is raised when a chart is about to be disposed, i.e., deleted and cleaned from memory.
       * Usually, this event is triggered by {@link FusionCharts#dispose}. It can also be internally raised when
       * an already rendered chart is forced to re-render or if a child chart in a chain of *LinkedCharts* is
       * about to be closed.
       *
       * @see FusionCharts#dispose
       * @see FusionCharts#event:disposed
       * @see FusionCharts#event:disposeCancelled
       * @event FusionCharts#beforeDispose
       * @group chart:dispose
       */
      (0, _eventApi.triggerEvent)('beforeDispose', chart, eventArgs, UNDEF, function () {
        // Call dispose on the renderer. Renderer should dispose between
        // the beforeDispose and disposed event.
        fcGlobal.renderer.dispose(chart);

        /**
         * This event is raised when a chart has been disposed, i.e., deleted and cleaned from memory.
         *
         * Usually, this event is triggered by {@link FusionCharts#dispose}. It can also be internally raised
         * when an already rendered chart has been forced to re-render  or if a child chart in a chain of
         * *LinkedCharts* is closed.
         *
         * > You should dispose unused charts to avoid memory-leaks within your application or dashboard.
         *
         * @see FusionCharts#dispose
         * @see FusionCharts#event:beforeDispose
         * @event FusionCharts#disposed
         * @group chart:dispose
         */
        (0, _eventApi.triggerEvent)('disposed', chart, eventArgs);

        // Dispose all local events
        (0, _eventApi.disposeEvents)(chart);

        // Delete the reference of the item
        delete fcGlobal.core.items[chart.id];

        // Remove all variables within this object, making this variable not usable.
        for (var prop in chart) {
          if (chart.hasOwnProperty(prop)) {
            delete chart[prop];
          }
        }

        // Flag it as disposed
        chart.disposed = true;
      }, function () {
        /**
         * This event is cancelled when `eventObject.preventDefault()` is on the event
         * {@link FusionCharts#event:beforeDispose}. This results in cancelling of dispose of charts, which is
         * usually issued by {@link FusionCharts#dispose}.
         *
         * @see FusionCharts#dispose
         * @see FusionCharts#event:beforeDispose
         * @event FusionCharts#disposeCancelled
         * @group chart:dispose
         */
        (0, _eventApi.triggerEvent)('disposeCancelled', chart, eventArgs);
      });
    },

    /**
     * FusionCharts displays various status messages while rendering a chart. For example, while a chart's data
     * is being fetched from a remote URL, the chart will display "Retrieving data. Please wait." These messages
     * can be configured using this function.
     *
     * @since 3.2.0
     * @group chart
     *
     * @param {FusionCharts~chartStatusMessages} option - The option can either be a string specifying the property
     * that is to be configured, in which case, the second parameter must be provided. Otherwise, this can be an
     * object having key-value pair of all configuration options.
     *
     * @param {string=} [value] - In case the first parameter is a single key as string, this parameter must be
     * provided as value of that configuration key.
     */
    configure: function configure(option, value) {
      var hash;
      if (!option) {
        return;
      } else if (typeof option === 'string') {
        hash = {};
        hash[option] = value;
      } else {
        hash = option;
      }
      fcGlobal.renderer.config(this, hash);
    }
  });

  fcGlobal.normalizeCSSDimension = normalizeCSSDimension;
  fcGlobal.executeWaitingCommands = executeWaitingCommands;
}

exports.executeWaitingCommands = executeWaitingCommands;
exports.normalizeCSSDimension = normalizeCSSDimension;
exports['default'] = javascriptRenderer;

/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__(9);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(10);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2['default'] === "function" && typeof _iterator2['default'] === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2['default'] === "function" && obj.constructor === _symbol2['default'] && obj !== _symbol2['default'].prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                                                                                         * FusionCharts JavaScript Library SmartLabel component module.
                                                                                                                                                                                                                                                                                                                                         * @private
                                                                                                                                                                                                                                                                                                                                         *
                                                                                                                                                                                                                                                                                                                                         * @module fusioncharts.renderer.javascript.smartlabel
                                                                                                                                                                                                                                                                                                                                         * @requires fusioncharts.renderer.javascript.lib
                                                                                                                                                                                                                                                                                                                                         */

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var userAgent = window && window.navigator && window.navigator.userAgent || '',
    isWebKit = new RegExp(' AppleWebKit/').test(userAgent),
    doc = window.document,
    UNDEF = void 0,
    hasCanvas = !!doc.createElement('canvas').getContext,
    canvasEl = !!(hasCanvas && doc.createElement('canvas').getContext('2d')),
    hasMeasureText = canvasEl && canvasEl.measureText,
    isHeadLess = new RegExp(' HtmlUnit').test(userAgent),
    brReplaceRegex = /<br\/>/ig,
    BLANK_ARR = [],
    math = Math,
    mathMax = math.max,
    mathRound = math.round,
    BLANK = '',
    ltgtRegex = /&lt;|&gt;/g,
    htmlSplCharSpace = { ' ': '&nbsp;' },
    maxAdvancedCacheLimit = 500,
    // need to be detect according to the browser capacity

SmartLabelManager = function () {
  var supportedCanvasStyle = {
    fontWeight: 1,
    'font-weight': 1,
    fontStyle: 1,
    'font-style': 1,
    fontSize: 1,
    'font-size': 1,
    fontFamily: 1,
    'font-family': 1
  },

  // style that will be set at the creation of the text container and will
  // not be changed
  fixedStyle = {
    position: 'absolute',
    top: '-9999em',
    // Fix value -9999em of left for smartlabel container makes page wider in IE & Firefox
    // thus, disabling it.
    // left: '-9999em',
    whiteSpace: 'nowrap',
    padding: '0px',
    width: '1px',
    height: '1px',
    overflow: 'hidden'
  },
      SVG_BBOX_CORRECTION = isWebKit ? 0 : 4.5,
      // Arrived at through trial and error. Why 4.5??
  ellipsesWidth = 0,

  // class name
  className = '_SmartLabel',
      className2 = '_SmartLabelBR',

  // have to modyfy sothat it can retrive classname among more
  classNameReg = /\b_SmartLabel\b/,
      classNameBrReg = /\b_SmartLabelBR\b/,
      spanAdditionRegx = /(<[^<\>]+?\>)|(&(?:[a-z]+|#[0-9]+);|.)/ig,
      spanAdditionReplacer = '$1<span class="' + className + '">$2</span>',
      spanRemovalRegx = new RegExp('\\<span[^\\>]+?' + className + '[^\\>]{0,}\\>(.*?)\\<\\/span\\>', 'ig'),
      xmlTagRegEx = new RegExp('<[^>][^<]*[^>]+>', 'i'),
      testStrAvg = 'WgI',
      isBrowserLess = false,
      minWidth = 0,

  // avgCharWidth = 0,
  dotWidth = 0,

  // containerIdIncriment = 0,
  spanTagString = 'span',
      ChildRetriverFN,
      ChildRetriverSTRING,
      noClassTesting;

  if (doc.getElementsByClassName) {
    ChildRetriverFN = 'getElementsByClassName';
    ChildRetriverSTRING = className;
    noClassTesting = true;
  } else {
    ChildRetriverFN = 'getElementsByTagName';
    ChildRetriverSTRING = spanTagString;
    noClassTesting = false;
  }

  // this function will create a container
  function createContainer(containerParent) {
    var body, container;

    if (containerParent && (containerParent.offsetWidth || containerParent.offsetHeight)) {
      if (containerParent.appendChild) {
        containerParent.appendChild(container = doc.createElement('div'));
        container.className = 'fusioncharts-smartlabel-container';
        container.setAttribute('aria-hidden', 'true');
        container.setAttribute('role', 'presentation');
        return container;
      }
    } else {
      body = doc.getElementsByTagName('body')[0];
      // if body ready then Execuate the function otherwise add it at dom ready

      if (body && body.appendChild) {
        // //create the text container element
        container = doc.createElement('div');
        container.className = 'fusioncharts-smartlabel-container';
        container.setAttribute('aria-hidden', 'true');
        container.setAttribute('role', 'presentation');
        // containerIdIncriment += 1;
        // append the container element
        body.appendChild(container);
        return container;
      }
    }
    return UNDEF;
  }

  function getNearestChar(text, maxWidth, sl) {
    var difference,
        getWidth = sl.getWidthFunction(),
        charLen = 0,
        increment = 0,
        oriWidth,
        avgWidth;

    if (!text || !text.length) {
      return 0;
    }

    oriWidth = getWidth(text);
    avgWidth = oriWidth / text.length;

    difference = maxWidth;
    charLen = Math.ceil(maxWidth / avgWidth);

    if (oriWidth < maxWidth) {
      return text.length - 1;
    }

    if (charLen > text.length) {
      difference = maxWidth - oriWidth;
      charLen = text.length;
    }

    while (difference > 0) {
      difference = maxWidth - getWidth(text.substr(0, charLen));
      increment = Math.floor(difference / avgWidth);
      if (increment) {
        charLen += increment;
      } else {
        return charLen;
      }
    }

    while (difference < 0) {
      difference = maxWidth - getWidth(text.substr(0, charLen));
      increment = Math.floor(difference / avgWidth);
      if (increment) {
        charLen += increment;
      } else {
        return charLen;
      }
    }
    return charLen;
  }

  // Set the line height in the style object in case
  function setLineHeight(styleObj) {
    var fSize = styleObj.fontSize = styleObj.fontSize || '12px';
    styleObj.lineHeight = styleObj.lineHeight || styleObj['line-height'] || parseInt(fSize, 10) * 1.2 + 'px';
  }

  function ContainerManager(parentContainer, maxContainers) {
    var svg;
    // Limit the maximum container between MAXC and MINC.
    maxContainers = maxContainers > 5 ? maxContainers : 5;
    maxContainers = maxContainers < 20 ? maxContainers : 20;

    this.maxContainers = maxContainers;
    this.first = null;
    this.last = null;
    this.containers = {};
    this.length = 0;
    this.rootNode = parentContainer;

    if (isBrowserLess) {
      svg = doc.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttributeNS('http://www.w3.org/2000/svg', 'xlink', 'http://www.w3.org/1999/xlink');
      svg.setAttributeNS('http://www.w3.org/2000/svg', 'height', '0');
      svg.setAttributeNS('http://www.w3.org/2000/svg', 'width', '0');
      this.svgRoot = svg;
      this.rootNode.appendChild(svg);
    }
  }

  ContainerManager.prototype = {
    get: function get(style) {
      var o = this,
          containers = o.containers,
          len = o.length,
          max = o.maxContainers,
          diff,
          key,
          keyStr = '',
          canvasStr = '',

      // isCanvas = false,
      containerObj;

      // if (canvasStr = o.getCanvasFont(style)) {
      //   isCanvas = true;
      // }

      for (key in _lib.supportedStyle) {
        if (style[key] !== UNDEF) {
          keyStr += _lib.supportedStyle[key] + ':' + style[key] + ';';
        }
      }

      if (!keyStr) {
        return false;
      }

      if (containers[keyStr]) {
        // move to the beginning of the chain.
        containerObj = containers[keyStr];
        if (o.first !== containerObj) {
          containerObj.prev && (containerObj.prev.next = containerObj.next);
          containerObj.next && (containerObj.next.prev = containerObj.prev);
          containerObj.next = o.first;
          containerObj.next.prev = containerObj;
          o.last === containerObj && (o.last = containerObj.prev);
          containerObj.prev = null;
          o.first = containerObj;
        }
      } else {
        if (len >= max) {
          diff = len - max + 1;
          // +1 is to remove an extra entry to make space for the new container to be added.
          while (diff--) {
            o.removeContainer(o.last);
          }
        }
        containerObj = o.addContainer(keyStr, canvasStr);
      }

      return containerObj;
    },
    getCanvasFont: function getCanvasFont(style) {
      var key,
          fontArr = [];

      // Check if canvas tag is supported or not.
      if (!(hasCanvas && hasMeasureText)) {
        return false;
      }

      // Check if there are any non-canvas styles present.
      // If present, return false.
      /*  for (key in style) {
              if (!supportedCanvasStyle[key]) {
                  return false;
              }
          }
        */

      for (key in supportedCanvasStyle) {
        if (style[key] !== UNDEF) {
          fontArr.push(style[key]);
        }
      }

      return fontArr.join(' ');
    },
    setMax: function setMax(maxContainers) {
      var o = this,
          len = o.length,
          diff;

      maxContainers = maxContainers > 5 ? maxContainers : 5;
      maxContainers = maxContainers < 20 ? maxContainers : 20;

      if (maxContainers < len) {
        // TODO: remove additional containerObjects
        diff = len - maxContainers;
        while (diff--) {
          o.removeContainer(o.last);
        }
        o.length = maxContainers;
      }

      o.maxContainers = maxContainers;
    },
    addContainer: function addContainer(keyStr, canvasStr) {
      var o = this,
          node,
          context,
          container;

      o.containers[keyStr] = container = {
        next: null,
        prev: null,
        node: null,
        ellipsesWidth: 0,
        lineHeight: 0,
        dotWidth: 0,
        avgCharWidth: 4,
        keyStr: keyStr,
        canvasStr: canvasStr,
        charCache: {}
      };

      // Since the container objects are arranged from
      // most recent to least recent order, we need to add the new object
      // at the beginning of the list.
      container.next = o.first;
      container.next && (container.next.prev = container);
      o.first = container;
      if (!o.last) {
        o.last = container;
      }
      o.length += 1;

      node = container.node = doc.createElement('div');
      o.rootNode.appendChild(node);

      if (_lib.isIE && !_lib.hasSVG) {
        node.style.setAttribute('cssText', keyStr);
      } else {
        node.setAttribute('style', keyStr);
      }

      node.setAttribute('aria-hidden', 'true');
      node.setAttribute('role', 'presentation');
      node.style.display = 'inline-block';

      node.innerHTML = testStrAvg; // A test string.
      container.lineHeight = node.offsetHeight;
      container.avgCharWidth = node.offsetWidth / 3;

      if (isBrowserLess) {
        node = container.svgText = doc.createElementNS('http://www.w3.org/2000/svg', 'text');
        node.setAttribute('style', keyStr);
        o.svgRoot.appendChild(node);

        node.textContent = testStrAvg; // A test string.
        container.lineHeight = node.getBBox().height;
        container.avgCharWidth = (node.getBBox().width - SVG_BBOX_CORRECTION) / 3;

        node.textContent = '...';
        container.ellipsesWidth = node.getBBox().width - SVG_BBOX_CORRECTION;
        node.textContent = '.';
        container.dotWidth = node.getBBox().width - SVG_BBOX_CORRECTION;
      } else if (canvasStr) {
        node = container.canvas = doc.createElement('canvas');
        node.style.height = node.style.width = '0px';
        o.rootNode.appendChild(node);

        container.context = context = node.getContext('2d');
        context.font = canvasStr;

        container.ellipsesWidth = context.measureText('...').width;
        container.dotWidth = context.measureText('.').width;
      } else {
        node.innerHTML = '...';
        container.ellipsesWidth = node.offsetWidth;
        node.innerHTML = '.';
        container.dotWidth = node.offsetWidth;
        node.innerHTML = '';
      }

      return container;
    },
    removeContainer: function removeContainer(cObj) {
      var o = this,
          keyStr = cObj.keyStr;

      if (!keyStr || !o.length || !cObj) {
        return;
      }
      o.length -= 1;

      cObj.prev && (cObj.prev.next = cObj.next);
      cObj.next && (cObj.next.prev = cObj.prev);
      o.first === cObj && (o.first = cObj.next);
      o.last === cObj && (o.last = cObj.prev);

      cObj.node.parentNode.removeChild(cObj.node);
      if (cObj.canvas) {
        cObj.canvas.parentNode.removeChild(cObj.canvas);
      }

      delete o.containers[keyStr];
    },
    dispose: function dispose() {
      var o = this,
          key,
          containers = o.containers;

      o.maxContainers = null;
      for (key in containers) {
        o.removeContainer(containers[key]);
      }

      o.rootNode.parentNode.removeChild(o.rootNode);

      o.rootNode = null;
      o.first = null;
      o.last = null;
    }
  };

  ContainerManager.prototype.constructor = ContainerManager;

  function SmartLabelManager(id, container, useEllipses) {
    var wrapper, prop;

    if (typeof id === 'undefined' || (typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object') {
      return;
    }

    this.id = id;

    if (typeof container === 'string') {
      container = doc.getElementById(container);
    }

    wrapper = this.parentContainer = createContainer(container);

    wrapper.innerHTML = testStrAvg;
    if (isHeadLess || !_lib.isIE && !wrapper.offsetHeight && !wrapper.offsetWidth) {
      isBrowserLess = true;
    }
    wrapper.innerHTML = '';

    // Apply the fixed styles.
    for (prop in fixedStyle) {
      wrapper.style[prop] = fixedStyle[prop];
    }

    this.containerManager = new ContainerManager(wrapper, 10);

    this.showNoEllipses = !useEllipses;
    this.init = true;
    // create the blank style obj
    this.style = {};
    this.setStyle();
  }

  SmartLabelManager.prototype = {

    dispose: function dispose() {
      var label = this;

      if (!label.init) {
        return;
      }

      label.containerManager && label.containerManager.dispose && label.containerManager.dispose();

      delete label.container;
      delete label.context;
      delete label.cache;
      delete label.containerManager;
      delete label.containerObj;
      delete label.id;
      delete label.style;
      delete label.parentContainer;
      delete label.showNoEllipses;
    },

    useEllipsesOnOverflow: function useEllipsesOnOverflow(useEllipses) {
      if (!this.init) {
        return;
      }
      this.showNoEllipses = !useEllipses;
    },

    getWidthFunction: function getWidthFunction() {
      var sl = this,
          contObj = sl.containerObj,
          context = sl.context,
          container = sl.container,
          svgText = contObj.svgText;

      if (svgText) {
        return function (str) {
          var bbox, width;

          svgText.textContent = str;
          bbox = svgText.getBBox();
          width = bbox.width - SVG_BBOX_CORRECTION;
          if (width < 1) {
            width = bbox.width;
          }

          return width;
        };
      } else if (context) {
        return function (str) {
          /* Canvas measureText API returns wrong width for texts with "<br/>" as well as text with "\n"
            * To fix that, measure individual line, and return the max of them
            */
          var strArr = str && str.split ? str.split(brReplaceRegex) : BLANK_ARR,
              i = 0,
              ln = strArr.length,
              maxWidth = 0;
          for (i = 0; i < ln; i += 1) {
            maxWidth = mathMax(context.measureText(strArr[i] || BLANK).width, maxWidth);
          }
          // return context.measureText(str.replace(brReplaceRegex, NEWLINECHAR)).width;
          return maxWidth;
        };
      } else {
        return function (str) {
          container.innerHTML = str;
          return container.offsetWidth;
        };
      }
    },

    getSmartText: function getSmartText(text, maxWidth, maxHeight, noWrap) {
      // now smartify the string
      // create smart label object
      var sl = this,
          smartLabel = {},
          hasHTMLTag = false,
          len,
          trimStr,
          maxStrWidth = 0,
          tempArr,
          tmpText,
          maxWidthWithEll,
          toolText,
          oriWidth,
          oriHeight,
          lastDash = -1,
          lastSpace = -1,
          lastIndexBroken = -1,
          newCharIndex,
          container = sl.container,
          context = sl.context,
          strWidth = 0,
          strHeight = 0,
          nearestChar,
          tempChar,
          getWidth,
          initialLeft,
          initialTop,
          getOriSizeImproveObj,
          oriTextArr = [],
          i = 0,
          ellipsesStr = sl.showNoEllipses ? '' : '...',
          lineHeight = sl.lineHeight,
          spanArr,
          x,
          y,
          elem,
          chr,
          elemRightMostPoint,
          elemLowestPoint,
          lastBR,
          removeFromIndex,
          removeFromIndexForEllipses,
          characterArr = [],
          dashIndex = -1,
          spaceIndex = -1,
          fastTrim = function fastTrim(str) {
        var ws, i;
        str = str.replace(/^\s\s*/, '');
        ws = /\s/;
        i = str.length;
        while (ws.test(str.charAt(i -= 1))) {/* jshint noempty:false */}
        return str.slice(0, i + 1);
      },
          lastLineBreak = -1;

      if (!this.init) {
        return false;
      }

      // fix for UNDEF or null string
      if (text === UNDEF || text === null) {
        text = '';
      }
      smartLabel = {
        text: text,
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        width: null,
        height: null,
        oriTextWidth: null,
        oriTextHeight: null,
        oriText: text,
        isTruncated: false
      };

      getWidth = sl.getWidthFunction();

      // In some browsers, offsetheight of a single-line text is getting little (1 px) heigher value of
      // the lineheight. As a result, smartLabel is unable to return single-line text
      // where maxHeight =  lineHeight. To fix this, increase the maxHeight a little amount
      if (maxHeight === lineHeight) {
        maxHeight *= 1.2;
      }

      if (container) {
        if (!isBrowserLess) {
          // hasHTMLTag = false;
          hasHTMLTag = xmlTagRegEx.test(text);
          if (!hasHTMLTag) {
            // Due to support of <,> for xml we convert &lt;, &gt; to <,> respectively so to get the
            // correct width it is required to convert the same before calculation for the new improve
            // version of the get text width.
            tmpText = text.replace(ltgtRegex, function (match) {
              return match === '&lt;' ? '<' : '>';
            });
            getOriSizeImproveObj = sl.getOriSizeImprove(tmpText, true);

            smartLabel.oriTextWidth = oriWidth = getOriSizeImproveObj.width;
            smartLabel.oriTextHeight = oriHeight = getOriSizeImproveObj.height;
          } else {
            // To get text size set the text as innerhtml
            container.innerHTML = text;
            // add oriTextWidth & oriTextHeight
            smartLabel.oriTextWidth = oriWidth = container.offsetWidth;
            smartLabel.oriTextHeight = oriHeight = container.offsetHeight;
          }
          // fix for screenreader
          // container.innerHTML = "";

          if (oriHeight <= maxHeight && oriWidth <= maxWidth) {
            smartLabel.width = smartLabel.oriTextWidth = oriWidth;
            smartLabel.height = smartLabel.oriTextHeight = oriHeight;
            return smartLabel;
          }

          if (lineHeight > maxHeight) {
            smartLabel.text = '';
            smartLabel.width = smartLabel.oriTextWidth = 0;
            smartLabel.height = smartLabel.oriTextHeight = 0;
            return smartLabel;
          }
        }

        text = fastTrim(text).replace(/(\s+)/g, ' ');
        maxWidthWithEll = this.showNoEllipses ? maxWidth : maxWidth - ellipsesWidth;

        if (!hasHTMLTag) {
          oriTextArr = text.split('');
          len = oriTextArr.length;
          trimStr = '';
          tempArr = [];
          tempChar = oriTextArr[0];

          if (sl.cache[tempChar]) {
            minWidth = sl.cache[tempChar].width;
          } else {
            minWidth = getWidth(tempChar);
            sl.cache[tempChar] = {
              width: minWidth
            };
          }

          if (maxWidthWithEll > minWidth) {
            tempArr = text.substr(0, getNearestChar(text, maxWidthWithEll, sl)).split('');
            i = tempArr.length;
          } else if (minWidth > maxWidth) {
            // fix for screenreader
            // container.innerHTML = "";

            smartLabel.text = '';
            smartLabel.width = smartLabel.oriTextWidth = smartLabel.height = smartLabel.oriTextHeight = 0;
            return smartLabel;
          } else if (ellipsesStr) {
            maxWidthWithEll = maxWidth - 2 * dotWidth;
            if (maxWidthWithEll > minWidth) {
              ellipsesStr = '..';
            } else {
              maxWidthWithEll = maxWidth - dotWidth;
              if (maxWidthWithEll > minWidth) {
                ellipsesStr = '.';
              } else {
                maxWidthWithEll = 0;
                ellipsesStr = '';
              }
            }
          }

          strWidth = getWidth(tempArr.join(''));
          strHeight = sl.lineHeight;

          if (noWrap) {
            for (; i < len; i += 1) {
              tempChar = tempArr[i] = oriTextArr[i];
              if (sl.cache[tempChar]) {
                minWidth = sl.cache[tempChar].width;
              } else {
                if (!getOriSizeImproveObj || !(minWidth = getOriSizeImproveObj.detailObj[tempChar])) {
                  minWidth = getWidth(tempChar);
                }
                sl.cache[tempChar] = {
                  width: minWidth
                };
              }
              strWidth += minWidth;
              if (strWidth > maxWidthWithEll) {
                if (!trimStr) {
                  trimStr = tempArr.slice(0, -1).join('');
                }
                if (strWidth > maxWidth) {
                  smartLabel.text = fastTrim(trimStr) + ellipsesStr;
                  smartLabel.tooltext = smartLabel.oriText;
                  smartLabel.width = getWidth(smartLabel.text);
                  smartLabel.height = sl.lineHeight;
                  return smartLabel;
                }
              }
            }

            // fix for screenreader
            // container.innerHTML = "";

            smartLabel.text = tempArr.join('');
            smartLabel.width = strWidth;
            smartLabel.height = sl.lineHeight;
            return smartLabel;
          } else {
            for (; i < len; i += 1) {
              tempChar = tempArr[i] = oriTextArr[i];
              if (tempChar === ' ' && !context) {
                tempChar = '&nbsp;';
              }

              if (sl.cache[tempChar]) {
                minWidth = sl.cache[tempChar].width;
              } else {
                if (!getOriSizeImproveObj || !(minWidth = getOriSizeImproveObj.detailObj[tempChar])) {
                  minWidth = getWidth(tempChar);
                }
                sl.cache[tempChar] = {
                  width: minWidth
                };
              }
              strWidth += minWidth;

              if (strWidth > maxWidthWithEll) {
                if (!trimStr) {
                  trimStr = tempArr.slice(0, -1).join('');
                }
                if (strWidth > maxWidth) {
                  // TODO: Use regular expressions for better performance. */
                  lastSpace = text.substr(0, tempArr.length).lastIndexOf(' ');
                  lastDash = text.substr(0, tempArr.length).lastIndexOf('-');
                  if (lastSpace > lastIndexBroken) {
                    strWidth = getWidth(tempArr.slice(lastIndexBroken + 1, lastSpace).join(''));
                    tempArr.splice(lastSpace, 1, '<br/>');
                    lastIndexBroken = lastSpace;
                    newCharIndex = lastSpace + 1;
                  } else if (lastDash > lastIndexBroken) {
                    if (lastDash === tempArr.length - 1) {
                      strWidth = getWidth(tempArr.slice(lastIndexBroken + 1, lastSpace).join(''));
                      tempArr.splice(lastDash, 1, '<br/>-');
                    } else {
                      strWidth = getWidth(tempArr.slice(lastIndexBroken + 1, lastSpace).join(''));
                      tempArr.splice(lastDash, 1, '-<br/>');
                    }
                    lastIndexBroken = lastDash;
                    newCharIndex = lastDash + 1;
                  } else {
                    tempArr.splice(tempArr.length - 1, 1, '<br/>' + oriTextArr[i]);
                    lastLineBreak = tempArr.length - 2;
                    strWidth = getWidth(tempArr.slice(lastIndexBroken + 1, lastLineBreak + 1).join(''));
                    lastIndexBroken = lastLineBreak;
                    newCharIndex = i;
                  }
                  strHeight += sl.lineHeight;
                  if (strHeight > maxHeight) {
                    // fix for screenreader
                    // container.innerHTML = "";

                    smartLabel.text = fastTrim(trimStr) + ellipsesStr;
                    smartLabel.tooltext = smartLabel.oriText;
                    // The max width among all the lines will be the width of the string.
                    smartLabel.width = maxWidth;
                    smartLabel.height = strHeight - sl.lineHeight;
                    return smartLabel;
                  } else {
                    maxStrWidth = mathMax(maxStrWidth, strWidth);
                    trimStr = null;
                    nearestChar = getNearestChar(text.substr(newCharIndex), maxWidthWithEll, sl);
                    strWidth = getWidth(text.substr(newCharIndex, nearestChar || 1));
                    if (tempArr.length < newCharIndex + nearestChar) {
                      tempArr = tempArr.concat(text.substr(tempArr.length, newCharIndex + nearestChar - tempArr.length).split(''));
                      i = tempArr.length - 1;
                    }
                  }
                }
              }
            }

            maxStrWidth = mathMax(maxStrWidth, strWidth);

            // fix for screenreader
            // container.innerHTML = "";

            smartLabel.text = tempArr.join('');
            smartLabel.width = maxStrWidth;
            smartLabel.height = strHeight;
            return smartLabel;
          }
        } else {
          toolText = text.replace(spanAdditionRegx, '$2');
          text = text.replace(spanAdditionRegx, spanAdditionReplacer);
          text = text.replace(/(<br\s*\/*\>)/g, '<span class="' + [className, ' ', className2].join('') + '">$1</span>');

          container.innerHTML = text;

          spanArr = container[ChildRetriverFN](ChildRetriverSTRING);

          for (x = 0, y = spanArr.length; x < y; x += 1) {
            elem = spanArr[x];
            // chech whether this span is temporary inserted span from it's class
            if (noClassTesting || classNameReg.test(elem.className)) {
              chr = elem.innerHTML;
              if (chr !== '') {
                if (chr === ' ') {
                  spaceIndex = characterArr.length;
                } else if (chr === '-') {
                  dashIndex = characterArr.length;
                }

                characterArr.push({
                  spaceIdx: spaceIndex,
                  dashIdx: dashIndex,
                  elem: elem
                });
                oriTextArr.push(chr);
              }
            }
          }

          i = 0;
          len = characterArr.length;
          minWidth = characterArr[0].elem.offsetWidth;

          if (minWidth > maxWidth) {
            // fix for screenreader
            // container.innerHTML = "";

            smartLabel.text = '';
            smartLabel.width = smartLabel.oriTextWidth = smartLabel.height = smartLabel.oriTextHeight = 0;
            return smartLabel;
          } else if (minWidth > maxWidthWithEll && !this.showNoEllipses) {
            maxWidthWithEll = maxWidth - 2 * dotWidth;
            if (maxWidthWithEll > minWidth) {
              ellipsesStr = '..';
            } else {
              maxWidthWithEll = maxWidth - dotWidth;
              if (maxWidthWithEll > minWidth) {
                ellipsesStr = '.';
              } else {
                maxWidthWithEll = 0;
                ellipsesStr = '';
              }
            }
          }

          initialLeft = characterArr[0].elem.offsetLeft;
          initialTop = characterArr[0].elem.offsetTop;

          if (noWrap) {
            for (; i < len; i += 1) {
              elem = characterArr[i].elem;
              elemRightMostPoint = elem.offsetLeft - initialLeft + elem.offsetWidth;

              if (elemRightMostPoint > maxWidthWithEll) {
                if (!removeFromIndexForEllipses) {
                  removeFromIndexForEllipses = i;
                }
                if (container.offsetWidth > maxWidth) {
                  removeFromIndex = i;
                  i = len;
                }
              }
            }
          } else {
            for (; i < len; i += 1) {
              elem = characterArr[i].elem;
              elemLowestPoint = elem.offsetHeight + (elem.offsetTop - initialTop);
              elemRightMostPoint = elem.offsetLeft - initialLeft + elem.offsetWidth;

              lastBR = null;

              if (elemRightMostPoint > maxWidthWithEll) {
                if (!removeFromIndexForEllipses) {
                  removeFromIndexForEllipses = i;
                }

                if (elemRightMostPoint > maxWidth) {
                  lastSpace = characterArr[i].spaceIdx;
                  lastDash = characterArr[i].dashIdx;
                  if (lastSpace > lastIndexBroken) {
                    characterArr[lastSpace].elem.innerHTML = '<br/>';
                    lastIndexBroken = lastSpace;
                  } else if (lastDash > lastIndexBroken) {
                    if (lastDash === i) {
                      // in case the overflowing character itself is the '-'
                      characterArr[lastDash].elem.innerHTML = '<br/>-';
                    } else {
                      characterArr[lastDash].elem.innerHTML = '-<br/>';
                    }
                    lastIndexBroken = lastDash;
                  } else {
                    elem.parentNode.insertBefore(lastBR = doc.createElement('br'), elem);
                  }

                  // check whether this break made current element outside the area height
                  if (elem.offsetHeight + elem.offsetTop > maxHeight) {
                    // remove the lastly inserted line break
                    if (lastBR) {
                      lastBR.parentNode.removeChild(lastBR);
                    } else if (lastIndexBroken === lastDash) {
                      characterArr[lastDash].elem.innerHTML = '-';
                    } else {
                      characterArr[lastSpace].elem.innerHTML = ' ';
                    }
                    removeFromIndex = i;
                    // break the looping condition
                    i = len;
                  } else {
                    removeFromIndexForEllipses = null;
                  }
                }
              } else {
                // check whether this break made current element outside the area height
                if (elemLowestPoint > maxHeight) {
                  removeFromIndex = i;
                  i = len;
                }
              }
            }
          }

          if (removeFromIndex < len) {
            // set the trancated property of the smartlabel
            smartLabel.isTruncated = true;

            // TODO: Is this really needed?
            removeFromIndexForEllipses = removeFromIndexForEllipses || removeFromIndex;

            for (i = len - 1; i >= removeFromIndexForEllipses; i -= 1) {
              elem = characterArr[i].elem;
              // chech whether this span is temporary inserted span from it's class
              elem.parentNode.removeChild(elem);
            }

            for (; i >= 0; i -= 1) {
              elem = characterArr[i].elem;
              if (classNameBrReg.test(elem.className)) {
                // chech whether this span is temporary inserted span from it's class
                elem.parentNode.removeChild(elem);
              } else {
                i = 0;
              }
            }
          }

          // get the smart text
          smartLabel.text = container.innerHTML.replace(spanRemovalRegx, '$1').replace(/\&amp\;/g, '&');
          if (smartLabel.isTruncated) {
            smartLabel.text += ellipsesStr;
            smartLabel.tooltext = toolText;
          }
        }

        smartLabel.height = container.offsetHeight;
        smartLabel.width = container.offsetWidth;

        // fix for screenreader
        // container.innerHTML = "";

        return smartLabel;
      } else {
        smartLabel.error = new Error('Body Tag Missing!');
        return smartLabel;
      }
    },

    setStyle: function setStyle(style) {
      var sCont;

      if (!this.init) {
        return false;
      }

      if (style === this.style && !this.styleNotSet) {
        return;
      }

      if (!style) {
        style = this.style;
      }

      setLineHeight(style);
      this.style = style;

      this.containerObj = sCont = this.containerManager.get(style);

      if (this.containerObj) {
        this.container = sCont.node;
        this.context = sCont.context;
        this.cache = sCont.charCache;
        this.lineHeight = sCont.lineHeight;
        ellipsesWidth = sCont.ellipsesWidth;
        dotWidth = sCont.dotWidth;
        // avgCharWidth = sCont.dotWidth;
        this.styleNotSet = false;
      } else {
        this.styleNotSet = true;
      }
    },

    getTextSize: function getTextSize(text, maxWidth, maxHeight) {
      var smartLabel = {},
          container;

      if (!this.init) {
        return false;
      }
      smartLabel = {
        text: text,
        width: null,
        height: null,
        oriTextWidth: null,
        oriTextHeight: null,
        isTruncated: false
      };
      container = this.container;

      if (container) {
        // To get text size set the text as innerhtml
        container.innerHTML = text;
        // add oriTextWidth & oriTextHeight
        smartLabel.oriTextWidth = container.offsetWidth;
        smartLabel.oriTextHeight = container.offsetHeight;
        smartLabel.width = Math.min(smartLabel.oriTextWidth, maxWidth);
        smartLabel.height = Math.min(smartLabel.oriTextHeight, maxHeight);
        if (smartLabel.width < smartLabel.oriTextWidth || smartLabel.height < smartLabel.oriTextHeight) {
          smartLabel.isTruncated = true;
        }
      }
      return smartLabel;
    },

    getOriSize: function getOriSize(text) {
      var sl,
          smartLabel = {},
          container,
          getWidth,
          textLines,
          maxW = 0,
          i;

      if (!this.init) {
        return false;
      }

      sl = this;
      smartLabel = {
        text: text,
        width: null,
        height: null
      };
      container = sl.container;
      getWidth = sl.getWidthFunction();

      if (isBrowserLess) {
        // TODO: Avoid assuming non-formatted string here
        textLines = text.split(/(<br\s*\/*\>)/g);
        i = textLines.length;
        smartLabel.height = sl.lineHeight * i;
        while (i--) {
          maxW = mathMax(maxW, getWidth(textLines[i]));
        }
        smartLabel.width = maxW;
      } else if (container) {
        // To get text size set the text as innerhtml
        container.innerHTML = text;

        // add oriTextWidth & oriTextHeight
        smartLabel.width = container.offsetWidth;
        smartLabel.height = container.offsetHeight;
      }
      return smartLabel;
    },

    getOriSizeImprove: function getOriSizeImprove(text, detailedCalculationFlag) {
      var sl = this,
          textArr,
          letter,
          lSize,
          cumulativeSize = 0,
          height = 0,
          indiSizeStore = {},
          i,
          l;

      if (!this.init) {
        return false;
      }

      if (!detailedCalculationFlag) {
        return sl.calCharDimWithCache(text);
      }

      // calculate by lettrs
      textArr = text && text.split('');
      for (i = 0, l = text && textArr.length; i < l; i++) {
        letter = textArr[i];
        lSize = sl.calCharDimWithCache(letter, true, textArr.length);
        height = mathMax(height, lSize.height);
        cumulativeSize += lSize.width;
        indiSizeStore[letter] = lSize.width;
      }

      return {
        width: mathRound(cumulativeSize),
        height: height,
        detailObj: indiSizeStore
      };
    },

    calCharDimWithCache: function calCharDimWithCache(t, fflag, l) {
      var sl, container, s, size, cachedStyle, cache, advancedCacheKey, cacheName, cacheInitName, csArr, tw, twi, d;
      if (!this.init) {
        return false;
      }
      sl = this;
      container = sl.container;
      s = sl.style || {};
      cache = sl.advancedCache || (sl.advancedCache = {});
      advancedCacheKey = sl.advancedCacheKey || (sl.advancedCacheKey = []);
      cacheName = t + (s.fontSize || BLANK) + (s.fontFamily || BLANK) + (s.fontWeight || BLANK) + (s.fontStyle || BLANK);
      cacheInitName = t + 'init' + (s.fontSize || BLANK) + (s.fontFamily || BLANK) + (s.fontWeight || BLANK) + (s.fontStyle || BLANK);

      htmlSplCharSpace[t] && (t = htmlSplCharSpace[t]);
      if (!fflag) {
        d = 0;
      } else {
        if ((d = cache[cacheInitName]) === UNDEF) {
          container.innerHTML = t.repeat ? t.repeat(l) : Array(l + 1).join(t); // jshint ignore:line
          tw = container.offsetWidth;

          container.innerHTML = t;
          twi = container.offsetWidth;

          d = cache[cacheInitName] = (tw - l * twi) / (l + 1);
          advancedCacheKey.push(cacheInitName);
          if (advancedCacheKey.length > maxAdvancedCacheLimit) {
            delete cache[advancedCacheKey.shift()];
          }
        }
      }
      cachedStyle = cache[cacheName];
      if (cachedStyle) {
        csArr = cachedStyle.split(',');
        return {
          width: parseFloat(csArr[0], 10),
          height: parseFloat(csArr[1], 10)
        };
      }

      // place everything together
      container.innerHTML = t;

      size = {
        height: container.offsetHeight,
        width: container.offsetWidth + d
      };

      cache[cacheName] = size.width + ',' + size.height;
      advancedCacheKey.push(cacheName);
      if (advancedCacheKey.length > maxAdvancedCacheLimit) {
        delete cache[advancedCacheKey.shift()];
      }

      return size;
    }
  };

  SmartLabelManager.prototype.getOriSize = function (text) {
    return this.getOriSizeImprove(text, true);
  };

  SmartLabelManager.prototype.constructor = SmartLabelManager;

  return SmartLabelManager;
}();

exports['default'] = SmartLabelManager;

/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__(9);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(10);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2['default'] === "function" && typeof _iterator2['default'] === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2['default'] === "function" && obj.constructor === _symbol2['default'] && obj !== _symbol2['default'].prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                                                                                         * This module allows other FusionCharts JavaScript Library modules to raise
                                                                                                                                                                                                                                                                                                                                         * error and warning messages.
                                                                                                                                                                                                                                                                                                                                         * @private
                                                                                                                                                                                                                                                                                                                                         *
                                                                                                                                                                                                                                                                                                                                         * @module fusioncharts.debugger
                                                                                                                                                                                                                                                                                                                                         * @requires fusioncharts.constructor
                                                                                                                                                                                                                                                                                                                                         */

// import { _global } from '../constructor/constructor';


var _eventApi = __webpack_require__(7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

// function enableDibugging (_global) {
var UNDEF,

/**
 * Set the default options for the default output helper
 * @constant
 * @type String
 */
DEFAULT_OUTPUT_HELPER = 'text',
    DEBUGGER = 'debugger',
    logger; // namespace

/**
 * ~var {object} logger Conatins all routines pertaining to logging a debug
 * outout.
 */
logger = {
  /**
   * When debugger is enabled, it forwards its output to a callback function as explained in
   * {@link FusionCharts.debugger~debuggerCallback}. The parameters that can be forwarded to this callback
   * function can be adjusted based on the `outputFormat` set on the debugger. The `outputFormat`
   * can be configured using the function {@link FusionCharts.debugger.outputFormat} or by passing a format to
   * the third parameter of the function {@link FusionCharts.debugger.enable}.
   *
   * The different output formats that the debugger provides are:
   *
   * 1. `text` - (default) Meant for simple text output from the debugger
   * 2. `event` - Outputs the debugger messages in an event-like format, similar to
   *    {@link FusionCharts.eventListener}.
   * 3. `verbose` - Forwards all debugger messages and its associated arrguments as separate parameters.
   *
   * @name FusionCharts.debugger~outputFormats
   * @enum
   *
   * @property {string} text - With `text` set as the output format of debugger, the debugger callback function
   * receives only a single string parameter that contains details regarding the activities going on within the
   * FusionCharts framework.
   * @property {string} text.message - The single parameter that is passed on to the
   * {@link FusionCharts.debugger~debuggerCallback} function is the error message in a pre-formatted form
   * `#<event-id> fired "<event-name>" event.`
   *
   * @property {string} event - Function that calls the debugger method in typical FusionCharts events argument
   * format as specified in {@link FusionCharts~eventListener}. In this format, the output callback function
   * receives two arguments - the `eventObject` and the `eventArgument`.
   * @property {object} event.eventObject - This contains details regarding the event itself - such us the name
   * of the event, reference to the chart that raised this event, etc. More details regarding the properties of
   * this object is at {@link FusionCharts~eventListener}.
   * @property {object} event.eventArgument - This parameter is an object that contains information relevant to
   * the particular event being triggered. They are specific to each event.
   *
   * @property {string} verbose - This function formats outputs with all details, and still maintains a human
   * readable format. It is best used in conjunction with an advanced JavaScript console.
   * @property {number} verbose.eventId - This parameter is the incremental `id` that is associated to every new
   * event being fired. Even if the events are not received in order, their sequence of trigger can be inferred
   * from the event Id.
   * @property {string} verbose.senderId - The reference to the object that has triggered the debugger event.
   * @property {object} verbose.eventArguments - This parameter is an object that contains information relevant to
   * the particular event being triggered. They are specific to each event.
   */
  outputHelpers: {
    'text': function text(e, a) {
      var sender = (e.sender.id || e.sender).toString();
      logger.outputTo('#' + e.eventId + ' [' + sender + '] fired "' + e.eventType + '" event. ' + (e.eventType === 'error' || e.eventType === 'warning' ? a.message : ''));
    },

    'event': function event(e, a) {
      this.outputTo(e, a);
    },

    'verbose': function verbose(e, a) {
      logger.outputTo(e.eventId, e.sender.id, e.eventType, a);
    }
  },

  /**
   * ~var {object} outputHandler Is the eventHandler that indirectly calls
   * the output function via output helpers whenever any event is raised.
   */
  outputHandler: function outputHandler(e, a) {
    // Verify whether the output function exists or not.
    if (typeof logger.outputTo !== 'function') {
      // _global.core[DEBUGGER].outputFailed = true;
      return;
    }
    // Clear flag of data load fail upon rfcEach this line.
    // _global.core[DEBUGGER].outputFailed = false;
    // Call the current outputHelper in order to invoke the
    // required function.
    logger.currentOutputHelper(e, a);
  },

  /**
   * ~var {function} currentOutputHelper Is the function that formats the
   * debug output if event format to different formats as arguments.
   * ~var {function} outputTo Is the reference to the function that is
   * called when a debug event is raised.
   * ~var {boolean} keeps a track whether the logger is enabled or not.
   */
  currentOutputHelper: UNDEF,

  outputTo: UNDEF,

  enabled: false
};

// Set the initial default output helper to the one specified as default.
logger.currentOutputHelper = logger.outputHelpers[DEFAULT_OUTPUT_HELPER];

// Add debugger API to FusionCharts core object, so that it can be accessed
// by users globally.

/**
 * The `debugger` is used to trace errors within charts and verify the flow of events for a chart in case of
 * unexpected behaviors. The `debugger` logs all activities resulting from firing of all events in the
 * framwork.
 *
 * __For more information on how to enable the debugger, refer to {@link FusionCharts.debugger.enable}.__
 *
 * > The `debugger` should not be used in a production environment. It is intended only to be used in
 * > development or staging.
 * >
 * > To ensure compatibility with older versions of Internet Explorer, the `debugger` object should be called as
 * > `FusionCharts['debugger']` instead of `FusionCharts.debugger`.
 *
 * @namespace FusionCharts.debugger
 *
 * @example
 * // Use the debugger to output the debugger messages to JavaScript console.
 * FusionCharts["debugger"].enable(true, function (message) {
 *     console.log(message);
 * });
 */
exports['default'] = {
  'debugger': /** @lends FusionCharts.debugger */{
    /**
     * Specifies how to format the output of the function that will accept output from the debugger.
     *
     * @param {FusionCharts.debugger~outputFormats} format - Can be one of the accepted format names such as
     * `text`, `verbose`, `event` as available in {@link FusionCharts.debugger~outputFormats}.
     */
    outputFormat: function outputFormat(format) {
      // Validate the parameter.
      if (format && typeof format.toLowerCase === 'function' && typeof logger.outputHelpers[format = format.toLowerCase()] === 'function') {
        // set the current output helper function to the one specified
        // in parameter
        logger.currentOutputHelper = logger.outputHelpers[format];
        // Return "true" to users, indicating, output format
        // successfully updated.
        return true;
      }
      // In case validation fails, notify user that it failed by
      // returning false;
      return false;
    },

    /**
     * The debugger of FusionCharts framework is cabaple of receiving all messages, logs and events that occur
     * internally within the framework. However, the debugger has no way to output these messages. So, the
     * {@link FusionCharts.debugger~debuggerCallback} function needs to be attached to the debugger to which all
     * such debug messages get forwarded. This lets to output a custom function to output the message at a
     * desired location.
     *
     * This method allows specifying the function to which the debugger output will be redirected, i.e., the
     * activities of the debgger will be forwarded to a function provided through this method.
     *
     * @param {FusionCharts.debugger~debuggerCallback} debuggerCallback - This is the function to which the
     * debugger output will be passed on. Sending the value as `null` removes (detaches) the `debuggerCallback`
     * and subsequently disables the debugger.
     *
     * @example
     * <!-- In this example we will render a chart and output the debugger
     *      messages to an area within the page. -->
     * <html>
     * <head>
     * <script type="text/javascript" src="fusioncharts.js"></script>
     * <script type="text/javascript">
     * FusionCharts["debugger"].outputTo(function (message) {
     *     document.getElementById('debugger-output').innerHTML += '<p>' +
     *         message + '</p>';
     * });
     * FusionCharts["debugger"].enable(true);
     *
     * // Render a chart
     * FusionCharts.ready(function () {
     *     FusionCharts.render({
     *         type: 'pie2d',
     *         renderAt: 'chart-container',
     *         dataSource: {
     *             chart: {
     *                 caption: 'Sales Summary',
     *                 numberPrefix: '$'
     *             },
     *             data: [
     *                 { value: 234, label: 'Q1' },
     *                 { value: 167, label: 'Q2' },
     *                 { value: 110, label: 'Q3' },
     *                 { value: 36, label: 'Q4' }
     *             ]
     *         }
     *     });
     * });
     * </script>
     *
     * <!-- Style the debugger output to fix it in top right cormer of the page -->
     * <style type="text/css">
     * #debugger-output {
     *     position: absolute;
     *     top: 0;
     *     right:0;
     *     width: 300px;
     *     height: 125px;
     *     overflow: auto;
     * }
     * </style>
     * </head>
     * <body>
     *     <!-- we create a div element and position it in top
     *          right corner of the page -->
     *     <div id="debugger-output"></div>
     *     <div id="chart-container"></div>
     *  </body>
     *  </html>
     */
    outputTo: function outputTo(debuggerCallback) {
      // Check whether the logger is a function or not. If it is a
      // function, we set a reference to it to be used later as the
      // logger function.
      if (typeof debuggerCallback === 'function') {
        /**
         * The parameters passed on to the debugger callback function is in line with the value of
         * {@link FusionCharts.debugger~outputFormats} specified via {@link FusionCharts.debugger.outputTo}.
         * @callback FusionCharts.debugger~debuggerCallback
         *
         * @param {...*} outputFormatParameters - The parameters passed to the callback depend upon the
         * debugger output format set. The details regarding the different variants of parameter is at
         * {@link FusionCharts.debugger~outFormats}.
         */
        logger.outputTo = debuggerCallback;
      } else if (debuggerCallback === null) {
        // In case user sends 'null' as the value of the logger function,
        // we can assume that user wants not to log any output.
        // _global.core[DEBUGGER].enable(false);
        this.core[DEBUGGER].enable(false);
        delete logger.outputTo;
      }
    },

    /**
     * The FusionCharts debugger is not enabled by default. This method allows us to enable the debugger and
     * also optionally provide basic debugger configuration.
     *
     * The debugger works in conjunction with the browser's JavaScript console or any other special console-like
     * implementation that you may have. To enable the debugger, call this function and pass a callback that
     * outputs the message to the JavaScript console. The code would log the activities of every chart and the
     * entire framework.
     *
     * ```
     * FusionCharts['debugger'].enable(true, function (message) {
     *     console.log(message);
     * });
     * ```
     *
     * If you have added this code right after including the `fusioncharts.js` script in a page that renders a
     * single chart with id "myChart", your output would look somewhat like:
     *
     * ```
     * #1 [FusionCharts] fired "ready" event.
     * #2 [myChart] fired "beforeinitialize" event.
     * #3 [myChart] fired "beforedataupdate" event.
     * #4 [myChart] fired "dataupdated" event.
     * #5 [myChart] fired "initialized" event.
     * #6 [myChart] fired "beforerender" event.
     * #7 [myChart] fired "internal.loaded" event.
     * #8 [myChart] fired "internal.drawstart" event.
     * #9 [myChart] fired "dataloaded" event.
     * #10 [myChart] fired "internal.domelementcreated" event.
     * #11 [myChart] fired "loaded" event.
     * #12 [myChart] fired "drawcomplete" event.
     * #13 [myChart] fired "rendercomplete" event.
     * ```
     *
     * The output clearly shows that FusionCharts declared itself as `ready` and then the chart followed the
     * routine of initialising itself, loading data, loading dependencies and then completing the rendering
     * process. Had there been any error, it would have reflected in the output.
     *
     * > The debugger is not intended to be kept enabled on a production server since it has performance and
     * > memory requirement overhead. It is meant for pre-production debugging only.
     *
     * @param {boolean} state - Specifies whether to enable logging of debug information.
     *
     * @param {FusionCharts.debugger~debuggerCallback=} [outputTo] - The function to which the debugger output
     * will be passed on.
     *
     * @param {FusionCharts.debugger~outputFormats=} [outputFormat="text"] - Can be one of the accepted format
     * names such as "text", "verbose", "event".
     *
     * @return {boolean} The current 'enable' state of the debugger.
     */
    enable: function enable(state, outputTo, outputFormat) {
      // Allow object to be sent as configuration parameter.
      var config;
      // In case the first parameter is object and the only parameter,
      // we copy its contents to various linear parameters and save
      // a copy of the object for later use.
      if ((typeof state === 'undefined' ? 'undefined' : _typeof(state)) === 'object' && arguments.length === 1) {
        config = state;
        state = config.state;
        outputTo = config.outputTo;
        outputFormat = config.outputFormat;
      }

      // In case user send in only one parameter and that too a
      // function, we can assume that he wants to use it as a logger
      // function and also enable logging.
      if (typeof state === 'function') {
        if (typeof outputTo === 'string' && (arguments.length === 2 || config)) {
          outputFormat = outputTo;
        }
        outputTo = state;
        state = true;
      }

      // In case user sends in a valid parameter to change the current
      // state of the debugger, we update the debugger state.
      if (typeof state === 'boolean' && state !== logger.enabled) {
        logger.enabled = state;
        if (logger.enabled) {
          (0, _eventApi.addListener)('*', logger.outputHandler);
        } else {
          (0, _eventApi.removeListener)('*', logger.outputHandler);
        }
      }

      // If user sends in a parameter for the logger parameter, we
      // set it to the logger function reference.
      if (typeof outputTo === 'function') {
        logger.outputTo = outputTo;
      }

      // Set output format if needed.
      // _global.core[DEBUGGER].outputFormat(outputFormat);
      this.core[DEBUGGER].outputFormat(outputFormat);

      // Finally send the current debugger state to the user.
      return logger.enabled;
    }
  }
};

/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.raiseEventGroup = exports.raiseEventWithLegacy = undefined;

var _eventApi = __webpack_require__(7);

// function addEventAPI (root) {
//   var core = root.core,

//     // Facilitate for raising events internally.
//     // raiseEvent = root.raiseEvent = function (type, args, obj, originalEvent, defaultFn, cancelledFn) {
//     //   return triggerEvent(type, obj, args, originalEvent, defaultFn, cancelledFn);
//     // },

//     /**
//      * List of events that has an equivalent legacy event. Used by the
//      * raiseEvent method to check whether a particular event raised
//      * has any corresponding legacy event.
//      *
//      * @type object
//      */
//     legacyEventList = root.legacyEventList = {},

//     /**
//      * Maintains a list of recently raised conditional events
//      * @type object
//      */
var conditionChecks = {};

//   // root.disposeEvents = function (target) {
//   //   var type,
//   //     listeners = target && target !== core ? target._evtListeners : listeners;
//   //   // Iterate through all events in the collection of listeners
//   //   for (type in listeners) {
//   //     listeners[type].length && (listeners[type].length = 0);
//   //   }
//   // };
//   /**
//    * This method allows to uniformly raise events of FusionCharts
//    * Framework.
//    *
//    * @param {string} name specifies the name of the event to be raised.
//    * @param {object} args allows to provide an arguments object to be
//    * passed on to the event listeners.
//    * @param {core} obj is the FusionCharts instance object on
//    * behalf of which the event would be raised.
//    * @param {array} legacyArgs is an array of arguments to be passed on
//    * to the equivalent legacy event.
//    * @param {Event} source
//    * @param {function} defaultFn
//    * @param {function} cancelFn
//    *
//    * @type undefined
//    */
//   root.raiseEventWithLegacy = function (name, args, obj, legacyArgs,
//             eventScope, defaultFn, cancelledFn) {
//     var legacy = legacyEventList[name];
//     triggerEvent(name, obj, args, eventScope, defaultFn, cancelledFn);
//     if (legacy && window && typeof window[legacy] === 'function') {
//       setTimeout(function () {
//         window[legacy].apply(eventScope || window, legacyArgs);
//       }, 0);
//     }
//   };

//   /**
//    * This allows one to raise related events that are grouped together and
//    * raised by multiple sources. Usually this is used where a congregation
//    * of successive events need to cancel out each other and behave like a
//    * unified entity.
//    *
//    * @param {string} check is used to identify event groups. Provide same value
//    * for all events that you want to group together from multiple sources.
//    * @param {string} name specifies the name of the event to be raised.
//    * @param {object} args allows to provide an arguments object to be
//    * passed on to the event listeners.
//    * @param {core} obj is the FusionCharts instance object on
//    * behalf of which the event would be raised.
//    * @param {object} eventScope
//    * @param {function} defaultFn
//    * @param {function} cancelledFn
//    *
//    * @return {undefined}
//    */
//   root.raiseEventGroup = function (check, name, args, obj, eventScope, defaultFn, cancelledFn) {
//     var id = obj.id,
//       hash = check + id;

//     if (conditionChecks[hash]) {
//       clearTimeout(conditionChecks[hash]);
//       delete conditionChecks[hash];
//     } else {
//       if (id && hash) {
//         conditionChecks[hash] = setTimeout(function () {
//           triggerEvent(name, obj, args, eventScope, defaultFn, cancelledFn);
//           delete conditionChecks[hash];
//         }, 0);
//       } else {
//         triggerEvent(name, obj, args, eventScope, defaultFn, cancelledFn);
//       }
//     }
//   };

//   // Extend the eventlisteners to internal root.
//   // root.addEventListener = function (type, listener, bind) {
//   //   return addListener(type, listener, bind);
//   // };
//   // root.removeEventListener = function (type, listener, bind) {
//   //   return removeListener(type, listener, bind);
//   // };
//   // root.getEventListeners = function (type, bind) {
//   //   return getListeners(type, bind);
//   // };

//   extend2(core, /** @lends FusionCharts */ {
//     *
//      * Bind callbacks to events fired throughout FusionCharts. This method can be used to listen to events across
//      * all FusionCharts instances on a page.
//      *
//      * An event listener is used to execute custom functions when an event is fired. FusionCharts fires events at
//      * all stages of creating, updating, rendering or removing a chart. This function lets you tap into any of these
//      * events and provide your own functions which will be called when those events are triggered.
//      *
//      * An alternative to this function is to use {@link FusionCharts#addEventListener} method on a chart instance to
//      * bind to an event fired by a specific chart.
//      *
//      * @param {string|array} type - The event name to listen to. The event name is not case sensitive. In case you
//      * want to register an event to multiple events in the same registration call, provide them as an array of event
//      * names.
//      * @param {FusionCharts~eventListener} listener - Pass the function that is to be executed when the event is
//      * fired. Upon an event, the listeners for that event are executed sequentially with arguments that are specific
//      * to that event. See {@link FusionCharts~eventListener} for more details on the arguments.
//      *
//      * @group event-handling:add
//      * @example
//      * // Show a message when a number of charts have been rendered on a page.
//      * FusionCharts.ready(function {
//      *     var counter = 0,
//      *         threshold = 3;
//      *
//      *     FusionCharts.addEventListener("rendered", function (eventObject) {
//      *         counter++;
//      *         if (counter > threshold) {
//      *             alert("More than " + threshold + "charts rendered!");
//      *         }
//      *     });
//      * });

//     addEventListener: function (type, listener) {
//       return addListener(type, listener);
//     },
//     /**
//      * Removes an event that was originally added using {@link FusionCharts.addEventListener}.
//      * @param {string} type - The event name whose listener needs to be removed/detached.
//      * @param {function} listener - The listener function that needs to be removed.
//      *
//      * @group event-handling:remove
//      */
//     removeEventListener: function (type, listener) {
//       return removeListener(type, listener);
//     },

//     /**
//      * This function allows to register callback functions to be executed when FusionCharts library is ready to be
//      * used. In general, the framework is ready after `DOMContentLoaded` browser event has been fired and all the
//      * initial dependent files/modules are available. One can attach multiple callbacks by calling this function any
//      * number of time.
//      *
//      * The callback function is executed even when attached after FusionCharts is already ready! Thus, it is
//      * recommended that all entry-point and initialization codes are written within this block. This also helps in
//      * neatly organizing all codes within a script file or the page `<head>` and as such contextually separating
//      * code from HTML blocks.
//      *
//      * @param {FusionCharts~readyCallback} readyCallback - Pass a function that would be executed as callback when
//      * FusionCharts framework is ready.
//      * @param {*} [args={@link FusionCharts}] - Argument to be passed on to the callback function.
//      * @param {function=} [context={@link FusionCharts}] - In the situation where the function passed via `fn`
//      * parameter needs to be executed in a different scope than the default {@link FusionCharts} scope, pass the
//      * appropriate class object here.
//      *
//      * @example
//      * // Render a chart within a chart container `div` element.
//      * FusionCharts.ready(function (FusionCharts) {
//      *     var chart = new FusionCharts({
//      *         type: "column2d",
//      *         renderAt: "chart-container-div",
//      *         dataSource: "my-chart-data.json",
//      *         dataFormat: "jsonurl"
//      *     });
//      *     // Since we are in the `ready` block, the `chart-container-div`
//      *     // element should be available by now.
//      *     chart.render();
//      * });
//      */
//     ready: function (readyCallback, args, context) {
//       // Check if core is already ready or not. If not ready then we need  to attach the function to the ready
//       // event listener.
//       if (root.ready) {
//         // If it is already ready, we do not need to check for readiness subsequently as this state cannot ever
//         // rollback. Thus we redefine the function for performant consumption post readiness.
//         core.ready = function (callback, readyContext) {
//           (typeof callback === 'function') && setTimeout(function () {
//             /**
//              * The function passed as ready callback is executed when FusionCharts library is ready. Use
//              * {@link FusionCharts.ready} to request executing of your callback function.
//              * @callback FusionCharts~callback
//              * @param {FusionCharts|*} args - By default, the parameter passed to the callback function is
//              * the FusionCharts library class unless specified otherwise in the `args` parameter of
//              * {@link FusionCharts.ready}
//              */
//             callback.call(readyContext || core, args || core);
//           }, 0);
//         };
//         core.ready(readyCallback, context);
//       } else if (typeof readyCallback === 'function') {
//         core.addEventListener('ready', function () {
//           core.ready(readyCallback, args, context);
//         });
//       }

//       return this;
//     }
//   });
//   core.on = core.addEventListener; // alias

//   // Add eventListener extensibility to FusionCharts prototype so that individual FusionCharts objects can use
//   // per-chart events.
//   extend2(core.prototype, /** @lends FusionCharts# */ {
//     /**
//      * Listen to events fired by an individual chart. For more information on the available events, refer to the
//      * events section.
//      *
//      * @param {string|string[]} type - The event name that needs to be listened to. The event name is not case
//      * sensitive. In case you want to register an event to multiple events in the same registration call, provide
//      * them as an array of event names.
//      * @param {FusionCharts~eventListener} listener - Pass the function that is to be executed when the event is
//      * fired. Upon an event, the listeners for that event are executed sequentially with arguments that are
//      * specific to that event. See {@link FusionCharts~eventListener} for more details on the arguments.
//      *
//      * @group event-handling:add
//      */
//     addEventListener: function (type, listener) {
//       return addListener(type, listener, this);
//     },
//     /**
//      * Removes an event that was originally added using {@link FusionCharts#addEventListener}.
//      * @param {string} type - The event name whose listener needs to be removed/detached.
//      * @param {function} listener - The listener function that needs to be removed.
//      *
//      * @group event-handling:remove
//      */
//     removeEventListener: function (type, listener) {
//       return removeListener(type, listener, this);
//     }
//   });
//   core.prototype.on = core.prototype.addEventListener; // alias

//     // Add ability to parse events sent via core constructor.
//   root.policies.options.events = ['events', {}];

//   addListener('beforeInitialize', function (e) {
//     var chart = e.sender,
//       events = chart.options.events,
//       key;
//     if (events) {
//       for (key in events) {
//         if (typeof events[key] === 'function') {
//           chart.addEventListener(key, events[key]);
//         }
//       }
//     }
//   });

//   // Raise library initialization event, if not already done.

//   if (root.ready && !root.readyNotified) {
//     root.readyNotified = true;
//     /**
//      * @fires FusionCharts#ready
//      */
//     root.raiseEvent('ready', {
//       version: root.core.version,
//       now: root.readyNow
//     });
//   }
// }

// export default addEventAPI;

/**
 * This method allows to uniformly raise events of FusionCharts
 * Framework.
 *
 * @param {string} name specifies the name of the event to be raised.
 * @param {Object} args allows to provide an arguments object to be
 * passed on to the event listeners.
 * @param {Object} obj is the FusionCharts instance object on
 * behalf of which the event would be raised.
 * @param {Array} legacyArgs is an array of arguments to be passed on
 * to the equivalent legacy event.
 * @param {Event} eventScope
 * @param {Function} defaultFn
 * @param {Function} cancelledFn
 */
// /**
//  * This module allows FusionCharts to work with W3C Level 2 style events for
//  * allowing multiple handlers per event and also to do event driven development
//  * on a root or per-chart basis.
//  * @private
//  *
//  * @module fusioncharts.events
//  * @requires fusioncharts.constructor
//  * @requires fusioncharts.debugger
//  */
// import { extend2 } from '../../mantle/renderer-javascript/components/lib.js';
var raiseEventWithLegacy = exports.raiseEventWithLegacy = function raiseEventWithLegacy(name, args, obj, legacyArgs, eventScope, defaultFn, cancelledFn) {
  var legacy = this.legacyEventList[name];
  (0, _eventApi.triggerEvent)(name, obj, args, eventScope, defaultFn, cancelledFn);
  if (legacy && window && typeof window[legacy] === 'function') {
    setTimeout(function () {
      window[legacy].apply(eventScope || window, legacyArgs);
    }, 0);
  }
};

/**
 * This allows one to raise related events that are grouped together and
 * raised by multiple sources. Usually this is used where a congregation
 * of successive events need to cancel out each other and behave like a
 * unified entity.
 *
 * @param {string} check is used to identify event groups. Provide same value
 * for all events that you want to group together from multiple sources.
 * @param {string} name specifies the name of the event to be raised.
 * @param {object} args allows to provide an arguments object to be
 * passed on to the event listeners.
 * @param {core} obj is the FusionCharts instance object on
 * behalf of which the event would be raised.
 * @param {object} eventScope
 * @param {function} defaultFn
 * @param {function} cancelledFn
 */
var raiseEventGroup = exports.raiseEventGroup = function raiseEventGroup(check, name, args, obj, eventScope, defaultFn, cancelledFn) {
  var id = obj.id,
      hash = check + id;

  if (conditionChecks[hash]) {
    clearTimeout(conditionChecks[hash]);
    delete conditionChecks[hash];
  } else {
    if (id && hash) {
      conditionChecks[hash] = setTimeout(function () {
        (0, _eventApi.triggerEvent)(name, obj, args, eventScope, defaultFn, cancelledFn);
        delete conditionChecks[hash];
      }, 0);
    } else {
      (0, _eventApi.triggerEvent)(name, obj, args, eventScope, defaultFn, cancelledFn);
    }
  }
};

/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

exports.__esModule = true;

var _iterator = __webpack_require__(9);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(10);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2['default'] === "function" && typeof _iterator2['default'] === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2['default'] === "function" && obj.constructor === _symbol2['default'] && obj !== _symbol2['default'].prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */
var format = 'xml',
    UNDEF;

var COMPACTDATAMODE = 'compactdatamode',
    STRING = 'string',
    FUNCTION = 'function',
    OBJECT = 'object';

/**
 * Sanitises a string such that is cannot be used in XSS attacks.
 *
 * @param {string} s The string to be sanitised
 * @return {string} A sanitised string
 */
function xssEncode(s) {
  if (s === null || typeof s === 'undefined' || typeof s.toString !== 'function') {
    return '';
  }

  // do we convert to numerical or html entity?
  s = s.toString().replace(/&/g, '&amp;').replace(/\'/g, '&#39;') // no HTML equivalent as &apos is not cross browser supported
  .replace(/\"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

  return s;
}

/**
 * Trims a long string at lightning fast speed of less than an ms!
 *
 * @param {string} str The string to be trimmed.
 * @return {string} The trimmed string
 */
function fastTrim(str) {
  str = str.replace(/^\s\s*/, '');
  var ws = /\s/,
      i = str.length;
  while (ws.test(str.charAt(i -= 1))) {/* jshint noempty:false */}
  return str.slice(0, i + 1);
}

/**
 * Given a string, replaces its special characters with HTML safe entities
 *
 * @param {string} str A string with special characters
 * @return {string} A string with its special characters replaced by HTML safe entities
 */
function replaceSp(str) {
  return str.replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

var toJSON = function () {
  var XML_CHILDNODE = 1,
      XML_TEXTNODE = 3,
      rules = {
    /*
      * ~var {object} arr contains the nodeNames that are marked to be
      * expanded as an array.
      *
      * There are two ways of defining the type:
      * (a) in case the node is not constrained under a specific parent,
      * we simply specify <code>nodeName: true</code>
      *
      */
    arr: {
      set: true,
      trendlines: true,
      vtrendlines: true,
      line: {
        trendlines: true,
        vtrendlines: true
      },
      data: true,
      dataset: true,
      lineset: true,
      categories: true,
      category: true,
      tasks: true,

      // styles: true, // uncomment this to disable support for compact style syntax.
      linkeddata: true,

      // For application and definition, though we know that they are
      // always under <styles>, yet we cannot specify that here as these
      // two are in 'group' rule.
      application: true,
      definition: true,

      // PowerCharts group of rules
      axis: true,
      connectors: true,
      connector: {
        connectors: true
      },
      trendset: true,
      row: {
        rows: true
      },
      column: {
        columns: true
      },
      label: {
        labels: true
      },

      // Widgets specific rules
      color: {
        colorrange: true // gauges + powercharts
      },

      dial: {
        dials: true // gauge
      },
      pointer: {
        pointers: true // gauge
      },
      point: {
        trendpoints: true // gauge
      },

      // Gantt chart specific rules
      process: {
        processes: true // gantt
      },
      task: {
        tasks: true // gantt
      },
      milestone: {
        milestones: true // gantt
      },
      datacolumn: {
        datatable: true // gantt
      },
      text: {
        datacolumn: true // gantt
      },
      item: {
        legend: true // gantt
      },

      // alert manager for realtime charts and gauges
      alert: {
        alerts: true
      },

      // annotation specific rules
      groups: {
        annotations: true
      },
      items: {
        groups: true,
        data: true // first for maps in 3.4
      },

      // geo renderer specific rules
      shapes: true,
      shape: {
        shapes: true
      },
      entitydef: true, // map
      entity: {
        entitydef: true
      }
    },

    /**
     * ~var {object} tag contains nodeNames that are to be transformed
     * to a different nodeName as specified within this rule's meta.
     * note: supports comparison with base object.
     */
    tag: {
      chart: 'linkedchart',
      map: 'linkedmap',
      set: 'data',

      vline: {
        chart: 'data',
        graph: 'data', // legacy
        dataset: 'data',
        categories: 'category',
        linkedchart: 'data'
      },
      apply: {
        application: 'application'
      },
      style: {
        definition: 'definition'
      },

      marker: { // map
        application: 'application', // deprecated 3.4
        definition: 'definition', // deprecated 3.4
        data: 'items' // new in 3.4
      },

      entity: { // map
        entitydef: 'entitydef',
        data: 'data'
      },

      shape: { // map and powercharts
        shapes: 'shapes'
      },

      connector: { // map and powercharts
        connectors: {
          chart: 'connector',
          linkedchart: 'connector',
          map: 'connectors',
          linkedmap: 'connectors'
        }
      },

      // annotations
      annotationgroup: {
        annotations: 'groups'
      },
      annotation: {
        groups: 'items'
      }
    },

    /**
     * ~var {object} attr is the rule that defines the default
     * JSON variables to add in case a particular XML nodeName is found
     */
    attr: {
      vline: {
        vline: 'true'
      }
    },

    /**
     * ~var {object} ins contains nodeNames, that are treated as source
     * of attributes for a grand-child with same name as that of the
     * child.
     */
    ins: {
      chart: true,
      map: true,
      graph: true
    },

    /**
     * ~var {object} dsv contains nodeNames that are specially expected
     * to be delimiter separated textnodes. Useful for "compactDataMode".
     */
    dsv: {
      dataset: 'data',
      categories: 'category'
    },

    /**
     * ~var {object} text rule specifies the nodes that are always
     * treated as text node and appended to its parent with specified
     * name.
     *
     * When specified as an array, it denotes that the text values are
     * to be accumulated within a sibling array with specified name under
     * a specified parent.
     *
     * When enclosed in an object it specifies the parent restriction.
     *
     * NOTE: That for allowing text rule to work, to append it parent
     * we need to insert corresponding item in "group" rule.
     *
     * @example
     * nodeName: equivalentJSONKey // simple key: 'value' result
     */
    text: {
      target: 'target',
      value: 'value'
    },

    /**
     * ~var {object} group specifies which are the tags that are to
     * be promoted/inserted into its parent node (as in rule meta).
     */
    group: {
      styles: {
        definition: true,
        application: true
      },
      chart: {
        value: true, // widgets
        target: true // widgets
      },
      graph: { // legacy
        value: true, // legacy widgets
        target: true // legacy widgets
      },
      linkedchart: {
        value: true, // widgets
        target: true // widgets
      },
      // maps
      markers: {
        definition: true, // deprecated 3.4
        application: true, // deprecated 3.4
        shapes: true,
        connectors: true,
        data: true
      },
      map: {
        entitydef: true,
        data: true
      },
      linkedmap: {
        entitydef: true,
        data: true
      }
    }
  },
      parse,
      // namespace
  _parser,
      // function
  src;

  parse = {
    append: function append(childObj, obj, nodeName, parentNodeName) {
      // Before we append the childNode returned from the
      // previous recursion, we need to decide whether to
      // simply put that object with the nodeName as key, or
      // whether there is a qualification of 'arr' rule, by
      // which we push the data onto parent array.
      if (rules.arr[nodeName] && (rules.arr[nodeName] === true || rules.arr[nodeName][parentNodeName] === true)) {
        if (!(obj[nodeName] instanceof Array)) {
          obj[nodeName] = [];
        }
        obj[nodeName].push(childObj);
      } else {
        obj[nodeName] = childObj;
      }
    },

    child: function child(obj, children, parentNodeName, baseObj) {
      var i, nodeName, childNode, childObj, temp, rule;

      // Iterate through the children and parse it depending upon its
      // nodeType
      for (i = 0; i < children.length; i += 1) {
        // Retain reference to the child node
        childNode = children[i];

        // Desensitize the case of the nodeName
        nodeName = childNode.nodeName.toLowerCase();

        // When the child object is a child node, we need to recurse
        // onto it and also separately parse its attributes.
        switch (childNode.nodeType) {
          case XML_CHILDNODE:

            // Parse the attributes of the XML Node.
            childObj = parse.attr(childNode.attributes);

            rule = rules.ins[nodeName];
            if (rule === true) {
              // In case 'ins' rule is matched, we transfer the
              // parsed attributes to a grand-child having the node
              // name of child and rename the child to the new name
              // specified in the meta of 'tag' rule.
              temp = childObj;
              childObj = {};
              childObj[nodeName] = temp;
              temp = UNDEF;
            }

            // Apply the "attr" rule to add defalt flag variables.
            rule = rules.attr[nodeName];
            if ((typeof rule === 'undefined' ? 'undefined' : _typeof(rule)) === OBJECT) {
              global.extend(childObj, rule);
            }

            // Parse the tag rule.
            rule = rules.tag[nodeName];
            if (rule) {
              // Apply nodeName transformation 'tag' rule with
              // base-parent-child relationship.
              if ((typeof rule === 'undefined' ? 'undefined' : _typeof(rule)) === OBJECT && _typeof(rule[parentNodeName]) === OBJECT) {
                temp = UNDEF;
                for (temp in rule[parentNodeName]) {
                  if (baseObj[temp]) {
                    nodeName = rule[parentNodeName][temp];
                    break;
                  }
                }
              } else if ((typeof rule === 'undefined' ? 'undefined' : _typeof(rule)) === OBJECT &&
              // Apply nodeName transformation 'tag' rule with
              // parent-child relationship.
              _typeof(rule[parentNodeName]) === STRING) {
                nodeName = rule[parentNodeName];
              } else if ((typeof rule === 'undefined' ? 'undefined' : _typeof(rule)) === STRING) {
                // Apply nodeName transformation 'tag' rule with parent
                // independent relationship.
                nodeName = rule;
              }
            }
            // We now need to parse the rest of the childnodes as
            // recursed into this function.
            if (childNode.childNodes.length) {
              // Match the group rule. To check whether we need to append
              // the parsed children or treat the parsed children as siblings.
              rule = rules.group[parentNodeName];
              if (rule && rule[nodeName]) {
                parse.child(obj, childNode.childNodes, nodeName, baseObj);
              } else {
                parse.child(childObj, childNode.childNodes, nodeName, baseObj);
              }
            }

            // Append the computed childObject to parent depending
            // upon whether it has to be appended to an array or as
            // a child object.
            // Note: We append only when the "group" rule was not matched
            rule = rules.group[parentNodeName];
            if (!(rule && rule[nodeName])) {
              parse.append(childObj, obj, nodeName, parentNodeName);
            }
            break;

          // In case the child object is a text node and meets some
          // other requirements, we parse it as textNode
          case XML_TEXTNODE:

            // Parse mandatory text-node rule.
            rule = rules.text[parentNodeName];
            if (rule) {
              nodeName = rule;
              childObj = childNode.data;

              // Append the computed childObject to parent depending
              // upon whether it has to be appended to an array or as
              // a child object.
              parse.append(childObj, obj, nodeName, parentNodeName);
            }
            // Parse compact-data mode / optional text-node rule
            rule = rules.dsv[parentNodeName];
            if ((typeof rule === 'undefined' ? 'undefined' : _typeof(rule)) === STRING && baseObj.chart && parseInt(baseObj.chart[COMPACTDATAMODE], 10)) {
              // Create text node
              nodeName = rule;
              childObj = childNode.data;
              // Since this is DSV type text node, it is directly
              // appended to the object.
              obj[nodeName] = obj[nodeName] ? obj[nodeName] + childObj : childObj;
            }
            break;
        } // end switching based on node-type
      }
    },

    attr: function attr(attrObj) {
      var i,
          obj = {};
      // Check whether a valid xml attr NamedNode is passed.
      if (!attrObj || !attrObj.length) {
        return obj;
      }
      // Iterate through the attribute list and populate the return
      // object with the nodeValues.
      for (i = 0; i < attrObj.length; i += 1) {
        if (src === 'xml') {
          if (attrObj[i].value) {
            attrObj[i].value = replaceSp(attrObj[i].value);
          } else if (attrObj[i].nodeValue) {
            attrObj[i].nodeValue = replaceSp(attrObj[i].nodeValue);
          }
        }
        obj[attrObj[i].nodeName.toLowerCase()] = attrObj[i].value || attrObj[i].nodeValue;
      }

      // Finally return the converted object.
      return obj;
    }

  };

  _parser = function parser(xml) {
    var jsonObj = {},
        xmlDoc,
        xmlElem,
        root,
        rootName,
        newNode,
        nodeEle,
        rootAttrs,
        childNodes,
        i;
    // Validate parameters to check that xml can be converted into a string.
    if ((typeof xml === 'undefined' ? 'undefined' : _typeof(xml)) !== OBJECT && xml && _typeof(xml.toString) !== FUNCTION) {
      _parser.errorObject = new TypeError('xml2json.parse()');
      return jsonObj;
    }

    xml = xml.toString().replace(/<\!--[\s\S]*?-->/g, '') // remove xml comments
    .replace(/<\?xml[\s\S]*?\?>/ig, '') // remove xml definition
    // .replace(/\<\!\[cdata[\s\S]*?\]\]\>/ig, '') // remove CDATA
    // .replace(/(=\s*?\"[\s\S]*?\")(\w)/ig, '$1 $2') // fix whitespace attr with quot
    // .replace(/(=\s*?\'[\s\S]*?\')(\w)/ig, '$1 $2') // fix whitespace attr with apos
    .replace(/&(?!([^;\n\r]+?;))/g, '&amp;$1'); // fix ampersand
    xml = fastTrim(xml);

    // Check whether unwanted data like UNDEF, null blank string etc.
    if (!xml) {
      // parser.errorObject = new TypeError('xml2json.parse()');
      return jsonObj;
    }
    // Get XML Parser object depending upon browser capability and
    // subsequently load xml string.
    try {
      if (window.DOMParser) {
        xmlDoc = new window.DOMParser().parseFromString(xml, 'text/xml');
      } else {
        // Internet Explorer
        if (document.body && global.core.options.allowIESafeXMLParsing) {
          // Check if xml islands can be used
          xmlElem = document.createElement('xml');
          xmlElem.innerHTML = xml;
          document.body.appendChild(xmlElem);
          xmlDoc = xmlElem.XMLDocument;
          document.body.removeChild(xmlElem);
          xmlElem = null;
        } else {
          xmlDoc = new window.ActiveXObject('Microsoft.XMLDOM');
          xmlDoc.async = 'false';
          xmlDoc.loadXML(xml);
        }
      }

      if (!(xmlDoc && xmlDoc.childNodes && xmlDoc.childNodes.length === 1 && (root = xmlDoc.childNodes[0]) && root.nodeName && (rootName = root.nodeName.toLowerCase()) && (rootName === 'chart' || rootName === 'map' || rootName === 'graph'))) {
        _parser.errorObject = new TypeError('xml2json.parse()');
        return jsonObj;
      } else if (rootName === 'graph') {
        newNode = xmlDoc.createElement('chart');
        rootAttrs = root.attributes;
        i = rootAttrs && rootAttrs.length || 0;
        while (i--) {
          newNode.setAttribute(rootAttrs[i].name, rootAttrs[i].value);
          rootAttrs.removeNamedItem(rootAttrs[i].name);
        }

        childNodes = root.childNodes;
        i = childNodes && childNodes.length || 0;

        if (i) {
          i -= 1;
          nodeEle = root.removeChild(childNodes[i]);
          newNode.appendChild(nodeEle);
        }

        while (i--) {
          nodeEle = root.removeChild(childNodes[i]);
          newNode.insertBefore(nodeEle, newNode.firstChild);
        }

        xmlDoc.replaceChild(newNode, root);
        root = newNode;
      }
    } catch (e) {
      _parser.errorObject = e;
    }

    if (root) {
      // Do initial attribute parsing
      if (root.attributes) {
        jsonObj[rootName] = parse.attr(root.attributes);
      }

      // Parse all childNodes.
      if (root.childNodes) {
        parse.child(jsonObj, root.childNodes, rootName, jsonObj);
      }

      // Delete error flag.
      delete _parser.errorObject;
    } else {
      _parser.errorObject = new TypeError('xml2json.parse()');
    }

    return jsonObj;
  };

  return function (xml) {
    // Clear error flags of parser.
    delete _parser.errorObject;
    src = arguments[arguments.length - 1];
    // Call JSON2XML parser to retrieve the parsed data.
    var jsonData = _parser(xml);

    // Compile a return object for encoding function.
    return {
      data: jsonData,
      error: _parser.errorObject
    };
  };
}(),
    fromJSON = function () {
  var rules, // namespace
  _parser2; // function

  rules = {
    /*
      * ~var {object} items Collection of rules that are required to convert
      * JSON to FusionCharts XML.
      *
      * note: The rules are in the form:
      *       ruleType: { namespace: { nodeName: ruleMeta } }
      */
    items: {
      /**
       * ~var {object} explode Comprises of JSON attributes that needs to
       * be converted to a particular set of nodes. Generally the value of
       * such attributes/properties are an array of objects. Each object
       * in these arrays are converted to a particular XML node specified
       * within the rule meta.
       *
       * note: this rule is applied at the end, after all rules are applied
       */
      explode: {
        data: 'set',
        groups: {
          annotations: 'annotationgroup'
        },
        items: {
          groups: 'annotation'
        }
      },

      /**
       * ~var {object} text Comprises of JSON keys that are to be
       * always treated as text-node
       */
      text: {
        chart: {
          target: 'target',
          value: 'value'
        },
        graph: { // legacy
          target: 'target',
          value: 'value'
        }
      },

      /**
       * ~var {object} dsv contains nodeNames that are specially expected
       * to be delimiter separated textnodes. Useful for "compactDataMode".
       */
      dsv: {
        dataset: {
          data: 'dataset'
        },
        categories: {
          category: 'categories'
        }
      },

      /**
       * ~var {object} attr Comprises of JSON attributes whose values are
       * always added to the XML attributes of its namespace. Such nodes
       * generally are object containing strings. The keys within them
       * are to be converted to XML attributes and the values become XML
       * attribute values.
       *
       */
      attr: {
        chart: {
          chart: 'chart'
        },
        graph: { // legacy
          graph: 'graph'
        },
        map: {
          map: 'map'
        },
        linkedmap: {
          map: 'map'
        },
        linkedchart: {
          chart: 'chart'
        }

      },

      /**
       * ~var {object} group Comprises of JSON attributes whose children
       * are to be grouped under a particular node. The parentNode where
       * it has to be grouped are specified in the rule meta.
       *
       * @example
       * catch-object {
       *     having-name: and-put-content-as
       * }
       * result:
       * <catch-object>
       *   <having-name>
       *     <and-put-content-as />
       *     <and-put-content-as />
       *   </having-name>
       * </catch-object>
       *
       * -- also --
       * When this rule matches x for y:
       * x: [a, b, c] is <y><x a /><x b /><x c/></y>
       */
      group: {
        styles: {
          definition: 'style',
          application: 'apply'
        },
        map: {
          data: 'entity',
          entitydef: 'entity'
        },
        markers: { // for maps
          definition: 'marker', // deprecated 3.4
          application: 'marker', // deprecated 3.4
          shapes: 'shape',
          connectors: 'connector',
          items: 'marker'
        }
      },

      /*
        * ~var {object} Contains the rules for renaming tags (json keys)
        * during parsing. Changes `item` of parser in case of group,
        * attr, text. Note that explode rule also changes node name
        */
      tag: {
        markers: {
          items: 'data'
        }
      }
    },

    /**
     * This method verifies whether a name-item pair qualifies for a
     * rule or not. If so, it also returns the meta information of the
     * qualified rule.
     *
     * @param {string} rule is the name of the rule that you want to
     * verify. There must be a corresponding rule group in the items
     * object.
     * @param {variant} item The item to be comapred against the rule
     * @param {variant} namespace The namespace of the item that the rule is a part of
     *
     * @return {Object} Information about the rule, if any
     */
    qualify: function qualify(rule, item, namespace) {
      return _typeof(this.items[rule][namespace]) === OBJECT ? this.items[rule][namespace][item] : this.items[rule][namespace];
    }
  };

  /**
   * This function accepts a JSON object and converts it to FusionCharts
   * data xml.
   *
   * @param {Object} obj JSON object to be parsed.
   * @param {string} namespace is the parent/root namespace within which
   * the JSON object is contained.
   * @param {Object} namespaceparent the parent namespace
   * @param {Object} flags XMl flags
   *
   * @return {string} The XML equialent of the supplied JSON
   */
  _parser2 = function parser(obj, namespace, namespaceparent, flags) {
    // Initialize variables that stores the current namespace's XML
    // construction parameters.
    /**
     * ~var {string} attrString The serialized set of attributes key:value
     *      pairs generated for this namespace.
     * ~var {string} innerXML The innerXML of the node generated in this NS.
     * ~var {string} nodeName The current node name devised from the NS.
     * ~var {string} outerXML The outer XML generated for this JSON tree.
     * ~var {string} item The current child being processed within an NS.
     * ~var {string} lcaseItem The case desensitized current node item.
     * ~var {string} lcaseNS The case desensitized namespace.
     */
    var attrString = '',
        innerXML = '',
        outerXML = '',
        trailXML = '',
        tagName,
        item,
        lowerItem,
        qualifier;

    // Desensitize case of namespace.
    if (namespace && typeof namespace.toLowerCase === 'function') {
      namespace = namespace.toLowerCase();
    }

    // Special root namespace flag setting
    if (namespaceparent === UNDEF && obj[namespace]) {
      for (item in obj[namespace]) {
        lowerItem = item.toLowerCase();
        if (lowerItem === COMPACTDATAMODE) {
          flags.applyDSV = obj[namespace][item] === 1;
        }
      }
    }

    // In case the object is an array, apply explosion rule.
    if (obj instanceof Array) {
      // Iterate through every item within the array and expand it.
      for (item = 0; item < obj.length; item += 1) {
        // If the value of the node is string we expand its contents
        // into the content of the node for COMPACT_MODE data
        if (_typeof(obj[item]) === STRING) {
          outerXML += xssEncode(obj[item]);
        } else {
          // If the node is not string, we process its contents as
          // another node.
          outerXML += _parser2(obj[item], namespace, namespaceparent, flags);
        }
      }
    } else {
      // For any other data-type other than Array we iterate through the
      // contents of the variable and parse each node.
      for (item in obj) {
        // Store a lower-case version of this
        // Remove all special characters including space except ".", "_", "-"
        // if present in namespace, as DOM parser fails to convert that node
        lowerItem = item.toLowerCase().replace(/[`~!@#$%^&*()|+\=?;:'", <>\{\}\[\]\\\/]/gi, '');

        // Parse "group" rule. Here, we test whether we are to group
        // a JSON Array under a particular XML node.
        // @example where this rule matches x for y:
        // x: [a, b, c] is <y><x a /><x b /><x c/></y>
        if (obj[item] instanceof Array && (qualifier = rules.qualify('group', lowerItem, namespace))) {
          tagName = rules.qualify('tag', lowerItem, namespace) || lowerItem;
          innerXML += '<' + tagName + '>' + _parser2(obj[item], qualifier, namespace, flags) + '</' + tagName + '>';
        } else if (_typeof(obj[item]) === OBJECT) {
          // Parse "attr" rule. Here we test whether to use the items
          // within a particular item as the XML attributes of the
          // parent namespace.
          // Check whether there is a qualifying rule for using
          // an OBJECT as source of attributes of a namespace.
          if (qualifier = rules.qualify('attr', lowerItem, namespace)) {
            trailXML = _parser2(obj[item], qualifier, namespace, flags).replace(/\s*\/\>/ig, '');
            namespace = lowerItem;
          } else {
            // Otherwise, recurse the parser to process the object
            // as a child JSON object.
            innerXML += _parser2(obj[item], lowerItem, namespace, flags);
          }
        } else {
          // Parse "vLine" and other static rules.
          if (flags.applyDSV && (qualifier = rules.qualify('dsv', lowerItem, namespace))) {
            innerXML += obj[item];
          } else if (qualifier = rules.qualify('text', lowerItem, namespace)) {
            // Check for text qualifier
            tagName = rules.qualify('tag', lowerItem, namespace) || qualifier;
            innerXML += '<' + tagName + '>' + obj[item] + '</' + tagName + '>';
          } else if (lowerItem === 'vline' && Boolean(obj[item])) {
            namespace = 'vline';
          } else {
            attrString += ' ' + lowerItem + '=\"' + xssEncode(obj[item]).toString().replace(/\"/ig, '&quot;') + '\"';
          }
        }
      }

      // When parsing completes, we need to check whether we have any
      // namespace adjustments or not.
      // Explode rule.
      if (qualifier = rules.qualify('explode', namespaceparent, namespace)) {
        namespace = qualifier;
      }
      // this tagname  is not influenced by rule since the explode rule
      // is the one doing the job here.
      tagName = namespace;

      // Build the final XML node string.
      outerXML = (trailXML !== '' ? trailXML : '<' + tagName) + attrString + (innerXML !== '' ? '>' + innerXML + '</' + tagName + '>' : ' />');
    }

    return outerXML;
  };

  return function (jsonData) {
    // Clear error flags of parser.
    delete _parser2.errorObject;

    // In case user sends the JSON data as STRING, we need to parse
    // it and convert to JSON object.
    if (jsonData && (typeof jsonData === 'undefined' ? 'undefined' : _typeof(jsonData)) === STRING) {
      // Parse the data within atry block in order to receive all
      // errors.
      try {
        jsonData = JSON.parse(jsonData);
      } catch (e) {
        _parser2.errorObject = e;
      }
    }

    // Call JSON2XML parser to retrieve the parsed data.
    var rootNS = jsonData && jsonData.graph ? 'graph' : jsonData && jsonData.map ? 'map' : 'chart',
        xmlData = _parser2(jsonData, rootNS, UNDEF, {});

    // Compile a return object for encoding function.
    return {
      data: xmlData,
      error: _parser2.errorObject
    };
  };
}();

exports['default'] = {
  extension: {
    format: format,
    toJSON: toJSON,
    fromJSON: fromJSON
  },
  name: 'XML',
  type: 'transcoder'
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)))

/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
/* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */
/**
 * handles transcoding between JSON data
 *
 * @param {Object | string} input JSON input as a string or as an object
 * @return {Object} A JSON object
 */
function json2json(input) {
  var out = {
    data: {}
  };

  if (!input) {
    return out;
  }

  if (typeof input === 'string') {
    try {
      out.data = JSON.parse(input);
    } catch (err) {
      out.error = err;
    }
  } else {
    out.data = input;
  }

  return out;
}

exports['default'] = {
  extension: {
    format: 'json',
    toJSON: json2json,
    fromJSON: json2json
  },
  name: 'JSON',
  type: 'transcoder'
};

/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _eventApi = __webpack_require__(7);

var _urlTranscoderUtils = __webpack_require__(186);

/* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */
var BASE_FORMAT = 'json';

var UNDEF = void 0;

/**
 * Fetches JSON from the given URL.
 *
 * @param {string}   url           The URL from which to fetch data
 * @param {Object}   config        The arguments to be passed to the callback functions of the
 *                                 'dataLoadrequested' event
 * @param {Function} callback      The callback to be invoked after the data is fetched
 * @param {boolean}  silent        Silence errors or warnings associated with the data
 * @param {Object}   chartInstance The instance of the chart which asked for the data to be loaded
 */
function fetchJSON(url, config, callback, silent, chartInstance) {
  (0, _eventApi.triggerEvent)('dataLoadRequested', chartInstance, {
    source: _urlTranscoderUtils.sourceName,
    url: url,
    dataFormat: BASE_FORMAT,
    silent: !!silent,
    config: config,
    successcallback: callback
  }, UNDEF, _urlTranscoderUtils.onDataLoadRequest, _urlTranscoderUtils.onDataLoadRequestCancel);
}

exports['default'] = {
  extension: {
    format: 'jsonurl',
    toJSON: fetchJSON
  },
  name: 'JSONUrl',
  type: 'transcoder'
};

/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _eventApi = __webpack_require__(7);

var _urlTranscoderUtils = __webpack_require__(186);

/* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */
var BASE_FORMAT = 'xml';

var UNDEF = void 0;

/**
 * Fetches XML from the given URL.
 *
 * @param {string}   url           The URL from which to fetch data
 * @param {Object}   config        The arguments to be passed to the callback functions of the
 *                                 'dataLoadrequested' event
 * @param {Function} callback      The callback to be invoked after the data is fetched
 * @param {boolean}  silent        Silence errors or warnings associated with the data
 * @param {Object}   chartInstance The instance of the chart which asked for the data to be loaded
 */
function fetchXML() {
  var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var callback = arguments[2];
  var silent = arguments[3];
  var chartInstance = arguments[4];

  (0, _eventApi.triggerEvent)('dataLoadRequested', chartInstance, {
    source: _urlTranscoderUtils.sourceName,
    url: url,
    dataFormat: BASE_FORMAT,
    silent: !!silent,
    config: config,
    successcallback: callback
  }, UNDEF, _urlTranscoderUtils.onDataLoadRequest, _urlTranscoderUtils.onDataLoadRequestCancel);
}

exports['default'] = {
  extension: {
    format: 'xmlurl',
    toJSON: fetchXML
  },
  name: 'XMLUrl',
  type: 'transcoder'
};

/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _stringify = __webpack_require__(42);

var _stringify2 = _interopRequireDefault(_stringify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */
var QUOT = '\"',
    QUOTCOLON = '\":';

/**
 * Listens to the FusionCharts' 'beforedataupdate' event to convert all keys in the user's input
 * JSON to lower case.
 *
 * @param {Object} FusionCharts The FusionCharts class on which the extension will attach its
 *                              listener
 */
function ignoreCaseExt(FusionCharts) {
  // eslint-disable-next-line
  FusionCharts.addEventListener('beforedataupdate', function (event, args) {
    var dataSource = (0, _stringify2['default'])(args.dataSource);

    args.dataSource = JSON.parse(dataSource.replace(/"([^"]+)"[\s]*:/g, function () {
      return QUOT + arguments[1].toLowerCase() + QUOTCOLON;
    }));
  });
}

exports['default'] = {
  extension: ignoreCaseExt,
  name: 'IgnoreCaseExt',
  type: 'extension',
  requiresFusionCharts: true
};

/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

var core  = __webpack_require__(19)
  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});
module.exports = function stringify(it){ // eslint-disable-line no-unused-vars
  return $JSON.stringify.apply($JSON, arguments);
};

/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__(9);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(10);

var _symbol2 = _interopRequireDefault(_symbol);

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _typeof = typeof _symbol2['default'] === "function" && typeof _iterator2['default'] === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2['default'] === "function" && obj.constructor === _symbol2['default'] && obj !== _symbol2['default'].prototype ? "symbol" : typeof obj; }; /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */


var _componentInterface = __webpack_require__(6);

var _componentInterface2 = _interopRequireDefault(_componentInterface);

var _dependencyManager = __webpack_require__(80);

var _eventApi = __webpack_require__(7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var UNDEF = void 0,
    BLANK = '',
    OBJECTSTRING = 'object',
    arrayToStr = '[object Array]',
    objectToStr = '[object Object]',
    themer = void 0,
    isImportantRegEx = /\s+!important$/,
    importantStrRegEx = /\\!important$/,

/**
 * Gets all currently registered themes with FusionCharts
 *
 * @param {Object} addedThemes The raw theme dependencies of FusionCharts
 *
 * @return {Object} The theme object prepared for use with ThemeManager#themify
 */
getRegisteredThemes = function getRegisteredThemes(addedThemes) {
  var themes = {},
      theme = void 0;

  for (var key in addedThemes) {
    if (addedThemes.hasOwnProperty(key)) {
      theme = addedThemes[key];
      themes[theme.name] = theme;
    }
  }

  return themes;
},
    trimString = function trimString(strArg) {
  var str = strArg.replace(/^\s\s*/, ''),
      ws = /\s/,
      i = str.length;

  while (ws.test(str.charAt(i -= 1))) {/* jshint noempty:false */}
  return str.slice(0, i + 1);
},
    checkCyclicRef = function checkCyclicRef(obj, parentArr) {
  var i = parentArr.length,
      bIndex = -1;

  while (i--) {
    if (obj === parentArr[i]) {
      bIndex = i;
      return bIndex;
    }
  }

  return bIndex;
},
    merge = function merge(obj1, obj2, skipUndef, tgtArr, srcArr) {
  var item, srcVal, tgtVal, str, cRef;

  if (!srcArr) {
    tgtArr = [obj1];
    srcArr = [obj2];
  } else {
    tgtArr.push(obj1);
    srcArr.push(obj2);
  }

  if (obj2 instanceof Array) {
    for (item = 0; item < obj2.length; item += 1) {
      try {
        srcVal = obj1[item];
        tgtVal = obj2[item];
      } catch (e) {
        continue;
      }

      if ((typeof tgtVal === 'undefined' ? 'undefined' : _typeof(tgtVal)) !== OBJECTSTRING) {
        if (!(skipUndef && tgtVal === UNDEF)) {
          obj1[item] = tgtVal;
        }
      } else {
        if (srcVal === null || (typeof srcVal === 'undefined' ? 'undefined' : _typeof(srcVal)) !== OBJECTSTRING) {
          srcVal = obj1[item] = tgtVal instanceof Array ? [] : {};
        }
        cRef = checkCyclicRef(tgtVal, srcArr);
        if (cRef !== -1) {
          srcVal = obj1[item] = tgtArr[cRef];
        } else {
          merge(srcVal, tgtVal, skipUndef, tgtArr, srcArr);
        }
      }
    }
  } else {
    for (item in obj2) {
      try {
        srcVal = obj1[item];
        tgtVal = obj2[item];
      } catch (e) {
        continue;
      }

      if (tgtVal !== null && (typeof tgtVal === 'undefined' ? 'undefined' : _typeof(tgtVal)) === OBJECTSTRING) {
        // Fix for issue BUG: FWXT-602
        // IE < 9 Object.prototype.toString.call(null) gives
        // '[object Object]' instead of '[object Null]'
        // that's why null value becomes Object in IE < 9
        str = Object.prototype.toString.call(tgtVal);
        if (str === objectToStr) {
          if (srcVal === null || (typeof srcVal === 'undefined' ? 'undefined' : _typeof(srcVal)) !== OBJECTSTRING) {
            srcVal = obj1[item] = {};
          }
          cRef = checkCyclicRef(tgtVal, srcArr);
          if (cRef !== -1) {
            srcVal = obj1[item] = tgtArr[cRef];
          } else {
            merge(srcVal, tgtVal, skipUndef, tgtArr, srcArr);
          }
        } else if (str === arrayToStr) {
          if (srcVal === null || !(srcVal instanceof Array)) {
            srcVal = obj1[item] = [];
          }
          cRef = checkCyclicRef(tgtVal, srcArr);
          if (cRef !== -1) {
            srcVal = obj1[item] = tgtArr[cRef];
          } else {
            merge(srcVal, tgtVal, skipUndef, tgtArr, srcArr);
          }
        } else {
          obj1[item] = tgtVal;
        }
      } else {
        obj1[item] = tgtVal;
      }
    }
  }
  return obj1;
},
    extend2 = function extend2(obj1, obj2, skipUndef) {
  // if none of the arguments are object then return back
  if ((typeof obj1 === 'undefined' ? 'undefined' : _typeof(obj1)) !== OBJECTSTRING && (typeof obj2 === 'undefined' ? 'undefined' : _typeof(obj2)) !== OBJECTSTRING) {
    return null;
  }

  if ((typeof obj2 === 'undefined' ? 'undefined' : _typeof(obj2)) !== OBJECTSTRING || obj2 === null) {
    return obj1;
  }

  if ((typeof obj1 === 'undefined' ? 'undefined' : _typeof(obj1)) !== OBJECTSTRING) {
    obj1 = obj2 instanceof Array ? [] : {};
  }
  merge(obj1, obj2, skipUndef);
  return obj1;
},
    checkImportance = function checkImportance(value) {
  var returnObj = {
    important: false,
    str: BLANK
  };

  if (!value) {
    return returnObj;
  }

  value = value.toString();
  if (isImportantRegEx.test(value)) {
    value = value.replace(isImportantRegEx, BLANK);
    returnObj.important = true;
  } else {
    value = value.replace(importantStrRegEx, '!imporant');
    returnObj.important = false;
  }
  returnObj.str = value;
  return returnObj;
},
    mergeThemeWithData = function mergeThemeWithData(dataJSON, themeComponent) {
  var items = themeComponent.getAll(),
      key,
      valStr,
      imp;

  for (key in items) {
    valStr = items[key].toString();
    imp = checkImportance(valStr);
    if (imp.important) {
      dataJSON[key.toLowerCase()] = imp.str;
    } else if (dataJSON[key.toLowerCase()] === UNDEF) {
      dataJSON[key.toLowerCase()] = imp.str;
    }
  }
},
    onChartTypeChange = function onChartTypeChange(eventObj, args) {
  var chartObj = eventObj.sender,
      dataObj = chartObj.getChartData((0, _dependencyManager.getDepsByType)('transcoder').JSON, true),
      chartTheme;

  if (!dataObj.error) {
    chartTheme = dataObj.data.chart.theme;
    if (chartTheme) {
      themer.themify(chartTheme, chartObj, chartObj.chartType(), dataObj.data, args.defaultSeriesType === 'geo' && 'geo');
    } else {
      chartObj.jsVars && chartObj.jsVars.themeObject && chartObj.jsVars.themeObject.dispose();
    }
  }
},
    recursiveApply = function recursiveApply(dataObj, themeObject) {
  var key,
      dataItem,
      themeComponent,
      item,
      i,
      ii,
      vLineIndex = 0,
      // needed for the special handling of vlines in the category array
  catIndex = 0; // needed for the special handling of vlines in the category array

  for (key in dataObj) {
    dataItem = dataObj[key];
    if (dataItem instanceof Array) {
      ii = dataItem.length;
      for (i = 0; i < ii; i += 1) {
        item = dataItem[i];
        if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object') {
          if (key === 'category') {
            // The category array in the data needs special handling as it may
            // contain vlines also which are in the same array as the categories
            // enumerated on the xaxis. By handling this exception, we can theme
            // the vlines separately.
            if (item.vline === 'true') {
              themeComponent = themeObject.component('vline', vLineIndex, item);
              if (themeComponent) {
                mergeThemeWithData(item, themeComponent);
                vLineIndex += 1;
              }
            } else {
              themeComponent = themeObject.component('category', catIndex, item, ii);
              if (themeComponent) {
                mergeThemeWithData(item, themeComponent);
                catIndex += 1;
              }
            }
          } else {
            themeComponent = themeObject.component(key, i, item, ii);
            if (themeComponent) {
              mergeThemeWithData(item, themeComponent);
              recursiveApply(item, themeComponent);
            }
          }
        }
      }
    } else if ((typeof dataItem === 'undefined' ? 'undefined' : _typeof(dataItem)) === 'object') {
      themeComponent = themeObject.component(key, null, dataItem);
      if (themeComponent) {
        mergeThemeWithData(dataItem, themeComponent);
        recursiveApply(dataItem, themeComponent);
      }
    }
  }
},
    onDrawStart = function onDrawStart(event, args) {
  if (args.defaultSeriesType === 'geo') {
    onChartTypeChange.call(this, event, args);
  }
};

/**
 * The ThemeManager is a class that exists at the FusionCharts framework
 * level i.e there is one instance of this class in the whole framework.
 *
 * This class is responsible for
 * - storing all the themes that are registered with it
 * - evaluating the final theme that get applied to the chart from the
 * theme file that contains themes for single as well as repeating elements
 * - creating a theme instance per chart instance that contains the theme
 * related details corresponding to the chart
 */

var ThemeManager = function (_ComponentInterface) {
  _inherits(ThemeManager, _ComponentInterface);

  function ThemeManager() {
    _classCallCheck(this, ThemeManager);

    return _possibleConstructorReturn(this, _ComponentInterface.apply(this, arguments));
  }

  /**
   * Configure ThemeManager
   */
  ThemeManager.prototype.configure = function configure() {
    !this.config.themeStore && (this.config.themeStore = {});
  };
  /**
   * Add a themeJSON to the themeStore.
   *
   * @param {Object} themeJSON Contains the themeJSON extracted as is from the
   * theme file.
   */


  ThemeManager.prototype.add = function add(themeJSON) {
    var tm = this,
        i = 0,
        ii = themeJSON.length,
        themeName;

    for (; i < ii; i += 1) {
      themeName = themeJSON[i].name;
      if (themeName) {
        tm.config.themeStore[themeName] = themeJSON[i];
      }
    }
  };

  /**
   * Applies a particular theme to the chart by modifying the chart definition (dataObj)
   * @param {string} themeName name of theme
   * @param {Object} chartInstance instance of chart
   * @param {string} chartType type of chart
   * @param {Object} chartDefinition input data source of chart
   * @param {Object} additionalBase additional base chart
   */


  ThemeManager.prototype.themify = function themify(themeName, chartInstance, chartType, chartDefinition, additionalBase) {
    // get theme object from theme name
    var tm = this,
        jsVars = chartInstance.jsVars,
        themes = themeName.split(','),
        themeArr = [],
        ii = themes.length,
        themeJSON,
        i;

    tm.config.themeStore = getRegisteredThemes((0, _dependencyManager.getDepsByType)('theme'));

    if (ii) {
      for (i = 0; i < ii; i += 1) {
        themeJSON = tm.config.themeStore[trimString(themes[i])];
        themeJSON && themeArr.push(ThemeManager.evaluateThemeJSON(themeJSON.theme, chartInstance, chartType, additionalBase));
      }

      if (themeArr.length) {
        // Create a theme instance using the array of evaluated themes.
        // The logic to cascade the themes is handled by the theme instance.
        jsVars.themeObject = new ThemeInstance(themeArr, chartInstance, false, chartDefinition);
        ThemeManager.applyTheme(chartInstance);

        chartInstance.addEventListener('chartTypeChanged', onChartTypeChange);
        chartInstance.addEventListener('internal.drawstart', onDrawStart);
      } else {
        /**
         * The reference to the theme name provided as part of the chart data is not registered. Verify
         * whether the corresponding theme file has been included in page.
         *
         * @typedef {RuntimeException} Warning-14051100501
         * @memberOf FusionCharts.debugger
         * @group debugger-warning
         */
        (0, _eventApi.raiseWarning)(chartInstance, '14051100501', 'run', 'api.themes~themify()', 'The theme \"' + themeName + '\" requested has not been registered.');
      }
    }
  };

  /**
   * Evaluates a themeJSON and creates the final evaled theme json that can be passed in an
   * array to the themeInstance
   * @param {Object} themeObject The theme object as stored in the theme file
   * @param {Object} chartInstance instance of chart
   * @param {string} chartType type of chart
   * @param {Object} additionalBase additional base chart
   * @return {Object} evaledTheme The evaluated theme object
   */


  ThemeManager.evaluateThemeJSON = function evaluateThemeJSON(themeObject, chartInstance, chartType, additionalBase) {
    var evaledTheme = {},
        jsVars = chartInstance.jsVars,
        evaluator = function evaluator(tblock) {
      var key, item;

      for (key in tblock) {
        item = tblock[key];

        if (item instanceof Array) {
          evaledTheme[key] = extend2(evaledTheme[key] || [], item);
        } else if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object') {
          evaledTheme[key] = extend2(evaledTheme[key] || {}, item);
        } else {
          evaledTheme[key] = item;
        }
      }
    };

    chartType = chartType || chartInstance.chartType();

    /**
     * @todo: Why is this here?
     */
    if (jsVars.themeObject && themeObject !== jsVars.themeObject) {
      jsVars.themeObject.dispose();
      delete jsVars.themeObject;
    }
    evaluator(themeObject.base);

    // Special evaluation for maps. Maps need to have a generic definition as well.
    if (additionalBase && themeObject[additionalBase]) {
      evaluator(themeObject[additionalBase]);
    }

    // Apply chart type specifix theme
    if (chartType && themeObject[chartType]) {
      evaluator(themeObject[chartType]);
    }

    return evaledTheme;
  };

  /**
   * applyTheme applies the theme information stored in the themeInstance object to the
   * various components of the chart definition.
   *
   * @param {Object} chartInstance instance of chart
   *
   */


  ThemeManager.applyTheme = function applyTheme(chartInstance) {
    var themeObj = chartInstance.jsVars.themeObject,
        themedData = themeObj.getThemedJSONData().data;

    if (themedData) {
      recursiveApply(themedData, themeObj);
    }
  };

  return ThemeManager;
}(_componentInterface2['default']);

/**
 * ThemeInstance is a class that get instantiated per chart. It contains all the theme related
 * information that pertains to that particular chart instance.
 *
 * @private
 */


var ThemeInstance = function (_ComponentInterface2) {
  _inherits(ThemeInstance, _ComponentInterface2);

  /**
   * Constructor function of ThemeInstance
   * @param {Array} themeJSONArr Contains an array of JSON that correspond to the themes that have
   * to be cascaded and applied to the chart.
   * @param {Object} parent instance of chart
   * @param {boolean} isChildInstance determines it is an child instance or not
   * @param {Object} chartDefinition input data source of chart
   */
  function ThemeInstance(themeJSONArr, parent, isChildInstance, chartDefinition) {
    _classCallCheck(this, ThemeInstance);

    var _this2 = _possibleConstructorReturn(this, _ComponentInterface2.call(this));

    var i = 0,
        ii;
    _this2.themeArray = themeJSONArr;
    _this2.themeComponents = {};
    _this2.base = {};
    _this2.chartInstance = parent;
    _this2.isChildInstance = Boolean(isChildInstance);

    _this2.themedData = isChildInstance ? null : extend2({}, chartDefinition);

    _this2.length = themeJSONArr.length;

    ii = themeJSONArr.length;

    for (; i < ii; i += 1) {
      _this2.parse(themeJSONArr[i]);
    }
    return _this2;
  }

  /**
   * Adds a new theme to cascade with the existing theme array.
   * @param  {Object} themeJSON an evaled theme JSON.
   * @memberOf ThemeInstance
   */


  ThemeInstance.prototype.pushTheme = function pushTheme(themeJSON) {
    if (themeJSON) {
      this.themeArray.push(themeJSON);
      this.parse(themeJSON);
      this.length += 1;
    }
  };

  /**
   * Removes a theme JSON from the theme array
   */
  // popTheme () {
  //   // Not implemented as there isn't really a use-case for this.
  // }

  /**
   * Parses the theme JSON and creates themeComponents based on the JSON structure.
   * @param  {Object} themeJSON input theme JSON
   * @private
   */


  ThemeInstance.prototype.parse = function parse(themeJSON) {
    var ti = this,
        components = ti.themeComponents,
        parent = ti.chartInstance,
        base = ti.base,
        componentArr,
        key,
        imp1,
        imp2,
        block;

    block = themeJSON;

    for (key in block) {
      if (typeof block[key] === 'string' || typeof block[key] === 'number') {
        if (base[key]) {
          // If the base has already been populated by a previous theme then merge the
          // new value properly.
          imp1 = checkImportance(block[key]);
          imp2 = checkImportance(base[key]);

          if (imp1.important || !imp2.important) {
            base[key] = block[key];
          }
        } else {
          base[key] = block[key];
        }
      } else {
        if (!components[key]) {
          components[key] = [];
        }

        componentArr = components[key];
        // If it is an array then it has to be applied to repeating elements of the chart
        if (block[key] instanceof Array) {
          componentArr.push(extend2([], block[key]));
        } else if (_typeof(block[key]) === 'object') {
          // If an object then we make a separate theme instance for the component that
          // will get cascaded with other theme objects (if any) and applied to the
          // component.
          componentArr.push(new ThemeInstance([block[key]], parent, true));
        } else if (typeof block[key] === 'function') {
          // If it is a function then it has to be invoked during runtime and applied to
          // chart component depending on the return type.
          componentArr.push(block[key]);
        }
      }
    }
  };
  /**
   * Merges the ThemeInstance object passed with itself.
   * @param  {ThemeInstance} instance The object to be merged
   *
   */


  ThemeInstance.prototype.merge = function merge(instance) {
    var ti = this,
        thisBase = ti.base,
        thatBase = instance.base,
        thisComponents = ti.themeComponents,
        thatComponents = instance.themeComponents,
        imp1,
        imp2,
        key;

    for (key in thatBase) {
      imp1 = checkImportance(thisBase[key]);
      imp2 = checkImportance(thatBase[key]);

      if (!imp1.important || imp2.important) {
        thisBase[key] = thatBase[key];
      }
    }

    for (key in thatComponents) {
      if (thisComponents[key]) {
        thisComponents[key] = thisComponents[key].concat(thatComponents[key]);
      } else {
        thisComponents[key] = [].concat(thatComponents[key]);
      }
    }

    ti.length += instance.length;
  };

  /**
   * Getter function to get the value of a theme property from the `base` property of the
   * theme instance.
   *
   * @param  {string} key The key corresponding to the theme property.
   * @return {string} The value of the theme property as given in the evaled theme JSON.
   */


  ThemeInstance.prototype.get = function get(key) {
    return this.base[key];
  };

  /**
   * Getter to get all the properties that are there in the base.
   *
   * @return {Object} a copy of the base object that contains all the key value pairs
   * corresponding to the chart component.
   */


  ThemeInstance.prototype.getAll = function getAll() {
    return extend2({}, this.base);
  };

  /**
   * Traverses the themeComponents of the parent theme instance and returns a new themeInstance
   * corresponding to the chart component for which it is being fetched.
   *
   * @param  {string} key - The key corresponding to the chart component to be themed
   *
   * @param  {number} index - If it is a repeating component then the index indicating the
   * index of the component is also passed.
   *
   * @param  {Object} dataJSON - input JSON data object
   *
   * @param {number=} [length] - Specify the total length of the component for function iterators that needs the
   * total length to be passed as a parameter.
   *
   * @return {themeInstance} The ThemeInstance object corresponding to the component.
   */


  ThemeInstance.prototype.component = function component(key, index, dataJSON, length) {
    var ti = this,
        components = ti.themeComponents,
        parent = ti.chartInstance,
        returnInstance = new ThemeInstance([], parent, true),
        item,
        i,
        ii,
        len,
        componentArr,
        each;

    componentArr = components[key];

    if (!componentArr) {
      return null;
    }

    for (i = 0, ii = componentArr.length; i < ii; i += 1) {
      each = componentArr[i];

      if (typeof each === 'function') {
        index = index || 0;
        returnInstance.pushTheme(each.call(parent, index, dataJSON, length));
      } else {
        if (each instanceof Array) {
          index = index || 0;
          len = each.length;

          index = index % len;
          item = each[index];

          if (item instanceof ThemeInstance) {
            returnInstance.merge(item);
          } else {
            if (typeof item === 'function') {
              returnInstance.pushTheme(item.call(parent, index, dataJSON, length));
            } else {
              returnInstance.pushTheme(item);
            }
          }
        } else {
          if (each instanceof ThemeInstance) {
            returnInstance.merge(each);
          } else {
            returnInstance.pushTheme(each);
          }
        }
      }
    }

    return returnInstance;
  };
  /**
   * Returns applied theme data
   * @return {Object} returns data prepared after theme applied
   */


  ThemeInstance.prototype.getThemedJSONData = function getThemedJSONData() {
    return { data: this.themedData };
  };

  /**
   * Disposes the theme instance.
   */


  ThemeInstance.prototype.dispose = function dispose() {
    var ti = this,
        components = ti.themeComponents,
        chartObj = ti.chartInstance,
        key,
        i;

    for (key in components) {
      i = components[key].length;
      if (i) {
        while (i--) {
          components[key][i].dispose && components[key][i].dispose();
        }
        delete components[key];
      }
    }

    if (!ti.isChildInstance) {
      chartObj.removeEventListener('chartTypeChanged', onChartTypeChange);
      chartObj.removeEventListener('internal.drawstart', onDrawStart);
    }

    ti.themeComponents = null;
    ti.chartInstance = null;
    ti.base = null;
    ti.themeArray = null;
    ti.isChildInstance = null;
    ti.dataWithoutTheme = null;
  };

  return ThemeInstance;
}(_componentInterface2['default']);

/**
 * The single instance of ThemeManager that handles the theming of all the charts.
 * @private
 */


themer = new ThemeManager();
themer.configure();
/**
 * Wrapper function
 * @param {Object} FusionCharts FusionCharts global class
 */
function FCPlugger(FusionCharts) {
  // Support for backward compatibility of theme files only
  FusionCharts.register = function (type, data) {
    if (type && typeof type === 'string' && type === 'theme' && data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
      (0, _dependencyManager.addDep)(data);
    }
  };

  // Listening to the data updated event fired when the chart data is updated and themifying the chart definition
  // before the chart attributes are read and applied to the chart definition.
  FusionCharts.addEventListener('beforeDataUpdate', function (eventObj, args) {
    var chartObj = eventObj.sender,

    // dataObj = global.core.transcodeData(args.data, args.format, global.dataFormats.JSON),
    dataObj = args.dataSource,
        themeName = dataObj.chart && dataObj.chart.theme;

    if (themeName) {
      themer.themify(themeName, chartObj, chartObj.args.type, dataObj);
    } else if (chartObj.jsVars && chartObj.jsVars.themeObject) {
      chartObj.jsVars && chartObj.jsVars.themeObject.dispose();
      chartObj.jsVars && delete chartObj.jsVars.themeObject;
    }
  });
}

exports['default'] = {
  extension: FCPlugger,
  name: 'ThemeEngine',
  type: 'extension',
  requiresFusionCharts: true
};

/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(330);
var $Object = __webpack_require__(19).Object;
module.exports = function defineProperty(it, key, desc){
  return $Object.defineProperty(it, key, desc);
};

/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(31);
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(39), 'Object', {defineProperty: __webpack_require__(38).f});

/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(332);
var $Object = __webpack_require__(19).Object;
module.exports = function getOwnPropertyDescriptor(it, key){
  return $Object.getOwnPropertyDescriptor(it, key);
};

/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject                 = __webpack_require__(33)
  , $getOwnPropertyDescriptor = __webpack_require__(124).f;

__webpack_require__(125)('getOwnPropertyDescriptor', function(){
  return function getOwnPropertyDescriptor(it, key){
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(334);
var $Object = __webpack_require__(19).Object;
module.exports = function getOwnPropertyNames(it){
  return $Object.getOwnPropertyNames(it);
};

/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 Object.getOwnPropertyNames(O)
__webpack_require__(125)('getOwnPropertyNames', function(){
  return __webpack_require__(181).f;
});

/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(336);
module.exports = __webpack_require__(19).Object.setPrototypeOf;

/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(31);
$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(337).set});

/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(64)
  , anObject = __webpack_require__(63);
var check = function(O, proto){
  anObject(O);
  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function(test, buggy, set){
      try {
        set = __webpack_require__(174)(Function.call, __webpack_require__(124).f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch(e){ buggy = true; }
      return function setPrototypeOf(O, proto){
        check(O, proto);
        if(buggy)O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export  = __webpack_require__(52)
  , $forEach = __webpack_require__(84)(0)
  , STRICT   = __webpack_require__(196)([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */){
    return $forEach(this, callbackfn, arguments[1]);
  }
});

/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

var anObject       = __webpack_require__(340)
  , IE8_DOM_DEFINE = __webpack_require__(341)
  , toPrimitive    = __webpack_require__(343)
  , dP             = Object.defineProperty;

exports.f = __webpack_require__(128) ? Object.defineProperty : function defineProperty(O, P, Attributes){
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if(IE8_DOM_DEFINE)try {
    return dP(O, P, Attributes);
  } catch(e){ /* empty */ }
  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
  if('value' in Attributes)O[P] = Attributes.value;
  return O;
};

/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(83);
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};

/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(128) && !__webpack_require__(129)(function(){
  return Object.defineProperty(__webpack_require__(342)('div'), 'a', {get: function(){ return 7; }}).a != 7;
});

/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(83)
  , document = __webpack_require__(65).document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};

/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(83);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function(it, S){
  if(!isObject(it))return it;
  var fn, val;
  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ }),
/* 344 */
/***/ (function(module, exports) {

module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};

/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

var global    = __webpack_require__(65)
  , hide      = __webpack_require__(127)
  , has       = __webpack_require__(346)
  , SRC       = __webpack_require__(188)('src')
  , TO_STRING = 'toString'
  , $toString = Function[TO_STRING]
  , TPL       = ('' + $toString).split(TO_STRING);

__webpack_require__(82).inspectSource = function(it){
  return $toString.call(it);
};

(module.exports = function(O, key, val, safe){
  var isFunction = typeof val == 'function';
  if(isFunction)has(val, 'name') || hide(val, 'name', key);
  if(O[key] === val)return;
  if(isFunction)has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if(O === global){
    O[key] = val;
  } else {
    if(!safe){
      delete O[key];
      hide(O, key, val);
    } else {
      if(O[key])O[key] = val;
      else hide(O, key, val);
    }
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString(){
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

/***/ }),
/* 346 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};

/***/ }),
/* 347 */
/***/ (function(module, exports) {

module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};

/***/ }),
/* 348 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(190);
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};

/***/ }),
/* 349 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};

/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(351);

module.exports = function(original, length){
  return new (speciesConstructor(original))(length);
};

/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(83)
  , isArray  = __webpack_require__(194)
  , SPECIES  = __webpack_require__(195)('species');

module.exports = function(original){
  var C;
  if(isArray(original)){
    C = original.constructor;
    // cross-realm fallback
    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
    if(isObject(C)){
      C = C[SPECIES];
      if(C === null)C = undefined;
    }
  } return C === undefined ? Array : C;
};

/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(65)
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};

/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(354);
module.exports = __webpack_require__(66)('Array').findIndex;

/***/ }),
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = __webpack_require__(52)
  , $find   = __webpack_require__(84)(6)
  , KEY     = 'findIndex'
  , forced  = true;
// Shouldn't skip holes
if(KEY in [])Array(1)[KEY](function(){ forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn/*, that = undefined */){
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(130)(KEY);

/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
/* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */
/** !
 * @license FusionCharts JavaScript Library
 * Copyright FusionCharts, Inc.
 * License Information at <http://www.fusioncharts.com/license>
 */
/**
 * @private
 * @module fusioncharts.api.themes.default
 */

var themeObject = {
  name: 'default',
  theme: {
    base: {
      chart: {
        labelDisplay: 'stagger !important',
        caption: 'Theme Caption \\!important',
        canvasBgColor: '#56EF22',
        borderThickness: '5 !important',
        borderColor: '#E60539',
        baseFontColor: '#781129'
      },
      categories: [{
        fontColor: '#0F4F40',
        fontSize: 15,
        category: function category(index) {
          return {
            showLabel: index % 2 ? 0 : 1
          };
        },
        vline: {
          color: '#000000',
          thickness: 2
        }
      }],
      dataset: [{
        color: '#8C3146',
        data: function data(index, dataObj) {
          if (index == 8) {
            dataObj.value = '';
          }
          return {
            color: Number(dataObj.value) < 32000 ? '#8C3146' : '#FF0000',
            alpha: '100'
          };
        }
      }],
      trendlines: [{
        line: function line(index) {
          if (index) {
            return {
              color: '#ff0000',
              thickness: 3
            };
          } else {
            return {
              color: '#ffff00',
              thickness: 3
            };
          }
        }
      }]
    },
    pie2d: {
      chart: {
        bgColor: '#FF0000'
      }
    },
    msline: {
      chart: {
        canvasBgColor: '#ff0000'
      }
    },

    geo: {
      chart: {
        canvasBgColor: '#0000ff'
      }
    },

    world: {
      chart: {
        canvasBgColor: '#00ff00'
      }
    }
  }
};

exports['default'] = {
  extension: themeObject,
  name: 'DefaultTheme',
  type: 'theme'
};

/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _tooltipComponent = __webpack_require__(357);

var _tooltipComponent2 = _interopRequireDefault(_tooltipComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TOOL_TIP_KEY = '__FC_tooltipText',
    MOVE_HANDLER = '__FC_onTooltipMove',
    OUT_HANDLER = '__FC_onTooltipOut';

var moveHandler = function moveHandler(toolTip, controller, event) {
  var universeBounds = controller.universe.getBoundingClientRect(),
      mousePointerWidthOffset = 11,
      mousePointerHeightOffset = 11,
      x = event.clientX,
      y = event.clientY;

  // Adjust for the offset of the container. This will position the tooltip exactly under the
  // mouse pointer
  x -= universeBounds.left;
  y -= universeBounds.top;

  // Now shift the tooltip such that is displays slightly to the left of and to the bottom of the
  // mouse pointer
  x += mousePointerWidthOffset;
  y += mousePointerHeightOffset;

  ToolTipController._draw(x, y, this.data(TOOL_TIP_KEY), toolTip);
},
    outHandler = function outHandler(toolTip) {
  ToolTipController._hide(toolTip);
};
// touchEnabled = ('ontouchstart' in document),
// stubEvent = {
//   pageX: 0,
//   pageY: 0
// };

// function getTouchEvent (event) {
//   var e = event && (event.sourceEvent || event.originalEvent || event);
//   return (touchEnabled && e && e.touches && e.touches[0]) || e || stubEvent;
// }

/**
 * Serves as the backbone of all tooltips associated with a given container. This container is
 * considered to be its "universe". The ToolTipController is always instantiated with a universe.
 * The controller automatically creates and removes tooltips of the appropriate type, as required.
 *
 * The ToolTipController is capable of instantiating two kinds of tooltips, implicit and explicit.
 * * Implicit tooltips are those that are left to the ToolTipController to control.
 * * Explicit tooltips are those which are controlled by the instantiator. The instantiator
 * explicitly draws and hides tooltips by using the ToolTipController.
 * @class
 */

var ToolTipController = function () {
  /**
   * Instantiates the class with its universe and its pool of tooltips.
   * @param  {HTMLELement} universe The HTML element in which the tooltip elements will be created.
   */
  function ToolTipController(universe) {
    _classCallCheck(this, ToolTipController);

    this.universe = universe;
    // this.isFixed = false;
    this.toolTips = {
      implicit: [],
      explicit: []
    };
  }

  /**
   * Creates an instance of a specific type of tooltip
   * @param  {string}  toolTipType The type of tooltip to be created, either implicit or explicit
   * @return {ToolTip}             The created tooltip
   * @private
   */


  ToolTipController.prototype._createToolTip = function _createToolTip(toolTipType) {
    var toolTip = void 0;

    toolTip = new _tooltipComponent2['default'](this.universe);
    this.toolTips[toolTipType].push(toolTip);

    return toolTip;
  };

  /**
   * Enable an implicit tooltip on a given Raphael element
   * @param  {Object} element The Raphael element on which to enable the implicit tooltip
   * @param  {string} text    The text to display in the implicit tooltip
   */


  ToolTipController.prototype.enableToolTip = function enableToolTip(element, text) {
    var toolTip = this._getAvailableToolTip('implicit');

    this.disableToolTip(element);
    if (text === undefined || text === '' || text === false) {
      return;
    }

    element.data(TOOL_TIP_KEY, text);
    element.data(MOVE_HANDLER, moveHandler.bind(element, toolTip, this));
    element.data(OUT_HANDLER, outHandler.bind(element, toolTip, this));

    element.on('mousemove', element.data(MOVE_HANDLER));
    element.on('mouseout', element.data(OUT_HANDLER));

    return this;
  };

  /**
   * Disable the implicit tooltip on a Raphael element
   * @param  {Object} element The Raphael element from which the implicit tooltip will be removed
   */
  // eslint-disable-next-line


  ToolTipController.prototype.disableToolTip = function disableToolTip(element) {
    var elemOutHandler = element.data(OUT_HANDLER),
        elemMoveHandler = element.data(MOVE_HANDLER);

    elemMoveHandler && element.off('mousemove', elemMoveHandler);
    elemOutHandler && element.off('mouseout', elemOutHandler);

    return this;
  };

  /**
   * Creates an explicit tooltip at the position of the mouse cursor with the given text
   * when invoked
   * @param  {Object} element The Raphael element on which to enable the explicit tooltip
   * @param  {Event}  event   The Event object from which to determine the x and y co-ordinates of
   *                          the mouse
   * @param  {string} text    The text to be displayed in the explicit tooltip
   * @return {ToolTip}        The explicit tooltip created
   */


  ToolTipController.prototype.draw = function draw(event, text, toolTip) {
    var universeBounds = this.universe.getBoundingClientRect(),
        mousePointerWidthOffset = 11,
        mousePointerHeightOffset = 11,
        x = event.clientX,
        y = event.clientY;

    toolTip = toolTip || this._getAvailableToolTip('explicit');

    // Adjust for the offset of the container. This will position the tooltip exactly under the
    // mouse pointer
    x -= universeBounds.left;
    y -= universeBounds.top;

    // Now shift the tooltip such that is displays slightly to the left of and to the bottom of the
    // mouse pointer
    x += mousePointerWidthOffset;
    y += mousePointerHeightOffset;

    ToolTipController._draw(x, y, text, toolTip);

    return toolTip;
  };

  /**
   * Internal method to show and update tooltips on elements
   * @param  {Object}  element  The Raphael element on which to draw the tooltip
   * @param  {number}  x        The X position at which to draw the tooltip
   * @param  {number}  y        The Y position at which to draw the tooltip
   * @param  {ToolTip} toolTip  The tooltip to draw or update
   * @private
   */


  ToolTipController._draw = function _draw(x, y, text, toolTip) {
    toolTip.show(text);
    toolTip.update(x, y);
  };

  /**
   * Gets an available tooltip of a specific type. If no tooltip is available, create a new one.
   * @param  {string} type      The type of tooltip to search for, either implicit or explicit
   * @param  {Object} [element] In case of an explicit tooltip, the element which will be checked
   *                            for active tooltips
   * @return {ToolTip}          The tooltip element that was found or newly created
   * @private
   */


  ToolTipController.prototype._getAvailableToolTip = function _getAvailableToolTip(type) {
    var toolTips = this.toolTips[type],
        toolTip = void 0,
        isToolTipInactive = void 0;

    for (var i = 0, ii = toolTips.length; i < ii; i++) {
      toolTip = toolTips[i];
      isToolTipInactive = toolTip.getData('active') === false;
      if (isToolTipInactive) {
        return toolTip;
      }
    }

    return this._createToolTip(type);
  };

  /**
   * Given a toolTip, hides it
   * @param  {ToolTip} toolTip The tooltip to hide
   */


  ToolTipController.prototype.hide = function hide(toolTip) {
    ToolTipController._hide(toolTip, 'dispose');
    return this;
  };

  /**
   * internal method to control the hiding and disposal of a tooltip.
   * @param  {ToolTip} toolTip       The tooltip to hide or dispose
   * @param  {boolean} [willDispose] If true, indicates that the tooltip should dispose itself,
   *                                 i.e. remove its associated DOM element
   * @private
   */


  ToolTipController._hide = function _hide(toolTip, willDispose) {
    if (toolTip) {
      if (willDispose) {
        toolTip.dispose();
      } else {
        toolTip.hide();
      }
    }
  };

  return ToolTipController;
}();

exports['default'] = {
  extension: ToolTipController,
  name: 'ToolTipController',
  type: 'plugin'
};

/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FC_TOOLTIP_CLASS = 'fc__tooltip';
/**
 * This component is responsible for drawing and updating the tooltips associated with the chart
 * @class
 */

var ToolTip = function () {
  function ToolTip(universe) {
    _classCallCheck(this, ToolTip);

    this.text = '';
    this.x = 0;
    this.y = 0;
    this.universeBounds = universe.getBoundingClientRect();
    this.data = {
      active: false,
      target: false
    };
    this.element = this.createElement(universe);
  }

  ToolTip.prototype.createElement = function createElement(universe) {
    var div = document.createElement('div');
    div.setAttribute('class', FC_TOOLTIP_CLASS);

    div.innerHTML = this.text;

    div.style.color = '#000';
    div.style.padding = '3px';
    div.style.fontSize = '0.8em';
    div.style.overflow = 'hidden';
    div.style.borderWidth = '1px';
    div.style.borderColor = '#666';
    div.style.whiteSpace = 'nowrap';
    div.style.position = 'absolute';
    div.style.borderStyle = 'solid';
    div.style.backgroundColor = '#EEE';

    div.style['user-select'] = 'none'; // Chrome and Opera
    div.style['-ms-user-select'] = 'none'; // Internet Explorer and Edge
    div.style['-moz-user-select'] = 'none'; // Firefox
    div.style['-webkit-user-select'] = 'none'; // Safari
    div.style['-webkit-touch-callout'] = 'none'; // iOS Safari

    div.style.top = this.x + 'px';
    div.style.left = this.y + 'px';
    div.style.visibility = 'hidden';
    div.style['pointer-events'] = 'none';

    universe.appendChild(div);

    return div;
  };

  ToolTip.prototype.setData = function setData(key, val) {
    this.data[key] = val;
  };

  ToolTip.prototype.getData = function getData(key) {
    return this.data[key];
  };

  ToolTip.prototype.show = function show(text) {
    this.text = text;

    if (this.element.innerHTML !== this.text) {
      this.element.innerHTML = this.text;
    }

    this.setData('active', true);
    this.element.style.visibility = 'visible';
  };

  ToolTip.prototype.update = function update() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.x;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.y;

    var universeBounds = this.universeBounds,

    // toolTipBounds = this.element.getBoundingClientRect(),
    universeLeft = universeBounds.left,
        universeTop = universeBounds.top;

    if (x + universeLeft + this.element.offsetWidth < universeBounds.right) {
      this.element.style.left = x + 'px';
    } else {
      // this.element.style.left = `${x - universeLeft - toolTipBounds.width}px`;
      this.element.style.left = this.universeBounds.right - this.element.offsetWidth - universeLeft + 'px';
    }

    if (y + universeTop + this.element.offsetHeight < universeBounds.bottom) {
      this.element.style.top = y + 'px';
    } else {
      this.element.style.top = this.universeBounds.bottom - this.element.offsetHeight - universeTop + 'px';
    }
  };

  ToolTip.prototype.hide = function hide() {
    this.y = 0;
    this.x = 0;
    this.x = '';
    this.setData('active', false);
    this.setData('target', false);

    // this.element.style.top = `${this.y}px`;
    // this.element.style.left = `${this.x}px`;
    this.element.style.visibility = 'hidden';
    this.element.innerHTML = '';
  };

  ToolTip.prototype.dispose = function dispose() {
    this.hide();
    // Also remove html element
  };

  return ToolTip;
}();

exports['default'] = ToolTip;

/***/ }),
/* 358 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */
/* eslint class-methods-use-this: 'off' */
/**
 * Represents the base class and showcases the minimal APIs that a tooltip provider needs to enable
 * in order for FusionCharts to use it.
 *
 * @class SkeletonTooltipController
 */
var SkeletonTooltipController = function () {
  function SkeletonTooltipController() {
    _classCallCheck(this, SkeletonTooltipController);
  }

  /**
   * Skeleton method which draws a tooltip at specified co-ordinates with the given text
   */
  SkeletonTooltipController.prototype.draw = function draw() {}
  // Skeleton function


  /**
   * Skeleton method to hide the tooltip
   */
  ;

  SkeletonTooltipController.prototype.hide = function hide() {}
  // Skeleton function


  /**
   * Skeleton method to enable tooltip on an element
   */
  ;

  SkeletonTooltipController.prototype.enableToolTip = function enableToolTip() {}
  // Skeleton function


  /**
   * Skeleton method to disable tooltip on an element
   */
  ;

  SkeletonTooltipController.prototype.disableToolTip = function disableToolTip() {
    // Skeleton function
  };

  return SkeletonTooltipController;
}();

exports['default'] = {
  extension: SkeletonTooltipController,
  name: 'ToolTipController',
  type: 'plugin'
};

/***/ }),
/* 359 */,
/* 360 */,
/* 361 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _lib = __webpack_require__(5);

var _redraphael = __webpack_require__(17);

var _redraphael2 = _interopRequireDefault(_redraphael);

var _chartmessage = __webpack_require__(402);

var _chartmessage2 = _interopRequireDefault(_chartmessage);

var _componentInterface = __webpack_require__(6);

var _componentInterface2 = _interopRequireDefault(_componentInterface);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var MOUSEOUT = 'mouseout';

var BaseChart = function (_ComponentInterface) {
  _inherits(BaseChart, _ComponentInterface);

  function BaseChart() {
    _classCallCheck(this, BaseChart);

    return _possibleConstructorReturn(this, _ComponentInterface.apply(this, arguments));
  }

  /**
   * Provides the name of the chart extension
   *
   * @static
   * @return {string} The name of the chart extension
   */
  BaseChart.getName = function getName() {
    return 'BaseChart';
  };

  /**
   * Provides the type of the chart extension
   *
   * @static
   * @return {string} The type of the chart extension
   */


  BaseChart.getType = function getType() {
    return 'chart';
  };

  BaseChart.prototype._mouseEvtHandler = function _mouseEvtHandler(e) {
    var iapi = this,
        data = e.data,
        mouseTracker = data.mouseTracker,
        oriEvent = e.originalEvent,
        chartConfig = iapi.config,
        canvasLeft = chartConfig.canvasLeft - (chartConfig.toleranceLeft || 0),
        canvasRight = chartConfig.canvasRight + (chartConfig.toleranceRight || 0),
        canvasBottom = chartConfig.canvasBottom + (chartConfig.toleranceBottom || 0),
        canvasTop = chartConfig.canvasTop - (chartConfig.toleranceTop || 0),
        datasets = chartConfig.datasetOrder || iapi.getDatasets(),
        coordinate = (0, _lib.getMouseCoordinate)(iapi.getFromEnv('chart-container'), oriEvent, iapi),
        chartX = coordinate.chartX,
        chartY = coordinate.chartY,
        dataset,
        chartComponents = iapi.components,
        group = 'datasetGroup_' + (datasets[0]._name || datasets[0].type),
        hoveredInfo,
        pointFound = false,
        i = datasets.length,
        j,
        l,
        derivedEvensInfo,
        _lastDatasetIndex = mouseTracker._lastDatasetIndex,
        _lastPointIndex = mouseTracker._lastPointIndex;

    // if inside the canvas
    if (chartX > canvasLeft && chartX < canvasRight && chartY > canvasTop && chartY < canvasBottom) {
      // todo make sure the datasets are as per their z-order
      while (i-- && !pointFound) {
        dataset = datasets[i];
        if (dataset && dataset.getState('visible')) {
          hoveredInfo = dataset._getHoveredPlot && dataset._getHoveredPlot(chartX, chartY);
          if (hoveredInfo && hoveredInfo.hovered) {
            pointFound = true;
            hoveredInfo.datasetIndex = i;
            derivedEvensInfo = mouseTracker.getMouseEvents(e, hoveredInfo.datasetIndex, hoveredInfo.pointIndex);
          }
        }
      }
    }

    // todo instead of sending event names, create a event object of that type and send it

    // fire out on last hovered plot
    if ((!pointFound || derivedEvensInfo && derivedEvensInfo.fireOut) && typeof _lastDatasetIndex !== 'undefined') {
      // delete stored last ds details
      delete mouseTracker._lastDatasetIndex;
      delete mouseTracker._lastPointIndex;
      datasets[_lastDatasetIndex] && datasets[_lastDatasetIndex]._firePlotEvent && datasets[_lastDatasetIndex]._firePlotEvent(MOUSEOUT, _lastPointIndex, e);

      // todo scope to have sticky tracked tooltip
    }
    // fire remaining events
    if (pointFound) {
      l = derivedEvensInfo.events && derivedEvensInfo.events.length;
      // store the index of the hovered DS and plot
      mouseTracker._lastDatasetIndex = hoveredInfo.datasetIndex;
      _lastPointIndex = mouseTracker._lastPointIndex = hoveredInfo.pointIndex;

      chartConfig.drawTrendRegion && chartComponents[group]._notifyGroup(true, e);
      for (j = 0; j < l; j += 1) {
        dataset && dataset._firePlotEvent && dataset._firePlotEvent(derivedEvensInfo.events[j], _lastPointIndex, e, hoveredInfo.datasetIndex);
      }
    } else {
      chartConfig.drawTrendRegion && chartComponents[group]._notifyGroup(false, e);
    }

    chartConfig.drawTrendRegion && chartComponents[group]._getHoveredRegion(chartX, chartY, e);
  };

  /**
   * Queries the chart's children for datasets
   * @param {Component} parentComp set a parent component from where it will iterate and find the datasets
   * @return {Array} An array of datasets found in the vCanvas
   */


  BaseChart.prototype.getDatasets = function getDatasets(parentComp) {
    var comp = parentComp || this,
        datasets = [];

    comp.iterateComponents(function (component) {
      if (component.getType() === 'dataset') {
        datasets.push(component);
      }
    });

    return datasets;
  };

  BaseChart.prototype.setChartMessage = function setChartMessage(message, chartObj, container) {
    var iapi = this,
        chartInstance = iapi.chartInstance,
        options = chartInstance.options,
        args = chartInstance.args,
        config = iapi.config || (iapi.config = {}),
        height,
        width,
        attr,
        paper,
        smartText,
        style,
        smartLabel = iapi.linkedItems && iapi.linkedItems.smartLabel || chartInstance.jsVars.smartLabel,
        strObj = (0, _lib.getImageURL)(typeof message !== 'undefined' ? message : options.dataEmptyMessage),
        offsetWidth,
        offsetHeight;

    if (!iapi.linkedItems) {
      iapi.linkedItems = {};
    }
    if (container) {
      iapi.addToEnv('chart-container', container);
    } else {
      container = iapi.getFromEnv('chart-container');
    }

    offsetWidth = config.prevWidth = container.offsetWidth;
    offsetHeight = config.prevHeight = container.offsetHeight;

    height = config.height = Number(offsetHeight);
    width = config.width = Number(offsetWidth);

    config.hasChartMessage = true;

    if (!iapi.getFromEnv('paper')) {
      paper = new _redraphael2['default'](container, offsetWidth, offsetHeight);
      iapi.addToEnv('paper', paper);
      paper.setConfig('stroke-linecap', _lib.ROUND);
    } else {
      paper = iapi.getFromEnv('paper').setSize(offsetWidth, offsetHeight);
    }

    if (strObj.image) {
      attr = strObj.string;

      if (!chartObj) {
        style = {
          imageHAlign: (0, _lib.pluck)(args.dataEmptyMessageImageHAlign, options.baseChartMessageImageHAlign).toLowerCase(),
          imageVAlign: (0, _lib.pluck)(args.dataEmptyMessageImageVAlign, options.baseChartMessageImageVAlign).toLowerCase(),
          imageAlpha: (0, _lib.pluckNumber)(args.dataEmptyMessageImageAlpha, options.baseChartMessageImageAlpha),
          imageScale: (0, _lib.pluckNumber)(args.dataEmptyMessageImageScale, options.baseChartMessageImageScale)
        };
      } else {
        style = {
          imageHAlign: (0, _lib.pluck)(chartObj._chartMessageImageStyle.imageHAlign, options.baseChartMessageImageHAlign).toLowerCase(),
          imageVAlign: (0, _lib.pluck)(chartObj._chartMessageImageStyle.imageVAlign, options.baseChartMessageImageVAlign).toLowerCase(),
          imageAlpha: (0, _lib.pluckNumber)(chartObj._chartMessageImageStyle.imageAlpha, options.baseChartMessageImageAlpha),
          imageScale: (0, _lib.pluckNumber)(chartObj._chartMessageImageStyle.imageScale, options.baseChartMessageImageScale)
        };
      }

      config.chartMessageType = 'image';
    } else {
      if (!chartObj) {
        style = {
          'font-family': args.dataEmptyMessageFont || options.baseChartMessageFont,
          'font-size': args.dataEmptyMessageFontSize || options.baseChartMessageFontSize,
          fill: args.dataEmptyMessageColor || options.baseChartMessageColor
        };
      } else {
        style = {
          'font-family': chartObj._chartMessageStyle.fontFamily || options.baseChartMessageFont,
          'font-size': chartObj._chartMessageStyle.fontSize || options.baseChartMessageFontSize,
          fill: chartObj._chartMessageStyle.color || options.baseChartMessageColor
        };
      }

      smartLabel.setStyle(style);
      smartText = smartLabel.getSmartText((0, _lib.parseUnsafeString)(strObj.string), width, height);

      attr = {
        text: smartText.text,
        x: width / 2,
        y: height / 2

      };

      config.chartMessageType = 'text';
    }

    config.chartMessageAttr = attr;
    config.chartMessageStyle = style;
  };

  BaseChart.prototype.drawChartMessage = function drawChartMessage() {
    var iapi = this,
        config = iapi.config,
        paper = iapi.getFromEnv('paper'),
        message,
        messageGroup,
        chartMessage,
        graphics,

    // chartGraphics = iapi.graphics || (iapi.graphics = { }),
    attr = (0, _lib.extend2)(config.chartMessageAttr, config.chartMessageStyle);
    (0, _lib.componentFactory)(iapi, _chartmessage2['default'], 'chartMessage');
    chartMessage = iapi.getChildren('chartMessage')[0];
    message = chartMessage.getGraphicalElement('message');
    graphics = chartMessage._graphics;
    // messageGroup = chartGraphics.messageGroup || (chartGraphics.messageGroup = paper.group('messageGroup'));
    messageGroup = iapi.getChildContainer('messageGroup') || iapi.addChildContainer('messageGroup', paper.group('messageGroup'));
    // Hiding any previous chart messages.
    iapi._hideChartMessage();

    config.hasChartMessage = true;

    if (config.chartMessageType === 'image') {
      iapi._drawBackground(config.chartMessageAttr, config.chartMessageStyle);
    } else if (!message && config.chartMessageType === 'text') {
      message = chartMessage.addGraphicalElement('message', paper.text(attr, messageGroup));
    } else {
      graphics.message = message.attr(attr);
      message.show();
    }
    iapi._drawCreditLabel();
  };

  BaseChart.prototype._hideChartMessage = function _hideChartMessage() {
    var iapi = this,
        config = iapi.config,
        chartMessages = iapi.getChildren('chartMessage'),
        chartMessage = chartMessages && chartMessages[0],
        messageItems = chartMessage && chartMessage.graphics,
        graphics;

    if (!chartMessage) {
      return;
    }
    // Checking for existance of image and setting flag
    if (config.chartMessageType === 'image' && !messageItems.backgroundImage && messageItems.backgroundElement) {
      config.stopImageDraw = true;
    }

    config && (config.hasChartMessage = false);
    for (graphics in messageItems) {
      // Second condition is for hiding images
      messageItems[graphics].hide ? messageItems[graphics].hide() : messageItems[graphics][0] && messageItems[graphics][0].hide();
    }
  };

  BaseChart.prototype._getBackgroundCosmetics = function _getBackgroundCosmetics() {
    var iapi = this,
        chartAttrs = iapi.jsonData.chart,
        colorM = iapi.getFromEnv('color-manager'),
        is3d = iapi.is3D,
        palleteString = is3d ? _lib.chartPaletteStr.chart3D : _lib.chartPaletteStr.chart2D;
    return {
      FCcolor: {
        color: (0, _lib.pluck)(chartAttrs.bgcolor, iapi.bgColor, colorM.getColor(palleteString.bgColor)),
        alpha: (0, _lib.pluck)(chartAttrs.bgalpha, iapi.bgAlpha, colorM.getColor(palleteString.bgAlpha)),
        angle: (0, _lib.pluck)(chartAttrs.bgangle, colorM.getColor(palleteString.bgAngle)),
        ratio: (0, _lib.pluck)(chartAttrs.bgratio, colorM.getColor(palleteString.bgRatio))
      }
    };
  };

  BaseChart.prototype._drawBackground = function _drawBackground(imageString, imageAttr) {
    var iapi = this,

    // chartGraphics = iapi.graphics,
    chartAttrs = iapi.jsonData && iapi.jsonData.chart || {},
        paper = iapi.getFromEnv('paper'),
        background = imageString ? iapi.getChildren('chartMessage')[0] : iapi.getChildren('background')[0],
        graphics = background._graphics,
        backgroundElement = background.getGraphicalElement('backgroundElement'),
        borderElement = background.getGraphicalElement('borderElement'),
        config = background.config || {},
        chartConfig = iapi.config,
        chartWidth = chartConfig.width,
        chartHeight = chartConfig.height,
        strConsts = BaseChart.stringConstants,
        attrObj,
        backgroundColor,
        referenceImage,
        xRepeatCount,
        yRepeatCount,
        bgImageAttr,
        imgY,
        yCount,
        imageElement,
        counter,
        animationObj = iapi.get && iapi.get(_lib.configStr, _lib.animationObjStr) || {},
        animType = animationObj.animType,
        animObj = animationObj.animObj,
        dummyObj = animationObj.dummyObj,
        animationDuration = animationObj.duration,
        bgSWF = config.bgSWF = (0, _lib.pluck)(imageString, chartAttrs.bgimage, chartAttrs.bgswf),
        len,
        i,
        hideFn = function hideFn() {
      this.hide();
    },
        callBackAttrFn = function callBackAttrFn(attr) {
      attr.src = bgSWF;
      this.show().attr(attr);
    },
        backgroundGroup = imageString ? iapi.getChildContainer('messageGroup') : iapi.getContainer('backgroundGroup'),

    // TILE = 'tile',
    // FILL = 'fill',
    // FIT = 'fit',
    chartBorderWidth = config.borderWidth || 0,

    // chartBorderWidth = config.borderWidth = pluckNumber (chartAttrs.borderwidth, 1),
    borderRadius = config.borderRadius,
        borderDashStyle = config.borderDashStyle,
        borderColor = config.borderColor,
        bgSWFAlpha = config.bgSWFAlpha = (0, _lib.pluckNumber)(imageAttr && imageAttr.imageAlpha, chartAttrs.bgimagealpha, chartAttrs.bgswfalpha, 100),
        imgClipRect = config.imgClipRect = chartBorderWidth + _lib.COMMA + chartBorderWidth + _lib.COMMA + (chartWidth - chartBorderWidth * 2) + _lib.COMMA + (chartHeight - chartBorderWidth * 2),
        bgImageDisplayMode = (0, _lib.pluck)(chartAttrs.bgimagedisplaymode, _lib.preDefStr.noneStr).toLowerCase(),
        bgImageVAlign = (imageAttr && (0, _lib.getValidValue)(imageAttr.imageVAlign) || (0, _lib.getValidValue)(chartAttrs.bgimagevalign, _lib.BLANKSTRING)).toLowerCase(),
        bgImageHAlign = (imageAttr && imageAttr.imageHAlign || chartAttrs.bgimagehalign || _lib.BLANKSTRING).toLowerCase(),
        bgImageScale = config.bgImageScale = (0, _lib.pluckNumber)(imageAttr && imageAttr.imageScale, chartAttrs.bgimagescale, 100),
        containerBackgroundColor = config.containerBackgroundColor = (0, _lib.getContainerBackgroundColor)(iapi.chartInstance);

    paper.canvas.style.backgroundColor = containerBackgroundColor;

    if (bgImageDisplayMode === _lib.TILE || bgImageDisplayMode === _lib.FILL || bgImageDisplayMode === _lib.FIT) {
      if (bgImageVAlign !== _lib.POSITION_TOP && bgImageVAlign !== _lib.POSITION_MIDDLE && bgImageVAlign !== _lib.POSITION_BOTTOM) {
        bgImageVAlign = _lib.POSITION_MIDDLE;
      }
      if (bgImageHAlign !== _lib.POSITION_LEFT && bgImageHAlign !== _lib.POSITION_MIDDLE && bgImageHAlign !== _lib.POSITION_RIGHT) {
        bgImageHAlign = _lib.POSITION_MIDDLE;
      }
    } else {
      if (bgImageVAlign !== _lib.POSITION_TOP && bgImageVAlign !== _lib.POSITION_MIDDLE && bgImageVAlign !== _lib.POSITION_BOTTOM) {
        bgImageVAlign = _lib.POSITION_TOP;
      }
      if (bgImageHAlign !== _lib.POSITION_LEFT && bgImageHAlign !== _lib.POSITION_MIDDLE && bgImageHAlign !== _lib.POSITION_RIGHT) {
        bgImageHAlign = _lib.POSITION_LEFT;
      }
    }
    config.bgSWFAlpha = bgSWFAlpha;
    config.bgImageVAlign = bgImageVAlign;
    config.bgImageHAlign = bgImageHAlign;

    config.backgroundColor = backgroundColor = !imageString && iapi._getBackgroundCosmetics();
    attrObj = {
      x: chartBorderWidth,
      y: chartBorderWidth,
      width: chartWidth - chartBorderWidth * 2,
      height: chartHeight - chartBorderWidth * 2,
      stroke: _lib.preDefStr.noneStr,
      fill: (0, _lib.toRaphaelColor)(backgroundColor)
    };

    if (!backgroundElement) {
      background.addGraphicalElement('backgroundElement', paper.rect(attrObj, backgroundGroup));
    } else {
      iapi.getFromEnv('animationManager').registerAnimation([{
        animType: animType,
        data: [{
          el: backgroundElement,
          attrs: {
            x: chartBorderWidth,
            y: chartBorderWidth,
            width: chartWidth - chartBorderWidth * 2,
            height: chartHeight - chartBorderWidth * 2,
            fill: (0, _lib.toRaphaelColor)(backgroundColor)
          }
        }]
      }], 'default');

      backgroundElement.attr({
        stroke: _lib.preDefStr.noneStr
      });
    }

    attrObj = {
      x: chartBorderWidth / 2,
      y: chartBorderWidth / 2,
      width: chartWidth - chartBorderWidth,
      height: chartHeight - chartBorderWidth,
      stroke: borderColor,
      'stroke-width': chartBorderWidth,
      'stroke-dasharray': borderDashStyle,
      fill: _lib.preDefStr.noneStr,
      r: borderRadius || 0
    };

    if (!borderElement && !imageString) {
      background.addGraphicalElement('borderElement', paper.rect(attrObj, backgroundGroup));
    } else if (!imageString) {
      iapi.getFromEnv('animationManager').registerAnimation([{
        animType: animType,
        data: [{
          el: borderElement,
          attrs: {
            x: chartBorderWidth / 2,
            y: chartBorderWidth / 2,
            width: chartWidth - chartBorderWidth,
            height: chartHeight - chartBorderWidth,
            r: borderRadius || 0,
            stroke: borderColor,
            'stroke-width': chartBorderWidth
          }
        }]
      }], 'default');

      // borderElement.animateWith(dummyObj, animObj, {
      //   x: chartBorderWidth / 2,
      //   y: chartBorderWidth / 2,
      //   width: (chartWidth - chartBorderWidth),
      //   height: (chartHeight - chartBorderWidth),
      //   r: borderRadius || 0
      // }, animationDuration, animType);
      borderElement.attr({
        fill: _lib.preDefStr.noneStr,
        'stroke-dasharray': borderDashStyle
      });
    }

    if (bgSWF) {
      referenceImage = new Image();
      xRepeatCount = 1;
      yRepeatCount = 1;

      referenceImage.onload = function () {
        // Check for not drawn chart message images
        if (chartConfig.stopImageDraw) {
          chartConfig.stopImageDraw = false;
          return;
        }

        !graphics.backgroundImage && (graphics.backgroundImage = []);

        if (graphics.backgroundImage) {
          for (i = 0, len = graphics.backgroundImage.length; i < len; i++) {
            // graphics.backgroundImage[i].hide();

            graphics.backgroundImage[i].animateWith(dummyObj, animObj, {
              opacity: 0
            }, animationDuration, animType, hideFn, {
              start: 0,
              end: 0.5
            });
          }
        }

        bgImageAttr = (0, _lib.setImageDisplayMode)(bgImageDisplayMode, bgImageVAlign, bgImageHAlign, bgImageScale, chartBorderWidth, chartWidth, chartHeight, referenceImage);
        bgImageAttr[strConsts.clipRectStr] = imgClipRect;
        if (bgImageAttr.tileInfo) {
          xRepeatCount = bgImageAttr.tileInfo.xCount;
          yRepeatCount = yCount = bgImageAttr.tileInfo.yCount;
          imgY = bgImageAttr.y;

          delete bgImageAttr.tileInfo;
          counter = 0;
          while (xRepeatCount && bgImageAttr.width && bgImageAttr.height) {
            yCount -= 1;
            // Use the renderer ref from chartBGImageGroup
            // as in case of realtime chart the renderer may be
            // destroyed before onload
            if (!imageElement) {
              if (!graphics.backgroundImage[counter]) {
                graphics.backgroundImage[counter] = paper.image(bgSWF, backgroundGroup).attr({
                  opacity: 0
                });
                // graphics.backgroundImage[counter].attr (bgImageAttr);
              }
              graphics.backgroundImage[counter].animateWith(dummyObj, animObj, {
                opacity: 0
              }, animationDuration, animType, callBackAttrFn.bind(graphics.backgroundImage[counter], (0, _lib.extend2)({}, bgImageAttr)), {
                start: 0,
                end: 0.5
              });

              graphics.backgroundImage[counter].animateWith(dummyObj, animObj, {
                opacity: bgSWFAlpha * 0.01
              }, animationDuration, animType, null, {
                start: 0.5,
                end: 1
              });

              // graphics.backgroundImage[counter]
              //     .attr ({
              //         src: bgSWF
              //     })
              //     .css ( {
              //         opacity: bgSWFAlpha * 0.01
              //     });
            } else {
              graphics.backgroundImage[counter] = imageElement.clone().attr({
                src: bgSWF,
                x: bgImageAttr.x,
                y: bgImageAttr.y
              });
              backgroundGroup.appendChild(graphics.backgroundImage[counter]);
            }

            bgImageAttr.y += bgImageAttr.height;
            if (yCount === 0) {
              yCount = yRepeatCount;
              xRepeatCount -= 1;
              bgImageAttr.x += bgImageAttr.width;
              bgImageAttr.y = imgY;
            }
            counter++;
          }
        } else {
          // Return if the previous chart has disposed
          // todo
          // if (chart.disposed || paper.disposed) {
          //     return;
          // }
          if (!graphics.backgroundImage[0]) {
            graphics.backgroundImage[0] = paper.image(bgSWF, backgroundGroup).attr({
              opacity: 0
            });
          }

          graphics.backgroundImage[0].animateWith(dummyObj, animObj, {
            opacity: 0
          }, animationDuration, animType, function () {
            bgImageAttr.src = bgSWF;
            bgImageAttr.visibility = _lib.VISIBLE;
            bgImageAttr['clip-rect'] = imgClipRect;
            graphics.backgroundImage[0].show().attr(bgImageAttr);
          }, {
            start: 0,
            end: 0.5
          });

          graphics.backgroundImage[0].animateWith(dummyObj, animObj, {
            opacity: bgSWFAlpha * 0.01
          }, animationDuration, animType, null, {
            start: 0.5,
            end: 1
          });

          graphics.backgroundImage[0].show();

          // graphics.backgroundImage[0].animateWith(dummyObj, animObj, bgImageAttr,
          //  animationDuration, animType);

          // graphics.backgroundImage[0]
          //     .css ( {
          //         opacity: bgSWFAlpha * 0.01
          //     })
          //     .attr ( {
          //         src: bgSWF,
          //         visibility: VISIBLE,
          //         'clip-rect': imgClipRect
          //     });
        }

        /**
         * This event is fired for external background image for a chart has loaded succesfully. These
         * background images are applied using the `bgImage` chart attribute. In case loading fails, the
         * { @link FusionCharts#event.backgroundLoadError } event is fired.
         *
         * To know more about how to load and configure chart background image, see:
         * { @tutorial configuring-your-chart-border-and-background }.
         *
         * > This event is not fired if `bgImage` attribute is not provided.
         * @see FusionCharts#event:backgroundLoadError
         * @event FusionCharts#backgroundLoaded
         * @group chart
         * @param { string } url - URL of the background image
         * @param { number } bgImageAlpha - The value of the image alpha
         * @param { string } bgImageDisplayMode - The mode in which the images are displayed in background
         * of the chart
         * @param { string } bgImageVAlign - The vertical alignment of the background image
         * @param { string } bgImageHAlign -The horizontal alignment of the background image
         * @param { number } imageWidth - The width of the background image
         * @param { number } imageHeight - The height of the background image
         */
        global.raiseEvent(strConsts.BACKGROUNDLOADED, {
          url: bgSWF,
          bgImageAlpha: bgSWFAlpha * 100,
          bgImageDisplayMode: bgImageDisplayMode,
          bgImageVAlign: bgImageVAlign,
          bgImageHAlign: bgImageHAlign,
          bgImageScale: bgImageScale,
          imageWidth: referenceImage.width,
          imageHeight: referenceImage.height
        }, iapi.chartInstance);
      };
      // error event
      referenceImage.onerror = function (e) {
        /**
         * This event is fired for external background image for a chart failed to load. These
         * background images are applied using the `bgImage` chart attribute.
         *
         * The cause of failure can be network connectivity issues or invalid value passed to the
         * `bgImage` attribute. There can also be errors due to cross-domain policies and other security
         * restrictions enforced by browsers.
         *
         * To know more about how to load and configure chart background image, see:
         * { @tutorial configuring-your-chart-border-and-background }.
         *
         * > This event is not fired if `bgImage` attribute is not provided.
         * @see FusionCharts#event:backgroundLoaded
         * @event FusionCharts#backgroundLoadError
         * @group chart
         *
         * @param { string } url - The URL of the background image
         * @param { number } bgImageAlpha - The alpha value of the image.
         * @param { string } error - Contains error message.
         * @param { string } bgImageDisplayMode - The mode in which the images are displayed in the
         * background of the chart.
         * @param { string } bgImageVAlign - Vertical alignment of the background image.
         * @param { string } bgImageHAlign - Horizontal alignment of the background image.
         * @param { number } bgImageScale - The value of the scaling of the image.
         * @param { number } imageHeight - The height of the background image.
         */
        global.raiseEvent(strConsts.BACKGROUNDLOADERROR, {
          url: bgSWF,
          bgImageAlpha: bgSWFAlpha * 100,
          error: e,
          bgImageDisplayMode: bgImageDisplayMode,
          bgImageVAlign: bgImageVAlign,
          bgImageHAlign: bgImageHAlign,
          bgImageScale: bgImageScale
        }, iapi.chartInstance);
      };

      referenceImage.src = bgSWF;
    } else {
      if (graphics.backgroundImage) {
        for (i = 0, len = graphics.backgroundImage.length; i < len; i++) {
          // graphics.backgroundImage[i].hide();
          graphics.backgroundImage[i].animateWith(dummyObj, animObj, {
            opacity: 0
          }, animationDuration, animType, hideFn, {
            start: 0,
            end: 0.5
          });
        }
      }
    }
  };

  BaseChart.prototype.redraw = function redraw() {
    // todo: decide whether it need to have a transpose animation during redrawing
    var iapi = this,
        dummyObj = iapi.graphics.dummyObj;
    dummyObj && dummyObj.stop(undefined, true, true);
    iapi.draw && iapi.syncDraw();
  };

  // function to remove waiting jobs


  BaseChart.prototype._removeWaitingJobs = function _removeWaitingJobs() {
    this.removeAllJobs();
  };

  BaseChart.prototype._drawCreditLabel = function _drawCreditLabel() {
    var iapi = this,
        config = iapi.config,
        coreOptions = iapi.getFromEnv('core-options'),
        globalCreditLabel = coreOptions.creditLabel,
        chartCreditLabel = iapi.chartInstance.args.creditLabel,
        hasCreditLabel,
        chartHeight = config.height,
        creditLabelElem = iapi.getGraphicalElement('creditLabel'),
        creditGroup,
        parentGroup = iapi.getContainer('parentgroup'),
        attr,
        css,
        paper = iapi.getFromEnv('paper'),
        credits = {
      href: _lib.CREDIT_HREF,
      text: _lib.CREDIT_STRING
    };

    hasCreditLabel = iapi.creditLabel && (typeof chartCreditLabel === 'undefined' ? globalCreditLabel !== false : chartCreditLabel !== false);

    if (hasCreditLabel) {
      // if (!creditGroup) {
      //   creditGroup = graphics.creditGroup = paper.group('creditgroup');
      //   parentGroup && creditGroup.insertAfter(parentGroup);
      // }
      creditGroup = iapi.getContainer('creditgroup') || iapi.addContainer('creditgroup', paper.group('creditgroup'));
      parentGroup && creditGroup.insertAfter(parentGroup);
      attr = {
        text: credits.text,
        x: 6,
        y: chartHeight - 4,
        'vertical-align': _lib.POSITION_BOTTOM,
        'text-anchor': _lib.POSITION_START,
        fill: 'rgba(0,0,0,0.5)',
        title: credits.title || _lib.BLANK
      };

      css = {
        fontSize: 9,
        fontFamily: 'Verdana,sans',
        cursor: _lib.POINTER,
        '_cursor': _lib.HAND
      };
      if (!creditLabelElem) {
        creditLabelElem = iapi.addGraphicalElement('creditLabel', paper.text(attr, css, creditGroup)).click(function () {
          try {
            open(credits.href);
          } catch (err) {
            (top || window).location.href = credits.href;
          }
        });
      } else {
        creditLabelElem.attr(attr).css(css);
      }
    } else if (creditLabelElem && creditLabelElem.remove) {
      creditLabelElem.remove();
      delete iapi.graphics.creditLabel;
    }
  };

  return BaseChart;
}(_componentInterface2['default']);

BaseChart.stringConstants = {
  BACKGROUNDLOADED: 'BackgroundLoaded',
  BACKGROUNDLOADERROR: 'BackgroundLoadError',
  clipRectStr: 'clip-rect'
};

exports['default'] = BaseChart;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)))

/***/ }),
/* 362 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.canvas = exports.vml = exports.svg = undefined;

var _raphael = __webpack_require__(85);

var _raphael2 = _interopRequireDefault(_raphael);

var _raphael3 = __webpack_require__(393);

var _raphael4 = _interopRequireDefault(_raphael3);

var _raphael5 = __webpack_require__(394);

var _raphael6 = _interopRequireDefault(_raphael5);

var _raphael7 = __webpack_require__(395);

var _raphael8 = _interopRequireDefault(_raphael7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

exports.svg = _raphael4['default'];
exports.vml = _raphael6['default'];
exports.canvas = _raphael8['default'];
exports['default'] = _raphael2['default'];

/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(364);
__webpack_require__(377);
module.exports = __webpack_require__(141).f('iterator');

/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at  = __webpack_require__(365)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(198)(String, 'String', function(iterated){
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , index = this._i
    , point;
  if(index >= O.length)return {value: undefined, done: true};
  point = $at(O, index);
  this._i += point.length;
  return {value: point, done: false};
});

/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(131)
  , defined   = __webpack_require__(132);
// true  -> String#at
// false -> String#codePointAt
module.exports = function(TO_STRING){
  return function(that, pos){
    var s = String(defined(that))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

/***/ }),
/* 366 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(367);
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};

/***/ }),
/* 367 */
/***/ (function(module, exports) {

module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};

/***/ }),
/* 368 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create         = __webpack_require__(203)
  , descriptor     = __webpack_require__(89)
  , setToStringTag = __webpack_require__(140)
  , IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(53)(IteratorPrototype, __webpack_require__(56)('iterator'), function(){ return this; });

module.exports = function(Constructor, NAME, next){
  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
};

/***/ }),
/* 369 */
/***/ (function(module, exports, __webpack_require__) {

var dP       = __webpack_require__(54)
  , anObject = __webpack_require__(86)
  , getKeys  = __webpack_require__(90);

module.exports = __webpack_require__(55) ? Object.defineProperties : function defineProperties(O, Properties){
  anObject(O);
  var keys   = getKeys(Properties)
    , length = keys.length
    , i = 0
    , P;
  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(205);
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};

/***/ }),
/* 371 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(44)
  , toLength  = __webpack_require__(372)
  , toIndex   = __webpack_require__(373);
module.exports = function(IS_INCLUDES){
  return function($this, el, fromIndex){
    var O      = toIObject($this)
      , length = toLength(O.length)
      , index  = toIndex(fromIndex, length)
      , value;
    // Array#includes uses SameValueZero equality algorithm
    if(IS_INCLUDES && el != el)while(length > index){
      value = O[index++];
      if(value != value)return true;
    // Array#toIndex ignores holes, Array#includes - not
    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
      if(O[index] === el)return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

/***/ }),
/* 372 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(131)
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

/***/ }),
/* 373 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(131)
  , max       = Math.max
  , min       = Math.min;
module.exports = function(index, length){
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

/***/ }),
/* 374 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(36).document && document.documentElement;

/***/ }),
/* 375 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has         = __webpack_require__(43)
  , toObject    = __webpack_require__(376)
  , IE_PROTO    = __webpack_require__(137)('IE_PROTO')
  , ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function(O){
  O = toObject(O);
  if(has(O, IE_PROTO))return O[IE_PROTO];
  if(typeof O.constructor == 'function' && O instanceof O.constructor){
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

/***/ }),
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(132);
module.exports = function(it){
  return Object(defined(it));
};

/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(378);
var global        = __webpack_require__(36)
  , hide          = __webpack_require__(53)
  , Iterators     = __webpack_require__(136)
  , TO_STRING_TAG = __webpack_require__(56)('toStringTag');

for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
  var NAME       = collections[i]
    , Collection = global[NAME]
    , proto      = Collection && Collection.prototype;
  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}

/***/ }),
/* 378 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(379)
  , step             = __webpack_require__(380)
  , Iterators        = __webpack_require__(136)
  , toIObject        = __webpack_require__(44);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(198)(Array, 'Array', function(iterated, kind){
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , kind  = this._k
    , index = this._i++;
  if(!O || index >= O.length){
    this._t = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

/***/ }),
/* 379 */
/***/ (function(module, exports) {

module.exports = function(){ /* empty */ };

/***/ }),
/* 380 */
/***/ (function(module, exports) {

module.exports = function(done, value){
  return {value: value, done: !!done};
};

/***/ }),
/* 381 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(382);
__webpack_require__(389);
__webpack_require__(390);
__webpack_require__(391);
module.exports = __webpack_require__(134).Symbol;

/***/ }),
/* 382 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global         = __webpack_require__(36)
  , has            = __webpack_require__(43)
  , DESCRIPTORS    = __webpack_require__(55)
  , $export        = __webpack_require__(199)
  , redefine       = __webpack_require__(202)
  , META           = __webpack_require__(383).KEY
  , $fails         = __webpack_require__(88)
  , shared         = __webpack_require__(138)
  , setToStringTag = __webpack_require__(140)
  , uid            = __webpack_require__(91)
  , wks            = __webpack_require__(56)
  , wksExt         = __webpack_require__(141)
  , wksDefine      = __webpack_require__(142)
  , keyOf          = __webpack_require__(384)
  , enumKeys       = __webpack_require__(385)
  , isArray        = __webpack_require__(386)
  , anObject       = __webpack_require__(86)
  , toIObject      = __webpack_require__(44)
  , toPrimitive    = __webpack_require__(135)
  , createDesc     = __webpack_require__(89)
  , _create        = __webpack_require__(203)
  , gOPNExt        = __webpack_require__(387)
  , $GOPD          = __webpack_require__(388)
  , $DP            = __webpack_require__(54)
  , $keys          = __webpack_require__(90)
  , gOPD           = $GOPD.f
  , dP             = $DP.f
  , gOPN           = gOPNExt.f
  , $Symbol        = global.Symbol
  , $JSON          = global.JSON
  , _stringify     = $JSON && $JSON.stringify
  , PROTOTYPE      = 'prototype'
  , HIDDEN         = wks('_hidden')
  , TO_PRIMITIVE   = wks('toPrimitive')
  , isEnum         = {}.propertyIsEnumerable
  , SymbolRegistry = shared('symbol-registry')
  , AllSymbols     = shared('symbols')
  , OPSymbols      = shared('op-symbols')
  , ObjectProto    = Object[PROTOTYPE]
  , USE_NATIVE     = typeof $Symbol == 'function'
  , QObject        = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function(){
  return _create(dP({}, 'a', {
    get: function(){ return dP(this, 'a', {value: 7}).a; }
  })).a != 7;
}) ? function(it, key, D){
  var protoDesc = gOPD(ObjectProto, key);
  if(protoDesc)delete ObjectProto[key];
  dP(it, key, D);
  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function(tag){
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
  return typeof it == 'symbol';
} : function(it){
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D){
  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if(has(AllSymbols, key)){
    if(!D.enumerable){
      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = _create(D, {enumerable: createDesc(0, false)});
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P){
  anObject(it);
  var keys = enumKeys(P = toIObject(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P){
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key){
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
  it  = toIObject(it);
  key = toPrimitive(key, true);
  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
  var D = gOPD(it, key);
  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it){
  var names  = gOPN(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
  var IS_OP  = it === ObjectProto
    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if(!USE_NATIVE){
  $Symbol = function Symbol(){
    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function(value){
      if(this === ObjectProto)$set.call(OPSymbols, value);
      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f   = $defineProperty;
  __webpack_require__(208).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(143).f  = $propertyIsEnumerable;
  __webpack_require__(207).f = $getOwnPropertySymbols;

  if(DESCRIPTORS && !__webpack_require__(133)){
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function(name){
    return wrap(wks(name));
  }
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});

for(var symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);

for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    if(isSymbol(key))return keyOf(SymbolRegistry, key);
    throw TypeError(key + ' is not a symbol!');
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it){
    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
    var args = [it]
      , i    = 1
      , replacer, $replacer;
    while(arguments.length > i)args.push(arguments[i++]);
    replacer = args[1];
    if(typeof replacer == 'function')$replacer = replacer;
    if($replacer || !isArray(replacer))replacer = function(key, value){
      if($replacer)value = $replacer.call(this, key, value);
      if(!isSymbol(value))return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(53)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

/***/ }),
/* 383 */
/***/ (function(module, exports, __webpack_require__) {

var META     = __webpack_require__(91)('meta')
  , isObject = __webpack_require__(87)
  , has      = __webpack_require__(43)
  , setDesc  = __webpack_require__(54).f
  , id       = 0;
var isExtensible = Object.isExtensible || function(){
  return true;
};
var FREEZE = !__webpack_require__(88)(function(){
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function(it){
  setDesc(it, META, {value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  }});
};
var fastKey = function(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add metadata
    if(!create)return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function(it, create){
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return true;
    // not necessary to add metadata
    if(!create)return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function(it){
  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY:      META,
  NEED:     false,
  fastKey:  fastKey,
  getWeak:  getWeak,
  onFreeze: onFreeze
};

/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

var getKeys   = __webpack_require__(90)
  , toIObject = __webpack_require__(44);
module.exports = function(object, el){
  var O      = toIObject(object)
    , keys   = getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};

/***/ }),
/* 385 */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(90)
  , gOPS    = __webpack_require__(207)
  , pIE     = __webpack_require__(143);
module.exports = function(it){
  var result     = getKeys(it)
    , getSymbols = gOPS.f;
  if(getSymbols){
    var symbols = getSymbols(it)
      , isEnum  = pIE.f
      , i       = 0
      , key;
    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
  } return result;
};

/***/ }),
/* 386 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(205);
module.exports = Array.isArray || function isArray(arg){
  return cof(arg) == 'Array';
};

/***/ }),
/* 387 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(44)
  , gOPN      = __webpack_require__(208).f
  , toString  = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function(it){
  try {
    return gOPN(it);
  } catch(e){
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it){
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),
/* 388 */
/***/ (function(module, exports, __webpack_require__) {

var pIE            = __webpack_require__(143)
  , createDesc     = __webpack_require__(89)
  , toIObject      = __webpack_require__(44)
  , toPrimitive    = __webpack_require__(135)
  , has            = __webpack_require__(43)
  , IE8_DOM_DEFINE = __webpack_require__(200)
  , gOPD           = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(55) ? gOPD : function getOwnPropertyDescriptor(O, P){
  O = toIObject(O);
  P = toPrimitive(P, true);
  if(IE8_DOM_DEFINE)try {
    return gOPD(O, P);
  } catch(e){ /* empty */ }
  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
};

/***/ }),
/* 389 */
/***/ (function(module, exports) {



/***/ }),
/* 390 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(142)('asyncIterator');

/***/ }),
/* 391 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(142)('observable');

/***/ }),
/* 392 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

exports.__esModule = true;

// Copyright (c) 2017 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ┌────────────────────────────────────────────────────────────┐ \\
// │ Eve 0.5.3 - JavaScript Events Library                      │ \\
// ├────────────────────────────────────────────────────────────┤ \\
// │ Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/) │ \\
// └────────────────────────────────────────────────────────────┘ \\

exports["default"] = function (glob) {
    var version = "0.5.3",
        has = "hasOwnProperty",
        separator = /[\.\/]/,
        comaseparator = /\s*,\s*/,
        wildcard = "*",
        fun = function fun() {},
        numsort = function numsort(a, b) {
        return a - b;
    },
        current_event,
        stop,
        events = { n: {} },
        firstDefined = function firstDefined() {
        for (var i = 0, ii = this.length; i < ii; i++) {
            if (typeof this[i] != "undefined") {
                return this[i];
            }
        }
    },
        lastDefined = function lastDefined() {
        var i = this.length;
        while (--i) {
            if (typeof this[i] != "undefined") {
                return this[i];
            }
        }
    },
        objtos = Object.prototype.toString,
        Str = String,
        isArray = Array.isArray || function (ar) {
        return ar instanceof Array || objtos.call(ar) == "[object Array]";
    },

    /*\
     * eve
     [ method ]
      * Fires event with given `name`, given scope and other parameters.
      - name (string) name of the *event*, dot (`.`) or slash (`/`) separated
     - scope (object) context for the event handlers
     - varargs (...) the rest of arguments will be sent to event handlers
      = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.
    \*/
    eve = function eve(name, scope) {
        var e = events,
            oldstop = stop,
            args = Array.prototype.slice.call(arguments, 2),
            listeners = eve.listeners(name),
            z = 0,
            f = false,
            l,
            indexed = [],
            queue = {},
            out = [],
            ce = current_event,
            errors = [];
        out.firstDefined = firstDefined;
        out.lastDefined = lastDefined;
        current_event = name;
        stop = 0;
        for (var i = 0, ii = listeners.length; i < ii; i++) {
            if ("zIndex" in listeners[i]) {
                indexed.push(listeners[i].zIndex);
                if (listeners[i].zIndex < 0) {
                    queue[listeners[i].zIndex] = listeners[i];
                }
            }
        }indexed.sort(numsort);
        while (indexed[z] < 0) {
            l = queue[indexed[z++]];
            out.push(l.apply(scope, args));
            if (stop) {
                stop = oldstop;
                return out;
            }
        }
        for (i = 0; i < ii; i++) {
            l = listeners[i];
            if ("zIndex" in l) {
                if (l.zIndex == indexed[z]) {
                    out.push(l.apply(scope, args));
                    if (stop) {
                        break;
                    }
                    do {
                        z++;
                        l = queue[indexed[z]];
                        l && out.push(l.apply(scope, args));
                        if (stop) {
                            break;
                        }
                    } while (l);
                } else {
                    queue[l.zIndex] = l;
                }
            } else {
                out.push(l.apply(scope, args));
                if (stop) {
                    break;
                }
            }
        }
        stop = oldstop;
        current_event = ce;
        return out;
    };
    // Undocumented. Debug only.
    eve._events = events;
    /*\
     * eve.listeners
     [ method ]
      * Internal method which gives you array of all event handlers that will be triggered by the given `name`.
      - name (string) name of the event, dot (`.`) or slash (`/`) separated
      = (array) array of event handlers
    \*/
    eve.listeners = function (name) {
        var names = isArray(name) ? name : name.split(separator),
            e = events,
            item,
            items,
            k,
            i,
            ii,
            j,
            jj,
            nes,
            es = [e],
            out = [];
        for (i = 0, ii = names.length; i < ii; i++) {
            nes = [];
            for (j = 0, jj = es.length; j < jj; j++) {
                e = es[j].n;
                items = [e[names[i]], e[wildcard]];
                k = 2;
                while (k--) {
                    item = items[k];
                    if (item) {
                        nes.push(item);
                        out = out.concat(item.f || []);
                    }
                }
            }
            es = nes;
        }
        return out;
    };
    /*\
     * eve.separator
     [ method ]
      * If for some reasons you don’t like default separators (`.` or `/`) you can specify yours
     * here. Be aware that if you pass a string longer than one character it will be treated as
     * a list of characters.
      - separator (string) new separator. Empty string resets to default: `.` or `/`.
    \*/
    eve.separator = function (sep) {
        if (sep) {
            sep = Str(sep).replace(/(?=[\.\^\]\[\-])/g, "\\");
            sep = "[" + sep + "]";
            separator = new RegExp(sep);
        } else {
            separator = /[\.\/]/;
        }
    };
    /*\
     * eve.on
     [ method ]
     **
     * Binds given event handler with a given name. You can use wildcards “`*`” for the names:
     | eve.on("*.under.*", f);
     | eve("mouse.under.floor"); // triggers f
     * Use @eve to trigger the listener.
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     **
     - name (array) if you don’t want to use separators, you can use array of strings
     - f (function) event handler function
     **
     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment.
     > Example:
     | eve.on("mouse", eatIt)(2);
     | eve.on("mouse", scream);
     | eve.on("mouse", catchIt)(1);
     * This will ensure that `catchIt` function will be called before `eatIt`.
     *
     * If you want to put your handler before non-indexed handlers, specify a negative value.
     * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.
    \*/
    eve.on = function (name, f) {
        if (typeof f != "function") {
            return function () {};
        }
        var names = isArray(name) ? isArray(name[0]) ? name : [name] : Str(name).split(comaseparator);
        for (var i = 0, ii = names.length; i < ii; i++) {
            (function (name) {
                var names = isArray(name) ? name : Str(name).split(separator),
                    e = events,
                    exist;
                for (var i = 0, ii = names.length; i < ii; i++) {
                    e = e.n;
                    e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = { n: {} });
                }
                e.f = e.f || [];
                for (i = 0, ii = e.f.length; i < ii; i++) {
                    if (e.f[i] == f) {
                        exist = true;
                        break;
                    }
                }!exist && e.f.push(f);
            })(names[i]);
        }
        return function (zIndex) {
            if (+zIndex == +zIndex) {
                f.zIndex = +zIndex;
            }
        };
    };
    /*\
     * eve.f
     [ method ]
     **
     * Returns function that will fire given event with optional arguments.
     * Arguments that will be passed to the result function will be also
     * concated to the list of final arguments.
     | el.onclick = eve.f("click", 1, 2);
     | eve.on("click", function (a, b, c) {
     |     console.log(a, b, c); // 1, 2, [event object]
     | });
     - event (string) event name
     - varargs (…) and any other arguments
     = (function) possible event handler function
    \*/
    eve.f = function (event) {
        var attrs = [].slice.call(arguments, 1);
        return function () {
            eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));
        };
    };
    /*\
     * eve.stop
     [ method ]
     **
     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.
    \*/
    eve.stop = function () {
        stop = 1;
    };
    /*\
     * eve.nt
     [ method ]
     **
     * Could be used inside event handler to figure out actual name of the event.
     **
     - subname (string) #optional subname of the event
     **
     = (string) name of the event, if `subname` is not specified
     * or
     = (boolean) `true`, if current event’s name contains `subname`
    \*/
    eve.nt = function (subname) {
        var cur = isArray(current_event) ? current_event.join(".") : current_event;
        if (subname) {
            return new RegExp("(?:\\.|\\/|^)" + subname + "(?:\\.|\\/|$)").test(cur);
        }
        return cur;
    };
    /*\
     * eve.nts
     [ method ]
     **
     * Could be used inside event handler to figure out actual name of the event.
     **
     **
     = (array) names of the event
    \*/
    eve.nts = function () {
        return isArray(current_event) ? current_event : current_event.split(separator);
    };
    /*\
     * eve.off
     [ method ]
     **
     * Removes given function from the list of event listeners assigned to given name.
     * If no arguments specified all the events will be cleared.
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
    \*/
    /*\
     * eve.unbind
     [ method ]
     **
     * See @eve.off
    \*/
    eve.off = eve.unbind = function (name, f) {
        if (!name) {
            eve._events = events = { n: {} };
            return;
        }
        var names = isArray(name) ? isArray(name[0]) ? name : [name] : Str(name).split(comaseparator);
        if (names.length > 1) {
            for (var i = 0, ii = names.length; i < ii; i++) {
                eve.off(names[i], f);
            }
            return;
        }
        names = isArray(name) ? name : Str(name).split(separator);
        var e,
            key,
            splice,
            i,
            ii,
            j,
            jj,
            cur = [events],
            inodes = [];
        for (i = 0, ii = names.length; i < ii; i++) {
            for (j = 0; j < cur.length; j += splice.length - 2) {
                splice = [j, 1];
                e = cur[j].n;
                if (names[i] != wildcard) {
                    if (e[names[i]]) {
                        splice.push(e[names[i]]);
                        inodes.unshift({
                            n: e,
                            name: names[i]
                        });
                    }
                } else {
                    for (key in e) {
                        if (e[has](key)) {
                            splice.push(e[key]);
                            inodes.unshift({
                                n: e,
                                name: key
                            });
                        }
                    }
                }
                cur.splice.apply(cur, splice);
            }
        }
        for (i = 0, ii = cur.length; i < ii; i++) {
            e = cur[i];
            while (e.n) {
                if (f) {
                    if (e.f) {
                        for (j = 0, jj = e.f.length; j < jj; j++) {
                            if (e.f[j] == f) {
                                e.f.splice(j, 1);
                                break;
                            }
                        }!e.f.length && delete e.f;
                    }
                    for (key in e.n) {
                        if (e.n[has](key) && e.n[key].f) {
                            var funcs = e.n[key].f;
                            for (j = 0, jj = funcs.length; j < jj; j++) {
                                if (funcs[j] == f) {
                                    funcs.splice(j, 1);
                                    break;
                                }
                            }!funcs.length && delete e.n[key].f;
                        }
                    }
                } else {
                    delete e.f;
                    for (key in e.n) {
                        if (e.n[has](key) && e.n[key].f) {
                            delete e.n[key].f;
                        }
                    }
                }
                e = e.n;
            }
        }
        // prune inner nodes in path
        prune: for (i = 0, ii = inodes.length; i < ii; i++) {
            e = inodes[i];
            for (key in e.n[e.name].f) {
                // not empty (has listeners)
                continue prune;
            }
            for (key in e.n[e.name].n) {
                // not empty (has children)
                continue prune;
            }
            // is empty
            delete e.n[e.name];
        }
    };
    /*\
     * eve.once
     [ method ]
     **
     * Binds given event handler with a given name to only run once then unbind itself.
     | eve.once("login", f);
     | eve("login"); // triggers f
     | eve("login"); // no listeners
     * Use @eve to trigger the listener.
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     **
     = (function) same return function as @eve.on
    \*/
    eve.once = function (name, f) {
        var f2 = function f2() {
            eve.off(name, f2);
            return f.apply(this, arguments);
        };
        return eve.on(name, f2);
    };
    /*\
     * eve.version
     [ property (string) ]
     **
     * Current version of the library.
    \*/
    eve.version = version;
    eve.toString = function () {
        return "You are running Eve " + version;
    };
    glob.eve = eve;
    // typeof module != "undefined" && module.exports ? module.exports = eve : typeof define === "function" && define.amd ? define("eve", [], function() { return eve; }) : glob.eve = eve;
    return eve;
}(typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : null);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)))

/***/ }),
/* 393 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _raphael = __webpack_require__(85);

var _raphael2 = _interopRequireDefault(_raphael);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

if (_raphael2["default"].svg) {
    /*
     * Recursively shows the element and stores the visibilties of its parents
     * in a tree structure for future restoration.
     * @param el - Element which is to shown recursively
     * @return Function - Function to restore the old visibility state.
    */
    var showRecursively = function showRecursively(el) {
        var origAttrTree = {},
            currentEl = el,
            currentNode = origAttrTree,
            fn = function fn() {
            var localEl = el,
                localNode = origAttrTree;
            while (localEl) {
                if (localNode._doHide) {
                    localEl.hide();
                }
                localEl = localEl.parent;
                localNode = localNode.parent;
            }
        };
        while (currentEl) {
            if (currentEl.node && currentEl.node.style && currentEl.node.style.display === "none") {
                currentEl.show();
                currentNode._doHide = true;
            }
            currentEl = currentEl.parent;
            currentNode.parent = {};
            currentNode = currentNode.parent;
        }
        return fn;
    };

    var LoadRefImage = function LoadRefImage(element, attrs) {
        var src = attrs.src,
            parent = element._.group,
            node = element.node,
            RefImg = element._.RefImg;

        if (!RefImg) {
            RefImg = element._.RefImg = new Image();
        }

        if (attrs.src !== undefined) {
            RefImg.src = src;
            RefImg.onload = function () {
                element.attr({
                    width: element.attrs.width || RefImg.width,
                    height: element.attrs.height || RefImg.height
                });
                // parent.canvas && parent.canvas.appendChild(node);
            };
            RefImg.onerror = function (e) {
                node.onerror && node.onerror(e);
            };
            element._.RefImg = RefImg;
        }
    };

    var has = "hasOwnProperty",
        Str = String,
        toFloat = parseFloat,
        toInt = parseInt,
        math = Math,
        mmax = math.max,
        abs = math.abs,
        pow = math.pow,
        sqrt = math.sqrt,
        separator = /[, ]+/,
        arrayShift = Array.prototype.shift,
        zeroStrokeFix = !!(/AppleWebKit/.test(_raphael2["default"]._g.win.navigator.userAgent) && (!/Chrome/.test(_raphael2["default"]._g.win.navigator.userAgent) || _raphael2["default"]._g.win.navigator.appVersion.match(/Chrome\/(\d+)\./)[1] < 29)),
        eve = _raphael2["default"].eve,
        E = "",
        S = " ",
        xlink = "http://www.w3.org/1999/xlink",
        markers = {
        block: "M5,0 0,2.5 5,5z",
        classic: "M5,0 0,2.5 5,5 3.5,3 3.5,2z",
        diamond: "M2.5,0 5,2.5 2.5,5 0,2.5z",
        open: "M6,1 1,3.5 6,6",
        oval: "M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z"
    },
        markerCounter = {},
        updateReferenceUrl = function updateReferenceUrl() {
        return _raphael2["default"]._url = _raphael2["default"]._g.win.location.href.replace(/#.*?$/, E);
    };

    _raphael2["default"].cachedFontHeight = {};

    _raphael2["default"].toString = function () {
        return "Your browser supports SVG.\nYou are running Rapha\xebl " + this.version;
    };

    // Code commented as resources will now be referenced using relative urls.
    // @todo Remove once we have acertained that there are no issues in any environment.
    // Automatic gradient and other reference update on state change
    // R._url = (/msie/i.test(navigator.userAgent) && !window.opera) ?
    //     E : updateReferenceUrl();
    // if (R._url && R._g.win.history.pushState) {
    //     R._g.win.history.pushState = (function () {
    //         var fn = R._g.win.history.pushState;
    //         return function () {
    //             var ret = fn.apply(R._g.win.history, arguments);
    //             return updateReferenceUrl(), ret;
    //         };
    //     }());
    //     R._g.win.addEventListener("popstate", updateReferenceUrl, false);
    // }
    _raphael2["default"]._url = E;

    var updateGradientReference = function updateGradientReference(element, newGradient) {
        var gradient = element.gradient;

        if (gradient) {
            if (gradient === newGradient) {
                return; // no change
            }
            // else gradient is specified and it is not same as newGradient, implying a dereference
            gradient.refCount--;
            if (!gradient.refCount) {
                gradient.parentNode.removeChild(gradient);
            }
            delete element.gradient;
        }

        if (newGradient) {
            // add new gradient
            element.gradient = newGradient;
            newGradient.refCount++;
        }
    };

    var $ = _raphael2["default"]._createNode = function (el, attr) {
        if (attr) {
            if (typeof el == "string") {
                el = $(el);
            }
            for (var key in attr) {
                if (attr[has](key)) {
                    if (key.substring(0, 6) == "xlink:") {
                        el.setAttributeNS(xlink, key.substring(6), Str(attr[key]));
                    } else {
                        el.setAttribute(key, Str(attr[key]));
                    }
                }
            }
        } else {
            el = _raphael2["default"]._g.doc.createElementNS("http://www.w3.org/2000/svg", el);
        }
        return el;
    },
        gradientUnitNames = {
        userSpaceOnUse: 'userSpaceOnUse',
        objectBoundingBox: 'objectBoundingBox'
    },
        gradientSpreadNames = {
        pad: 'pad',
        redlect: 'reflect',
        repeat: 'repeat'
    },
        addGradientFill = function addGradientFill(element, gradient) {
        if (!element.paper || !element.paper.defs) {
            return 0;
        }

        var type = "linear",
            SVG = element.paper,
            id = _raphael2["default"].getElementID((SVG.id + '-' + gradient).replace(/[\(\)\s%:,\xb0#]/g, "_")),
            fx = .5,
            fy = .5,
            r,
            cx,
            cy,
            units,
            spread,
            o = element.node,
            s = o.style,
            el = _raphael2["default"]._g.doc.getElementById(id);

        if (!el) {
            gradient = Str(gradient).replace(_raphael2["default"]._radial_gradient, function (all, opts) {
                type = "radial";
                opts = opts && opts.split(',') || [];
                units = opts[5];
                spread = opts[6];

                var _fx = opts[0],
                    _fy = opts[1],
                    _r = opts[2],
                    _cx = opts[3],
                    _cy = opts[4],
                    shifted = _fx && _fy,
                    dir,
                    sqx;

                if (_r) {
                    r = /\%/.test(_r) ? _r : toFloat(_r);
                }

                if (units === gradientUnitNames.userSpaceOnUse) {
                    if (shifted) {
                        fx = _fx;
                        fy = _fy;
                    }
                    if (_cx && _cy) {
                        cx = _cx;
                        cy = _cy;
                        if (!shifted) {
                            fx = cx;
                            fy = cy;
                        }
                    }
                    return E;
                }

                if (shifted) {
                    fx = toFloat(_fx);
                    fy = toFloat(_fy);
                    dir = (fy > .5) * 2 - 1;
                    (sqx = pow(fx - .5, 2)) + pow(fy - .5, 2) > .25 && sqx < .25 && (fy = sqrt(.25 - sqx) * dir + .5) && fy !== .5 && (fy = fy.toFixed(5) - 1e-5 * dir);
                }
                if (_cx && _cy) {
                    cx = toFloat(_cx);
                    cy = toFloat(_cy);
                    dir = (cy > .5) * 2 - 1;

                    (sqx = pow(cx - .5, 2)) + pow(cy - .5, 2) > .25 && sqx < .25 && (cy = sqrt(.25 - sqx) * dir + .5) && cy !== .5 && (cy = cy.toFixed(5) - 1e-5 * dir);

                    if (!shifted) {
                        fx = cx;
                        fy = cy;
                    }
                }

                return E;
            });
            gradient = gradient.split(/\s*\-\s*/);
            if (type == "linear") {
                var angle = gradient.shift(),
                    specs = angle.match(/\((.*)\)/),
                    vector,
                    max;

                specs = specs && specs[1] && specs[1].split(/\s*\,\s*/);
                angle = -toFloat(angle);
                if (isNaN(angle)) {
                    return null;
                }
                if (specs && specs.length) {
                    if (specs[0] in gradientUnitNames) {
                        units = specs.shift();
                        specs[0] in gradientSpreadNames && (spread = specs.shift());
                    } else {
                        specs[4] && (units = specs[4]);
                        specs[5] && (spread = specs[5]);
                    }

                    /** @todo apply angle rotation and validation */
                    vector = [specs[0] || "0%", specs[1] || "0%", specs[2] || "100%", specs[3] || "0%"];
                } else {
                    vector = [0, 0, math.cos(_raphael2["default"].rad(angle)), math.sin(_raphael2["default"].rad(angle))];
                    max = 1 / (mmax(abs(vector[2]), abs(vector[3])) || 1);
                    vector[2] *= max;
                    vector[3] *= max;
                    if (vector[2] < 0) {
                        vector[0] = -vector[2];
                        vector[2] = 0;
                    }
                    if (vector[3] < 0) {
                        vector[1] = -vector[3];
                        vector[3] = 0;
                    }
                }
            }
            var dots = _raphael2["default"]._parseDots(gradient);
            if (!dots) {
                return null;
            }

            el = $(type + "Gradient", {
                id: id
            });
            el.refCount = 0;
            units in gradientUnitNames && el.setAttribute('gradientUnits', Str(units));
            spread in gradientSpreadNames && el.setAttribute('spreadMethod', Str(spread));
            if (type === "radial") {
                r !== undefined && el.setAttribute('r', Str(r));

                if (cx !== undefined && cy !== undefined) {
                    el.setAttribute('cx', Str(cx));
                    el.setAttribute('cy', Str(cy));
                }
                el.setAttribute('fx', Str(fx));
                el.setAttribute('fy', Str(fy));
            } else {
                $(el, {
                    x1: vector[0],
                    y1: vector[1],
                    x2: vector[2],
                    y2: vector[3]
                });
            }

            for (var i = 0, ii = dots.length; i < ii; i++) {
                el.appendChild($("stop", {
                    offset: dots[i].offset ? dots[i].offset : i ? "100%" : "0%",
                    "stop-color": dots[i].color || "#fff",
                    //add stop opacity information
                    "stop-opacity": dots[i].opacity === undefined ? 1 : dots[i].opacity
                }));
            }
            SVG.defs.appendChild(el);
        }

        updateGradientReference(element, el);

        $(o, {
            fill: "url('" + _raphael2["default"]._url + "#" + id + "')",
            "fill-opacity": 1
        });

        s.fill = E;
        s.fillOpacity = 1;
        return 1;
    },
        updatePosition = function updatePosition(o) {
        var bbox = o.getBBox(1);
        $(o.pattern, {
            patternTransform: o.matrix.invert() + " translate(" + bbox.x + "," + bbox.y + ")"
        });
    },
        addArrow = function addArrow(o, value, isEnd) {
        if (o.type == "path") {
            var values = Str(value).toLowerCase().split("-"),
                p = o.paper,
                se = isEnd ? "end" : "start",
                node = o.node,
                attrs = o.attrs,
                stroke = attrs["stroke-width"],
                i = values.length,
                type = "classic",
                from,
                to,
                dx,
                refX,
                attr,
                w = 3,
                h = 3,
                t = 5;
            while (i--) {
                switch (values[i]) {
                    case "block":
                    case "classic":
                    case "oval":
                    case "diamond":
                    case "open":
                    case "none":
                        type = values[i];
                        break;
                    case "wide":
                        h = 5;
                        break;
                    case "narrow":
                        h = 2;
                        break;
                    case "long":
                        w = 5;
                        break;
                    case "short":
                        w = 2;
                        break;
                }
            }
            if (type == "open") {
                w += 2;
                h += 2;
                t += 2;
                dx = 1;
                refX = isEnd ? 4 : 1;
                attr = {
                    fill: "none",
                    stroke: attrs.stroke
                };
            } else {
                refX = dx = w / 2;
                attr = {
                    fill: attrs.stroke,
                    stroke: "none"
                };
            }
            if (o._.arrows) {
                if (isEnd) {
                    o._.arrows.endPath && markerCounter[o._.arrows.endPath]--;
                    o._.arrows.endMarker && markerCounter[o._.arrows.endMarker]--;
                } else {
                    o._.arrows.startPath && markerCounter[o._.arrows.startPath]--;
                    o._.arrows.startMarker && markerCounter[o._.arrows.startMarker]--;
                }
            } else {
                o._.arrows = {};
            }
            if (type != "none") {
                var pathId = "raphael-marker-" + type,
                    markerId = "raphael-marker-" + se + type + w + h + "-obj" + o.id;
                if (!_raphael2["default"]._g.doc.getElementById(pathId)) {
                    p.defs.appendChild($($("path"), {
                        "stroke-linecap": "round",
                        d: markers[type],
                        id: pathId
                    }));
                    markerCounter[pathId] = 1;
                } else {
                    markerCounter[pathId]++;
                }
                var marker = _raphael2["default"]._g.doc.getElementById(markerId),
                    use;
                if (!marker) {
                    marker = $($("marker"), {
                        id: markerId,
                        markerHeight: h,
                        markerWidth: w,
                        orient: "auto",
                        refX: refX,
                        refY: h / 2
                    });
                    use = $($("use"), {
                        "xlink:href": "#" + pathId,
                        transform: (isEnd ? "rotate(180 " + w / 2 + " " + h / 2 + ") " : E) + "scale(" + w / t + "," + h / t + ")",
                        "stroke-width": (1 / ((w / t + h / t) / 2)).toFixed(4)
                    });
                    marker.appendChild(use);
                    p.defs.appendChild(marker);
                    markerCounter[markerId] = 1;
                } else {
                    markerCounter[markerId]++;
                    use = marker.getElementsByTagName("use")[0];
                }
                $(use, attr);
                var delta = dx * (type != "diamond" && type != "oval");
                if (isEnd) {
                    from = o._.arrows.startdx * stroke || 0;
                    to = _raphael2["default"].getTotalLength(attrs.path) - delta * stroke;
                } else {
                    from = delta * stroke;
                    to = _raphael2["default"].getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
                }
                attr = {};
                attr["marker-" + se] = "url('" + _raphael2["default"]._url + "#" + markerId + "')";
                if (to || from) {
                    attr.d = _raphael2["default"].getSubpath(attrs.path, from, to);
                }
                $(node, attr);
                o._.arrows[se + "Path"] = pathId;
                o._.arrows[se + "Marker"] = markerId;
                o._.arrows[se + "dx"] = delta;
                o._.arrows[se + "Type"] = type;
                o._.arrows[se + "String"] = value;
            } else {
                if (isEnd) {
                    from = o._.arrows.startdx * stroke || 0;
                    to = _raphael2["default"].getTotalLength(attrs.path) - from;
                } else {
                    from = 0;
                    to = _raphael2["default"].getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
                }
                o._.arrows[se + "Path"] && $(node, {
                    d: _raphael2["default"].getSubpath(attrs.path, from, to)
                });
                delete o._.arrows[se + "Path"];
                delete o._.arrows[se + "Marker"];
                delete o._.arrows[se + "dx"];
                delete o._.arrows[se + "Type"];
                delete o._.arrows[se + "String"];
            }
            for (attr in markerCounter) {
                if (markerCounter[has](attr) && !markerCounter[attr]) {
                    var item = _raphael2["default"]._g.doc.getElementById(attr);
                    item && item.parentNode.removeChild(item);
                }
            }
        }
    },
        dasharray = {
        // In Firefox 37.0.1 the value of "stroke-dasharray" attribute `0` make the stroke/border invisible.
        // The actual issue is setting `none` as the value of `stroke-dasharray` attribute
        // redraphael internally changes the "none" value to "0", thus the stroke/border becomes invisible
        // To fix this issue now instead of setting the value as `0` for `stroke-dasharray` attribute
        // now using `none` string as none is a w3c standard value for stroke-dasharray
        "": ["none"],
        "none": ["none"],
        "-": [3, 1],
        ".": [1, 1],
        "-.": [3, 1, 1, 1],
        "-..": [3, 1, 1, 1, 1, 1],
        ". ": [1, 3],
        "- ": [4, 3],
        "--": [8, 3],
        "- .": [4, 3, 1, 3],
        "--.": [8, 3, 1, 3],
        "--..": [8, 3, 1, 3, 1, 3]
    },
        addDashes = function addDashes(o, value, params) {
        var predefValue = dasharray[Str(value).toLowerCase()],
            calculatedValues,
            width,
            butt,
            i,
            l,
            widthFactor;

        value = predefValue || value !== undefined && [].concat(value);
        if (value) {

            width = o.attrs["stroke-width"] || 1;
            butt = {
                round: width,
                square: width,
                butt: 0
            }[params["stroke-linecap"] || o.attrs["stroke-linecap"]] || 0;
            l = i = value.length;
            widthFactor = predefValue ? width : 1;

            if (value[0] == 'none') {
                calculatedValues = value;
            } else {
                calculatedValues = [];
                while (i--) {
                    calculatedValues[i] = value[i] * widthFactor + (i % 2 ? 1 : -1) * butt;
                    calculatedValues[i] <= 0 && (calculatedValues[i] = 0.01 + (width <= 1 ? butt : 0));
                    if (isNaN(calculatedValues[i])) {
                        calculatedValues[i] = 0;
                    }
                }
            }

            if (_raphael2["default"].is(value, 'array')) {
                $(o.node, {
                    "stroke-dasharray": calculatedValues.join(",")
                });
            }
        }
    },
        applyCustomAttributes = function applyCustomAttributes(o, attrs) {
        for (var key in attrs) {
            eve("raphael.attr." + key + "." + o.id, o, attrs[key], key);
            o.ca[key] && o.attr(key, attrs[key]);
        }
    },
        setFillAndStroke = _raphael2["default"]._setFillAndStroke = function (o, params, group) {
        if (!o.paper.canvas) {
            return;
        }
        var node = o.node,
            attrs = o.attrs,
            paper = o.paper,
            s = node.style,
            vis = s.visibility,
            i,
            l;
        // Convert all the &lt; and &gt; to < and > and if there is any <br/> tag in between &lt; and &gt;
        // then converting them into <<br/> and ><br/> respectively.
        if (params && params.text && params.text.replace) {
            params.text = params.text.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&<br\/>lt;|&l<br\/>t;|&lt<br\/>;/g, "<<br/>").replace(/&<br\/>gt;|&g<br\/>t;|&gt<br\/>;/g, "><br/>");
        }
        s.visibility = "hidden";
        if (o.type === "image") {
            LoadRefImage(o, params);
        }
        for (var att in params) {
            if (params[has](att)) {
                if (!_raphael2["default"]._availableAttrs[has](att)) {
                    continue;
                }
                var value = params[att];
                attrs[att] = value;
                switch (att) {
                    case "blur":
                        o.blur(value);
                        break;
                    case "href":
                    case "title":
                    case "target":
                        var pn = node.parentNode;
                        if (pn.tagName.toLowerCase() != "a") {
                            if (value == E) {
                                break;
                            }
                            var hl = $("a");
                            hl.raphael = true;
                            hl.raphaelid = node.raphaelid;
                            pn.insertBefore(hl, node);
                            hl.appendChild(node);
                            pn = hl;
                        }
                        if (att == "target") {
                            pn.setAttributeNS(xlink, "show", value == "blank" ? "new" : value);
                        } else {
                            pn.setAttributeNS(xlink, att, value);
                        }
                        node.titleNode = pn;
                        break;
                    case "cursor":
                        s.cursor = value;
                        break;
                    case "transform":
                        o.transform(value);
                        break;
                    case "rotation":
                        if (_raphael2["default"].is(value, "array")) {
                            o.rotate.apply(o, value);
                        } else {
                            o.rotate(value);
                        }
                        break;
                    case "arrow-start":
                        addArrow(o, value);
                        break;
                    case "arrow-end":
                        addArrow(o, value, 1);
                        break;
                    case "clip-path":
                        var pathClip = true;
                    case "clip-rect":
                        var rect = !pathClip && Str(value).split(separator);
                        o._.clipispath = !!pathClip;
                        if (pathClip || rect.length == 4) {
                            o.clip && o.clip.parentNode.parentNode.removeChild(o.clip.parentNode);
                            var el = $("clipPath"),
                                rc = $(pathClip ? "path" : "rect");
                            el.id = _raphael2["default"].getElementID(_raphael2["default"].createUUID());
                            $(rc, pathClip ? {
                                d: value ? attrs['clip-path'] = _raphael2["default"]._pathToAbsolute(value) : _raphael2["default"]._availableAttrs.path,
                                fill: 'none'
                            } : {
                                x: rect[0],
                                y: rect[1],
                                width: rect[2],
                                height: rect[3],
                                transform: o.matrix.invert()
                            });
                            el.appendChild(rc);
                            paper.defs.appendChild(el);
                            $(node, {
                                "clip-path": "url('" + _raphael2["default"]._url + "#" + el.id + "')"
                            });
                            o.clip = rc;
                        }
                        if (!value) {
                            var path = node.getAttribute("clip-path");
                            if (path) {
                                var clip = _raphael2["default"]._g.doc.getElementById(path.replace(/(^url\(#|\)$)/g, E));
                                clip && clip.parentNode.removeChild(clip);
                                $(node, {
                                    "clip-path": E
                                });
                                document.documentMode === 11 && node.removeAttribute('clip-path');
                                delete o.clip;
                            }
                        }
                        break;
                    case "path":
                        if (o.type == "path") {
                            $(node, {
                                d: value ? attrs.path = _raphael2["default"]._pathToAbsolute(value) : _raphael2["default"]._availableAttrs.path
                            });
                            o._.dirty = 1;
                            if (o._.arrows) {
                                "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                                "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                            }
                        }
                        break;
                    case "width":
                        node.setAttribute(att, value);
                        o._.dirty = 1;
                        if (attrs.fx) {
                            att = "x";
                            value = attrs.x;
                        } else {
                            break;
                        }
                    case "x":
                        if (attrs.fx) {
                            value = -attrs.x - (attrs.width || 0);
                        }
                    case "rx":
                        if (att == "rx" && o.type == "rect") {
                            break;
                        }
                    case "cx":
                        node.setAttribute(att, value);
                        o.pattern && updatePosition(o);
                        o._.dirty = 1;
                        break;
                    case "height":
                        node.setAttribute(att, value);
                        o._.dirty = 1;
                        if (attrs.fy) {
                            att = "y";
                            value = attrs.y;
                        } else {
                            break;
                        }
                    case "y":
                        if (attrs.fy) {
                            value = -attrs.y - (attrs.height || 0);
                        }
                    case "ry":
                        if (att == "ry" && o.type == "rect") {
                            break;
                        }
                    case "cy":
                        node.setAttribute(att, value);
                        o.pattern && updatePosition(o);
                        o._.dirty = 1;
                        break;
                    case "r":
                        if (o.type == "rect") {
                            $(node, {
                                rx: value,
                                ry: value
                            });
                        } else {
                            node.setAttribute(att, value);
                        }
                        o._.dirty = 1;
                        break;
                    case "src":
                        if (o.type == "image") {
                            node.setAttributeNS(xlink, "href", value);
                        }
                        break;
                    case "stroke-width":
                        if (o._.sx != 1 || o._.sy != 1) {
                            value /= mmax(abs(o._.sx), abs(o._.sy)) || 1;
                        }
                        if (paper._vbSize) {
                            value *= paper._vbSize;
                        }
                        if (zeroStrokeFix && value === 0) {
                            value = 0.000001;
                        }
                        node.setAttribute(att, value);
                        if (attrs["stroke-dasharray"]) {
                            addDashes(o, attrs["stroke-dasharray"], params);
                        }
                        if (o._.arrows) {
                            "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                            "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                        }
                        break;
                    case "stroke-dasharray":
                        addDashes(o, value, params);
                        break;
                    case "fill":
                        var isURL = Str(value).match(_raphael2["default"]._ISURL);
                        if (isURL) {
                            el = $("pattern");
                            var ig = $("image");
                            el.id = _raphael2["default"].getElementID(_raphael2["default"].createUUID());
                            $(el, {
                                x: 0,
                                y: 0,
                                patternUnits: "userSpaceOnUse",
                                height: 1,
                                width: 1
                            });
                            $(ig, {
                                x: 0,
                                y: 0,
                                "xlink:href": isURL[1]
                            });
                            el.appendChild(ig);

                            (function (el) {
                                _raphael2["default"]._preload(isURL[1], function () {
                                    var w = this.offsetWidth,
                                        h = this.offsetHeight;
                                    $(el, {
                                        width: w,
                                        height: h
                                    });
                                    $(ig, {
                                        width: w,
                                        height: h
                                    });
                                    paper.safari();
                                });
                            })(el);
                            paper.defs.appendChild(el);
                            s.fill = "url('" + _raphael2["default"]._url + "#" + el.id + "')";
                            $(node, {
                                fill: s.fill
                            });

                            o.pattern = el;
                            o.pattern && updatePosition(o);
                            break;
                        }
                        var clr = _raphael2["default"].getRGB(value);
                        if (!clr.error) {
                            delete params.gradient;
                            delete attrs.gradient;
                            // !R.is(attrs.opacity, "undefined") &&
                            //     R.is(params.opacity, "undefined") &&
                            //     $(node, {
                            //         opacity: attrs.opacity
                            //     });
                            !_raphael2["default"].is(attrs["fill-opacity"], "undefined") && _raphael2["default"].is(params["fill-opacity"], "undefined") && $(node, {
                                "fill-opacity": attrs["fill-opacity"]
                            });
                            o.gradient && updateGradientReference(o);
                        } else if ((o.type == "circle" || o.type == "ellipse" || Str(value).charAt() != "r") && addGradientFill(o, value)) {
                            if ("opacity" in attrs || "fill-opacity" in attrs) {
                                var gradient = _raphael2["default"]._g.doc.getElementById(node.getAttribute("fill").replace(/^url\(#|\)$/g, E));
                                if (gradient) {
                                    var stops = gradient.getElementsByTagName("stop");
                                    $(stops[stops.length - 1], {
                                        "stop-opacity": ("opacity" in attrs ? attrs.opacity : 1) * ("fill-opacity" in attrs ? attrs["fill-opacity"] : 1)
                                    });
                                }
                            }
                            attrs.gradient = value;
                            // attrs.fill = "none";
                            s.fill = E;
                            break;
                        }
                        if (clr[has]("opacity")) {
                            $(node, {
                                "fill-opacity": s.fillOpacity = clr.opacity > 1 ? clr.opacity / 100 : clr.opacity
                            });
                            o._.fillOpacityDirty = true;
                        } else if (o._.fillOpacityDirty && _raphael2["default"].is(attrs['fill-opacity'], "undefined") && _raphael2["default"].is(params["fill-opacity"], "undefined")) {
                            node.removeAttribute('fill-opacity');
                            s.fillOpacity = E;
                            delete o._.fillOpacityDirty;
                        }
                    case "stroke":
                        clr = _raphael2["default"].getRGB(value);
                        node.setAttribute(att, clr.hex);
                        s[att] = clr.hex;
                        if (att == "stroke") {
                            // remove stroke opacity when stroke is set to none
                            if (clr[has]("opacity")) {
                                $(node, {
                                    "stroke-opacity": s.strokeOpacity = clr.opacity > 1 ? clr.opacity / 100 : clr.opacity
                                });
                                o._.strokeOpacityDirty = true;
                            } else if (o._.strokeOpacityDirty && _raphael2["default"].is(attrs['stroke-opacity'], "undefined") && _raphael2["default"].is(params["stroke-opacity"], "undefined")) {
                                node.removeAttribute('stroke-opacity');
                                s.strokeOpacity = E;
                                delete o._.strokeOpacityDirty;
                            }
                            if (o._.arrows) {
                                "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                                "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                            }
                        }
                        break;
                    case "gradient":
                        (o.type == "circle" || o.type == "ellipse" || Str(value).charAt() != "r") && addGradientFill(o, value);
                        break;
                    case 'line-height': // do not apply
                    case 'vertical-align':
                        // do not apply
                        break;
                    case "visibility":
                        value === 'hidden' ? o.hide() : o.show();
                        break;
                    case "opacity":
                        // if (attrs.gradient && !attrs[has]("stroke-opacity")) {
                        //     $(node, {
                        //         "stroke-opacity": value > 1 ? value / 100 : value
                        //     });
                        // }
                        value = value > 1 ? value / 100 : value;
                        $(node, {
                            "opacity": value
                        });
                        s.opacity = value;
                        break;
                    // fall
                    case "fill-opacity":
                        // if (attrs.gradient) {
                        //     gradient = R._g.doc.getElementById(node.getAttribute("fill").replace(/^url\([\'\"]#|[\'\"]\)$/g, E));
                        //     if (gradient) {
                        //         stops = gradient.getElementsByTagName("stop");
                        //         l = stops.length;
                        //         for (i = 0; i < l; i += 1) {
                        //           $(stops[i], {
                        //               "stop-opacity": value
                        //           });
                        //         }
                        //     }
                        //     break;
                        // }
                        value = value > 1 ? value / 100 : value;
                        $(node, {
                            "fill-opacity": value
                        });
                        s.fillOpacity = value;
                        break;
                    default:
                        att == "font-size" && (value = toInt(value, 10) + "px");
                        var cssrule = att.replace(/(\-.)/g, function (w) {
                            return w.substring(1).toUpperCase();
                        });
                        s[cssrule] = value;
                        o._.dirty = 1;
                        node.setAttribute(att, value);
                        break;
                }
            }
        }
        o.type === 'text' && !params["_do-not-tune"] && tuneText(o, params, group);
        s.visibility = vis;
    },

    /*
     * Keeps the follower element in sync with the leaders.
     * First and second arguments represents the context(element) and the
     name of the callBack function respectively.
     * The callBack is invoked for indivual follower Element with the rest of
     arguments.
    */
    updateFollowers = _raphael2["default"]._updateFollowers = function () {
        var i,
            ii,
            followerElem,
            args = arguments,
            o = arrayShift.call(args),
            fnName = arrayShift.call(args);
        for (i = 0, ii = o.followers.length; i < ii; i++) {
            followerElem = o.followers[i].el;
            followerElem[fnName].apply(followerElem, args);
        }
    },
        leading = 1.2,
        tuneText = function tuneText(el, params, group) {
        if (el.type != "text" || !(params[has]("text") || params[has]("font") || params[has]("font-size") || params[has]("x") || params[has]("y") || params[has]("line-height") || params[has]("vertical-align"))) {
            return;
        }
        var a = el.attrs,
            node = el.node,
            computedStyle = node.firstChild && _raphael2["default"]._g.doc.defaultView.getComputedStyle(node.firstChild, E),
            fontSize = params['fontSize'] || params['font-size'] || a['font-size'] || group && group.attrs.fontSize,
            lineHeight = toFloat(params['line-height'] || a['line-height']) || fontSize * leading,
            actualValign = a[has]("vertical-align") ? a["vertical-align"] : "middle",
            direction = params["direction"] || group && group.attrs.direction || "initial",
            isIE = /*@cc_on!@*/false || !!document.documentMode,
            valign,
            fontFamily = params['fontFamily'] || params['font-family'] || a['font-family'] || group && group.attrs.fontFamily || 'Verdana,sans';

        fontSize = fontSize === undefined ? lineHeight / 1.2 || 10 : fontSize.toString().replace(/px/, '');

        if (isNaN(lineHeight)) {
            lineHeight = fontSize * leading;
        }

        if (_raphael2["default"].is(params.text, 'array')) {
            params.text = params.text.join('<br>');
        }

        valign = actualValign === 'top' ? -0.5 : actualValign === 'bottom' ? 0.5 : 0;

        if (params[has]("text") && (params.text !== a.text || el._textdirty)) {
            a.text = params.text;
            while (node.firstChild) {
                node.removeChild(node.firstChild);
            }
            var texts = Str(params.text).split(/\n|<br\s*?\/?>/ig),
                tspans = [],
                tspan;
            for (var i = 0, ii = texts.length; i < ii; i++) {
                tspan = $("tspan");
                if (i) {
                    $(tspan, {
                        dy: lineHeight,
                        x: a.x
                    });
                } else {
                    $(tspan, {
                        dy: lineHeight * texts.length * valign,
                        x: a.x
                    });
                }
                if (!texts[i]) {
                    // preserve blank lines
                    tspan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
                    texts[i] = " ";
                }
                tspan.appendChild(_raphael2["default"]._g.doc.createTextNode(texts[i]));
                node.appendChild(tspan);
                tspans[i] = tspan;

                if (!isIE && direction === "rtl" && i < ii - 1) {
                    tspan = $("tspan");
                    $(tspan, {
                        visibility: "hidden",
                        "font-size": "0px"
                    });
                    tspan.appendChild(_raphael2["default"]._g.doc.createTextNode("i"));
                    node.appendChild(tspan);
                }
            }
            el._textdirty = false;
        } else {
            tspans = node.getElementsByTagName("tspan");
            var obj,
                numDummyTspans = 0;

            for (i = 0, ii = tspans.length; i < ii; i++) {
                tspan = tspans[i];
                obj = tspan.attributes[0];

                if (obj && (obj.name === "visibility" || obj.nodeName === "visibility") && (obj.value === "hidden" || obj.nodeValue === "hidden")) {
                    continue;
                }

                if (i) {
                    $(tspan, {
                        dy: lineHeight,
                        x: a.x
                    });
                } else {
                    obj = tspans[1] && tspans[1].attributes[0];
                    if (obj && (obj.name === "visibility" || obj.nodeName === "visibility") && (obj.value === "hidden" || obj.nodeValue === "hidden")) {
                        numDummyTspans = math.floor(tspans.length * 0.5);
                    }

                    $(tspans[0], {
                        dy: lineHeight * (tspans.length - numDummyTspans) * valign,
                        x: a.x
                    });
                }
            }
        }
        $(node, {
            x: a.x,
            y: a.y
        });
        el._.dirty = 1;
        var bb = el._getCustomBBox(fontFamily, fontSize + 'px', actualValign, i),
            dif = bb.diff;

        dif && _raphael2["default"].is(dif, "finite") && tspans[0] && $(tspans[0], {
            dy: dif
        });
    },
        Element = function Element(node, svg, group /*, dontAppend*/) {
        var o = this,
            parent = group || svg;

        /*!dontAppend && */parent.canvas && parent.canvas.appendChild(node);

        o.node = o[0] = node;
        node.raphael = true;
        node.raphaelid = o.id = _raphael2["default"]._oid++;

        o.matrix = _raphael2["default"].matrix();
        o.realPath = null;

        o.attrs = o.attrs || {};
        o.followers = o.followers || [];

        o.paper = svg;
        o.ca = o.customAttributes = o.customAttributes || new svg._CustomAttributes();

        o._ = {
            transform: [],
            sx: 1,
            sy: 1,
            deg: 0,
            dx: 0,
            dy: 0,
            dirty: 1
        };

        o.parent = parent;
        !parent.bottom && (parent.bottom = o);

        o.prev = parent.top;
        parent.top && (parent.top.next = o);
        parent.top = o;
        o.next = null;
    },
        elproto = _raphael2["default"].el;

    Element.prototype = elproto;
    elproto.constructor = Element;

    _raphael2["default"]._engine.getNode = function (el) {
        var node = el.node || el[0].node;
        return node.titleNode || node;
    };
    _raphael2["default"]._engine.getLastNode = function (el) {
        var node = el.node || el[el.length - 1].node;
        return node.titleNode || node;
    };

    elproto.rotate = function (deg, cx, cy) {
        var o = this,
            bbox;
        if (o.removed) {
            return o;
        }
        updateFollowers(o, 'rotate', deg, cx, cy);
        deg = Str(deg).split(separator);
        if (deg.length - 1) {
            cx = toFloat(deg[1]);
            cy = toFloat(deg[2]);
        }
        deg = toFloat(deg[0]);
        cy == null && (cx = cy);
        if (cx == null || cy == null) {
            bbox = o.getBBox(1);
            cx = bbox.x + bbox.width / 2;
            cy = bbox.y + bbox.height / 2;
        }
        o.transform(o._.transform.concat([["r", deg, cx, cy]]));
        return o;
    };

    elproto.scale = function (sx, sy, cx, cy) {
        var o = this,
            bbox;
        if (o.removed) {
            return o;
        }
        updateFollowers(o, 'scale', sx, sy, cx, cy);
        sx = Str(sx).split(separator);
        if (sx.length - 1) {
            sy = toFloat(sx[1]);
            cx = toFloat(sx[2]);
            cy = toFloat(sx[3]);
        }
        sx = toFloat(sx[0]);
        sy == null && (sy = sx);
        cy == null && (cx = cy);
        if (cx == null || cy == null) {
            bbox = o.getBBox(1);
        }
        cx = cx == null ? bbox.x + bbox.width / 2 : cx;
        cy = cy == null ? bbox.y + bbox.height / 2 : cy;
        o.transform(o._.transform.concat([["s", sx, sy, cx, cy]]));
        return o;
    };

    elproto.translate = function (dx, dy) {
        var o = this;
        if (o.removed) {
            return o;
        }
        updateFollowers(o, 'translate', dx, dy);
        dx = Str(dx).split(separator);
        if (dx.length - 1) {
            dy = toFloat(dx[1]);
        }
        dx = toFloat(dx[0]) || 0;
        dy = +dy || 0;
        o.transform(o._.transform.concat([["t", dx, dy]]));
        return o;
    };

    elproto.transform = function (tstr) {
        var o = this,
            _ = o._,
            sw;

        if (tstr == null) {
            return _.transform;
        }
        _raphael2["default"]._extractTransform(o, tstr);

        o.clip && !_.clipispath && $(o.clip, {
            transform: o.matrix.invert()
        });
        o.pattern && updatePosition(o);
        o.node && $(o.node, {
            transform: o.matrix
        });

        sw = o.attrs[has]("stroke-width") ? o.attrs["stroke-width"] : 1;
        o.attr({
            "stroke-width": sw
        });

        return o;
    };

    elproto.hide = function () {
        var o = this;
        updateFollowers(o, 'hide');
        !o.removed && o.paper.safari(o.node.style.display = "none");
        return o;
    };

    elproto.show = function () {
        var o = this;
        updateFollowers(o, 'show');
        !o.removed && o.paper.safari(o.node.style.display = E);
        return o;
    };

    elproto.remove = function () {
        if (this.removed || !this.parent.canvas) {
            return;
        }

        var o = this,
            node = _raphael2["default"]._engine.getNode(o),
            paper = o.paper,
            defs = paper.defs,
            i;

        paper.__set__ && paper.__set__.exclude(o);
        eve.unbind("raphael.*.*." + o.id);

        if (o.gradient && defs) {
            updateGradientReference(o);
        }
        while (i = o.followers.pop()) {
            i.el.remove();
        }
        while (i = o.bottom) {
            i.remove();
        }

        if (o._drag) {
            o.undrag();
        }

        if (o.events) {
            while (i = o.events.pop()) {
                i.unbind();
            }
        }

        o.parent.canvas.contains(node) && o.parent.canvas.removeChild(node);
        o.removeData();
        delete paper._elementsById[o.id]; // remove from lookup hash
        _raphael2["default"]._tear(o, o.parent);

        for (i in o) {
            o[i] = typeof o[i] === "function" ? _raphael2["default"]._removedFactory(i) : null;
        }

        o.removed = true;
    };;

    elproto._getCustomBBox = function (fontFamily, fontSize, valign, lines) {
        var fn,
            o = this,
            node = o.node,
            hide,
            isText = o.type === "text",
            isIE = /*@cc_on!@*/false || !!document.documentMode,
            cachedFontHeight,
            txtElem,
            theText,
            theMSG,
            availableFontFamily,
            availableFontSize,
            info,
            randomPos,
            bboxY,
            diff,
            bbox,
            bboxHeight;
        if (isIE && isText) {
            fn = showRecursively(o);
        } else {
            if (node.style.display === "none") {
                o.show();
                hide = true;
            }
        }

        if (isText) {
            cachedFontHeight = _raphael2["default"].cachedFontHeight;
            txtElem = cachedFontHeight.txtElem;
            availableFontFamily = cachedFontHeight[fontFamily] || (cachedFontHeight[fontFamily] = {});
            availableFontSize = availableFontFamily[fontSize];
            randomPos = -100;

            if (!availableFontSize) {
                if (!txtElem) {
                    txtElem = cachedFontHeight.txtElem = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    txtElem.setAttribute('x', randomPos);
                    txtElem.setAttribute('y', randomPos);

                    theMSG = document.createTextNode('abcdefhiklmnopqrstuvwxyz');
                    txtElem.appendChild(theMSG);

                    document.getElementsByTagName('svg')[0].appendChild(txtElem);
                }
                txtElem.setAttribute('style', 'font-family :' + fontFamily + '; font-size :' + fontSize);

                bbox = txtElem.getBBox();
                availableFontFamily[fontSize] = availableFontSize = [];
                availableFontSize.push(bbox.height);
                availableFontSize.push(bbox.y);
            }

            bboxY = availableFontSize[1];
            bboxHeight = availableFontSize[0];
            switch (valign) {
                case "bottom":
                    diff = randomPos - bboxY - bboxHeight * lines;
                    break;
                case "top":
                    diff = randomPos - bboxY;
                    break;
                default:
                    diff = randomPos - bboxY - bboxHeight / 2 * lines;
            };

            bbox = {
                height: availableFontSize[0],
                diff: diff
            };
        }

        isIE && isText ? fn && fn() : hide && o.hide();
        return bbox;
    };

    elproto._getBBox = function () {
        var fn,
            o = this,
            node = o.node,
            bbox = {},
            a = o.attrs,
            align,
            hide,
            isText = o.type === "text",
            isIE = /*@cc_on!@*/false || !!document.documentMode;
        if (isIE && isText) {
            fn = showRecursively(o);
        } else {
            if (node.style.display === "none") {
                o.show();
                hide = true;
            }
        }

        try {
            bbox = node.getBBox();
            if (isText) {
                // If bbox does not have x / y, which is possible in certain
                // environments, we mathematically calculate these values by
                // using x, y (adjusted using the values of text-anchor, and
                // vertical-align attributes), of the element along with the
                // width and height provided by the getBBox().
                if (bbox.x === undefined) {
                    bbox.isCalculated = true;
                    align = a['text-anchor'];
                    bbox.x = (a.x || 0) - bbox.width * (align === "start" ? 0 : align === "middle" ? 0.5 : 1);
                }

                if (bbox.y === undefined) {
                    bbox.isCalculated = true;
                    align = a['vertical-align'];
                    bbox.y = (a.y || 0) - bbox.height * (align === "bottom" ? 1 : align === "middle" ? 0.5 : 0);
                }
            }
        } catch (e) {
            // Firefox 3.0.x plays badly here
        } finally {
            bbox = bbox || {};
        }
        isIE && isText ? fn && fn() : hide && o.hide();
        return bbox;
    };

    elproto.attr = function (name, value) {
        if (this.removed) {
            return this;
        }
        if (name == null) {
            var res = {};
            for (var a in this.attrs) {
                if (this.attrs[has](a)) {
                    res[a] = this.attrs[a];
                }
            }res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
            res.transform = this._.transform;
            res.visibility = this.node.style.display === "none" ? "hidden" : "visible";
            return res;
        }
        if (value == null && _raphael2["default"].is(name, "string")) {
            if (name == "fill" && this.attrs.fill == "none" && this.attrs.gradient) {
                return this.attrs.gradient;
            }
            if (name == "transform") {
                return this._.transform;
            }
            if (name == "visibility") {
                return this.node.style.display === "none" ? "hidden" : "visible";
            }
            var names = name.split(separator),
                out = {};
            for (var i = 0, ii = names.length; i < ii; i++) {
                name = names[i];
                if (name in this.attrs) {
                    out[name] = this.attrs[name];
                } else if (_raphael2["default"].is(this.ca[name], "function")) {
                    out[name] = this.ca[name].def;
                } else {
                    out[name] = _raphael2["default"]._availableAttrs[name];
                }
            }
            return ii - 1 ? out : out[names[0]];
        }
        if (value == null && _raphael2["default"].is(name, "array")) {
            out = {};
            for (i = 0, ii = name.length; i < ii; i++) {
                out[name[i]] = this.attr(name[i]);
            }
            return out;
        }
        if (value != null) {
            var params = {};
            params[name] = value;
        } else if (name != null && _raphael2["default"].is(name, "object")) {
            params = name;
        }
        if (_raphael2["default"].stopEvent !== false) {
            for (var key in params) {
                eve("raphael.attr." + key + "." + this.id, this, params[key], key);
            }
        }
        var todel = {};
        for (key in this.ca) {
            if (this.ca[key] && params[has](key) && _raphael2["default"].is(this.ca[key], "function") && !this.ca['_invoked' + key]) {

                this.ca['_invoked' + key] = true; // prevent recursion
                var par = this.ca[key].apply(this, [].concat(params[key]));
                delete this.ca['_invoked' + key];

                for (var subkey in par) {
                    if (par[has](subkey)) {
                        params[subkey] = par[subkey];
                    }
                }
                this.attrs[key] = params[key];
                if (par === false) {
                    todel[key] = params[key];
                    delete params[key];
                }
            }
        }

        setFillAndStroke(this, params);

        var follower;
        for (i = 0, ii = this.followers.length; i < ii; i++) {
            follower = this.followers[i];
            follower.cb && !follower.cb.call(follower.el, params, this) || follower.el.attr(params);
        }

        for (subkey in todel) {
            params[subkey] = todel[subkey];
        }
        return this;
    };

    elproto.blur = function (size) {
        // Experimental. No Safari support. Use it on your own risk.
        var t = this;
        if (+size !== 0) {
            var fltr = $("filter"),
                blur = $("feGaussianBlur");
            t.attrs.blur = size;
            fltr.id = _raphael2["default"].getElementID(_raphael2["default"].createUUID());
            $(blur, {
                stdDeviation: +size || 1.5
            });
            fltr.appendChild(blur);
            t.paper.defs.appendChild(fltr);
            t._blur = fltr;
            $(t.node, {
                filter: "url('" + _raphael2["default"]._url + "#" + fltr.id + "')"
            });
        } else {
            if (t._blur) {
                t._blur.parentNode.removeChild(t._blur);
                delete t._blur;
                delete t.attrs.blur;
            }
            t.node.removeAttribute("filter");
        }
    };

    /*\
     * Element.on
     [ method ]
     **
     * Bind handler function for a particular event to Element
     * @param eventType - Type of event
     * @param handler - Function to be called on the firing of the event
    \*/
    elproto.on = function (eventType, handler) {
        var elem = this,
            fn,
            oldEventType;
        if (this.removed) {
            return this;
        }

        if (eventType === 'dragstart') {
            this.drag(null, handler);
            return this;
        } else if (eventType === 'dragmove') {
            this.drag(handler);
            return this;
        } else if (eventType === 'dragend') {
            this.drag(null, null, handler);
            return this;
        }

        fn = handler;
        oldEventType = eventType;
        if (_raphael2["default"].supportsTouch) {
            eventType = _raphael2["default"]._touchMap[eventType] || eventType === 'click' && 'touchstart' || eventType;
            if (eventType !== oldEventType) {
                // store the new listeners for removeEventListener
                if (!elem._tempTouchListeners) {
                    elem._tempTouchListeners = {};
                }
                if (!elem._tempTouchListeners[oldEventType]) {
                    elem._tempTouchListeners[oldEventType] = [];
                }
                fn = function fn(e) {
                    e.preventDefault();
                    handler(e);
                };
                elem._tempTouchListeners[oldEventType].push({
                    oldFn: handler,
                    newFn: fn,
                    newEvt: eventType
                });
            }
        }
        if (this.node.addEventListener) {
            this.node.addEventListener(eventType, fn);
        } else {
            this.node['on' + eventType] = fn;
        }
        return this;
    };

    /*\
     * Element.off
     [ method ]
     **
     * Remove handler function bind to an event of element
     * @param eventType - Type of event
     * @param handler - Function to be removed from event
    \*/
    elproto.off = function (eventType, handler) {
        var elem = this,
            fn,
            i,
            l,
            oldEventType;
        if (this.removed) {
            return this;
        }

        if (eventType === 'dragstart') {
            this.undragstart();
            return this;
        } else if (eventType === 'dragmove') {
            this.undragmove();
            return this;
        } else if (eventType === 'dragend') {
            this.undragend();
            return this;
        }

        fn = handler;
        oldEventType = eventType;

        if (_raphael2["default"].supportsTouch && elem._tempTouchListeners && elem._tempTouchListeners[oldEventType]) {
            l = elem._tempTouchListeners[oldEventType].length;
            for (i = 0; i < l && oldEventType === eventType; i += 1) {
                if (elem._tempTouchListeners[oldEventType][i] && elem._tempTouchListeners[oldEventType][i].oldFn === fn) {
                    eventType = elem._tempTouchListeners[oldEventType][i].newEvt;
                    fn = elem._tempTouchListeners[oldEventType][i].newFn;
                    elem._tempTouchListeners[oldEventType].splice(i, 1);
                }
            }
        }
        if (this.node.removeEventListener) {
            this.node.removeEventListener(eventType, fn);
        } else {
            this.node['on' + eventType] = null;
        }
        return this;
    };

    _raphael2["default"]._engine.path = function (svg, attrs, group) {
        var el = $("path"),
            res = new Element(el, svg, group);

        res.type = "path";
        setFillAndStroke(res, attrs);
        applyCustomAttributes(res, attrs);
        return res;
    };

    _raphael2["default"]._engine.group = function (svg, id, group) {
        var el = $("g"),
            res = new Element(el, svg, group);

        res.type = "group";
        res.canvas = res.node;
        res.top = res.bottom = null;
        res._id = id || E;
        id && el.setAttribute('class', 'raphael-group-' + res.id + '-' + id);
        return res;
    };

    _raphael2["default"]._engine.circle = function (svg, attrs, group) {
        var el = $("circle"),
            res = new Element(el, svg, group);

        res.type = "circle";
        setFillAndStroke(res, attrs);
        applyCustomAttributes(res, attrs);
        return res;
    };
    _raphael2["default"]._engine.rect = function (svg, attrs, group) {
        var el = $("rect"),
            res = new Element(el, svg, group);

        res.type = "rect";
        attrs.rx = attrs.ry = attrs.r;
        setFillAndStroke(res, attrs);
        applyCustomAttributes(res, attrs);
        return res;
    };
    _raphael2["default"]._engine.ellipse = function (svg, attrs, group) {
        var el = $("ellipse"),
            res = new Element(el, svg, group);

        res.type = "ellipse";
        setFillAndStroke(res, attrs);
        applyCustomAttributes(res, attrs);
        return res;
    };
    ;
    _raphael2["default"]._engine.image = function (svg, attrs, group) {
        var el = $("image"),
            src = attrs.src,
            res = new Element(el, svg, group, true);

        res._.group = group || svg;
        res.type = "image";
        el.setAttribute("preserveAspectRatio", "none");
        setFillAndStroke(res, attrs);
        applyCustomAttributes(res, attrs);
        return res;
    };
    _raphael2["default"]._engine.text = function (svg, attrs, group, css) {
        var el = $("text"),
            res = new Element(el, svg, group);
        res.type = "text";
        res._textdirty = true;
        // Ideally this code should not be here as .css() is not a function of rapheal.
        css && res.css && res.css(css, undefined, true);

        setFillAndStroke(res, attrs, group);
        applyCustomAttributes(res, attrs);
        return res;
    };

    _raphael2["default"]._engine.setSize = function (width, height) {
        this.width = width || this.width;
        this.height = height || this.height;
        this.canvas.setAttribute("width", this.width);
        this.canvas.setAttribute("height", this.height);
        if (this._viewBox) {
            this.setViewBox.apply(this, this._viewBox);
        }
        return this;
    };
    _raphael2["default"]._engine.create = function () {
        var con = _raphael2["default"]._getContainer.apply(0, arguments),
            container = con && con.container,
            x = con.x,
            y = con.y,
            width = con.width,
            height = con.height;
        if (!container) {
            throw new Error("SVG container not found.");
        }
        var cnvs = $("svg"),
            css = "overflow:hidden;-webkit-tap-highlight-color:rgba(0,0,0,0);" + "-webkit-user-select:none;-moz-user-select:-moz-none;-khtml-user-select:none;" + "-ms-user-select:none;user-select:none;-o-user-select:none;cursor:default;",
            css = css + "vertical-align:middle;",
            isFloating;
        x = x || 0;
        y = y || 0;
        width = width || 512;
        height = height || 342;
        $(cnvs, {
            height: height,
            version: 1.1,
            width: width,
            xmlns: "http://www.w3.org/2000/svg"
        });
        if (container == 1) {
            cnvs.style.cssText = css + "position:absolute;left:" + x + "px;top:" + y + "px";
            _raphael2["default"]._g.doc.body.appendChild(cnvs);
            isFloating = 1;
        } else {
            cnvs.style.cssText = css + "position:relative";
            if (container.firstChild) {
                container.insertBefore(cnvs, container.firstChild);
            } else {
                container.appendChild(cnvs);
            }
        }
        container = new _raphael2["default"]._Paper();
        container.width = width;
        container.height = height;
        container.canvas = cnvs;
        $(cnvs, {
            id: "raphael-paper-" + container.id
        });
        container.clear();
        container._left = container._top = 0;
        isFloating && (container.renderfix = function () {});
        container.renderfix();
        return container;
    };
    _raphael2["default"]._engine.setViewBox = function (x, y, w, h, fit) {
        eve("raphael.setViewBox", this, this._viewBox, [x, y, w, h, fit]);
        var size = mmax(w / this.width, h / this.height),
            top = this.top,
            aspectRatio = fit ? "meet" : "xMinYMin",
            vb,
            sw;
        if (x == null) {
            if (this._vbSize) {
                size = 1;
            }
            delete this._vbSize;
            vb = "0 0 " + this.width + S + this.height;
        } else {
            this._vbSize = size;
            vb = x + S + y + S + w + S + h;
        }
        $(this.canvas, {
            viewBox: vb,
            preserveAspectRatio: aspectRatio
        });
        while (size && top) {
            sw = "stroke-width" in top.attrs ? top.attrs["stroke-width"] : 1;
            top.attr({
                "stroke-width": sw
            });
            top._.dirty = 1;
            top._.dirtyT = 1;
            top = top.prev;
        }
        this._viewBox = [x, y, w, h, !!fit];
        return this;
    };

    _raphael2["default"].prototype.renderfix = function () {
        var cnvs = this.canvas,
            s = cnvs.style,
            pos;
        try {
            pos = cnvs.getScreenCTM() || cnvs.createSVGMatrix();
        } catch (e) {
            pos = cnvs.createSVGMatrix();
        }
        var left = -pos.e % 1,
            top = -pos.f % 1;
        if (left || top) {
            if (left) {
                this._left = (this._left + left) % 1;
                s.left = this._left + "px";
            }
            if (top) {
                this._top = (this._top + top) % 1;
                s.top = this._top + "px";
            }
        }
    };

    _raphael2["default"].prototype._desc = function (txt) {
        var desc = this.desc;

        if (!desc) {
            this.desc = desc = $("desc");
            this.canvas.appendChild(desc);
        } else {
            while (desc.firstChild) {
                desc.removeChild(desc.firstChild);
            }
        }
        desc.appendChild(_raphael2["default"]._g.doc.createTextNode(_raphael2["default"].is(txt, "string") ? txt : "Created with Red Rapha\xebl " + _raphael2["default"].version));
    };

    _raphael2["default"].prototype.clear = function () {
        var c;
        eve("raphael.clear", this);

        while (c = this.bottom) {
            c.remove();
        }

        c = this.canvas;
        while (c.firstChild) {
            c.removeChild(c.firstChild);
        }
        this.bottom = this.top = null;
        c.appendChild(this.desc = $("desc"));
        c.appendChild(this.defs = $("defs"));
    };

    _raphael2["default"].prototype.remove = function () {
        var i;
        eve("raphael.remove", this);

        while (i = this.bottom) {
            i.remove();
        }

        this.defs && this.defs.parentNode.removeChild(this.defs);
        this.desc && this.desc.parentNode.removeChild(this.desc);
        this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);
        for (i in this) {
            this[i] = typeof this[i] == "function" ? _raphael2["default"]._removedFactory(i) : null;
        }
        this.removed = true;
    };
    var setproto = _raphael2["default"].st;
    for (var method in elproto) {
        if (elproto[has](method) && !setproto[has](method)) {
            setproto[method] = function (methodname) {
                return function () {
                    var arg = arguments;
                    return this.forEach(function (el) {
                        el[methodname].apply(el, arg);
                    });
                };
            }(method);
        }
    }
} /**!
  * RedRaphael 1.0.0 - JavaScript Vector Library SVG Module
  * Copyright (c) 2012-2013 FusionCharts, Inc. <http://www.fusioncharts.com>
  *
  * Raphael 2.1.0 - JavaScript Vector Library SVG Module
  * Copyright (c) 2008-2012 Dmitry Baranovskiy <http://raphaeljs.com>
  * Copyright © 2008-2012 Sencha Labs <http://sencha.com>
  *
  * Licensed under the MIT license.
  */
// Define _window as window object in case of indivual file inclusion.

exports["default"] = _raphael2["default"];

/***/ }),
/* 394 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _raphael = __webpack_require__(85);

var _raphael2 = _interopRequireDefault(_raphael);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

if (_raphael2["default"].vml) {
    var has = "hasOwnProperty",
        Str = String,
        toFloat = parseFloat,
        math = Math,
        round = math.round,
        mmax = math.max,
        mmin = math.min,
        sqrt = math.sqrt,
        abs = math.abs,
        fillString = "fill",
        separator = /[, ]+/,
        eve = _raphael2["default"].eve,
        ms = " progid:DXImageTransform.Microsoft",
        arrayShift = Array.prototype.shift,
        S = " ",
        E = "",
        map = {
        M: "m",
        L: "l",
        C: "c",
        Z: "x",
        m: "t",
        l: "r",
        c: "v",
        z: "x"
    },
        bites = /([clmz]),?([^clmz]*)/gi,
        blurregexp = / progid:\S+Blur\([^\)]+\)/g,
        val = /-?[^,\s-]+/g,
        cssDot = "position:absolute;left:0;top:0;width:1px;height:1px",
        zoom = 21600,
        pathTypes = {
        path: 1,
        rect: 1,
        image: 1
    },
        ovalTypes = {
        circle: 1,
        ellipse: 1
    },
        path2vml = function path2vml(path) {
        var total = /[ahqstv]/ig,
            command = _raphael2["default"]._pathToAbsolute;
        Str(path).match(total) && (command = _raphael2["default"]._path2curve);
        total = /[clmz]/g;
        if (command == _raphael2["default"]._pathToAbsolute && !Str(path).match(total)) {
            var res = Str(path).replace(bites, function (all, command, args) {
                var vals = [],
                    isMove = command.toLowerCase() == "m",
                    res = map[command];
                args.replace(val, function (value) {
                    if (isMove && vals.length == 2) {
                        res += vals + map[command == "m" ? "l" : "L"];
                        vals = [];
                    }
                    vals.push(round(value * zoom));
                });
                return res + vals;
            });

            return res || 'm0,0';
        }
        var pa = command(path),
            p,
            r;
        res = [];
        for (var i = 0, ii = pa.length; i < ii; i++) {
            p = pa[i];
            r = pa[i][0].toLowerCase();
            r == "z" && (r = "x");
            for (var j = 1, jj = p.length; j < jj; j++) {
                r += round(p[j] * zoom) + (j != jj - 1 ? "," : E);
            }
            res.push(r);
        }
        return res.length ? res.join(S) : 'm0,0';
    },
        compensation = function compensation(deg, dx, dy) {
        var m = _raphael2["default"].matrix();
        m.rotate(-deg, .5, .5);
        return {
            dx: m.x(dx, dy),
            dy: m.y(dx, dy)
        };
    },
        setCoords = function setCoords(p, sx, sy, dx, dy, deg) {
        var _ = p._,
            m = p.matrix,
            fillpos = _.fillpos,
            o = p.node,
            s = o.style,
            y = 1,
            flip = "",
            dxdy,
            kx = zoom / sx,
            ky = zoom / sy;
        s.visibility = "hidden";
        if (!sx || !sy) {
            return;
        }
        o.coordsize = abs(kx) + S + abs(ky);
        s.rotation = deg * (sx * sy < 0 ? -1 : 1);
        if (deg) {
            var c = compensation(deg, dx, dy);
            dx = c.dx;
            dy = c.dy;
        }
        sx < 0 && (flip += "x");
        sy < 0 && (flip += " y") && (y = -1);
        s.flip = flip;
        o.coordorigin = dx * -kx + S + dy * -ky;
        if (fillpos || _.fillsize) {
            var fill = o.getElementsByTagName(fillString);
            fill = fill && fill[0];
            if (fill) {
                o.removeChild(fill);
                if (fillpos) {
                    c = compensation(deg, m.x(fillpos[0], fillpos[1]), m.y(fillpos[0], fillpos[1]));
                    fill.position = c.dx * y + S + c.dy * y;
                }
                if (_.fillsize) {
                    fill.size = _.fillsize[0] * abs(sx) + S + _.fillsize[1] * abs(sy);
                }
                o.appendChild(fill);
            }
        }
        s.visibility = "visible";
    };
    _raphael2["default"]._url = E;
    _raphael2["default"].toString = function () {
        return "Your browser doesn\u2019t support SVG. Falling down to VML.\nYou are running Rapha\xEBl " + this.version;
    };
    var addArrow = function addArrow(o, value, isEnd) {
        var values = Str(value).toLowerCase().split("-"),
            se = isEnd ? "end" : "start",
            i = values.length,
            type = "classic",
            w = "medium",
            h = "medium";
        while (i--) {
            switch (values[i]) {
                case "block":
                case "classic":
                case "oval":
                case "diamond":
                case "open":
                case "none":
                    type = values[i];
                    break;
                case "wide":
                case "narrow":
                    h = values[i];
                    break;
                case "long":
                case "short":
                    w = values[i];
                    break;
            }
        }
        var stroke = o.node.getElementsByTagName("stroke")[0];
        stroke[se + "arrow"] = type;
        stroke[se + "arrowlength"] = w;
        stroke[se + "arrowwidth"] = h;
    },
        applyCustomAttributes = function applyCustomAttributes(o, attrs) {
        for (var key in attrs) {
            eve("raphael.attr." + key + "." + o.id, o, attrs[key], key);
            o.ca[key] && o.attr(key, attrs[key]);
        }
    },
        setFillAndStroke = _raphael2["default"]._setFillAndStroke = function (o, params) {
        if (!o.paper.canvas) return;
        // o.paper.canvas.style.display = "none";
        o.attrs = o.attrs || {};
        var node = o.node,
            a = o.attrs,
            s = node.style,
            xy,
            oriOp,
            newpath = pathTypes[o.type] && (params.x != a.x || params.y != a.y || params.width != a.width || params.height != a.height || params.cx != a.cx || params.cy != a.cy || params.rx != a.rx || params.ry != a.ry || params.r != a.r),
            isOval = ovalTypes[o.type] && (a.cx != params.cx || a.cy != params.cy || a.r != params.r || a.rx != params.rx || a.ry != params.ry),
            isGroup = o.type === 'group',
            res = o;
        oriOp = res.oriOp || (res.oriOp = {});
        for (var par in params) {
            if (params[has](par)) {
                a[par] = params[par];
            }
        }if (newpath) {
            a.path = _raphael2["default"]._getPath[o.type](o);
            o._.dirty = 1;
        }
        params.href && (node.href = params.href);
        params.title && (node.title = params.title);
        params.target && (node.target = params.target);
        params.cursor && (s.cursor = params.cursor);
        "blur" in params && o.blur(params.blur);

        if (params.path && o.type == "path" || newpath) {
            node.path = path2vml(~Str(a.path).toLowerCase().indexOf("r") ? _raphael2["default"]._pathToAbsolute(a.path) : a.path);
            if (o.type == "image") {
                o._.fillpos = [a.x, a.y];
                o._.fillsize = [a.width, a.height];
                setCoords(o, 1, 1, 0, 0, 0);
            }
        }
        "transform" in params && o.transform(params.transform);
        if ("rotation" in params) {
            var rotation = params.rotation;
            if (_raphael2["default"].is(rotation, "array")) {
                o.rotate.apply(o, rotation);
            } else {
                o.rotate(rotation);
            }
        }
        if ("visibility" in params) {
            params.visibility === 'hidden' ? o.hide() : o.show();
        }
        if (isOval) {
            var cx = +a.cx,
                cy = +a.cy,
                rx = +a.rx || +a.r || 0,
                ry = +a.ry || +a.r || 0;
            node.path = _raphael2["default"].format("ar{0},{1},{2},{3},{4},{1},{4},{1}x", round((cx - rx) * zoom), round((cy - ry) * zoom), round((cx + rx) * zoom), round((cy + ry) * zoom), round(cx * zoom));
        }
        if ("clip-rect" in params) {
            var rect = Str(params["clip-rect"]).split(separator);

            if (rect.length == 4) {
                rect[0] = +rect[0];
                rect[1] = +rect[1];
                rect[2] = +rect[2] + rect[0];
                rect[3] = +rect[3] + rect[1];

                /** @todo create separate element for group clip-rect to
                 * avoid unclipping issue */
                var div = isGroup ? node : node.clipRect || _raphael2["default"]._g.doc.createElement("div"),
                    offset,
                    dstyle = div.style;

                if (isGroup) {
                    o.clip = rect.slice(); // copy param
                    offset = o.matrix.offset();
                    offset = [toFloat(offset[0]), toFloat(offset[1])];
                    // invert matrix calculation
                    rect[0] -= offset[0];
                    rect[1] -= offset[1];
                    rect[2] -= offset[0];
                    rect[3] -= offset[1];
                    // Fix for bug in ie clip-auto when height/width is not defined
                    /** @todo set dynamic w/h based on clip bounds or find
                     * another workaround fix */
                    //dstyle.width = "10800px";
                    //dstyle.height = "10800px";

                    // Not sure about the above fix
                    // Revert the fix because it's creating another issue.
                    // Setting the Group style, width/height as "10800px" makes the other group inaccessible
                    // which is below this group
                    dstyle.width = "1px";
                    dstyle.height = "1px";
                } else if (!node.clipRect) {
                    dstyle.top = "0";
                    dstyle.left = "0";
                    dstyle.width = o.paper.width + "px";
                    dstyle.height = o.paper.height + "px";
                    node.parentNode.insertBefore(div, node);
                    div.appendChild(node);
                    div.raphael = true;
                    div.raphaelid = node.raphaelid;
                    node.clipRect = div;
                }
                dstyle.position = "absolute";
                dstyle.clip = _raphael2["default"].format("rect({1}px {2}px {3}px {0}px)", rect);
            }
            if (!params["clip-rect"]) {
                if (isGroup && o.clip) {
                    node.style.clip = "rect(0px 10800px 10800px 0px)";
                    delete o.clip;
                } else if (node.clipRect) {
                    node.clipRect.style.clip = "rect(0px 10800px 10800px 0px)";
                }
            }
        }
        // Css styles will be applied in element or group.
        if (o.textpath || isGroup) {
            var textpathStyle = isGroup ? node.style : o.textpath.style;
            params.font && (textpathStyle.font = params.font);
            params["font-family"] && (textpathStyle.fontFamily = '"' + params["font-family"].split(",")[0].replace(/^['"]+|['"]+$/g, E) + '"');
            params["font-size"] && (textpathStyle.fontSize = params["font-size"]);
            params["font-weight"] && (textpathStyle.fontWeight = params["font-weight"]);
            params["font-style"] && (textpathStyle.fontStyle = params["font-style"]);
        }
        if ("arrow-start" in params) {
            addArrow(res, params["arrow-start"]);
        }
        if ("arrow-end" in params) {
            addArrow(res, params["arrow-end"], 1);
        }
        if (params.opacity != null || params["stroke-width"] != null || params.fill != null || params.src != null || params.stroke != null || params["stroke-width"] != null || params["stroke-opacity"] != null || params["fill-opacity"] != null || params["stroke-dasharray"] != null || params["stroke-miterlimit"] != null || params["stroke-linejoin"] != null || params["stroke-linecap"] != null) {
            var fill = node.getElementsByTagName(fillString),
                newfill = false,
                fillOpacity = -1;
            fill = fill && fill[0];
            !fill && (newfill = fill = createNode(fillString));
            if (o.type == "image" && params.src) {
                fill.src = params.src;
            }
            params.fill && (fill.on = true);
            if (fill.on == null || params.fill == "none" || params.fill === null) {
                fill.on = false;
            }

            if (fill.on && params.fill) {
                var isURL = Str(params.fill).match(_raphael2["default"]._ISURL);
                if (isURL) {
                    fill.parentNode == node && node.removeChild(fill);
                    fill.rotate = true;
                    fill.src = isURL[1];
                    fill.type = "tile";
                    var bbox = o.getBBox(1);
                    fill.position = bbox.x + S + bbox.y;
                    o._.fillpos = [bbox.x, bbox.y];

                    _raphael2["default"]._preload(isURL[1], function () {
                        o._.fillsize = [this.offsetWidth, this.offsetHeight];
                    });
                } else {
                    var color = _raphael2["default"].getRGB(params.fill);
                    fill.color = color.hex;
                    fill.src = E;
                    fill.type = "solid";

                    if (color.error && (res.type in {
                        circle: 1,
                        ellipse: 1
                    } || Str(params.fill).charAt() != "r") && addGradientFill(res, params.fill, fill)) {
                        a.fill = "none";
                        a.gradient = params.fill;
                        fill.rotate = false;
                    } else if ("opacity" in color && !("fill-opacity" in params)) {
                        // store oiginal non gradient color opacity
                        oriOp.nonGradOpacity = fillOpacity = color.opacity;
                    }
                }
            }

            if (fillOpacity !== -1 || "fill-opacity" in params || "opacity" in params) {
                var opacity = ((+a["fill-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+fillOpacity + 1 || 2) - 1);
                opacity = mmin(mmax(opacity, 0), 1);
                oriOp.opacity = opacity;
                // if gradient color opacity is set then opacity (applied through the params)
                //  should be multiplied with the gradient opacity so that ratio will remain same
                if (oriOp.opacity1 !== undefined) {
                    fill.opacity = oriOp.opacity1 * opacity;
                    fill['o:opacity2'] = oriOp.opacity2 * opacity;
                } else {
                    // multiply with the original non gradient color opacity with the opacity to preserve the ratio of the opacity
                    fill.opacity = opacity * (oriOp.nonGradOpacity === undefined ? 1 : oriOp.nonGradOpacity);
                }
                if (fill.src) {
                    fill.color = "none";
                }
            }
            oriOp.opacity = undefined;
            node.appendChild(fill);
            var stroke = node.getElementsByTagName("stroke") && node.getElementsByTagName("stroke")[0],
                newstroke = false;
            !stroke && (newstroke = stroke = createNode("stroke"));
            if (params.stroke && params.stroke != "none" || params["stroke-width"] || params["stroke-opacity"] != null || params["stroke-dasharray"] || params["stroke-miterlimit"] || params["stroke-linejoin"] || params["stroke-linecap"]) {
                stroke.on = true;
            }
            (params.stroke == "none" || params.stroke === null || stroke.on == null || params.stroke == 0 || params["stroke-width"] == 0) && (stroke.on = false);
            var strokeColor = _raphael2["default"].getRGB('stroke' in params ? params.stroke : a.stroke);
            stroke.on && params.stroke && (stroke.color = strokeColor.hex);
            opacity = ((+a["stroke-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+strokeColor.opacity + 1 || 2) - 1);
            var width = (toFloat(params["stroke-width"]) || 1) * .75;
            opacity = mmin(mmax(opacity, 0), 1);
            params["stroke-width"] == null && (width = a["stroke-width"]);
            params["stroke-width"] && (stroke.weight = width);
            width && width < 1 && (opacity *= width) && (stroke.weight = 1);
            stroke.opacity = opacity;

            params["stroke-linejoin"] && (stroke.joinstyle = params["stroke-linejoin"]) || newstroke && (newstroke.joinstyle = 'miter');
            stroke.miterlimit = params["stroke-miterlimit"] || 8;
            params["stroke-linecap"] && (stroke.endcap = params["stroke-linecap"] == "butt" ? "flat" : params["stroke-linecap"] == "square" ? "square" : "round");
            if (params["stroke-dasharray"]) {
                var dasharray = {
                    "-": "shortdash",
                    ".": "shortdot",
                    "-.": "shortdashdot",
                    "-..": "shortdashdotdot",
                    ". ": "dot",
                    "- ": "dash",
                    "--": "longdash",
                    "- .": "dashdot",
                    "--.": "longdashdot",
                    "--..": "longdashdotdot"
                };
                stroke.dashstyle = dasharray[has](params["stroke-dasharray"]) ? dasharray[params["stroke-dasharray"]] : params["stroke-dasharray"].join && params["stroke-dasharray"].join(' ') || E;
            }
            newstroke && node.appendChild(stroke);
        }
        if (res.type == "text") {
            res.paper.canvas.style.display = E;
            var span = res.paper.span,
                m = 100,
                fontSize = a.font && a.font.match(/\d+(?:\.\d*)?(?=px)/),
                lineHeight = a['line-height'] && (a['line-height'] + E).match(/\d+(?:\.\d*)?(?=px)/);
            s = span.style;
            a.font && (s.font = a.font);
            a["font-family"] && (s.fontFamily = a["font-family"]);
            a["font-weight"] && (s.fontWeight = a["font-weight"]);
            a["font-style"] && (s.fontStyle = a["font-style"]);
            fontSize = toFloat(a["font-size"] || fontSize && fontSize[0]) || 10;
            s.fontSize = fontSize * m + "px";
            lineHeight = toFloat(a["line-height"] || lineHeight && lineHeight[0]) || 12;
            a["line-height"] && (s.lineHeight = lineHeight * m + 'px');
            _raphael2["default"].is(params.text, 'array') && (params.text = res.textpath.string = params.text.join('\n').replace(/<br\s*?\/?>/ig, '\n'));
            res.textpath.string && (span.innerHTML = Str(res.textpath.string).replace(/</g, "&#60;").replace(/&/g, "&#38;").replace(/\n/g, "<br>"));
            var brect = span.getBoundingClientRect();
            res.W = a.w = (brect.right - brect.left) / m;
            res.H = a.h = (brect.bottom - brect.top) / m;
            // res.paper.canvas.style.display = "none";
            res.X = a.x;
            res.Y = a.y;
            var leading = lineHeight - fontSize;

            switch (a["vertical-align"]) {
                case "top":
                    res.bby = res.H / 2; // + leading;
                    break;
                case "bottom":
                    res.bby = -res.H / 2; // - leading;
                    break;
                default:
                    res.bby = 0;
            }

            ("x" in params || "y" in params || res.bby !== undefined) && (res.path.v = _raphael2["default"].format("m{0},{1}l{2},{1}", round(a.x * zoom), round((a.y + (res.bby || 0)) * zoom), round(a.x * zoom) + 1));
            var dirtyattrs = ["x", "y", "text", "font", "font-family", "font-weight", "font-style", "font-size", "line-height"];
            for (var d = 0, dd = dirtyattrs.length; d < dd; d++) {
                if (dirtyattrs[d] in params) {
                    res._.dirty = 1;
                    break;
                }
            } // text-anchor emulation
            switch (a["text-anchor"]) {
                case "start":
                    res.textpath.style["v-text-align"] = "left";
                    res.bbx = res.W / 2;
                    break;
                case "end":
                    res.textpath.style["v-text-align"] = "right";
                    res.bbx = -res.W / 2;
                    break;
                default:
                    res.textpath.style["v-text-align"] = "center";
                    res.bbx = 0;
                    break;
            }
            res.textpath.style["v-text-kern"] = true;
        }
        // res.paper.canvas.style.display = E;
    },

    /*
     * Keeps the follower element in sync with the leaders.
     * First and second arguments represents the context(element) and the
     name of the callBack function respectively.
     * The callBack is invoked for indivual follower Element with the rest of
     arguments.
    */
    updateFollowers = _raphael2["default"]._updateFollowers = function () {
        var i,
            ii,
            followerElem,
            args = arguments,
            o = arrayShift.call(args),
            fnName = arrayShift.call(args);
        for (i = 0, ii = o.followers.length; i < ii; i++) {
            followerElem = o.followers[i].el;
            followerElem[fnName].apply(followerElem, args);
        }
    },
        addGradientFill = function addGradientFill(o, gradient, fill) {
        o.attrs = o.attrs || {};
        var attrs = o.attrs,
            pow = Math.pow,
            oriFOpacity,
            oriOp = o.oriOp,
            opacity,
            oindex,
            type = "linear",
            fxfy = ".5 .5";
        o.attrs.gradient = gradient;
        gradient = Str(gradient).replace(_raphael2["default"]._radial_gradient, function (all, opts) {
            type = "radial";
            opts = opts && opts.split(',') || [];

            // fx,fy of vml is cx,cy of svg
            var cx = opts[0],
                cy = opts[1],
                r = opts[2],
                fx = opts[3],
                fy = opts[4],
                units = opts[5];
            if (fx && fy) {
                fx = toFloat(fx);
                fy = toFloat(fy);
                pow(fx - .5, 2) + pow(fy - .5, 2) > .25 && (fy = sqrt(.25 - pow(fx - .5, 2)) * ((fy > .5) * 2 - 1) + .5);
                fxfy = fx + S + fy;
            }
            return E;
        });
        gradient = gradient.split(/\s*\-\s*/);
        if (type == "linear") {
            var angle = gradient.shift();
            angle = -toFloat(angle);
            if (isNaN(angle)) {
                return null;
            }
        }
        var dots = _raphael2["default"]._parseDots(gradient);
        if (!dots) {
            return null;
        }
        o = o.shape || o.node;
        if (dots.length) {
            fill.parentNode == o && o.removeChild(fill);
            fill.on = true;
            fill.method = "none";
            fill.color = dots[0].color;
            fill.color2 = dots[dots.length - 1].color;
            //For VML use first and last available alpha
            var clrs = [],
                opacity1 = 1,
                opacity2 = dots[0].opacity === undefined ? 1 : dots[0].opacity;
            for (var i = 0, ii = dots.length; i < ii; i++) {
                dots[i].offset && clrs.push(dots[i].offset + S + dots[i].color);
                if (dots[i].opacity !== undefined) {
                    opacity1 = dots[i].opacity; //update with latest avaible opacity
                }
            }
            fill.colors = clrs.length ? clrs.join() : "0% " + fill.color;
            //set opacity1 & opacity2
            // store original gradient color opacity
            oriOp.opacity1 = opacity1;
            oriOp.opacity2 = opacity2;
            oriFOpacity = oriOp.opacity === undefined ? 1 : oriOp.opacity;
            // if gradient color opacity is set then opacity (applied through the params)
            // should be multiplied with the gradient opacity so that ratio will remain same
            fill.opacity = opacity1 * oriFOpacity;
            fill['o:opacity2'] = opacity2 * oriFOpacity;
            if (type == "radial") {
                fill.type = "gradientTitle";
                fill.focus = "100%";
                fill.focussize = "0 0";
                fill.focusposition = fxfy;
                fill.angle = 0;
            } else {
                // fill.rotate= true;
                fill.type = "gradient";
                fill.angle = (270 - angle) % 360;
            }
            o.appendChild(fill);
        }
        return 1;
    },
        Element = function Element(node, vml, group /*, dontAppend*/) {
        var o = this,
            parent = group || vml,
            skew;

        /*!dontAppend && */parent.canvas && parent.canvas.appendChild(node);
        skew = createNode("skew");
        skew.on = true;
        node.appendChild(skew);
        o.skew = skew;

        o.node = o[0] = node;
        node.raphael = true;
        node.raphaelid = o.id = _raphael2["default"]._oid++;

        o.X = 0;
        o.Y = 0;

        o.attrs = o.attrs || {};
        o.followers = o.followers || [];

        o.paper = vml;
        o.ca = o.customAttributes = o.customAttributes || new vml._CustomAttributes();

        o.matrix = _raphael2["default"].matrix();
        o._ = {
            transform: [],
            sx: 1,
            sy: 1,
            dx: 0,
            dy: 0,
            deg: 0,
            dirty: 1,
            dirtyT: 1
        };

        o.parent = parent;
        !parent.bottom && (parent.bottom = o);

        o.prev = parent.top;
        parent.top && (parent.top.next = o);
        parent.top = o;
        o.next = null;
    };
    var elproto = _raphael2["default"].el;

    Element.prototype = elproto;
    elproto.constructor = Element;

    elproto.transform = function (tstr) {
        if (tstr == null) {
            return this._.transform;
        }
        var vbs = this.paper._viewBoxShift,
            vbt = vbs ? "s" + [vbs.scale, vbs.scale] + "-1-1t" + [vbs.dx, vbs.dy] : E,
            oldt;

        if (vbs) {
            oldt = tstr = Str(tstr).replace(/\.{3}|\u2026/g, this._.transform || E);
        }

        _raphael2["default"]._extractTransform(this, vbt + tstr);

        var matrix = this.matrix.clone(),
            skew = this.skew,
            o = this.node,
            split,
            isGrad = ~Str(this.attrs.fill).indexOf("-"),
            isPatt = !Str(this.attrs.fill).indexOf("url(");
        matrix.translate(-.5, -.5);
        if (isPatt || isGrad || this.type == "image") {
            skew.matrix = "1 0 0 1";
            skew.offset = "0 0";
            split = matrix.split();
            if (isGrad && split.noRotation || !split.isSimple) {
                o.style.filter = matrix.toFilter();
                var bb = this.getBBox(),
                    bbt = this.getBBox(1),
                    xget = bb.x2 && bbt.x2 && 'x2' || 'x',
                    yget = bb.y2 && bbt.y2 && 'y2' || 'y',
                    dx = bb[xget] - bbt[xget],
                    dy = bb[yget] - bbt[yget];
                o.coordorigin = dx * -zoom + S + dy * -zoom;
                setCoords(this, 1, 1, dx, dy, 0);
            } else {
                o.style.filter = E;
                setCoords(this, split.scalex, split.scaley, split.dx, split.dy, split.rotate);
            }
        } else {
            o.style.filter = E;
            skew.matrix = Str(matrix);
            skew.offset = matrix.offset();
        }
        oldt && (this._.transform = oldt);

        return this;
    };
    elproto.rotate = function (deg, cx, cy) {
        var o = this;
        if (o.removed) {
            return o;
        }
        updateFollowers(o, 'rotate', deg, cx, cy);
        if (deg == null) {
            return;
        }
        deg = Str(deg).split(separator);
        if (deg.length - 1) {
            cx = toFloat(deg[1]);
            cy = toFloat(deg[2]);
        }
        deg = toFloat(deg[0]);
        cy == null && (cx = cy);
        if (cx == null || cy == null) {
            var bbox = o.getBBox(1);
            cx = bbox.x + bbox.width / 2;
            cy = bbox.y + bbox.height / 2;
        }
        o._.dirtyT = 1;
        o.transform(o._.transform.concat([["r", deg, cx, cy]]));
        return o;
    };
    elproto.translate = function (dx, dy) {
        var o = this;
        if (o.removed) {
            return o;
        }
        updateFollowers(o, 'translate', dx, dy);
        dx = Str(dx).split(separator);
        if (dx.length - 1) {
            dy = toFloat(dx[1]);
        }
        dx = toFloat(dx[0]) || 0;
        dy = +dy || 0;
        if (o._.bbox) {
            o._.bbox.x += dx;
            o._.bbox.y += dy;
        }
        o.transform(o._.transform.concat([["t", dx, dy]]));
        return o;
    };
    elproto.scale = function (sx, sy, cx, cy) {
        var o = this;
        if (o.removed) {
            return o;
        }
        updateFollowers(o, 'scale', sx, sy, cx, cy);
        sx = Str(sx).split(separator);
        if (sx.length - 1) {
            sy = toFloat(sx[1]);
            cx = toFloat(sx[2]);
            cy = toFloat(sx[3]);
            isNaN(cx) && (cx = null);
            isNaN(cy) && (cy = null);
        }
        sx = toFloat(sx[0]);
        sy == null && (sy = sx);
        cy == null && (cx = cy);
        if (cx == null || cy == null) {
            var bbox = o.getBBox(1);
        }
        cx = cx == null ? bbox.x + bbox.width / 2 : cx;
        cy = cy == null ? bbox.y + bbox.height / 2 : cy;

        o.transform(o._.transform.concat([["s", sx, sy, cx, cy]]));
        o._.dirtyT = 1;
        return o;
    };
    elproto.hide = function (soft) {
        var o = this;
        updateFollowers(o, 'hide', soft);
        !o.removed && (o.node.style.display = "none");
        return o;
    };

    elproto.show = function (soft) {
        var o = this;
        updateFollowers(o, 'show', soft);
        !o.removed && (o.node.style.display = E);
        return o;
    };
    elproto._getBBox = function () {
        var o = this;
        if (o.removed) {
            return {};
        }
        return {
            x: o.X + (o.bbx || 0) - o.W / 2,
            y: o.Y + (o.bby || 0) - o.H / 2,
            width: o.W,
            height: o.H
        };
    };
    elproto.remove = function () {
        if (this.removed || !this.parent.canvas) {
            return;
        }

        var o = this,
            node = _raphael2["default"]._engine.getNode(o),
            paper = o.paper,
            shape = o.shape,
            i;

        paper.__set__ && paper.__set__.exclude(o);
        eve.unbind("raphael.*.*." + o.id);

        shape && shape.parentNode.removeChild(shape);
        node.parentNode && node.parentNode.removeChild(node);

        while (i = o.followers.pop()) {
            i.el.remove();
        }
        while (i = o.bottom) {
            i.remove();
        }

        if (o._drag) {
            o.undrag();
        }

        if (o.events) {
            while (i = o.events.pop()) {
                i.unbind();
            }
        }

        o.removeData();
        delete paper._elementsById[o.id];
        _raphael2["default"]._tear(o, o.parent);

        for (var i in o) {
            o[i] = typeof o[i] === "function" ? _raphael2["default"]._removedFactory(i) : null;
        }
        o.removed = true;
    };

    elproto.attr = function (name, value) {
        if (this.removed) {
            return this;
        }
        if (name == null) {
            var res = {};
            for (var a in this.attrs) {
                if (this.attrs[has](a)) {
                    res[a] = this.attrs[a];
                }
            }res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
            res.transform = this._.transform;
            res.visibility = this.node.style.display === "none" ? "hidden" : "visible";
            return res;
        }
        if (value == null && _raphael2["default"].is(name, "string")) {
            if (name == fillString && this.attrs.fill == "none" && this.attrs.gradient) {
                return this.attrs.gradient;
            }
            if (name == "visibility") {
                return this.node.style.display === "none" ? "hidden" : "visible";
            }
            var names = name.split(separator),
                out = {};
            for (var i = 0, ii = names.length; i < ii; i++) {
                name = names[i];
                if (name in this.attrs) {
                    out[name] = this.attrs[name];
                } else if (_raphael2["default"].is(this.ca[name], "function")) {
                    out[name] = this.ca[name].def;
                } else {
                    out[name] = _raphael2["default"]._availableAttrs[name];
                }
            }
            return ii - 1 ? out : out[names[0]];
        }
        if (this.attrs && value == null && _raphael2["default"].is(name, "array")) {
            out = {};
            for (i = 0, ii = name.length; i < ii; i++) {
                out[name[i]] = this.attr(name[i]);
            }
            return out;
        }
        var params;
        if (value != null) {
            params = {};
            params[name] = value;
        }
        value == null && _raphael2["default"].is(name, "object") && (params = name);
        if (_raphael2["default"].stopEvent !== false) {
            for (var key in params) {
                eve("raphael.attr." + key + "." + this.id, this, params[key], key);
            }
        }
        if (params) {
            var todel = {};
            for (key in this.ca) {
                if (this.ca[key] && params[has](key) && _raphael2["default"].is(this.ca[key], "function") && !this.ca['_invoked' + key]) {
                    this.ca['_invoked' + key] = true; // prevent recursion
                    var par = this.ca[key].apply(this, [].concat(params[key]));
                    delete this.ca['_invoked' + key];

                    for (var subkey in par) {
                        if (par[has](subkey)) {
                            params[subkey] = par[subkey];
                        }
                    }
                    this.attrs[key] = params[key];
                    if (par === false) {
                        todel[key] = params[key];
                        delete params[key];
                    }
                }
            }

            // this.paper.canvas.style.display = "none";
            if ('text' in params && this.type == "text") {
                _raphael2["default"].is(params.text, 'array') && (params.text = params.text.join('\n'));
                this.textpath.string = params.text.replace(/<br\s*?\/?>/ig, '\n');
            }
            setFillAndStroke(this, params);
            var follower;
            for (i = 0, ii = this.followers.length; i < ii; i++) {
                follower = this.followers[i];
                follower.cb && !follower.cb.call(follower.el, params, this) || follower.el.attr(params);
            }
            for (var subkey in todel) {
                params[subkey] = todel[subkey];
            }
            // this.paper.canvas.style.display = E;
        }
        return this;
    };

    elproto.blur = function (size) {
        var s = this.node.runtimeStyle,
            f = s.filter;
        f = f.replace(blurregexp, E);
        if (+size !== 0) {
            this.attrs.blur = size;
            s.filter = f + S + ms + ".Blur(pixelradius=" + (+size || 1.5) + ")";
            s.margin = _raphael2["default"].format("-{0}px 0 0 -{0}px", round(+size || 1.5));
        } else {
            s.filter = f;
            s.margin = 0;
            delete this.attrs.blur;
        }
        return this;
    };

    /*\
     * Element.on
     [ method ]
     **
     * Bind handler function for a particular event to Element
     * @param eventType - Type of event
     * @param handler - Function to be called on the firing of the event
    \*/
    elproto.on = function (eventType, handler) {
        if (this.removed) {
            return this;
        }

        if (eventType === 'dragstart') {
            this.drag(null, handler);
            return this;
        } else if (eventType === 'dragmove') {
            this.drag(handler);
            return this;
        } else if (eventType === 'dragend') {
            this.drag(null, null, handler);
            return this;
        }
        if (this.node.attachEvent) {
            this.node.attachEvent('on' + eventType, handler);
        } else {
            this.node['on' + eventType] = function () {
                var evt = _raphael2["default"]._g.win.event;
                evt.target = evt.srcElement;
                handler(evt);
            };
        }
        return this;
    };

    /*\
     * Element.off
     [ method ]
     **
     * Remove handler function bind to an event of element
     * @param eventType - Type of event
     * @param handler - Function to be removed from event
    \*/
    elproto.off = function (eventType, handler) {
        if (this.removed) {
            return this;
        }

        if (eventType === 'dragstart') {
            this.undragstart();
            return this;
        } else if (eventType === 'dragmove') {
            this.undragmove();
            return this;
        } else if (eventType === 'dragend') {
            this.undragend();
            return this;
        }
        if (this.node.attachEvent) {
            this.node.detachEvent('on' + eventType, handler);
        } else {
            this.node['on' + eventType] = null;
        }
        return this;
    };

    _raphael2["default"]._engine.getNode = function (el) {
        var node = el.node || el[0].node;
        return node.clipRect || node;
    };
    _raphael2["default"]._engine.getLastNode = function (el) {
        var node = el.node || el[el.length - 1].node;
        return node.clipRect || node;
    };

    _raphael2["default"]._engine.group = function (vml, id, group) {
        var el = _raphael2["default"]._g.doc.createElement("div"),
            p = new Element(el, vml, group);

        el.style.cssText = cssDot;
        p._id = id || E;
        id && (el.className = 'raphael-group-' + p.id + '-' + id);
        (group || vml).canvas.appendChild(el);

        p.type = 'group';
        p.canvas = p.node;
        p.transform = _raphael2["default"]._engine.group.transform;
        p.top = null;
        p.bottom = null;

        return p;
    };

    _raphael2["default"]._engine.group.transform = function (tstr) {
        if (tstr == null) {
            return this._.transform;
        }

        var o = this,
            s = o.node.style,
            c = o.clip,
            vbs = o.paper._viewBoxShift,
            vbt = vbs ? "s" + [vbs.scale, vbs.scale] + "-1-1t" + [vbs.dx, vbs.dy] : E,
            oldt,
            matrix,
            offset,
            tx,
            ty;

        if (vbs) {
            oldt = tstr = Str(tstr).replace(/\.{3}|\u2026/g, o._.transform || E);
        }
        _raphael2["default"]._extractTransform(o, vbt + tstr);
        matrix = o.matrix;
        offset = matrix.offset();
        tx = toFloat(offset[0]) || 0;
        ty = toFloat(offset[1]) || 0;

        s.left = tx + "px";
        s.top = ty + "px";
        s.zoom = (o._.tzoom = matrix.get(0)) + E;

        /** @todo try perform relative group transform, thus avoiding
         * transform on clipping */
        c && (s.clip = _raphael2["default"].format("rect({1}px {2}px {3}px {0}px)", [c[0] - tx, c[1] - ty, c[2] - tx, c[3] - ty]));

        return o;
    };

    _raphael2["default"]._engine.path = function (vml, attrs, group) {
        var el = createNode("shape");
        el.style.cssText = cssDot;
        el.coordsize = zoom + S + zoom;
        el.coordorigin = vml.coordorigin;

        var p = new Element(el, vml, group);
        p.type = attrs.type || "path";
        p.path = [];
        p.Path = E;

        attrs.type && delete attrs.type;
        setFillAndStroke(p, attrs);
        applyCustomAttributes(p, attrs);
        return p;
    };

    _raphael2["default"]._engine.rect = function (vml, attrs, group) {
        var path = _raphael2["default"]._rectPath(attrs.x, attrs.y, attrs.w, attrs.h, attrs.r);

        attrs.path = path;
        attrs.type = "rect";

        var res = vml.path(attrs, group),
            a = res.attrs;
        res.X = a.x;
        res.Y = a.y;
        res.W = a.width;
        res.H = a.height;
        a.path = path;

        return res;
    };
    _raphael2["default"]._engine.ellipse = function (vml, attrs, group) {
        attrs.type = "ellipse";

        var res = vml.path(attrs, group),
            a = res.attrs;
        res.X = a.x - a.rx;
        res.Y = a.y - a.ry;
        res.W = a.rx * 2;
        res.H = a.ry * 2;

        return res;
    };
    _raphael2["default"]._engine.circle = function (vml, attrs, group) {
        attrs.type = "circle";

        var res = vml.path(attrs, group),
            a = res.attrs;

        res.X = a.x - a.r;
        res.Y = a.y - a.r;
        res.W = res.H = a.r * 2;
        return res;
    };
    _raphael2["default"]._engine.image = function (vml, attrs, group) {
        var path = _raphael2["default"]._rectPath(attrs.x, attrs.y, attrs.w, attrs.h);

        attrs.path = path;
        attrs.type = "image";
        attrs.stroke = "none";
        var res = vml.path(attrs, group),
            a = res.attrs,
            node = res.node,
            fill = node.getElementsByTagName(fillString)[0];

        a.src = attrs.src;
        res.X = a.x = attrs.x;
        res.Y = a.y = attrs.y;
        res.W = a.width = attrs.w;
        res.H = a.height = attrs.h;

        fill.parentNode == node && node.removeChild(fill);
        fill.rotate = true;
        fill.src = a.src;
        fill.type = "tile";
        res._.fillpos = [a.x, a.y];
        res._.fillsize = [a.w, a.h];
        node.appendChild(fill);
        setCoords(res, 1, 1, 0, 0, 0);
        return res;
    };
    _raphael2["default"]._engine.text = function (vml, attrs, group, css) {
        var el = createNode("shape"),
            path = createNode("path"),
            o = createNode("textpath");
        x = attrs.x || 0;
        y = attrs.y || 0;
        text = attrs.text;
        path.v = _raphael2["default"].format("m{0},{1}l{2},{1}", round(attrs.x * zoom), round(attrs.y * zoom), round(attrs.x * zoom) + 1);
        path.textpathok = true;
        o.string = Str(attrs.text).replace(/<br\s*?\/?>/ig, '\n');
        o.on = true;
        el.style.cssText = cssDot;
        el.coordsize = zoom + S + zoom;
        el.coordorigin = "0 0";
        var p = new Element(el, vml, group);

        p.shape = el;
        p.path = path;
        p.textpath = o;
        p.type = "text";
        p.attrs.text = Str(attrs.text || E);
        p.attrs.x = attrs.x;
        p.attrs.y = attrs.y;
        p.attrs.w = 1;
        p.attrs.h = 1;
        css && p.css && p.css(css, undefined, true);
        setFillAndStroke(p, attrs);
        applyCustomAttributes(p, attrs);

        el.appendChild(o);
        el.appendChild(path);

        return p;
    };

    _raphael2["default"]._engine.setSize = function (width, height) {
        var cs = this.canvas.style;
        this.width = width;
        this.height = height;
        width == +width && (width += "px");
        height == +height && (height += "px");
        width && (cs.width = width);
        height && (cs.height = height);
        cs.clip = "rect(0 " + cs.width + " " + cs.height + " 0)";
        if (this._viewBox) {
            _raphael2["default"]._engine.setViewBox.apply(this, this._viewBox);
        }
        return this;
    };
    _raphael2["default"]._engine.setViewBox = function (x, y, w, h, fit) {
        eve("raphael.setViewBox", this, this._viewBox, [x, y, w, h, fit]);
        var width = this.width,
            height = this.height,
            size = 1 / mmax(w / width, h / height),
            H,
            W;
        if (fit) {
            H = height / h;
            W = width / w;
            if (w * H < width) {
                x -= (width - w * H) / 2 / H;
            }
            if (h * W < height) {
                y -= (height - h * W) / 2 / W;
            }
        }
        this._viewBox = [x, y, w, h, !!fit];
        this._viewBoxShift = {
            dx: -x,
            dy: -y,
            scale: size
        };
        this.forEach(function (el) {
            el.transform("...");
        });
        return this;
    };
    var createNode;
    _raphael2["default"]._engine.initWin = function (win) {
        var doc = win.document;
        doc.createStyleSheet().addRule(".rvml", "behavior:url(#default#VML)");
        try {
            !doc.namespaces.rvml && doc.namespaces.add("rvml", "urn:schemas-microsoft-com:vml");
            createNode = _raphael2["default"]._createNode = function (tagName, attrs) {
                var el = doc.createElement('<rvml:' + tagName + ' class="rvml">'),
                    prop;
                for (prop in attrs) {
                    el[prop] = Str(attrs[prop]);
                }
                return el;
            };
        } catch (e) {
            createNode = _raphael2["default"]._createNode = function (tagName, attrs) {
                var el = doc.createElement('<' + tagName + ' xmlns="urn:schemas-microsoft.com:vml" class="rvml">'),
                    prop;
                for (prop in attrs) {
                    el[prop] = Str(attrs[prop]);
                }
                return el;
            };
        }
    };
    _raphael2["default"]._engine.initWin(_raphael2["default"]._g.win);
    _raphael2["default"]._engine.create = function () {
        var con = _raphael2["default"]._getContainer.apply(0, arguments),
            container = con.container,
            height = con.height,
            s,
            width = con.width,
            x = con.x,
            y = con.y;
        if (!container) {
            throw new Error("VML container not found.");
        }
        var res = new _raphael2["default"]._Paper(),
            c = res.canvas = _raphael2["default"]._g.doc.createElement("div"),
            cs = c.style;
        x = x || 0;
        y = y || 0;
        width = width || 512;
        height = height || 342;
        res.width = width;
        res.height = height;
        width == +width && (width += "px");
        height == +height && (height += "px");
        res.coordsize = zoom * 1e3 + S + zoom * 1e3;
        res.coordorigin = "0 0";
        c.id = "raphael-paper-" + res.id;
        res.span = _raphael2["default"]._g.doc.createElement("span");
        res.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;";
        c.appendChild(res.span);
        cs.cssText = _raphael2["default"].format("top:0;left:0;width:{0};height:{1};display:inline-block;cursor:default;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden", width, height);
        if (container == 1) {
            _raphael2["default"]._g.doc.body.appendChild(c);
            cs.left = x + "px";
            cs.top = y + "px";
            cs.position = "absolute";
        } else {
            if (container.firstChild) {
                container.insertBefore(c, container.firstChild);
            } else {
                container.appendChild(c);
            }
        }
        res.renderfix = function () {};
        return res;
    };
    _raphael2["default"].prototype.clear = function () {
        var c;
        eve("raphael.clear", this);
        while (c = this.bottom) {
            c.remove();
        }
        this.canvas.innerHTML = E;
        this.span = _raphael2["default"]._g.doc.createElement("span");
        this.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;";
        this.canvas.appendChild(this.span);
        this.bottom = this.top = null;
    };
    _raphael2["default"].prototype.remove = function () {
        var i;
        eve("raphael.remove", this);
        while (i = this.bottom) {
            i.remove();
        }
        this.canvas.parentNode.removeChild(this.canvas);
        for (i in this) {
            this[i] = typeof this[i] == "function" ? _raphael2["default"]._removedFactory(i) : null;
        }
        return true;
    };

    var setproto = _raphael2["default"].st;
    for (var method in elproto) {
        if (elproto[has](method) && !setproto[has](method)) {
            setproto[method] = function (methodname) {
                return function () {
                    var arg = arguments;
                    return this.forEach(function (el) {
                        el[methodname].apply(el, arg);
                    });
                };
            }(method);
        }
    }
} /**!
  * RedRaphael 1.0.0 - JavaScript Vector Library VML Module
  * Copyright (c) 2012-2013 FusionCharts, Inc. <http://www.fusioncharts.com>
  *
  * Raphael 2.1.0 - JavaScript Vector Library VML Module
  * Copyright (c) 2008-2012 Dmitry Baranovskiy <http://raphaeljs.com>
  * Copyright © 2008-2012 Sencha Labs <http://sencha.com>
  *
  * Licensed under the MIT license.
  */
// Define _window as window object in case of indivual file inclusion.

exports["default"] = _raphael2["default"];

/***/ }),
/* 395 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__(197);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(206);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2['default'] === "function" && typeof _iterator2['default'] === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2['default'] === "function" && obj.constructor === _symbol2['default'] && obj !== _symbol2['default'].prototype ? "symbol" : typeof obj; }; /*jslint forin: true, regexp: true, todo: true, white: false, browser: true,
                                                                                                                                                                                                                                                                                                                                         sloppy: true, white: true, eqeq: false, newcap: true, nomen: true */

/*global FusionCharts */

/**
 * Raphael Canvas Extension
 */

var _raphael = __webpack_require__(85);

var _raphael2 = _interopRequireDefault(_raphael);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

if (_raphael2['default'].canvas) {
    var win = _raphael2['default']._g.win,
        doc = _raphael2['default']._g.doc,
        g = _raphael2['default']._g,
        STRING = 'string',
        PX = 'px',
        separator = /[, ]+/,
        Str = win.String,
        toInt = win.parseInt,
        toFloat = win.parseFloat,
        math = win.Math,
        mmax = math.max,
        mmin = math.min,
        pi = math.PI,
        mathFloor = math.floor,
        eve = _raphael2['default'].eve,
        paperproto = _raphael2['default'].fn,
        elproto = _raphael2['default'].el,
        setproto = _raphael2['default'].st,
        clone = _raphael2['default'].clone,
        deg2rad = pi / 180,
        rad2deg = 180 / pi,
        DEFAULT_FILL = "#fff",
        DEFAULT_STROKE = "#000",
        has = "hasOwnProperty",
        S = " ",

    /** @todo: detect touch */
    supportsTouch = 'ontouchstart' in win || navigator.msMaxTouchPoints > 0,
        events = "click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel".split(S),
        noHandle = false,
        $,
        FauxNode,
        Element,
        draggable = [],
        drag = [],
        dragMove = function dragMove(e) {
        var x = e.clientX,
            y = e.clientY,
            scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
            scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
            dragi,
            j = drag.length;
        while (j--) {
            dragi = drag[j];
            if (supportsTouch) {
                var i = e.touches.length,
                    touch;
                while (i--) {
                    touch = e.touches[i];
                    if (touch.identifier == dragi.el._drag.id) {
                        x = touch.clientX;
                        y = touch.clientY;
                        (e.originalEvent ? e.originalEvent : e).preventDefault();
                        break;
                    }
                }
            } else {
                e.preventDefault();
            }

            //var node = dragi.el.node;
            //o,
            //next = node.nextSibling,
            //parent = node.parentNode,
            //display = node.style.display;

            /** @todo: implement raphael.drag.over */

            //g.win.opera && parent.removeChild(node);
            //node.style.display = "none";
            //o = dragi.el.paper.getElementByPoint(x, y);
            //node.style.display = display;
            //g.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));
            //o && eve("raphael.drag.over." + dragi.el.id, dragi.el, o);
            x += scrollX;
            y += scrollY;
            eve("raphael.drag.move." + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
        }
    },
        dragUp = function dragUp(e) {
        _raphael2['default'].unmousemove(dragMove).unmouseup(dragUp);
        var i = drag.length,
            dragi;
        while (i--) {
            dragi = drag[i];
            dragi.el._drag = {};
            dragi.onendHandler && eve("raphael.drag.end." + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
        }
        drag = [];
    };

    $ = _raphael2['default']._createNode = function (el, attr) {
        if (attr) {
            if ((typeof el === 'undefined' ? 'undefined' : _typeof(el)) === STRING) {
                el = $(el);
            }
            for (var key in attr) {
                if (attr.hasOwnProperty(key)) {
                    el.setAttribute(key, Str(attr[key]));
                }
            }
        } else {
            el = doc.createElement(el);
        }
        return el;
    };

    _raphael2['default']._getConnectedNodes = function (node) {
        return {
            above: [],
            below: []
        };
    };

    _raphael2['default']._getTargetNode = function (coords) {
        var x = coords[0],
            y = coords[1];
    };

    _raphael2['default']._containerEventHandler = function (event) {
        event = event || win.event;

        if (noHandle) {
            return;
        }

        /** @todo: do not use offsetX and offsetY */
        var x = event.offsetX,
            //mathFloor(event.pageX || (event.clientX + doc.body.scrollLeft + doc.documentElement.scrollLeft) || 0),
        y = event.offsetY,
            //mathFloor(event.pageY || (event.clientY + doc.body.scrollTop + doc.documentElement.scrollTop) || 0),
        type = event.type,
            node = _raphael2['default']._getTargetNode([x, y]);

        //console.log(type + ":: x: " + x + " y: " + y);

        /*
        if (typeof node.listeners[type] === 'function') {
            node.listeners[type].call(node, e);
        }*/
    };

    FauxNode = function FauxNode(parent) {
        this.type = "basic";

        this.owner = parent;

        // Element reference needed to get attrs so that there is no need to
        // maintain a redundant copy.
        this._rElement = null;

        // False if this element does not need mouse interactivity.
        this.mouseInteractions = false;
        this.matrix = null;

        // An outline path that will be the outline of the shape or in case of
        // text the rect that bounds the text.
        this.outlinePath = null;

        this.conf = {};
    };

    FauxNode.prototype = {

        constructor: FauxNode,

        /**
         * This method does the complete rendering of the element, including
         * (re)setting the bbox and image map.
         *
         * @returns {_L10.FauxNode.prototype}
         */
        render: function render() {

            var o = this;

            o.draw();
            o.setBBox();

            return o;
        },

        /**
         * Applies the transforms and clipping to the context and draws the
         * element.
         *
         * @returns {undefined}
         */
        draw: function draw() {
            var o = this,
                ctx = o.context,
                el = o._rElement,
                m = el.matrix,
                isClipped = o.isClipped,
                attrs = o.validateAttrs(),
                cr,
                end;

            // After the validation the attributes need to be set to the element
            // as validateAttrs works on a copy of the attrs object.
            el.attrs = attrs;

            ctx.save();

            ctx.fillStyle = attrs.fill;
            ctx.strokeStyle = attrs.stroke;
            ctx.lineWidth = attrs['stroke-width'];

            // Applying the clip before the context is transformed as is the case
            // in case of SVG.
            if (cr = attrs['clip-rect']) {
                cr = cr.split(" ");
                ctx.rect(cr[0], cr[1], cr[2], cr[3]);
                ctx.clip();
                isClipped = o.isClipped = true;
            }

            o.applyTransform(m);

            o.paint();

            ctx.restore();
        },

        /**
         * Parse the attributes provided to paint the element shape using the
         * canvas context.
         *
         * Overridden by individual derived FauxNodes
         */
        paint: function paint() {},

        /**
         * The redraw of the FauxNodes is to be handled by the CanvasObjectModel
         * instance as it involves redrawing all the elements corresponsing to
         * that canvas in the proper order.
         */
        redraw: function redraw() {
            this.COMInstance.redraw(this);
        },

        /**
         * Clears the rectangle corresponding to the bounding box of the node.
         */
        clear: function clear() {
            var o = this,
                ctx = o.context,
                bbox = o._bbox;

            /** @todo: while clearing the stroke-width also needs to be accounted for. */
            if (bbox) {
                ctx.clearRect(bbox.x, bbox.y, bbox.width, bbox.height);
            }
        },

        /**
         * Creates the area node in the image map so that mouse interactivity
         * can be emulated using it.
         */
        addMouseInteractivity: function addMouseInteractivity() {
            var o = this,
                attrs = o._rElement.attrs,
                bbox = o._bbox,
                map = o.owner.wrapper._map,
                shape = o.type === 'circle' ? 'circle' : 'rect',
                coords = shape === 'circle' ? [attrs.cx, attrs.cy, attrs.r].join(",") : [bbox.x, bbox.y, bbox.x2, bbox.y2].join(","),
                area,
                end;

            area = $('area', { shape: shape, coords: coords });
            if (map.firstChild) {
                map.insertBefore(area, map.firstChild);
            } else {
                map.appendChild(area);
            }

            /** @todo: should be put this check here */
            o._mouseArea = area;

            // Needed for paths.
            o.eventListeners = {};
        },

        /**
         * Update the coords of the area node (image map) corresponding to the FauxNode
         * after it has been modified by changing attributes.
         */
        updateMapAreaCoords: function updateMapAreaCoords() {
            var o = this,
                oArea = o._mouseArea,
                bbox = o._bbox;

            if (oArea) {
                //o.context.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);
                if (o instanceof CircleFauxNode) {
                    var r = bbox.width / 2;
                    oArea.setAttribute('coords', [bbox.x + r, bbox.y + r, r].join(","));
                } else {
                    oArea.setAttribute('coords', [bbox.x, bbox.y, bbox.x2, bbox.y2].join(","));
                }
            }
        },

        /**
         * Applies the transform given the transformation matrix to the context.
         *
         * @param {type} matrix
         * @param {type} bbox
         * @param {type} dontsetbbox
         *
         * @returns {_L10.FauxNode.prototype.transformBBox.tbox}
         */
        applyTransform: function applyTransform(m) {
            var o = this,
                ctx = o.context,
                split;

            if (m) {
                split = m.split();
                ctx.translate(split.dx, split.dy);
                !split.noRotation && ctx.rotate(deg2rad * split.rotate);
                ctx.scale(split.scalex, split.scaley);
            }
        },

        /**
         *
         */
        setBBox: function setBBox() {
            var o = this,
                el = o._rElement,
                m = el.matrix,
                parent = o.owner,
                pm = parent.getTransformMatrix && parent.getTransformMatrix();

            if (pm) {
                pm = pm.clone();
                pm.add(m);
                m = pm;
            }

            if (o.outlinePath) {
                o._bbox = _raphael2['default'].pathBBox(_raphael2['default'].transformPath(o.outlinePath, m.toTransformString()).toString());
            } else {
                o.setShapeBBox(m);
            }

            o._mouseArea && o.updateMapAreaCoords();
        },

        getBBox: function getBBox() {
            return this._bbox;
        },

        drawPath: function drawPath(path) {
            var o = this,
                ctx = o.context,
                len = path && path.length || 0,
                pp = PathParser,
                i = 0,
                command,
                x,
                y,
                end;

            // The PathParser object has been borrowed from canvg. All 3rd party attributions implied.
            pp.reset();
            pp.setTokens(path);

            //var bb = new BoundingBox();
            if (ctx != null) {
                ctx.beginPath();
            }

            while (!pp.isEnd()) {
                pp.nextCommand();
                switch (pp.command) {
                    case 'M':
                    case 'm':
                        var p = pp.getAsCurrentPoint();
                        pp.addMarker(p);
                        //bb.addPoint(p.x, p.y);
                        if (ctx != null) {
                            ctx.moveTo(p.x, p.y);
                        }
                        pp.start = pp.current;
                        while (!pp.isCommandOrEnd()) {
                            var p = pp.getAsCurrentPoint();
                            pp.addMarker(p, pp.start);
                            //bb.addPoint(p.x, p.y);
                            if (ctx != null) {
                                ctx.lineTo(p.x, p.y);
                            }
                        }
                        break;
                    case 'L':
                    case 'l':
                        while (!pp.isCommandOrEnd()) {
                            var c = pp.current;
                            var p = pp.getAsCurrentPoint();
                            pp.addMarker(p, c);
                            //bb.addPoint(p.x, p.y);
                            if (ctx != null) {
                                ctx.lineTo(p.x, p.y);
                            }
                        }
                        break;
                    case 'H':
                    case 'h':
                        while (!pp.isCommandOrEnd()) {
                            var newP = new Point((pp.isRelativeCommand() ? pp.current.x : 0) + pp.getScalar(), pp.current.y);
                            pp.addMarker(newP, pp.current);
                            pp.current = newP;
                            //bb.addPoint(pp.current.x, pp.current.y);
                            if (ctx != null) {
                                ctx.lineTo(pp.current.x, pp.current.y);
                            }
                        }
                        break;
                    case 'V':
                    case 'v':
                        while (!pp.isCommandOrEnd()) {
                            var newP = new Point(pp.current.x, (pp.isRelativeCommand() ? pp.current.y : 0) + pp.getScalar());
                            pp.addMarker(newP, pp.current);
                            pp.current = newP;
                            //bb.addPoint(pp.current.x, pp.current.y);
                            if (ctx != null) {
                                ctx.lineTo(pp.current.x, pp.current.y);
                            }
                        }
                        break;
                    case 'C':
                    case 'c':
                        while (!pp.isCommandOrEnd()) {
                            var curr = pp.current;
                            var p1 = pp.getPoint();
                            var cntrl = pp.getAsControlPoint();
                            var cp = pp.getAsCurrentPoint();
                            pp.addMarker(cp, cntrl, p1);
                            //bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                            if (ctx != null) {
                                ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                            }
                        }
                        break;
                    case 'S':
                    case 's':
                        while (!pp.isCommandOrEnd()) {
                            var curr = pp.current;
                            var p1 = pp.getReflectedControlPoint();
                            var cntrl = pp.getAsControlPoint();
                            var cp = pp.getAsCurrentPoint();
                            pp.addMarker(cp, cntrl, p1);
                            //bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                            if (ctx != null) {
                                ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                            }
                        }
                        break;
                    case 'Q':
                    case 'q':
                        while (!pp.isCommandOrEnd()) {
                            var curr = pp.current;
                            var cntrl = pp.getAsControlPoint();
                            var cp = pp.getAsCurrentPoint();
                            pp.addMarker(cp, cntrl, cntrl);
                            //bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
                            if (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);
                        }
                        break;
                    case 'T':
                    case 't':
                        while (!pp.isCommandOrEnd()) {
                            var curr = pp.current;
                            var cntrl = pp.getReflectedControlPoint();
                            pp.control = cntrl;
                            var cp = pp.getAsCurrentPoint();
                            pp.addMarker(cp, cntrl, cntrl);
                            //bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
                            if (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);
                        }
                        break;
                    case 'A':
                    case 'a':
                        while (!pp.isCommandOrEnd()) {
                            var curr = pp.current;
                            var rx = pp.getScalar();
                            var ry = pp.getScalar();
                            var xAxisRotation = pp.getScalar() * (Math.PI / 180.0);
                            var largeArcFlag = pp.getScalar();
                            var sweepFlag = pp.getScalar();
                            var cp = pp.getAsCurrentPoint();

                            // Conversion from endpoint to center parameterization
                            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
                            // x1', y1'
                            var currp = new Point(Math.cos(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.sin(xAxisRotation) * (curr.y - cp.y) / 2.0, -Math.sin(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.cos(xAxisRotation) * (curr.y - cp.y) / 2.0);
                            // adjust radii
                            var l = Math.pow(currp.x, 2) / Math.pow(rx, 2) + Math.pow(currp.y, 2) / Math.pow(ry, 2);
                            if (l > 1) {
                                rx *= Math.sqrt(l);
                                ry *= Math.sqrt(l);
                            }
                            // cx', cy'
                            var s = (largeArcFlag == sweepFlag ? -1 : 1) * Math.sqrt((Math.pow(rx, 2) * Math.pow(ry, 2) - Math.pow(rx, 2) * Math.pow(currp.y, 2) - Math.pow(ry, 2) * Math.pow(currp.x, 2)) / (Math.pow(rx, 2) * Math.pow(currp.y, 2) + Math.pow(ry, 2) * Math.pow(currp.x, 2)));
                            if (isNaN(s)) s = 0;
                            var cpp = new Point(s * rx * currp.y / ry, s * -ry * currp.x / rx);
                            // cx, cy
                            var centp = new Point((curr.x + cp.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y, (curr.y + cp.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y);
                            // vector magnitude
                            var m = function m(v) {
                                return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2));
                            };
                            // ratio between two vectors
                            var r = function r(u, v) {
                                return (u[0] * v[0] + u[1] * v[1]) / (m(u) * m(v));
                            };
                            // angle between two vectors
                            var a = function a(u, v) {
                                return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(r(u, v));
                            };
                            // initial angle
                            var a1 = a([1, 0], [(currp.x - cpp.x) / rx, (currp.y - cpp.y) / ry]);
                            // angle delta
                            var u = [(currp.x - cpp.x) / rx, (currp.y - cpp.y) / ry];
                            var v = [(-currp.x - cpp.x) / rx, (-currp.y - cpp.y) / ry];
                            var ad = a(u, v);
                            if (r(u, v) <= -1) ad = Math.PI;
                            if (r(u, v) >= 1) ad = 0;

                            // for markers
                            var dir = 1 - sweepFlag ? 1.0 : -1.0;
                            var ah = a1 + dir * (ad / 2.0);
                            var halfWay = new Point(centp.x + rx * Math.cos(ah), centp.y + ry * Math.sin(ah));
                            pp.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);
                            pp.addMarkerAngle(cp, ah - dir * Math.PI);

                            //bb.addPoint(cp.x, cp.y); // TODO: this is too naive, make it better
                            if (ctx != null) {
                                var r = rx > ry ? rx : ry;
                                var sx = rx > ry ? 1 : rx / ry;
                                var sy = rx > ry ? ry / rx : 1;

                                ctx.translate(centp.x, centp.y);
                                ctx.rotate(xAxisRotation);
                                ctx.scale(sx, sy);
                                ctx.arc(0, 0, r, a1, a1 + ad, 1 - sweepFlag);
                                ctx.scale(1 / sx, 1 / sy);
                                ctx.rotate(-xAxisRotation);
                                ctx.translate(-centp.x, -centp.y);
                            }
                        }
                        break;
                    case 'Z':
                    case 'z':
                        if (ctx != null) ctx.closePath();
                        pp.current = pp.start;
                }
            }

            o.outlinePath = path;

            return o;
        },

        /**
         * Methods to add and remove event listeners emulating the DOM of
         * standard browsers (and also the non-standard one).
         */
        addEventListener: function addEventListener() {
            var o = this,
                args = arguments,
                eventName = args && args[0],
                handler = args && args[1],
                area,
                checkPathHandler,
                end;

            if (!o._mouseArea) {
                o.addMouseInteractivity();
            }

            area = o._mouseArea;

            if (typeof eventName === 'string' && typeof handler === 'function') {
                /*
                 * If the shape has an associated path then we need to check if
                 * the mouse is within the co-ordinates of the path.
                 */
                if (o._path) {

                    /*
                     * If the event being listened to is mouseover, mouseout or
                     * mousemove then the mouse position has to be constantly
                     * monitored and the event handler called explicitly when
                     * appropriate.
                     */
                    if (eventName === 'mouseover' || eventName === 'mouseout' || eventName === 'mousemove') {

                        if (!o._mousemoveAdded) {
                            var startListening = function (node) {

                                var isInside = false,
                                    isOutside = true,
                                    transition = false;

                                return function (event) {
                                    /** @todo: replace layerX and layerY with
                                     * standard ways of determining mouse position.
                                     */
                                    var x = event.layerX,
                                        y = event.layerY;

                                    transition = false;
                                    /*
                                     * Check if the current position of the mouse
                                     * pointer lies within the path or not.
                                     */
                                    if (_raphael2['default'].isPointInsidePath(node._transformPath, x, y)) {
                                        /*
                                         * @todo: fix isPointInsidePath to return the
                                         * proper result when the mouse pointer is on
                                         * the same horizontal/vertical lines as one
                                         * of the vertices of the path.
                                         */
                                        isInside = true;
                                        if (isOutside) {
                                            isOutside = false;
                                            transition = true;
                                        }
                                    } else {
                                        isOutside = true;
                                        if (isInside) {
                                            isInside = false;
                                            transition = true;
                                        }
                                    }

                                    // Based on the state of the flags, fire the
                                    // appropriate event handlers.
                                    if (isOutside && transition && node.eventListeners['mouseout']) {
                                        node.eventListeners['mouseout'].apply(this, arguments);
                                    }
                                    if (isInside) {
                                        if (transition && node.eventListeners['mouseover']) {
                                            node.eventListeners['mouseover'].apply(this, arguments);
                                        }
                                        if (node.eventListeners['mousemove']) {
                                            node.eventListeners['mousemove'].apply(this, arguments);
                                        }
                                    }
                                };
                            }(o);

                            area.addEventListener('mousemove', startListening, false);
                            o._mousemoveAdded = true;
                        }

                        o.eventListeners[eventName] = handler;
                    } else {
                        var checkPathHandler = function (node, handler) {
                            return function (event) {
                                if (_raphael2['default'].isPointInsidePath(node._path, event.layerX, event.layerY)) {
                                    handler.apply(this, arguments);
                                }
                            };
                        }(o, handler);

                        area.addEventListener(eventName, checkPathHandler, false);
                    }
                } else {
                    area.addEventListener(eventName, handler, false);
                }
            }
        },

        removeEventListener: function removeEventListener() {
            var o = this,
                args = arguments,
                eventName = args && args[0],
                handler = args && args[1],
                area,
                end;

            if (!o._mouseArea) {
                return;
            }
            area = o._mouseArea;

            if (typeof eventName === 'string' && typeof handler === 'function') {
                area.removeEventListener(eventName, handler);
            }
        },

        attachEvent: function attachEvent() {},

        detachEvent: function detachEvent() {},

        validateAttrs: function validateAttrs(attrs) {

            var o = this,
                elAttrs = clone(o._rElement.attrs),
                attr,
                val;

            if (attrs === null) {
                if (o._isValid) {
                    return elAttrs;
                } else {
                    o._isValid = true;
                }
            }

            attrs = attrs || elAttrs;

            for (attr in attrs) {
                val = attrs[attr];

                switch (attr) {

                    default:
                        continue;
                }
            }

            return attrs;
        },

        attrs: function attrs() {}
    };

    var NodeListItem = function NodeListItem(node) {
        this.node = node;
        this.next = null;
        this.prev = null;
    },
        NodeList = function NodeList() {
        this.top = null;
        this.bottom = null;
    };

    NodeList.prototype = {

        constructor: NodeList,

        add: function add(node) {

            node = new NodeListItem(node);

            if (!this.bottom) {
                this.bottom = node;
            }
            if (this.top) {
                this.top.next = node;
            }
            node.next = null;
            node.prev = this.top;

            this.top = node;
        },

        addList: function addList(list) {
            if (!this.bottom) {
                this.bottom = list.bottom;
            }

            if (this.top) {
                this.top.next = list.bottom;
                list.bottom.prev = this.top;
            }

            this.top = list.top;
        },

        toFront: function toFront(node) {
            if (this.top === node) {
                return false;
            }

            if (this.bottom === node) {
                this.bottom = node.next;
            }

            //var map = node.node.canvas._map,
            //    area = node.node._mouseArea;

            node.prev && (node.prev.next = node.next);
            node.next && (node.next.prev = node.prev);

            this.top.next = node;
            node.prev = this.top;
            node.next = null;

            this.top = node;

            /*if (map.firstChild) {
                map.insertBefore(area, map.firstChild);
            }
            else {
                map.appendChild(area);
            }
             node.redraw();*/
        },

        toBack: function toBack(node) {
            if (this.bottom === node) {
                return false;
            }

            if (this.top === node) {
                this.top = node.prev;
            }

            //var map = node.canvas._map,
            //    area = node._mouseArea;

            node.prev && (node.prev.next = node.next);
            node.next && (node.next.prev = node.prev);

            this.bottom.prev = node;
            node.prev = null;
            node.next = this.bottom;

            this.bottom = node;

            /*map.appendChild(area);
             node.redraw();*/
        },

        insertBefore: function insertBefore() {},

        insertAfter: function insertAfter() {},

        each: function each(fn, args) {
            var item = this.bottom;

            while (item) {
                fn.apply(item.node, args);
                item = item.next;
            }
        },

        iterate: function iterate(fn, args) {
            var item = this.bottom,
                retVal = true;

            while (item) {
                retVal = fn.apply(item.node, args);

                if (retVal === false) {
                    break;
                }

                item = item.next;
            }
        },

        dispose: function dispose() {

            this.each(function () {
                this.node.dispose && this.node.dispose();
            });

            this.top = null;
            this.bottom = null;
        }
    };

    /**
     *
        ncowner, a NodeCollection that corresponds to the collection of which
        the layer neing created  is a part
         above, a NodeCollection iterator, that indicated the collection the layer has to be rendered. If
        not provided then this is the first layer of ncowner.
     */
    var CanvasLayer = function CanvasLayer(ncowner, canvas) {
        this.items = new NodeList();

        this.owner = ncowner;
        //this.above = above;
        this.element = null;

        if (canvas) {
            this.element = canvas;
        } else {
            this.init();
        }
    };

    CanvasLayer.prototype = {
        constructor: CanvasLayer,

        appendChild: function appendChild() {
            var o = this,
                ownerWrapper = o.owner.wrapper,
                ele = this.element;

            if (ownerWrapper._image) {
                ownerWrapper.insertBefore(ele, ownerWrapper._image);
            } else {
                ownerWrapper.appendChild(ele);
            }
        },

        insertBefore: function insertBefore() {},

        insertAfter: function insertAfter() {},

        init: function init() {
            this.element = $("canvas");
            // CHECKPOINT: width and height in %?
            $(this.element, {
                width: this.owner.wrapper.offsetWidth,
                height: this.owner.wrapper.offsetHeight
            });

            this.element.style.cssText = "position:absolute;left:0;top:0;";

            this.appendChild();
        },

        getCanvas: function getCanvas() {
            return this.element;
        },

        getContext: function getContext() {
            return this.element.getContext('2d');
        },

        addToLayer: function addToLayer(node) {
            this.items.add(node);
        },

        mergeWithLayerOnTop: function mergeWithLayerOnTop(layerObj) {
            this.items.addList(layerObj.items);
            layerObj.dispose(true);
        },

        mergeWithLayerOnBottom: function mergeWithLayerOnBottom(layerObj) {
            layerObj.items.addList(this.items);
            this.items = layerObj.items;
            layerObj.dispose(true);
        },

        dispose: function dispose(softDispose) {

            if (!softDispose) {
                this.items.each(function () {
                    this.dispose();
                });
            }

            this.items = null;
            this.owner = null;

            this.element.parentNode.removeChild(this.element);
            this.element = null;
        }
    };

    var NodeCollection = function NodeCollection(parent, wrapper, canvas) {

        this.nodeItems = new NodeList();
        this.collectionItems = new NodeList();
        this.layerItems = new NodeList();

        this.owner = this.parent = parent;
        this.layerOnTop = null;

        this.currentLayer = null;
        this.baseLayer = null;

        if (wrapper) {
            this.wrapper = wrapper;
            this.currentLayer = this.baseLayer = new CanvasLayer(this, canvas);
        } else {
            this.init();
        }
    };

    NodeCollection.prototype = {
        constructor: NodeCollection,

        init: function init() {

            var o = this,
                parent = o.parent,
                imageMap = parent.wrapper._image,
                wrapper = $("div");

            // Hacky but need a refernce to the image map to addEventListeners.
            wrapper.style.cssText = "width:100%;height:100%;position:absolute;left:0;top:0;";

            wrapper._map = parent.wrapper._map;

            if (imageMap) {
                parent.wrapper.insertBefore(wrapper, imageMap);
            } else {
                parent.wrapper.appendChild(wrapper);
            }

            o.wrapper = wrapper;
            o.currentLayer = o.baseLayer = new CanvasLayer(o);
        },

        getCurrentContext: function getCurrentContext() {
            return this.currentLayer.getContext();
        },

        setLayerOnTop: function setLayerOnTop(layerObj) {
            this.layerOnTop = layerObj;
        },

        getCurrentCanvas: function getCurrentCanvas() {
            return this.currentLayer.getCanvas();
        },

        addNode: function addNode(node) {
            this.nodeItems.add(node);

            if (node.type === "group") {
                this.addCollection(node);
            } else {
                this.currentLayer.addToLayer(node);
            }
        },

        addCollection: function addCollection(collectionNode) {

            collectionNode = collectionNode || new NodeCollection(this);

            this.collectionItems.add(collectionNode);
            this.currentLayer = new CanvasLayer(this);
            this.layerItems.add(this.currentLayer);
            collectionNode.setLayerOnTop(this.currentLayer);
        },

        dispose: function dispose() {
            this.nodeItems.dispose();
            this.collectionItems.dispose();
            this.layerItems.dispose();
            this.owner = this.parent = null;

            this.ownerLayer = null;
            this.currentLayer = null;
            this.baseLayer = null;
        }
    };

    /**
     * The CanvasObjectModel will be a layer of abstraction above the individual
     * FauxNodes created to emulate the DOM in case of canvas rendering.
     * The engine will be the point of contact for Raphael._engine that will be
     * the direct consumer of the FauxNodes.
     */
    var CanvasObjectModel = function CanvasObjectModel(cnvs, wrpr, width, height) {

        var com = this,
            root = new NodeCollection(null, wrpr, cnvs);

        //root.set

        com.width = width;
        com.height = height;

        com.createNode = function (type, parent) {

            parent = parent || root;

            var node,
                nodeItems = parent.nodeItems,
                layer = parent.currentLayer,
                canvasEle = layer.getCanvas();

            switch (type) {
                case 'rect':
                    node = new RectFauxNode(parent);
                    break;

                case 'circle':
                    node = new CircleFauxNode(parent);
                    break;

                case 'path':
                    node = new PathFauxNode(parent);
                    break;

                case 'text':
                    node = new TextFauxNode(parent);
                    break;

                case 'group':
                    node = new GroupFauxNode(parent);
                    parent.addCollection(node);
                    break;

                default:
                    node = new FauxNode(canvasEle);
            }

            node.COMInstance = this;
            nodeItems.add(node);
            layer.addToLayer(node);

            return node;
        };

        /**
         * This method is needed to redraw a node. Redraw is to be handled at the
         * COM level as redrawing one node needs all the (connected) nodes to be
         * redrawn in the right order.
         *
         * @param {type} node The node that needs to be redrawn.
         *
         * @returns {undefined}
         */
        com.redraw = function (node) {

            // Check if node is a group or a shape.
            var nodeList, childNode, layer;

            if (node.type === "group") {
                nodeList = node.nodeItems;
                node.render();
            } else {

                layer = node.layer;
                nodeList = layer.items;
                childNode = nodeList.bottom;

                // Clear the canvas.
                layer.element.width = layer.element.width;

                while (childNode) {
                    fNode = childNode.node;
                    fNode.type !== "group" && fNode.render();
                    childNode = childNode.next;
                }
            }
        };

        com.insertBefore = function (node) {};

        com.insertAfter = function (node) {};

        com.removeNode = function (node) {};

        com.refreshNode = function (node) {};

        com.refreshAll = function () {};
    };

    Point = function Point(x, y) {
        this.x = x;
        this.y = y;
    };

    Point.prototype.angleTo = function (p) {
        return Math.atan2(p.y - this.y, p.x - this.x);
    };

    Point.prototype.applyTransform = function (v) {
        var xp = this.x * v[0] + this.y * v[2] + v[4];
        var yp = this.x * v[1] + this.y * v[3] + v[5];
        this.x = xp;
        this.y = yp;
    };

    PathParser = new function () {

        this.tokens = null;

        this.setTokens = function (d) {
            if (typeof d === 'string') {
                this.tokens = d.split(' ');
            } else {
                this.tokens = d;
            }
        };

        this.reset = function () {
            this.i = -1;
            this.command = '';
            this.previousCommand = '';
            this.start = new Point(0, 0);
            this.control = new Point(0, 0);
            this.current = new Point(0, 0);
            this.points = [];
            this.angles = [];
        };

        this.isEnd = function () {
            return this.i >= this.tokens.length - 1;
        };

        this.isCommandOrEnd = function () {
            if (this.isEnd()) {
                return true;
            }

            return this.tokens[this.i + 1].toString().match(/^[A-Za-z]$/) != null;
        };

        this.isRelativeCommand = function () {
            switch (this.command) {
                case 'm':
                case 'l':
                case 'h':
                case 'v':
                case 'c':
                case 's':
                case 'q':
                case 't':
                case 'a':
                case 'z':
                    return true;
                    break;
            }
            return false;
        };

        this.getToken = function () {
            this.i++;
            return this.tokens[this.i];
        };

        this.getScalar = function () {
            return parseFloat(this.getToken());
        };

        this.nextCommand = function () {
            this.previousCommand = this.command;
            this.command = this.getToken();
        };

        this.getPoint = function () {
            var p = new Point(this.getScalar(), this.getScalar());
            return this.makeAbsolute(p);
        };

        this.getAsControlPoint = function () {
            var p = this.getPoint();
            this.control = p;
            return p;
        };

        this.getAsCurrentPoint = function () {
            var p = this.getPoint();
            this.current = p;
            return p;
        };

        this.getReflectedControlPoint = function () {
            if (this.previousCommand.toLowerCase() != 'c' && this.previousCommand.toLowerCase() != 's' && this.previousCommand.toLowerCase() != 'q' && this.previousCommand.toLowerCase() != 't') {
                return this.current;
            }

            // reflect point
            var p = new Point(2 * this.current.x - this.control.x, 2 * this.current.y - this.control.y);
            return p;
        };

        this.makeAbsolute = function (p) {
            if (this.isRelativeCommand()) {
                p.x += this.current.x;
                p.y += this.current.y;
            }
            return p;
        };

        this.addMarker = function (p, from, priorTo) {
            // if the last angle isn't filled in because we didn't have this point yet ...
            if (priorTo != null && this.angles.length > 0 && this.angles[this.angles.length - 1] == null) {
                this.angles[this.angles.length - 1] = this.points[this.points.length - 1].angleTo(priorTo);
            }
            this.addMarkerAngle(p, from == null ? null : from.angleTo(p));
        };

        this.addMarkerAngle = function (p, a) {
            this.points.push(p);
            this.angles.push(a);
        };

        this.getMarkerPoints = function () {
            return this.points;
        };

        this.getMarkerAngles = function () {
            for (var i = 0; i < this.angles.length; i++) {
                if (this.angles[i] == null) {
                    for (var j = i + 1; j < this.angles.length; j++) {
                        if (this.angles[j] != null) {
                            this.angles[i] = this.angles[j];
                            break;
                        }
                    }
                }
            }
            return this.angles;
        };
    }();

    /**
     * The FauxNode is the adapter written to give DOM node like handling to the
     * shapes that are create using canvas object model.
     */

    RectFauxNode = function RectFauxNode(parentObj) {
        this.type = "rect";
        this._isValid = false;

        this.parent = this.owner = parentObj;
        this.context = parentObj.getCurrentContext();
        this.layer = parentObj.currentLayer;
    };

    RectFauxNode.prototype = _raphael2['default'].extend(new FauxNode(), {

        constructor: RectFauxNode,

        paint: function paint() {

            var o = this,
                ctx = o.context,

            // CHECKPOINT 3. Rename validateAttrs to getValidAttrs?
            attrs = o.validateAttrs(),
                x = attrs.x,
                y = attrs.y,
                w = attrs.width,
                h = attrs.height,
                r = attrs.r,

            /** @todo: provide support for rx, ry */
            rx = r || attrs.rx,
                ry = r || attrs.ry;

            if (attrs.r) {
                path = ["M", x + rx, y, "L", x + w - rx, y].concat(["A", rx, ry, 0, 0, 1, x + w, y + ry]).concat(["L", x + w, y + h - ry]).concat(["A", rx, ry, 0, 0, 1, x + w - rx, y + h]).concat(["L", x + rx, y + h]).concat(["A", rx, ry, 0, 0, 1, x, y + h - ry]).concat(["L", x, y + ry]).concat(["A", rx, ry, 0, 0, 1, x + rx, y, "Z"]);
            } else {
                path = ["M", x, y, "H", x + w, "V", y + h, "H", x, "V", y, "Z"];
            }

            o.drawPath(path);

            if (attrs['stroke-width']) {
                var strokeAlpha = attrs['stroke-opacity'] === undefined ? attrs['opacity'] : attrs['stroke-opacity'];
                if (strokeAlpha !== undefined) {
                    ctx.globalAlpha = strokeAlpha;
                }
                ctx.stroke();
            }
            var fillAlpha = attrs['fill-opacity'] === undefined ? attrs['opacity'] : attrs['fill-opacity'];
            if (fillAlpha !== undefined) {
                ctx.globalAlpha = fillAlpha;
            }
            ctx.fill();

            return;
        },

        validateAttrs: function validateAttrs(attrs) {
            var o = this,
                elAttrs = clone(o._rElement.attrs),
                attr,
                val;

            if (attrs === null) {
                if (o._isValid) {
                    return elAttrs;
                } else {
                    o._isValid = true;
                }
            }

            attrs = attrs || elAttrs;

            for (attr in attrs) {
                val = attrs[attr];

                switch (attr) {
                    case "r":
                        var w = elAttrs.width,
                            h = elAttrs.height,
                            maxR = mmin(w, h) / 2;

                        if (val > maxR) {
                            attrs.r = maxR;
                        }

                        if (val < 0) {
                            attrs.r = 0;
                        }
                        break;

                    case "width":
                    case "height":
                        if (val < 0) {
                            attrs[attr] = 0;
                        };
                        break;

                    default:
                        continue;
                }
            }

            return attrs;
        },

        setShapeBBox: function setShapeBBox(m) {
            var o = this,
                el = o._rElement,
                attrs = el.attrs,
                sX = m.get(0),
                sY = m.get(3),
                tX = m.get(4),
                tY = m.get(5),
                strokeW = attrs['stroke-width'];

            o._bbox = {
                x: attrs.x * sX + tX - strokeW,
                y: attrs.y * sY + tY - strokeW,
                width: attrs.width * sX + 2 * strokeW,
                height: attrs.height * sY + 2 * strokeW
            };

            o._bbox.x2 = o._bbox.x + o._bbox.width;
            o._bbox.y2 = o._bbox.y + o._bbox.height;

            o.X = o._bbox.x;
            o.Y = o._bbox.y;
            o.W = o._bbox.width;
            o.H = o._bbox.height;
        }
    });

    var CircleFauxNode = function CircleFauxNode(parentObj) {
        this.type = "circle";
        this._isValid = false;

        this.parent = this.owner = parentObj;
        this.context = parentObj.getCurrentContext();
        this.layer = parentObj.currentLayer;
    },
        PathFauxNode = function PathFauxNode(parentObj) {
        this.type = "path";
        this._isValid = false;

        this.parent = this.owner = parentObj;
        this.context = parentObj.getCurrentContext();
        this.layer = parentObj.currentLayer;
    },
        TextFauxNode = function TextFauxNode(parentObj) {
        this.type = "text";
        this._isValid = false;

        this.parent = this.owner = parentObj;
        this.context = parentObj.getCurrentContext();
        this.layer = parentObj.currentLayer;
    },
        GroupFauxNode = function GroupFauxNode(parent, width, height) {

        this.type = "group";

        this.nodeItems = new NodeList();
        this.collectionItems = new NodeList();
        this.layerItems = new NodeList();

        this.owner = this.parent = parent;
        this.layerOnTop = parent.currentLayer;

        this.currentLayer = null;
        this.baseLayer = null;

        this.init();
    };

    CircleFauxNode.prototype = _raphael2['default'].extend(new FauxNode(), {

        constructor: CircleFauxNode,

        paint: function paint() {
            var o = this,
                ctx = o.context,
                attrs = o.validateAttrs(),
                x = attrs.cx,
                y = attrs.cy,
                r = attrs.r,

            /** @todo: provide support for rx, ry */
            rx = r || attrs.rx,
                ry = r || attrs.ry;

            if (attrs.r) {

                o.drawPath(["M", x + r, y, "A", rx, ry, 0, 1, 0, x - r, y, "A", rx, ry, 0, 1, 0, x + r, y, "Z"]);

                if (attrs['stroke-width']) {
                    var strokeAlpha = attrs['stroke-opacity'] === undefined ? attrs['opacity'] : attrs['stroke-opacity'];
                    if (strokeAlpha !== undefined) {
                        ctx.globalAlpha = strokeAlpha;
                    }
                    ctx.stroke();
                }
                var fillAlpha = attrs['fill-opacity'] === undefined ? attrs['opacity'] : attrs['fill-opacity'];
                if (fillAlpha !== undefined) {
                    ctx.globalAlpha = fillAlpha;
                }
                ctx.fill();
            }

            return;
        },

        setShapeBBox: function setShapeBBox(m) {
            var o = this,
                el = o._rElement,
                attrs = el.attrs,
                sX = m.get(0),
                sY = m.get(3),
                tX = m.get(4),
                tY = m.get(5),
                strokeW = attrs['stroke-width'];

            o._bbox = {
                x: tX + (attrs.cx - attrs.r) * sX - strokeW,
                y: tY + (attrs.cy - attrs.r) * sY - strokeW,
                width: 2 * (strokeW + attrs.r * sX),
                height: 2 * (attrs.r * sY + strokeW)
            };

            o._bbox.x2 = o._bbox.x + o._bbox.width;
            o._bbox.y2 = o._bbox.y + o._bbox.height;

            o.X = o._bbox.x;
            o.Y = o._bbox.y;
            o.W = o._bbox.width;
            o.H = o._bbox.height;
        }
    });

    PathFauxNode.prototype = _raphael2['default'].extend(new FauxNode(), {

        constructor: PathFauxNode,

        paint: function paint() {
            var o = this,
                el = o._rElement,
                attrs = el.attrs,
                path = el.attr('path'),
                m = el.matrix,
                ctx = o.context;

            // 1. Get the path from the path attribute
            // 2. Accept paths in different array formats.
            // 3. Optimize as this can potentially be a huge pain-point.
            // 4. Draw path mapping M,L,H,V etc to canvas APIs
            o.drawPath(path);
            o._transformPath = _raphael2['default'].transformPath(path, m.toTransformString());

            var strokeAlpha = attrs['stroke-opacity'] === undefined ? attrs['opacity'] : attrs['stroke-opacity'];
            if (strokeAlpha !== undefined) {
                ctx.globalAlpha = strokeAlpha;
            }
            ctx.stroke();
            var fillAlpha = attrs['fill-opacity'] === undefined ? attrs['opacity'] : attrs['fill-opacity'];
            if (fillAlpha !== undefined) {
                ctx.globalAlpha = fillAlpha;
            }
            ctx.fill();

            return;
        }
    });

    TextFauxNode.prototype = _raphael2['default'].extend(new FauxNode(), {

        constructor: TextFauxNode,

        paint: function paint() {
            var o = this,
                el = o._rElement,
                attrs = el.attr(),
                text = attrs['text'],
                stroke = attrs['stroke'],
                valign = attrs['vertical-align'],
                halign = attrs['text-anchor'],
                x = attrs['x'],
                y = attrs['y'],
                m = el.matrix,
                ctx = o.context,
                path;

            // apply the font styles, if any

            // find the dimensions of the text using the given styles.
            // All the dimensions should be present in the attrs user provided OR default.
            var fontSize = attrs['font-size'] || 10,
                lineHeight = attrs['line-height'] || toInt(fontSize, 10) * 1.2,
                fontArr = ["normal", fontSize, attrs['font']];

            // draw the text.
            ctx.fillStyle = stroke;
            ctx.font = fontArr.join(" ");

            if (text) {
                var texts = Str(text).split(/\n|<br\s*?\/?>/ig),
                    totalHeight = texts.length * lineHeight,
                    totalWidth = -Infinity,
                    startX = Infinity,
                    startY,
                    width,
                    textX,
                    textY;

                if (valign === "top") {
                    startY = y + lineHeight;
                } else if (valign === "middle") {
                    startY = y - totalHeight / 2 + lineHeight / 2;
                } else {
                    // valign is bottom.
                    startY = y - totalHeight + lineHeight;
                }

                for (var i = 0, ii = texts.length; i < ii; i += 1) {

                    text = texts[i];
                    textY = startY + lineHeight * i;
                    width = ctx.measureText(text).width;

                    if (halign === "start") {
                        textX = x;
                    } else if (halign === "middle") {
                        textX = x - width / 2;
                    } else {
                        textX = x - width;
                    }

                    totalWidth = mmax(totalWidth, width);
                    startX = mmin(startX, textX);

                    ctx.fillText(text, textX, textY);
                }

                el._textdirty = false;
            }

            o.outlinePath = ["M", startX, startY - lineHeight / 1.4, "H", startX + totalWidth, "V", startY - lineHeight + totalHeight, "H", startX, "V", startY - lineHeight / 1.4];

            return;
        }
    });

    GroupFauxNode.prototype = _raphael2['default'].extend(_raphael2['default'].extend(new FauxNode(), NodeCollection.prototype), {

        constructor: GroupFauxNode,

        draw: function draw() {

            // Clear the group canvas first.
            this.layerItems.each(function () {
                this.element.width = this.element.width;
            });

            FauxNode.prototype.draw.apply(this, arguments);
        },

        /**
         * This method does the complete rendering of the element, including
         * (re)setting the bbox and image map.
         *
         * @returns {_L10.FauxNode.prototype}
         */
        render: function render() {

            var o = this;

            o.draw();
            o.setBBox();

            return o;
        },

        paint: function paint() {
            var o = this,
                list = o.nodeList,
                el = o._rElement,
                canvas = o.canvas,
                attrs = el.attrs,
                childNode = list.bottom;

            /** @todo: Clean this up */
            if (attrs.opacity !== undefined) {
                this.layerItems.each(function () {
                    this.getContext().globalAlpha = attrs.opacity;
                });
            }

            while (childNode) {
                childNode.render();
                childNode = childNode.next;
            }
        },

        setBBox: function setBBox() {},

        addMouseInteractivity: function addMouseInteractivity() {},

        applyTransform: function applyTransform(m) {
            var o = this,
                parent = o.parent,
                parentMatrix = parent.getTransformMatrix && parent.getTransformMatrix();

            // Parent is a group element with a transformation applied to it.
            if (parentMatrix) {
                o.matrixApplied = parentMatrix.clone();
                o.matrixApplied.add(m.a, m.b, m.c, m.d, m.e, m.f);
            } else {
                o.matrixApplied = m;
            }

            this.layerItems.each(function () {
                FauxNode.prototype.applyTransform.apply(this, [o.matrixApplied]);
            });
        },

        getTransformMatrix: function getTransformMatrix() {
            return this.matrixApplied;
        }
    });

    Element = function Element(node, paper, group) {
        var o = this,
            parent = group || paper;

        o.node = o[0] = node;
        node.raphael = true;
        node.raphaelid = o.id = _raphael2['default']._oid++;
        node._rElement = o;

        o.X = 0;
        o.Y = 0;

        o.attrs = o.attrs || {};
        o.styles = o.styles || {};
        o.followers = o.followers || [];

        o.paper = paper;
        o.com = parent.com;

        o.ca = o.customAttributes = o.customAttributes || new paper._CustomAttributes();

        o.matrix = _raphael2['default'].matrix();
        o._ = {
            transform: [],
            sx: 1,
            sy: 1,
            dx: 0,
            dy: 0,
            deg: 0
        };

        o.parent = parent;
        !parent.bottom && (parent.bottom = o);

        o.prev = parent.top || null;
        parent.top && (parent.top.next = o);
        parent.top = o;
        o.next = null;
    };

    Element.prototype = elproto;
    elproto.constructor = Element;

    var repaint = function repaint(el, finalAttrs, positionChanged, dimensionChanged) {

        var node = getNode(el),
            preC = _raphael2['default']._getConnectedNodes(node),
            attrs = el.attrs,
            elAbove = preC.above,
            elBelow = preC.below,
            len,
            attr,
            i;

        for (attr in finalAttrs) {
            attrs[attr] = finalAttrs[attr];
        }

        node.redraw();
    },
        setFillAndStroke = function setFillAndStroke(el, params) {

        var attrs = el.attrs,
            node = el.node,
            finalAttrs = {},
            att,
            val,
            needsRepaint = false,
            positionChanged = false,
            dimensionChanged = false,
            i;

        for (att in params) {
            if (params[has](att)) {
                if (!_raphael2['default']._availableAttrs[has](att)) {
                    continue;
                }
                val = params[att];

                switch (att) {

                    case 'fill-opacity':
                    case 'opacity':
                    case 'stroke-opcaity':
                    case 'stroke':
                    case 'fill':
                        finalAttrs[att] = val;
                        needsRepaint = true;
                        break;

                    case 'stroke-width':
                    case "cx":
                    case "cy":
                    case "x":
                    case "y":
                        finalAttrs[att] = val;
                        positionChanged = true;
                        break;

                    case "width":
                    case "height":
                        finalAttrs[att] = val;
                        dimensionChanged = true;
                        break;

                    case "clip-rect":
                        finalAttrs[att] = val;
                        needsRepaint = true;
                        break;

                    case "font-size":
                    case "font":
                    case "vertical-align":
                    case "text-anchor":
                        finalAttrs[att] = val;
                        needsRepaint = true;

                    default:
                        continue;
                }
            }
        }

        tuneText(el, params, finalAttrs);

        finalAttrs = node.validateAttrs(finalAttrs);

        if (needsRepaint || positionChanged || dimensionChanged) {
            repaint(el, finalAttrs, positionChanged, dimensionChanged);
        }
    },
        leading = 1.2,
        tuneText = function tuneText(el, params, finalAttrs) {
        if (el.type != "text" || !(params[has]("text") || params[has]("font") || params[has]("font-size") || params[has]("x") || params[has]("y") || params[has]("line-height") || params[has]("vertical-align"))) {
            return;
        }

        var a = el.attr(),
            fontSize = params['font-size'] || a['font-size'] || 10,
            lineHeight = toFloat(params['line-height'] || a['line-height']) || toInt(fontSize, 10) * leading,
            valign = params["vertical-align"] || a["vertical-align"] || "middle";

        if (isNaN(lineHeight)) {
            lineHeight = fontSize * leading;
        }

        finalAttrs['font-size'] = toInt(fontSize, 10) + "px";
        finalAttrs['font'] = params['font'] || a['font'] || 'Verdana';
        finalAttrs['vertical-align'] = valign;
        finalAttrs['x'] = params['x'] || a['x'] || 0;
        finalAttrs['y'] = params['y'] || a['y'] || 0;
        finalAttrs['line-height'] = toInt(lineHeight, 10);
        finalAttrs['text-anchor'] = params['text-anchor'] || a['text-anchor'] || 'middle';
    };

    _raphael2['default']._engine.initWin = function (win) {
        win = win;
        doc = win.document;
    };

    _raphael2['default']._engine.setSize = function (w, h) {
        var paper = this,
            cs = paper.canvas.style;

        cs.width = (paper.width = +w || paper.width) + PX;
        cs.height = (paper.height = +h || paper.height) + PX;
        /** @todo call setViewBox from setSize() */
        return paper;
    };
    /** @todo implement setViewBox() */
    _raphael2['default']._engine.create = function () {
        var con = _raphael2['default']._getContainer.apply(0, arguments) || {},
            container = con.container,
            x = con.x,
            y = con.y,
            width = con.width,
            height = con.height,

        //handler = R._containerEventHandler,
        wrapper,
            cssText,
            image,
            mmap,
            i,
            paper,
            canvas;

        if (!container) {
            throw new Error("Canvas container not found.");
        }

        paper = new _raphael2['default']._Paper();
        paper.canvas = wrapper = $("div");

        x = x || 0;
        y = y || 0;
        paper.width = width = width || 512;
        paper.height = height = height || 342;
        paper.left = paper.top = 0;

        if (container == 1) {
            wrapper.style.cssText = cssText + _raphael2['default'].format(";width:100%;height:100%;position:absolute;left:{0}px;top:{1}px;", [x, y]);
            doc.body.appendChild(wrapper);
        } else {
            wrapper.style.cssText = cssText + ";width:100%;height:100%;position:absolute";
            if (container.firstChild) {
                container.insertBefore(wrapper, container.firstChild);
            } else {
                container.appendChild(wrapper);
            }
        }

        cssText = "overflow:hidden;-webkit-tap-highlight-color:rgba(0,0,0,0);" + "-webkit-user-select:none;-moz-user-select:-moz-none;" + "-khtml-user-select:none;-ms-user-select:none;user-select:none;" + "-o-user-select:none;cursor:default;" + _raphael2['default'].format("width:{0}px;height:{1}px;", [width, height]);

        // Create the canvas element and set it to occupy full space. Retain a
        // reference to its context.
        canvas = $("canvas");
        canvas.style.cssText = "position:absolute;left:0;top:0";
        canvas.setAttribute('width', paper.width);
        canvas.setAttribute('height', paper.height);

        paper.com = new CanvasObjectModel(canvas, wrapper, paper.width, paper.height);

        wrapper.appendChild(canvas);

        image = $("img");

        // Easter egg idea! :)
        image.src = "image1.png";

        image.style.cssText = "opacity: 0;z-index: 100;background: transparent;position: absolute;left: 0;top: 0;width: " + width + "px;height: " + height + "px";
        wrapper.appendChild(image);

        mmap = $("map");

        mmap.setAttribute("name", "mousemap");
        mmap.setAttribute("id", "mousemap"); // Needed for FF.

        wrapper.appendChild(mmap);

        image.setAttribute("usemap", "#mousemap");
        wrapper._image = image;
        wrapper._map = mmap;

        return paper;
    };

    var getNode = _raphael2['default']._engine.getNode = function (el) {
        return el.node || el[0].node;
    };

    _raphael2['default']._engine.getLastNode = function (el) {
        return el.node || el[el.length - 1].node;
    };

    _raphael2['default']._engine.rect = function (paper, x, y, w, h, r, group) {

        var node = paper.com.createNode('rect', group && group.node),
            el = new Element(node, paper, group),
            attrs = el.attrs;

        attrs.x = x;
        attrs.y = y;
        attrs.width = w;
        attrs.height = h;
        attrs.fill = "#fff";
        attrs.stroke = "#000";
        attrs['stroke-width'] = 1;
        attrs.r = r || 0;
        attrs.rx = r || 0;
        attrs.ry = r || 0;

        el.type = "rect";

        node.render();
        return el;
    };

    _raphael2['default']._engine.circle = function (paper, x, y, r, group) {
        var node = paper.com.createNode('circle', group && group.node),
            el = new Element(node, paper, group),
            attrs = el.attrs;

        attrs.cx = x;
        attrs.cy = y;
        attrs.r = r;
        attrs.fill = 'none';
        attrs.stroke = '#000';
        attrs['stroke-width'] = 1;

        el.type = "circle";

        node.render();
        return el;
    };

    _raphael2['default']._engine.ellipse = function (paper, x, y, rx, ry, group) {
        var node = new FauxNode(),
            el = new Element(node, paper, group);

        el.type = "ellipse";
        return el;
    };

    _raphael2['default']._engine.image = function (paper, src, x, y, w, h, group) {
        var node = new FauxNode(),
            el = new Element(node, paper, group);

        el.type = "image";
        return el;
    };

    _raphael2['default']._engine.text = function (paper, x, y, text, group) {
        var node = paper.com.createNode('text', group && group.node),
            el = new Element(node, paper, group),
            attrs = el.attrs;

        attrs.x = x;
        attrs.y = y;
        attrs.text = text;
        attrs.fill = 'none';
        attrs.stroke = '#000';
        attrs.font = 'Verdana';
        attrs['font-size'] = '12px';
        attrs['vertical-align'] = 'middle';
        attrs['text-anchor'] = 'middle';

        el.type = "text";
        node.render();
        return el;
    };

    _raphael2['default']._engine.path = function (pathString, paper, group) {
        var node = paper.com.createNode('path', group && group.node),
            el = new Element(node, paper, group),
            attrs = el.attrs;

        attrs.path = pathString;
        attrs.fill = "#fff";
        attrs.stroke = "#000";
        attrs['stroke-width'] = 1;

        el.type = "path";

        node.render();

        return el;
    };

    _raphael2['default']._engine.group = function (paper, id, group) {

        var node = paper.com.createNode('group', group && group.node),
            el = new Element(node, paper, group),
            wrapper = node.wrapper;

        id && wrapper.setAttribute('class', ['red', id].join('-'));

        el.canvas = wrapper;

        //(group && group.canvas.appendChild(wrapper)) || paper.canvas.appendChild(wrapper);

        el.type = "group";
        return el;
    };

    elproto._getBBox = function () {
        if (this.removed) {
            return {};
        }

        return {
            x: this.X + (this.bbx || 0) - this.W / 2,
            y: this.Y + (this.bby || 0) - this.H / 2,
            width: this.W,
            height: this.H
        };
    };

    /***** ELEMENT REORDERING / RESTRUCTING *****/

    elproto.toFront = function () {
        if (this.removed) {
            return this;
        }

        var o = this,
            thisNode = o.node,
            parent = o.parent,
            parentNode = thisNode.owner,
            followers = o.followers,
            follower,
            i,
            ii;

        if (_raphael2['default']._tofront(o, parent)) {
            if (elproto.type === "group") {
                parent.canvas.appendChild(thisNode);
            } else {
                parentNode.nodeList.tofront(thisNode);
            }
        }

        for (i = 0, ii = followers.length; i < ii; i++) {
            (follower = followers[i]).stalk && follower.el[follower.stalk](o);
        }

        return o;
    };

    elproto.toBack = function () {
        if (this.removed) {
            return this;
        }

        var o = this,
            thisNode = o.node,
            parent = o.parent,
            parentNode = thisNode.owner,
            followers = o.followers,
            follower,
            i,
            ii;

        if (_raphael2['default']._toback(o, parent)) {
            if (elproto.type === "group") {
                parent.canvas.appendChild(thisNode);
            } else {
                parentNode.nodeList.toback(thisNode);
            }
        }

        for (i = 0, ii = followers.length; i < ii; i++) {
            (follower = followers[i]).stalk && follower.el[follower.stalk](o);
        }

        return o;
    };

    elproto.insertAfter = function (element) {
        if (this.removed) {
            return this;
        }

        var o = this,
            thisNode = o.node,
            thatNode = element.node,
            parentNode = thatNode.owner,
            followers = o.followers,
            follower,
            i,
            ii;

        if (thatNode.next) {
            parentNode.nodeList.insertBefore(thisNode, thatNode.next);
        } else {
            parentNode.appendChild(thisNode);
        }

        _raphael2['default']._insertafter(o, element, o.parent, element.parent);

        for (i = 0, ii = followers.length; i < ii; i++) {
            (follower = followers[i]).stalk && follower.el[follower.stalk](element);
        }

        return o;
    };

    elproto.insertBefore = function (element) {
        if (this.removed) {
            return this;
        }

        var o = this,
            thisNode = o.node,
            thatNode = element.node,
            parentNode = thatNode.owner,
            followers = o.followers,
            follower,
            i,
            ii;

        if (thatNode) {
            parentNode.nodeList.insertBefore(thisNode, thatNode);
        } else {
            parentNode.appendChild(thisNode);
        }

        _raphael2['default']._insertafter(o, element, o.parent, element.parent);

        for (i = 0, ii = followers.length; i < ii; i++) {
            (follower = followers[i]).stalk && follower.el[follower.stalk](element);
        }

        return o;
    };

    elproto.appendChild = function (element) {
        return this;
    };

    elproto.removeChild = function (element) {
        return this;
    };

    /***** ELEMENT REORDERING / RESTRUCTING *****/

    elproto.attr = function (name, value) {
        if (this.removed) {
            return this;
        }

        var o = this,
            attrs = o.attrs,
            ca = o.ca,
            names,
            params,
            par,
            res,
            key,
            out,
            subkey,
            delkeys,
            follower,
            ii,
            i;

        // fetch a copy of all attributes
        if (name == null) {
            res = {};
            for (key in attrs) {
                if (attrs.hasOwnProperty(key)) {
                    res[key] = attrs[key];
                }
            }res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
            res.transform = o._.transform;
            /** @todo res.visibility = o.node.style.display === "none" ? "hidden" : "visible"; */
            return res;
        }

        // fetch a single value
        if (value == null && _raphael2['default'].is(name, "string")) {
            if (name == "fill" && attrs.fill == "none" && attrs.gradient) {
                return attrs.gradient;
            }
            if (name == "transform") {
                return o._.transform;
            }
            /** @todo if (name == "visibility") {
                return this.node.style.display === "none" ? "hidden" : "visible";
            }*/

            names = name.split(separator), out = {};

            for (i = 0, ii = names.length; i < ii; i++) {
                name = names[i];
                if (name in attrs) {
                    out[name] = attrs[name];
                } else if (_raphael2['default'].is(ca[name], "function")) {
                    out[name] = ca[name].def;
                } else {
                    out[name] = _raphael2['default']._availableAttrs[name];
                }
            }
            return ii - 1 ? out : out[names[0]];
        }

        // fetch specific attributes
        if (value == null && _raphael2['default'].is(name, "array")) {
            out = {};
            for (i = 0, ii = name.length; i < ii; i++) {
                out[name[i]] = o.attr(name[i]);
            }
            return out;
        }

        // prepare setter params
        if (value != null) {
            params = {};
            params[name] = value;
        } else if (name != null && _raphael2['default'].is(name, "object")) {
            params = name;
        }

        if (_raphael2['default'].stopEvent !== false) {
            for (key in params) {
                eve("raphael.attr." + key + "." + o.id, o, params[key], key);
            }
        }

        delkeys = {};
        for (key in ca) {

            if (ca[key] && params.hasOwnProperty(key) && _raphael2['default'].is(ca[key], "function") && !ca['_invoked' + key]) {

                ca['_invoked' + key] = true; // prevent recursion
                par = ca[key].apply(o, [].concat(params[key]));
                delete ca['_invoked' + key];

                for (subkey in par) {
                    if (par.hasOwnProperty(subkey)) {
                        params[subkey] = par[subkey];
                    }
                }
                attrs[key] = params[key];
                if (par === false) {
                    delkeys[key] = params[key];
                    delete params[key];
                }
            }
        }

        setFillAndStroke(this, params);

        for (i = 0, ii = o.followers.length; i < ii; i++) {
            follower = o.followers[i];
            follower.cb && !follower.cb.call(follower.el, params, o) || follower.el.attr(params);
        }

        for (subkey in delkeys) {
            params[subkey] = delkeys[subkey];
        }
        return this;
    };

    /**************** Drag *********************/
    elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {

        function start(e) {
            (e.originalEvent || e).preventDefault();
            var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;
            this._drag.x = e.clientX + scrollX;
            this._drag.y = e.clientY + scrollY;
            this._drag.id = e.identifier;
            !drag.length && _raphael2['default'].mousemove(dragMove).mouseup(dragUp);
            drag.push({
                el: this,
                move_scope: move_scope,
                start_scope: start_scope,
                end_scope: end_scope,
                onmoveHandler: onmove,
                onstartHandler: onstart,
                onendHandler: onend
            });
            onstart && eve.on("raphael.drag.start." + this.id, onstart);
            onmove && eve.on("raphael.drag.move." + this.id, onmove);
            onend && eve.on("raphael.drag.end." + this.id, onend);
            onstart && eve("raphael.drag.start." + this.id, start_scope || move_scope || this, e.clientX + scrollX, e.clientY + scrollY, e);
        }
        this._drag = {};
        draggable.push({
            el: this,
            start: start
        });
        this.mousedown(start);
        return this;
    };

    elproto.undrag = function () {
        var i = draggable.length;
        while (i--) {
            if (draggable[i].el == this) {
                this.unmousedown(draggable[i].start);
                draggable.splice(i, 1);
                eve.unbind("raphael.drag.*." + this.id);
            }
        }!draggable.length && _raphael2['default'].unmousemove(dragMove).unmouseup(dragUp);
    };

    /***************** Drag *****************/
    /************ TRANSFORMATIONS *************/

    elproto.rotate = function (deg, cx, cy) {

        var o = this,
            bbox;
        if (o.removed) {
            return o;
        }
        deg = Str(deg).split(separator);
        if (deg.length - 1) {
            cx = toFloat(deg[1]);
            cy = toFloat(deg[2]);
        }
        deg = toFloat(deg[0]);
        cy == null && (cx = cy);
        if (cx == null || cy == null) {
            bbox = o.getBBox(1);
            cx = bbox.x + bbox.width / 2;
            cy = bbox.y + bbox.height / 2;
        }
        o.transform(o._.transform.concat([["r", deg, cx, cy]]));
        return o;
    };

    elproto.scale = function (sx, sy, cx, cy) {
        var o = this,
            bbox;
        if (o.removed) {
            return o;
        }
        sx = Str(sx).split(separator);
        if (sx.length - 1) {
            sy = toFloat(sx[1]);
            cx = toFloat(sx[2]);
            cy = toFloat(sx[3]);
        }
        sx = toFloat(sx[0]);
        sy == null && (sy = sx);
        cy == null && (cx = cy);
        if (cx == null || cy == null) {
            bbox = o.getBBox(1);
        }
        cx = cx == null ? bbox.x + bbox.width / 2 : cx;
        cy = cy == null ? bbox.y + bbox.height / 2 : cy;
        o.transform(o._.transform.concat([["s", sx, sy, cx, cy]]));

        return o;
    };

    elproto.translate = function (dx, dy) {
        var o = this;
        if (o.removed) {
            return o;
        }
        dx = Str(dx).split(separator);
        if (dx.length - 1) {
            dy = toFloat(dx[1]);
        }
        dx = toFloat(dx[0]) || 0;
        dy = +dy || 0;
        o.transform(o._.transform.concat([["t", dx, dy]]));

        return o;
    };

    elproto.transform = function (tstr) {

        var o = this,
            _ = o._,
            sw;

        if (tstr === null) {
            return _.transform;
        }

        _raphael2['default']._extractTransform(o, tstr);

        /** @todo: what changes to be made here in the context of canvas */
        /*o.clip && !_.clipispath && $(o.clip, {
            transform: o.matrix.invert()
        });
        o.pattern && updatePosition(o); */
        if (_.sx != 1 || _.sy != 1) {
            sw = o.attrs[has]("stroke-width") ? o.attrs["stroke-width"] : 1;
            o.attr({
                "stroke-width": sw
            });
        }

        o.node && o.node.redraw();

        return o;
    };

    /************ TRANSFORMATIONS *************/

    elproto.hide = function () {
        return this;
    };

    elproto.show = function () {
        return this;
    };

    elproto.blur = function (size) {
        return this;
    };

    elproto.on = function (eventType, handler) {
        var el = this,
            listeners = el.listeners;

        if (!listeners) {
            listeners = el.listeners = {};
        }

        if (!listeners[eventType]) {
            listeners[eventType] = [];
        }

        listeners[eventType].push(handler);
    };

    elproto.remove = function () {
        return this;
    };

    paperproto.clear = function () {
        eve("raphael.clear", this);
        return this;
    };

    paperproto.remove = function () {
        if (this.removed) {
            return;
        }

        var paper = this,
            canvas = paper.canvas,
            pn = canvas.parentNode,
            i;

        eve("raphael.remove", paper);
        pn.removeChild(canvas);

        for (i in paper) {
            paper[i] = typeof paper[i] == "function" ? _raphael2['default']._removedFactory(i) : null;
        }

        this.removed = true;
    };

    _raphael2['default'].toString = function () {
        return "Your browser supports canvas.\nYou are running RedRaphael " + _raphael2['default'].version;
    };

    for (var method in elproto) {
        if (elproto.hasOwnProperty(method) && !setproto.hasOwnProperty(method)) {
            setproto[method] = function (methodname) {
                return function () {
                    var arg = arguments;
                    return this.forEach(function (el) {
                        el[methodname].apply(el, arg);
                    });
                };
            }(method);
        }
    };
}

exports['default'] = _raphael2['default'];

/***/ }),
/* 396 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__(9);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(10);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2['default'] === "function" && typeof _iterator2['default'] === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2['default'] === "function" && obj.constructor === _symbol2['default'] && obj !== _symbol2['default'].prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                                                                                         * RedRaphael extension for dealing with CSS
                                                                                                                                                                                                                                                                                                                                         *
                                                                                                                                                                                                                                                                                                                                         * @private
                                                                                                                                                                                                                                                                                                                                         * @since 3.3
                                                                                                                                                                                                                                                                                                                                         *
                                                                                                                                                                                                                                                                                                                                         * @module fusioncharts.redraphael.css
                                                                                                                                                                                                                                                                                                                                         * @requires fusioncharts.redraphael
                                                                                                                                                                                                                                                                                                                                         */


exports['default'] = function (R) {
  var UNDEF,

  // lib = this.hcLib,
  // R = lib.Raphael,
  eve = R.eve,
      g = R._g,
      paperproto = R.fn,
      elproto = R.el,
      separator = /[, ]+/,
      E = '',
      S = ' ',
      cssStyleRegEx = /\B([A-Z]{1})/g,
      TITLE_STR = 'fusioncharts-raphael-stylesheet',
      StyleSheet,
      sheetproto;

  /**
   * Manage Stylesheet on a page.
   *
   * @constructor
   * @private
   */
  StyleSheet = function StyleSheet(ns) {
    this.styleSheet = E;
    this.rules = {};
    this.ns = ns || E;
  };

  sheetproto = StyleSheet.prototype;

  /**
   * Gets the stylesheet node associated with this instance or creates new if not already.
   * @return {HTMLStyleElement}
   */
  sheetproto.getSheet = function () {
    var node = this.node;
    // Find if there is already a styleSheet in the page with title as TITLE_STR
    this.styleSheet = sheetproto.getStyleSheet(TITLE_STR);

    // If styleSheet doesn't exist, create the styleSheet and
    // set the title and other attribute.
    // This style sheet will be shared by all instances of FusionCharts.
    if (!this.styleSheet) {
      // Create a style node and append it to page head.
      node = this.node = g.doc.createElement('style');
      node.setAttribute('id', R.format('raphael-stylesheet-{0}', R._oid++)); // set an id to the sheet
      node.setAttribute('type', 'text/css');
      node.setAttribute('title', TITLE_STR); // set a title to the sheet
      (g.doc.head || g.doc.getElementsByTagName('head')[0]).appendChild(this.node); // attach to page
      this.styleSheet = sheetproto.getStyleSheet(TITLE_STR);
    }

    return this.styleSheet;
  };

  /**
   * Gets the stylesheet by title.
   * @param {string} title
   * @return {document.styleSheets}
   */
  sheetproto.getStyleSheet = function (title) {
    var styleSheets = g.doc.styleSheets,
        len = styleSheets.length,
        sheet;
    // Iterate through all style sheets in the page and find the FusionCharts style
    // by comparing with TITLE_STR
    while (len--) {
      sheet = styleSheets[len];
      if (sheet.title === title) {
        return sheet;
      }
    }
  };

  /**
   * Apply the css rule to the stylesheet.
   * @param {string} selector
   * @param {string} rule
   */
  sheetproto.applyCSSRule = function (selector, rule) {
    var styleSheet = this.styleSheet,
        rules,
        len;

    if (!styleSheet) {
      if (selector && rule) {
        styleSheet = this.getSheet();
      } else {
        // Nothing to set and no node to set anything to. Hence, nothing to do!
        return;
      }
    }

    rules = styleSheet.rules || styleSheet.cssRules || {};
    len = rules.length || 0;
    // Check whether it support the style insertStyle or addCss
    if (styleSheet.insertRule) {
      styleSheet.insertRule(selector + '{' + rule + '}', len);
    } else if (styleSheet.addRule) {
      styleSheet.addRule(selector, rule, len);
    }
  };

  /**
   * Removes the css rule from the stylesheet.
   * @param {string} selector
   */
  sheetproto.removeCSS = function (selector) {
    var styleSheet = this.styleSheet,
        rules = styleSheet.rules || styleSheet.cssRules || {},
        len = rules.length || 0,
        rule;

    selector = selector || this.ns;
    while (len--) {
      rule = rules[len];
      if (new RegExp(selector).test(rule.selectorText)) {
        // Delete the style
        if (styleSheet.removeRule) {
          styleSheet.removeRule(len);
        } else {
          styleSheet.deleteRule(len);
        }
      }
    }
  };

  /**
   * Disposes the stylesheet object.
   * @memberOf StyleSheet#
   */
  sheetproto.destroy = function () {
    this.removeCSS();
    delete this.node;
    delete this.styleSheet;
    delete this.ns;
    delete this.rules;
  };

  /**
   * Clears all css rules.
   * @memberOf StyleSheet#
   */
  sheetproto.clear = function () {
    this.removeCSS();
    this.rules = {};
  };

  /**
   * Adds a css rule
   * @memberOf StyleSheet#
   *
   * @param {string} selector
   * @param {Object} styles
   */
  sheetproto.add = function (selector, styles, compressed) {
    var prop,
        css = E,
        s = this.rules[selector] || (this.rules[selector] = {}),
        indent = compressed ? E : '\t',
        keyseparator = compressed ? ':' : ': ';

    for (prop in styles) {
      (s[prop] = styles[prop]) && (css += indent + prop.replace(cssStyleRegEx, '-$1').toLowerCase() + keyseparator + s[prop] + ';');
    }
    this.applyCSSRule(selector, css);
  };

  /**
   * Renders a stylesheet after it is updated.
   * @memberOf StyleSheet#
   */
  sheetproto.render = function () {
    this.setCssText();
  };

  /**
   * Sets css text on style node
   * @private
   * @param {string} cssText
   */
  sheetproto.setCssText = function (compressed) {
    var indent = compressed ? E : '\t',
        keyseparator = compressed ? ':' : ': ',
        css = E,
        selector = E,
        rule,
        prop;

    // Convert the css rules object to css text
    for (rule in this.rules) {
      css = E;
      selector = rule.replace(/(^|\,)/g, '$1' + this.ns + S);
      rule = this.rules[rule];
      for (prop in rule) {
        rule[prop] && (css += indent + prop.replace(cssStyleRegEx, '-$1').toLowerCase() + keyseparator + rule[prop] + ';');
      }
      this.applyCSSRule(selector, css);
    }
  };

  // Initialise stylesheet for new papers.
  eve.on('raphael.new', function () {
    this._stylesheet = this._stylesheet || new StyleSheet();
    this.cssNamespace(E);
  });

  // Remove stylesheet on paper dispose
  eve.on('raphael.remove', function () {
    this._stylesheet && this._stylesheet.destroy();
    delete this._stylesheet;
  });

  /**
   * Sets the namespace of the stylesheet associated with a paper
   * @param {string} ns
   */
  paperproto.cssNamespace = function (ns) {
    if (arguments.length) {
      // ensure strict paper locked namespace
      this._stylesheet.ns = R.format('{0}#raphael-paper-{1}', ns && ns + S || E, this.id);
    }
    return this._stylesheet.ns;
  };

  /**
   * Adds a css rule to the paper. The function can also accept a single object as argument having selectors as keys
   * and their corresponding style objects.
   *
   * @param {string} selector
   * @param {Object} styles
   */
  paperproto.cssAddRule = function (selector, styles) {
    if (arguments.length === 1 && (typeof selector === 'undefined' ? 'undefined' : _typeof(selector)) === 'object') {
      // support object style
      for (var prop in selector) {
        this.cssAddRule(prop, selector[prop]);
      }
      return this;
    }
    return this._stylesheet.add(selector, styles), this;
  };

  /**
   * Renders a stylesheet after it is updated.
   */
  paperproto.cssRender = function () {
    return R.svg && this._stylesheet.render(), this;
  };

  /**
   * Removes all css rules.
   */
  paperproto.cssClear = function () {
    return this._stylesheet.clear(), this;
  };

  R.ca['class'] = function (value) {
    var o = this,
        node = o.node,
        paper = o.paper,
        selector = '.' + value,
        styleRules = paper._stylesheet && paper._stylesheet.rules,
        target = o.parent,
        attrs = o.attrs,
        cssObj = {},
        rule,
        targetClass,
        i;
    if (R.svg) {
      value = value || E;
      node.setAttribute('class', o.type === 'group' && o._id ? 'raphael-group-' + o.id + '-' + o._id + S + value : value);
    } else if (R.vml) {
      // Special handling for VML based browsers
      node.className = o.type === 'group' ? value && o._id + S + value || o._id : 'rvml ' + value;

      /** @todo Implement stylesheet for VML */
      // Since vml does not play nice with dynamic css and styles  we have to explicitly apply the attributes to
      // the element. We traverse up all the parent elements and procure their classes.
      if (selector && styleRules) {
        rule = styleRules[selector];
        for (i in rule) {
          i === 'color' && o.type === 'text' && (i = 'fill');
          !attrs[i] && (cssObj[i] = rule[i]);
        }

        while (target && target.attr) {
          if (targetClass = target.attr('class')) {
            selector = '.' + targetClass + S + selector;
            rule = styleRules[selector];
            for (i in rule) {
              i === 'color' && o.type === 'text' && (i = 'fill');
              !attrs[i] && !cssObj[i] && (cssObj[i] = rule[i]);
            }
          }
          target = target.parent;
        }

        o.css(cssObj);
      }
    }
  };

  /**
   * Support for element.css
   * @param {string} name
   * @param {value} value
   */
  elproto.css = function (name, value, doNotTune) {
    var names, params, out, otherkey, doattrs, i, ii;

    // do not parse css in case element is removed.
    if (this.removed) {
      return this;
    }

    if (!this.styles) {
      this.styles = {};
    }

    // process as getter when a single key is sent as parameter.
    if (value === UNDEF && R.is(name, 'string')) {
      names = name.split(separator);
      out = {};
      for (i = 0, ii = names.length; i < ii; i++) {
        name = names[i];
        if (name in this.styles) {
          out[name] = this.styles[name];
        }
      }
      return ii - 1 ? out : out[names[0]];
    }
    // process as getter when multiple keys are pre-sent as array.
    if (value === UNDEF && R.is(name, 'array')) {
      out = {};
      for (i = 0, ii = name.length; i < ii; i++) {
        out[name[i]] = this.styles(name[i]);
      }
      return out;
    }

    // convert single key-value setter into object style standard.
    if (value !== UNDEF) {
      params = {};
      params[name] = value;
    } else if (name && R.is(name, 'object')) {
      params = name;
    }
    // iterate on keys and set style or raise events.
    doattrs = {};
    for (i in params) {
      otherkey = i.replace(/\B([A-Z]{1})/g, '-$1').toLowerCase();

      // If keys are supported via attr then use attr instead of css.
      if (R._availableAttrs.hasOwnProperty(otherkey) || otherkey === 'color') {
        // Replace 'color' with fill
        otherkey === 'color' && this.type === 'text' && (otherkey = 'fill');

        doattrs[otherkey] = params[i];
        doattrs.dirty = true;
        continue;
      }
      eve('raphael.css.' + otherkey + '.' + this.id, this, params[i], otherkey);
      this.node.style[otherkey] = params[i];
      this.styles[otherkey] = params[i];
    }
    // run on followers
    for (i = 0, ii = this.followers.length; i < ii; i++) {
      this.followers[i].el.attr(params);
    }
    // apply css via attrs
    if (doattrs.hasOwnProperty('dirty')) {
      delete doattrs.dirty;
      doNotTune && (doattrs['_do-not-tune'] = true);
      this.attr(doattrs);
    }
    return this;
  };
  /**
   * Support for element.removeCSS
   * @params {array} - list of css to be removed so that parent group css can be inherited.
   */
  elproto.removeCSS = function (params) {
    var element = this,
        param,
        i,
        len;
    !params && (params = _lib.appliedCSS);

    if (this.removed) {
      return this;
    }

    if (R.is(params, 'string')) {
      params = params.split(',');
    }

    if (R.is(params, 'array')) {
      len = params.length;
      for (i = 0; i < len; i++) {
        param = params[i].replace(/\B([A-Z]{1})/g, '-$1').toLowerCase();
        element.node.removeAttribute(param);
        element.node.style[param] = '';
      }
    }

    return this;
  };
};

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/***/ }),
/* 397 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__(9);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(10);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2['default'] === "function" && typeof _iterator2['default'] === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2['default'] === "function" && obj.constructor === _symbol2['default'] && obj !== _symbol2['default'].prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                                                                                         * Red Raphael JavaScript Library
                                                                                                                                                                                                                                                                                                                                         * ------------------------------
                                                                                                                                                                                                                                                                                                                                         * Extension for support of drop-shadow on elements
                                                                                                                                                                                                                                                                                                                                         * @private
                                                                                                                                                                                                                                                                                                                                         *
                                                                                                                                                                                                                                                                                                                                         * @module fusioncharts.redraphael.shadow
                                                                                                                                                                                                                                                                                                                                         * @requires fusioncharts.redraphael
                                                                                                                                                                                                                                                                                                                                         */


exports['default'] = function (R) {
  var win = window,
      UNDEF,
      math = Math,
      mathSqrt = math.sqrt,
      toFloat = win.parseFloat,
      toInt = win.parseInt,
      EMP = '',
      // empty string
  SPC = ' ',
      // white-space
  NONE = 'none',
      ROUND = 'round',
      STROKE_WIDTH = 'stroke-width',
      DROP_SHADOW = 'drop-shadow',
      BLACK = 'rgba(0,0,0,1)',
      hasSVGFilters = win.SVGFilterElement || win.SVGFEColorMatrixElement && win.SVGFEColorMatrixElement.SVG_FECOLORMATRIX_TYPE_SATURATE === 2,


  // R = lib.Raphael,
  forbiddenAttrs = {
    'drop-shadow': 'drop-shadow',
    'stroke': 'stroke',
    'fill': 'fill',
    'stroke-width': 'stroke-width',
    'stroke-opacity': 'stroke-opacity',
    'stroke-linecap': 'stroke-linecap',
    'stroke-linejoin': 'stroke-linejoin',
    'shape-rendering': 'shape-rendering',
    'transform': 'transform'
  },
      createNode = R._createNode,
      supervisor;

  if (R.svg) {
    // Browsers that support SVG filters needs filters to not just be
    // created, but managed as well. This is done so that multiple elements
    // can share same filter definition.
    if (hasSVGFilters) {
      R.el.dropshadow = function (dx, dy, spread, color) {
        var o = this,
            node = o.node,
            shadow = o._.shadowFilter,
            cache = o.paper.cacheShadows || (o.paper.cacheShadows = {}),
            hash = DROP_SHADOW + [dx, dy, spread, color].join(SPC),
            prop,
            filter,
            opacity,
            el;

        if (dx === NONE) {
          if (shadow) {
            shadow.use -= 1; // dereference
            o.node.removeAttribute('filter');

            // In case there is no remainig reference
            // for the shadow, we need to remove the
            // element in use.
            if (!shadow.use) {
              hash = shadow.hash; // retain hash
              for (prop in shadow) {
                el = shadow[prop];
                if (el.parentNode) {
                  el.parentNode.removeChild(el);
                }
                delete shadow[prop];
              }
              // Cleanup
              el = null;
              delete cache[hash];
            }
            // Cleanup
            shadow = null;
            delete o._.shadowFilter;
          }
        } else if (!(shadow && cache[hash] === shadow)) {
          // In case of a valid value and shadow is yet to be
          // defined then create one.
          filter = o.paper.defs.appendChild(createNode('filter', {
            id: R.getElementID(R.createUUID()),
            width: '200%',
            height: '200%'
          }));
          color = R.color(color);
          if (color.error) {
            color = R.color(BLACK);
          }
          opacity = R.pick(color.opacity, 1);

          // Create the filters that are required to give shadow
          // effect on an element.
          shadow = o._.shadowFilter = cache[hash] = {
            use: 1,
            filter: filter,
            hash: hash,
            offset: filter.appendChild(createNode('feOffset', {
              result: 'offOut',
              'in': 'SourceGraphic',
              dx: toFloat(dx),
              dy: toFloat(dy)
            })),
            matrix: filter.appendChild(createNode('feColorMatrix', {
              result: 'matrixOut',
              'in': 'offOut',
              type: 'matrix',
              // remove all colors and add specified color
              // retain original alpha channel to avoid feOffset
              // being overridden
              values: '0 0 0 0 ' + color.r / 255 + ' 0 0 0 0 ' + color.g / 255 + ' 0 0 0 0 ' + color.b / 255 + ' 0 0 0 ' + opacity + ' 0'
            })),
            blur: filter.appendChild(createNode('feGaussianBlur', {
              result: 'blurOut',
              'in': 'matrixOut',
              stdDeviation: mathSqrt(toFloat(spread))
            })),
            blend: filter.appendChild(createNode('feComposite', {
              'in': 'SourceGraphic',
              in2: 'blurOut',
              operator: 'over'
            }))
          };

          node.setAttribute('filter', 'url("' + R._url + '#' + filter.id + '")');
        }

        return this;
      };
    }

    supervisor = function supervisor(params, leader) {
      var o = this,
          scale = o.__shadowscale,
          del = {},
          matrix,
          key;

      for (key in params) {
        if (forbiddenAttrs[key]) {
          del[key] = params[key];
          delete params[key];
        }
        switch (key) {
          case 'transform':
            matrix = leader.matrix.clone();
            matrix.translate(o.__shadowx, o.__shadowy);
            o.transform(matrix.toTransformString());
            break;
          case STROKE_WIDTH:
            params[key] = ((del[key] || 1) + 6 - 2 * o.__shadowlevel) * scale;
            break;
        }
      }
      o.attr(params);
      for (key in del) {
        params[key] = del[key];
      }
    };
    // eslint-disable-next-line no-unused-vars
    R.ca[DROP_SHADOW] = function (offX, offY, spread, color, scale, group) {
      var o = this,
          shadows = o._.shadows || (o._.shadows = []),
          opacity,
          shadow,
          offset,
          matrix,
          tScale,
          strScale,
          i;

      if (o.__shadowblocked) {
        return false;
      } else if (offX === NONE) {
        shadow = shadows.pop();
        while (shadow) {
          shadow.remove();
          shadow = shadows.pop();
        }
      } else {
        color = R.color(color);
        if (color.error) {
          color = R.color(BLACK);
        }

        if (scale instanceof Array) {
          tScale = scale[0];
          strScale = scale[1];
        } else {
          tScale = strScale = scale;
        }

        tScale = 1 / R.pick(tScale, 1);
        strScale = 1 / R.pick(strScale, 1);

        offX = R.pick(offX, 1) * tScale;
        offY = R.pick(offY, 1) * tScale;
        opacity = R.pick(color.opacity, 1) * 0.05;
        offset = toInt(o.attr(STROKE_WIDTH) || 1, 10) + 6;
        matrix = o.matrix.clone();
        matrix.translate(offX, offY);

        for (i = 1; i <= 3; i++) {
          shadow = (shadows[i - 1] || o.clone().follow(o, supervisor, !group && 'before')).attr({
            'stroke': color.hex,
            'stroke-opacity': opacity * i,
            'stroke-width': (offset - 2 * i) * strScale,
            'transform': matrix.toTransformString(),
            'stroke-linecap': ROUND,
            'stroke-linejoin': ROUND,
            'fill': NONE
          });

          shadow.__shadowlevel = i;
          shadow.__shadowscale = strScale;
          shadow.__shadowx = offX;
          shadow.__shadowy = offY;
          group && group.appendChild(shadow);

          shadows.push(shadow);
        }
      }

      return false;
    };

    /**
    * Add or remove a shadow composition to the element.
    *
    * @param {boolean} apply
    * @param {number} opacity
    */
    R.el.shadow = function (apply, opacity, scale, group) {
      var useFilter;

      // allow alternative polymorphism in last two parameters
      if (scale && scale.constructor === R.el.constructor) {
        group = scale;
        scale = UNDEF;
      }

      // In case the parameter is provided in object style then expand it
      if ((typeof apply === 'undefined' ? 'undefined' : _typeof(apply)) === 'object') {
        opacity && opacity.constructor === R.el.constructor && (group = opacity);
        opacity = apply.opacity;
        scale = apply.scalefactor;
        useFilter = !!apply.useFilter;
        apply = apply.apply === UNDEF ? !!opacity : apply.apply;
      }

      // In case opacity is UNDEF, set it to full.
      opacity === UNDEF && (opacity = 1);

      // Check if filter based shadow needs some modification or not.
      if (this.dropshadow) {
        if (useFilter) {
          apply && this.dropshadow(1, 1, 3, 'rgb(64,64,64)') || this.dropshadow(NONE);
          return this;
        } else if (this._.shadowFilter) {
          this.dropshadow(NONE);
        }
      }

      return this.attr(DROP_SHADOW, apply ? [1, 1, 3, 'rgba(64,64,64,' + opacity + ')', scale, group] : NONE);
    };
  } else if (R.vml) {
    // For VML based browsers, there is a single implementation across IE 6-8.
    // As such, it requires only a single implementation.
    R.ca['drop-shadow'] = function (offX, offY, spread, color, scale, group) {
      var o = this,
          shadow = o._.shadow,
          style,
          filter,
          tScale,
          opacity;

      // do not apply shadow on shadow!
      if (o.isShadow) {
        return false;
      }

      if (offX === NONE) {
        shadow && (shadow = o._.shadow = shadow.remove());
      } else {
        if (!shadow) {
          shadow = o._.shadow = o.clone();
          // while adding to separate shadow group, we cannot mark the
          // shadow as stalker as that would break the shadow away from
          // shadow group and insert it before the main element.
          group && group.appendChild(shadow.follow(o)) || shadow.follow(o, UNDEF, 'before');

          shadow.attr({
            fill: 'none',
            'fill-opacity': 0.5,
            'stroke-opacity': 1
          }).isShadow = true;

          if (shadow.attr(STROKE_WIDTH) <= 0) {
            shadow.attr(STROKE_WIDTH, 1);
          }
        }

        style = shadow.node.runtimeStyle;
        filter = style.filter.replace(/ progid:\S+Blur\([^\)]+\)/g, EMP);

        color = R.color(color);
        if (color.error) {
          color = R.color(BLACK);
        }
        opacity = R.pick(color.opacity, 1) / 5;

        if (scale instanceof Array) {
          tScale = scale[0];
        } else {
          tScale = scale;
        }

        tScale = 1 / R.pick(scale, 1);

        offX = R.pick(offX, 1) * tScale;
        offY = R.pick(offY, 1) * tScale;

        shadow.translate(offX, offY);
        style.filter = filter + ' progid:DXImageTransform.Microsoft.Blur(pixelRadius=' + toFloat(spread * 0.4) + ' makeShadow=True Color=' + color.hex + ' shadowOpacity="' + opacity + '");';
      }

      return false;
    };

    /**
     * Add or remove a shadow composition to the element.
     *
     * @param {boolean} apply
     * @param {number} opacity
     */
    R.el.shadow = function (apply, opacity, scale, group) {
      var o = this;

      // allow alternative polymorphism in last two parameters
      if (scale && scale.constructor === R.el.constructor) {
        group = scale;
        scale = UNDEF;
      }

      // In case the parameter is provided in object style then expand it
      if ((typeof apply === 'undefined' ? 'undefined' : _typeof(apply)) === 'object') {
        opacity && opacity.type === 'group' && (group = opacity);
        opacity = apply.opacity;
        scale = apply.scalefactor;
        apply = apply.apply === UNDEF ? !!opacity : apply.apply;
      }

      // In case opacity is UNDEF, set it to full.
      opacity === UNDEF && (opacity = 1);

      return o.attr(DROP_SHADOW, apply || !opacity ? [1, 1, 5, 'rgba(64,64,64,' + opacity + ')', scale, group] : NONE);
    };
  } else if (R.canvas) {
    R.el.shadow = function () {
      return this;
    };
  }
};

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/***/ }),
/* 398 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports['default'] = function (R) {
  var doc = document,
      docBody = doc.body || doc.getElementsByTagName('body')[0],
      UNDEF,
      eve = R.eve,
      addEvent = _domEvent2['default'].addEvent,
      removeEvent = _domEvent2['default'].unlisten,
      touchSafeEvent = _lib.getTouchEvent,
      math = Math,
      mathCeil = math.ceil,
      mathFloor = math.floor,
      NONE = 'none',
      INLINE = 'inline',
      E = '',
      PX = 'px',
      MINVPWIDTH = 100,
      MINVPHEIGHT = 100,
      DUMBOBJ = {},
      vpHeight = screen.availHeight,
      vpWidth = screen.availWidth,
      cssVendorPrefixes = { E: 1, moz: 1, webkit: 1, o: 1, ms: 1 },
      vendorSpecificStyles = {
    borderRadius: 'borderRadius',
    boxShadow: 'boxShadow'
  },
      regexCamelCase = /\-([a-z])/ig,
      regexCamelCaseReplacer = function regexCamelCaseReplacer() {
    return arguments[1].toUpperCase();
  },
      StyleProperty = function StyleProperty(overrides) {
    var f = tip.forbiddenStyle,
        key,
        csskey,
        subkey;

    for (key in overrides) {
      // In case any hyphenated key is passed, convert it to camelCase.
      csskey = regexCamelCase.test(key) ? key.replace(regexCamelCase, regexCamelCaseReplacer) : key;
      overrides[key] !== UNDEF && !f[csskey] && (this[csskey] = overrides[key]);

      // Convert color to hex for VML based browsers since they do not
      // support RGBA.
      if (R.vml && /color/ig.test(csskey)) {
        this[csskey] = R.getRGB(this[csskey]).toString();
      }
    }

    // Do special handling and vendor prefixing for border radius
    for (key in vendorSpecificStyles) {
      if (this[key]) {
        for (subkey in cssVendorPrefixes) {
          this[subkey + key] = this[key];
        }
      }
    }
  },
      tip = /* lib.toolTip = */{
    elementId: 'fusioncharts-tooltip-element',
    element: null,
    lastTarget: null,
    currentTarget: null,
    currentPaper: null,
    pointeroffset: 12,
    prevented: false,

    defaultStyle: (0, _lib.extend2)(StyleProperty.prototype, {
      backgroundColor: '#ffffee',
      borderColor: '#000000',
      borderWidth: '1px',
      color: '#000000',
      fontSize: '10px',
      lineHeight: '12px',
      padding: '3px',
      borderStyle: 'solid'
    }),

    defaultContainerStyle: {
      position: 'absolute',
      textAlign: 'left',
      margin: '0',
      zIndex: '99999',
      pointer: 'default',
      display: 'block'
    },

    forbiddenStyle: {}
  },
      createContainer = function createContainer(tipObj, raiseEvents) {
    var container = tipObj.element,
        textElement = tipObj.textElement,
        containerStyle = tipObj.style,
        defaultContainerStyle = tipObj.defaultContainerStyle,
        f = tipObj.forbiddenStyle,
        key;

    container = tipObj.element = (0, _lib.createElement)('span');
    (doc.body || doc.getElementsByTagName('body')[0]).appendChild(container);
    container.setAttribute('id', tip.elementId);
    // Fix for toolip printing issue in VML #RED-1029
    containerStyle = tipObj.containerStyle = container.style;

    textElement = tipObj.textElement = (0, _lib.createElement)('span');
    container.appendChild(textElement);
    tipObj.style = R.vml ? textElement.runtimeStyle : textElement.style;
    tipObj.style.overflow = 'hidden';
    tipObj.style.display = 'block';

    tipObj.hidden = false;
    tip.hide.call(tipObj);
    // Set default styles.
    for (key in defaultContainerStyle) {
      !f[key] && (containerStyle[key] = defaultContainerStyle[key]);
    }

    // on accidental touch of element, move it fast.
    // addEvent(container, hasTouch && 'touchstart' || 'mouseover', tip.onredraw); // cannot in raphael event

    // on drag of elements, hide the tooltip
    tipObj.scatted = true;

    if (raiseEvents) {
      eve.on('raphael.drag.start.*', function () {
        tip.scatted && (tip.waitingScat = true);
      });
      eve.on('raphael.drag.move.*', function () {
        if (tip.waitingScat) {
          tip.block();
          tip.waitingScat = false;
        }
      });
      eve.on('raphael.drag.end.*', function () {
        tip.waitingScat = false;
        if (tip.scatted) {
          tip.unblock(true);
        }
      });

      // Ensure tooltip hides when paper is removed
      eve.on('raphael.remove', function () {
        if (tip.currentPaper === this || tip.currentTarget && tip.currentTarget.paper === this) {
          tip.hide();
          tip.currentTarget = tip.currentPaper = null;
        }
      });

      // Also need to handle the case of linkedCharts being invoked
      // in which case the tooltip should be hidden if the linkedChart
      // replaces the current chart.
      (0, _eventApi.addListener)('LinkedChartInvoked', function (event) {
        var chartObj = event.sender,
            chartPaper = chartObj.apiInstance.components.paper,
            tipPaper = tip.currentPaper;

        if (tipPaper === chartPaper) {
          tip.hide();
        }
      });

      // Also need to handle the case of realtimeCharts being updated
      // in which case the tooltip should be hidden if the realtimeChart
      // data-plot replaces the current data-plot.
      (0, _eventApi.addListener)('realTimeUpdateComplete', function (event) {
        var chartObj = event.sender,
            chartPaper = chartObj.apiInstance.components.paper,
            tipPaper = tip.currentPaper;

        if (tipPaper === chartPaper) {
          tip.hide();
        }
      });
    }
    return tipObj;
  },
      trackOutOfBoundInteraction = function trackOutOfBoundInteraction(event) {
    if (tip._oobready === true) {
      // first launch (ignore)
      tip._oobready = false;
      return;
    }

    removeEvent(docBody, 'touchstart', trackOutOfBoundInteraction);
    if (tip.hidden || !tip.currentTarget) {
      return;
    }

    var element = event.srcElement || event.target || DUMBOBJ;
    if (!element.raphael || tip.currentTarget.paper.getById(element.raphaelid) !== tip.currentTarget) {
      tip.hide();
    }
  };

  if (R.svg) {
    tip.defaultContainerStyle.pointerEvents = NONE;
    tip.defaultStyle.borderRadius = '0';
    tip.defaultStyle.boxShadow = NONE;
  }

  if (R.vml) {
    tip.forbiddenStyle.borderRadius = true;
    tip.forbiddenStyle.boxShadow = true;
    tip.defaultStyle.filter = E;
  }

  tip.setup = function () {
    var container = tip.element;

    if (!container) {
      createContainer(tip, true);
    }
  };

  tip.restyle = function (style) {
    var tip = this,
        s = tip.style,
        key;

    for (key in style) {
      s[key] = style[key];
    }
  };

  tip.onelement = function (event) {
    if (event.__tipProcessed) {
      return;
    }

    var tracker = this,
        paper = tracker.paper,
        o = tracker.type === 'group' ? paper && paper._elementFromEvent(event) : tracker,
        tipStyle = paper.__tipStyle;

    // If not setup then do not initiate
    if (!o || !tipStyle || !o.__tipNeeded) {
      return;
    }

    if ((event.originalEvent || event).FusionChartsPreventEvent) {
      tip.preventTooltip();
    }

    // prevent hiding.
    tip.hiding && (tip.hiding = clearTimeout(tip.hiding));

    tip.setStyle(paper);

    tip.lastTarget = tip.currentTarget;
    tip.currentTarget = o;

    // update scat information
    (tip.scatted = o.__tipScatted) && tip.unblock(true);

    tip.onredraw.call(this, event);

    event.__tipProcessed = true; // we mark tip processed after everything so that onredraw does not pre-exit

    // for touch device listen window click to hide tooltip
    if (_lib.hasTouch) {
      tip._oobready = true;
      addEvent(docBody || (docBody = doc.body || doc.getElementsByTagName('body')[0]), 'touchstart', trackOutOfBoundInteraction);
    }
  };

  tip.setStyle = function (paper) {
    var newTip = this;
    if (tip.currentPaper !== paper) {
      paper.__tipCp = paper.canvas && (0, _lib.getPosition)(paper.canvas.parentNode) || {};
      tip.restyle.call(newTip, paper.__tipStyle);
      tip.currentPaper = paper;
    }
  };

  tip.onredraw = function (event) {
    if (event.__tipProcessed) {
      return;
    }
    event.__tipProcessed = true;

    // Pointer is on element other than the tooltip target. If this.paper does not exist, it is safe to assume
    // click has been on some other non raphael element. Even if it is from some other paper, the getEventFromId
    // will return null
    if ((this.paper && this.paper._elementFromEvent(event)) !== tip.currentTarget) {
      return;
    }

    tip.setPosition(event);

    tip.redraw();
  };

  tip.setPosition = function (event, x, y) {
    var tip = this;
    event = touchSafeEvent(event);
    tip.x = x || mathFloor(event.pageX || event.clientX + doc.body.scrollLeft + doc.documentElement.scrollLeft || 0);
    tip.y = y || mathFloor(event.pageY || event.clientY + doc.body.scrollTop + doc.documentElement.scrollTop || 0);
  };

  tip.onhide = function (event) {
    if (event.__tipProcessed) {
      return;
    }
    event.__tipProcessed = true;
    if ((this.paper && this.paper._elementFromEvent(event)) !== tip.currentTarget) {
      return;
    }

    tip.hiding = setTimeout(tip.hide, 200);
  };

  tip.redraw = function () {
    var newTip = this,
        o,
        paper,
        text;
    if (tip.prevented || tip.blocked || !tip.currentTarget || !tip.currentTarget.__tipNeeded) {
      return;
    }

    o = tip.currentTarget;
    paper = o.paper;
    text = o.__tipText;

    tip.draw.call(newTip, text, paper);
  };

  // Function called to draw tooltip via mouse-tracker
  tip.customDraw = function (text, paper, event, x, y, chartId) {
    var newTip,

    // This flag will always have a boolean value if tip is drawn via customDraw
    isSameCallee = tip.callee && tip.callee === chartId;
    // Logic to create a different div for tooltip if charts are different and tooltip has to be shown at the same
    // time
    if (!(newTip = tip[chartId]) && tip.currentPaper !== paper) {
      if (!tip.hidden && !isSameCallee) {
        newTip = tip[chartId] = createContainer({
          elementId: 'fusioncharts-tooltip-element',
          pointeroffset: 12,
          defaultStyle: tip.defaultStyle,
          defaultContainerStyle: tip.defaultContainerStyle,
          forbiddenStyle: {}
        });
      } else {
        // Storing the chart id for referance indicating which chart used the common tip
        tip.callee = chartId;
      }
    }

    // Using the common tip
    !newTip && (newTip = tip);
    tip.setStyle.call(newTip, paper, tip.hidden && chartId);
    tip.setPosition.call(newTip, event, x, y);
    tip.draw.call(newTip, text, paper, isSameCallee);
  };

  tip.draw = function (text, paper, isSameCallee) {
    var newTip = isSameCallee !== UNDEF ? this : tip,
        textEl = newTip.textElement,
        containerStyle = newTip.containerStyle,
        style = newTip.style,
        offset = newTip.pointeroffset,
        cp = paper.__tipCp,
        x = newTip.x,
        y = newTip.y,
        width,
        tooltipWidth,
        height,
        diff,
        pw = paper.width,
        ph = paper.height,
        constrain = paper.__tipConstrain;

    if (pw < MINVPWIDTH || ph < MINVPHEIGHT) {
      constrain = false;
    }

    if (newTip.hidden) {
      newTip.containerStyle.top = '-999em'; // perform changes out of view
      tip.show.call(newTip);
    }

    if (!isSameCallee || text !== newTip.text) {
      newTip.text = text;
      containerStyle.width = containerStyle.height = E;

      // Set text and compute its dimensions when word-wrapping is not
      // applied.
      textEl.innerHTML = text;
      style.whiteSpace = 'nowrap';
      width = mathCeil(style.pixelWidth || textEl.offsetWidth || 0);
      height = mathCeil(style.pixelHeight || textEl.offsetHeight || 0);
      // tooltext will overflow chart area, when the width from the current
      // position will exceed the chart's right margin.
      newTip.textWidthOverflow = x + width > cp.left + pw;
      if (newTip.textWidthOverflow) {
        // tooltip width should always be the minimum among the width required
        // to render the total text or the chart width, which is the max
        // allowable width.
        tooltipWidth = pw - offset * 2 > width ? containerStyle.width : pw - offset * 2 || 0;
        containerStyle.width = tooltipWidth && tooltipWidth + PX || E;
        style.whiteSpace = 'normal';
      } else {
        containerStyle.width = E;
      }
      newTip.textHeightOverflow = height > ph;
      if (newTip.textHeightOverflow) {
        containerStyle.height = (ph || 0) - offset * 2 + PX;
        style.whiteSpace = 'normal';
      } else {
        containerStyle.height = E;
      }
    }

    width = mathCeil(style.pixelWidth || textEl.offsetWidth || 0);
    height = mathCeil(style.pixelHeight || textEl.offsetHeight || 0);

    // if the tooltip is to be constrained within the paper
    if (constrain) {
      // is there enough space to show the tooltip in the default position
      if (newTip.textWidthOverflow) {
        // When text overflows. We should set position based on the newly set
        // width. We should only align the text to the extreme chart left
        // when tooltext is going outside chart left.
        x = x - width < cp.left ? cp.left : x - width;
      } else if (!newTip.isFixed && (diff = x + offset + width - (cp.left + pw - offset)) && diff > 0) {
        // if not reposition the tooltip
        x = x - diff;
      } else if (x + offset + width > cp.left + pw - offset) {
        x = x - width - offset;
      }

      if (newTip.textHeightOverflow) {
        y = cp.top;
      } else if (!newTip.isFixed && (diff = y + offset + height - (cp.top + ph - offset)) && diff > 0) {
        y = y - diff;
      } else if (y + offset + height > cp.top + ph - offset) {
        y = y - height - offset * 1.5;
      }
    } else {
      if (vpWidth < x + offset + width) {
        x = x - width - offset;
      }

      if (vpHeight < y + offset + height) {
        y = y - height - offset * 1.5;
      }
    }

    containerStyle.left = (x + offset || 0) + PX;
    containerStyle.top = (y + offset || 0) + PX;

    if (newTip.hidden) {
      tip.show.call(newTip);
    }
  };

  // Function to know if the chart container or its parent has a 'position = fixed' or not.
  tip.inform = function (chartId) {
    (tip[chartId] || tip).isFixed = true;
  };

  tip.hide = function (chartId) {
    var newTip = tip[chartId] || tip;
    newTip.hiding && (newTip.hiding = clearTimeout(newTip.hiding));
    newTip.containerStyle.display = NONE;
    newTip.hidden = true;
    newTip.prevented = false;
  };

  tip.show = function () {
    var tip = this;
    if (!tip.blocked) {
      tip.hiding && (tip.hiding = clearTimeout(tip.hiding));
      tip.containerStyle.display = INLINE;
      tip.hidden = false;
    }
  };

  tip.preventTooltip = function () {
    tip.prevented = true;
  };

  tip.block = function () {
    var tip = this;
    tip.blocked = true;
    tip.containerStyle.display = NONE;
  };

  tip.unblock = function (retain) {
    var tip = this;
    tip.blocked = false;
    retain && (tip.containerStyle.display = tip.hidden && NONE || INLINE);
  };

  R.fn.tooltip = function (css, shadow, constrain) {
    var paper = this,
        op;

    if (shadow) {
      op = (shadow.opacity === UNDEF ? 1 : shadow.opacity) * 0.4;
      if (R.svg) {
        css.boxShadow = '1px 1px 3px rgba(64,64,64,' + op + ')';
      } else {
        css.filter = 'progid:DXImageTransform.Microsoft.Shadow' + '(Strength=2, Direction=135, Color="#404040", shadowOpacity="' + op / 2 + '")';
      }
    }

    paper.__tipStyle = new StyleProperty(css);
    paper.__tipCp = paper.canvas && (0, _lib.getPosition)(paper.canvas.parentNode) || {};
    paper.__tipConstrain = Boolean(constrain);

    // To update tooltip style via setChartAttribute() or setChartData()
    tip.style && tip.restyle(paper.__tipStyle);
    tip.containerStyle && tip.hide();

    return paper;
  };

  R.el.trackTooltip = function (status) {
    var o = this,
        tracking = !!o.__tiptracking;

    // no new state provided or no change in tracking state
    if (status === UNDEF || (status = !!status) === tracking) {
      return o;
    }

    if (status) {
      if (_lib.hasTouch) {
        o.touchstart(tip.onelement);
      } else {
        o.mouseover(tip.onelement);
        o.mousemove(tip.onredraw);
        o.mouseout(tip.onhide);
      }
    } else {
      if (_lib.hasTouch) {
        o.untouchstart(tip.onelement);
      } else {
        o.unmouseover(tip.onelement);
        o.unmousemove(tip.onredraw);
        o.unmouseout(tip.onhide);
      }
    }

    o.__tiptracking = status;
    return o;
  };

  R.el.tooltip = function (text, x, y, unscat, blocked) {
    tip.setup();
    // eslint-disable-next-line no-unused-vars
    R.el.tooltip = function (text, x, y, unscat, blocked) {
      var o = this,
          notext = text === false || text === UNDEF || text === E;

      o.__tipScatted = unscat === UNDEF ? o.__tipScatted : !unscat;
      o.__tipScatted === UNDEF && (o.__tipScatted = true);

      if (blocked !== null) {
        o.__tip_blocked = blocked; // jshint ignore: line
      }

      if (notext ^ !o.__tipText) {
        o.__tipNeeded = !notext;
      }
      o.__tipText = text;

      if (tip.currentTarget === o && text !== tip.text && !tip.hidden) {
        tip[notext ? 'hide' : 'redraw']();
      }

      return o;
    };
    return R.el.tooltip.call(this, text, x, y, unscat, blocked);
  };

  // Add ability to execute tooltip configuration from FusionCharts namespace.
  // fcGlobal.core._setTooltipZIndex = function (value) {
  //   // Ensure that the input is a valid number
  //   value = parseInt(value, 10);
  //   if (tip && !isNaN(value)) {
  //     // Update the default style property.
  //     tip.defaultContainerStyle.zIndex = value;
  //     // In case tooltip element is already ready then also directly
  //     // update its style.
  //     if (tip.containerStyle) {
  //       tip.containerStyle.zIndex = value;
  //     }
  //   }
  // };
};

var _lib = __webpack_require__(5);

var _eventApi = __webpack_require__(7);

var _domEvent = __webpack_require__(34);

var _domEvent2 = _interopRequireDefault(_domEvent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/***/ }),
/* 399 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__(9);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(10);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2['default'] === "function" && typeof _iterator2['default'] === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2['default'] === "function" && obj.constructor === _symbol2['default'] && obj !== _symbol2['default'].prototype ? "symbol" : typeof obj; }; /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */
/**
 * Red Raphael JavaScript Library
 * ------------------------------
 * Extension for support of easy drawing of polygons using raphael
 * @private
 *
 * @module fusioncharts.redraphael.shapes
 * @requires fusioncharts.redraphael
 *
 * @param {Object} R The RedRaphael class to be augmented.
 */


exports['default'] = function (R) {
  var win = window,
      userAgent = win.navigator.userAgent,
      UNDEF,
      hasTouch = 'createTouch' in win.document,
      isIE = /msie/i.test(userAgent) && !win.opera,
      math = Math,
      mathCos = math.cos,
      mathSin = math.sin,
      mathAbs = math.abs,
      mathPow = math.pow,
      mathAtan2 = math.atan2,
      mathTan = math.tan,
      mathAcos = math.acos,
      mathMin = math.min,
      mathRound = math.round,
      mathPI = math.PI,
      mathSqrt = math.sqrt,
      twoPI = 2 * mathPI,
      toInt = win.parseInt,
      toFloat = win.parseFloat,
      toStr = String,
      arraySlice = Array.prototype.slice,
      HAS = 'hasOwnProperty',
      ARRAY = 'array',
      OBJECT = 'object',
      BLANK = '',
      COMMA = ',',
      SPACE = ' ',
      NONE = 'none',
      CRISP = 'crisp',
      FILL = 'fill',
      WIDTH = 'width',
      HEIGHT = 'height',
      M = 'M',
      L = 'L',
      A = 'A',
      Z = 'Z',
      Q = 'Q',
      RStr = 'r',
      STROKE = 'stroke',
      PATH = 'path',
      POLYPATH = 'polypath',
      RINGPATH = 'ringpath',
      ARCPATH = 'arcpath',
      CUBEPATH = 'cubepath',
      TEXTBOUND = 'text-bound',
      FLAT = 'flat',
      TRANSPARENT = 'transparent',
      HORIZONTAL = 'horizontal',
      VERTICAL = 'vertical',
      SCROLL_RATIO = 'scroll-ratio',
      SCROLL_POSITION = 'scroll-position',
      SCROLL_ORIENTATION = 'scroll-orientation',
      SCROLL_REPAINT = 'scroll-repaint',
      SCROLL_DISPLAY_STYLE = 'scroll-display-style',
      SCROLL_DISPLAY_BUTTONS = 'scroll-display-buttons',
      EVE_SCROLLSTART = 'raphael.scroll.start.',
      EVE_SCROLLCHANGE = 'raphael.scroll.change.',
      EVE_SCROLLEND = 'raphael.scroll.end.',
      EPSILON = mathPow(2, -24),
      minRenderingDistance = 0.01,
      // Minimum distance between two pixel to render them.
  TRACKER_FILL = 'rgba(192,192,192,' + (isIE ? 0.002 : 0.000001) + ')',
      // invisible but clickable

  eve = R.eve,
      createNode = R._createNode,
      setFillAndStroke = R._setFillAndStroke,
      Element = R.el.constructor,
      shapeRenderingAttrs = {
    speed: 'optimizeSpeed',
    crisp: 'crispEdges',
    precision: 'geometricPrecision'
  },

  // Enum of attributes that are valid for button-active property
  buttonDisabledAttrs = {
    'enabled': false,
    'false': false,
    '0': false,
    'disabled': true,
    'true': true,
    '1': true
  },

  // High performance path rendering extension for Red Raphael.
  LITEPATH = 'litepath',
      CSSFLOOD = 'position:absolute;left:0;top:0;width:21600px;height:21600px;',
      COORD21600 = '21600 21600',
      s2vcmd = {
    'Q': 'L',
    'Z': 'X',
    'q': 'l',
    'z': 'x',
    ',': ' '
  },
      p2s = /,?([achlmqrstvxz]),?/gi,
      commaseparator = /\s*\,\s*/g,
      p2srep,
      path2string = function path2string() {
    return this.join(COMMA).replace(p2s, p2srep);
  },
      litepathsetter,
      vmlTransformHelper,
      p2pdistance = R._cacher(function (x1, y1, x2, y2) {
    // Returns distance between two points
    return mathSqrt(mathPow(x2 - x1, 2) + mathPow(y2 - y1, 2));
  }),
      pointAtLength = R._cacher(function (x1, y1, x2, y2, d) {
    /* Returns the coordinates of the point at distance 'd' from point (x1, y1)
     * on the line between point (x1, y1) and point (x2, y2).
     */

    // Calculate vectors along path
    var vx = x2 - x1,
        vy = y2 - y1,
        l,
        px,
        py;

    // Calculate total length of the path
    l = p2pdistance(x1, y1, x2, y2);

    // Normalize the vectors
    vx /= l;
    vy /= l;

    // Calculate required point coordinates
    px = x1 + vx * d;
    py = y1 + vy * d;

    return {
      x: px,
      y: py
    };
  });

  // Shape rendering attribute support
  if (R.svg) {
    eve.on('raphael.attr.shape-rendering', function (value, key) {
      var o = this,
          node = o.node;
      o.attrs[key] = value = shapeRenderingAttrs[value] || value || 'auto';
      node.setAttribute(key, value);
      node.style.shapeRendering = value;
    });
  } else if (R.vml) {
    eve.on('raphael.attr.shape-rendering', function (val) {
      this.node.style.antialias = val !== 'crisp';
    });
  }

  R.define && R.define([{
    name: 'polypath',

    // args: sides, cx, cy, r, angle, dip, group
    polypath: function polypath() {
      return this.path(UNDEF, R._lastArgIfGroup(arguments));
    },

    ca: {
      polypath: function polypath(sides, cx, cy, r, startAngle, dip) {
        var path, inangle, i, angle, h;

        path = [];
        sides = toInt(sides, 10) || 0;
        cx = toFloat(cx) || 0;
        cy = toFloat(cy) || 0;
        r = toFloat(r) || 0;
        startAngle = startAngle === null || isNaN(startAngle) ? mathPI * 0.5 : R.rad(startAngle);
        dip = dip === null || isNaN(dip) ? 0 : toFloat(dip);
        angle = startAngle;

        if (sides > 2) {
          inangle = 2 * mathPI / sides;

          switch (dip) {
            // polygon
            case 0:
              for (i = 0; i < sides; i++) {
                path.push(L, cx + r * mathCos(-angle), cy + r * mathSin(-angle));
                angle += inangle;
              }
              // we need to replace the first command to move. it was not
              // done earlier and is done now to ease out the algorithm.
              path[0] = M;
              // close path at end
              path.push(Z);
              break;

            // spoke
            case 1:
              for (i = 0; i < sides; i++) {
                path.push(M, cx, cy, L, cx + r * mathCos(-angle), cy + r * mathSin(-angle));
                angle += inangle;
              }
              break;

            // star
            default:
              inangle *= 0.5;
              // R cos(alpha) here is the radial distance of midpoint of two
              // consecutive vertices.
              h = r * mathCos(inangle) * (1 - dip);

              for (i = 0; i < sides; i++) {
                path.push(L, cx + r * mathCos(-angle), cy + r * mathSin(-angle));
                angle += inangle;

                path.push(L, cx + h * mathCos(-angle), cy + h * mathSin(-angle));
                angle += inangle;
              }
              // we need to replace the first command to move. it was not
              // done earlier and is done now to ease out the algorithm.
              path[0] = M;
              // close path at end
              path.push(Z);
              break;
          }
        } else {
          // If 'sides' is less than three then draw a circle.
          // In case r is zero, we need to avoid creating arcs so that VML
          // does not get broken due to zero-radius arcs.
          if (r === 0) {
            path.push(M, cx, cy, L, cx, cy, Z);
          } else {
            path.push(M, cx - r, cy, A, r, r, 0, 0, 0, cx + r, cy, A, r, r, 0, 0, 0, cx - r, cy, Z);
          }
        }

        return {
          path: path
        };
      },

      r: function r(value) {
        var o = this,
            attr = o.attrs.polypath;

        // if attr was previously defined then update the radius
        attr[3] = value;
        o.attr(POLYPATH, attr);

        return false;
      }
    }
  }, {
    name: RINGPATH,
    // args: x, y, r1, r2, start, end, group
    ringpath: function ringpath() {
      return this.path(UNDEF, R._lastArgIfGroup(arguments));
    },

    ca: function ca(x, y, rx1, rx2, start, end, ry1, ry2) {
      var o = this,

      // The angles are normalized to be in the range of - twoPI to +twoPI.
      delta = end % twoPI - start % twoPI,
          deltaOrig = end - start,

      // radian value of 0.01 degree
      shiftAngle = 0.0001745329,
          cosStart,
          sinStart,
          cosEnd,
          sinEnd,
          longshort,
          path,
          x1,
          x2,
          x3,
          x4,
          y1,
          y2,
          y3,
          y4;

      isNaN(ry1) && (ry1 = rx1);
      isNaN(ry2) && (ry2 = rx2);

      // Save the angle in private for use.
      o._.ringangle = (start + end) * 0.5;

      // For deltaOrig very close to zero, thin line drawing is required.
      if (mathAbs(deltaOrig) < EPSILON) {
        cosStart = mathCos(start);
        sinStart = mathSin(start);

        path = [M, x + rx1 * cosStart, y + ry1 * sinStart, L, x + rx2 * cosStart, y + ry2 * sinStart, Z];
      } else if (mathAbs(deltaOrig) > EPSILON && +(mathAbs(deltaOrig) % twoPI < EPSILON || twoPI - mathAbs(deltaOrig) % twoPI < EPSILON)) {
        // If delta is very close to multiples of PI, requiring full
        // circle drawing.
        // When angle is twoPI split arcs are drawn to combat the full arc
        // drawing issue.
        path = [M, x - rx1, y, A, rx1, ry1, 0, 0, 0, x + rx1, y, A, rx1, ry1, 0, 0, 0, x - rx1, y];
        // draw inner arc only if specified. this helps draw only a circle
        // when inner radius is zero.
        if (rx2 !== 0 || ry2 !== 0) {
          path = path.concat([M, x - rx2, y, A, rx2, ry2, 0, 0, 1, x + rx2, y, A, rx2, ry2, 0, 0, 1, x - rx2, y]);
        }
        path.push(Z);
      } else {
        cosStart = mathCos(start);
        sinStart = mathSin(start);
        cosEnd = mathCos(end);
        sinEnd = mathSin(end);

        delta = delta % twoPI;

        // Negative resolved value of delta indicate it to be between - twoPI
        // and zero. The value is further normalised to be in the range of zero
        // to twoPI.
        if (delta < 0) {
          delta += twoPI;
        }

        longshort = delta < mathPI ? 0 : 1;

        x1 = x + rx1 * cosStart;
        y1 = y + ry1 * sinStart;
        x2 = x + rx1 * cosEnd;
        y2 = y + ry1 * sinEnd;
        x3 = x + rx2 * cosEnd;
        y3 = y + ry2 * sinEnd;

        if (mathAbs(x1 - x2) < minRenderingDistance && mathAbs(y1 - y2) < minRenderingDistance) {
          /*
            * Since the distance between the point(x1, y1) and point(x2, y2) is too small, i.e.,
            * less than minimum rendering distance
            * The gap between them is slightly increased by increasing the start angle by 0.01 degree
            * thus re-calculating x1, y1.
            */
          x1 = x + rx1 * mathCos(start + shiftAngle);
          y1 = y + ry1 * mathSin(start + shiftAngle);
        }

        path = [M, x1, y1, A, rx1, ry1, 0, longshort, 1, x2, y2, L, x3, y3];
        // Draw inner arc only when inner radius is not zero. This is needed
        // to avoid zero arc related issue on Raphael's VML.
        if (rx2 !== 0 || ry2 !== 0) {
          x4 = x + rx2 * cosStart;
          y4 = y + ry2 * sinStart;
          if (mathAbs(x3 - x4) < minRenderingDistance && mathAbs(y3 - y4) < minRenderingDistance) {
            /*
              * Since the distance between the point(x3, y3) and point(x4, y4) is too small, i.e.,
              * less than minimum rendering distance
              * The gap between them is slightly increased by increasing the start angle by 0.01 degree
              * thus re-calculating x4, y4.
              */
            x4 = x + rx2 * mathCos(start + shiftAngle);
            y4 = y + ry2 * mathSin(start + shiftAngle);
          }
          path.push(A, rx2, ry2, 0, longshort, 0, x4, y4);
        }
        path.push(Z);
      }

      return {
        path: path
      };
    }
  }, {
    name: 'cubepath',
    // args: [x, y, w, h, zw, zh]
    cubepath: function cubepath() {
      var paper = this,
          shapeDefaultAttrs = {
        'stroke-linejoin': 'round',
        'shape-rendering': 'precision',
        'stroke': NONE
      },
          args = arguments,
          lastArg = args.length - 1,
          group = args[lastArg],
          top,
          side,
          a,
          face,
          generateCubepath = function generateCubepath(x, y, w, h, zw, zh) {
        var o = this,
            t = o._.cubetop,
            s = o._.cubeside;

        if (x === UNDEF && y === UNDEF && w === UNDEF && h === UNDEF && zw === UNDEF && zh === UNDEF) {
          return this;
        }

        x = x || o.attrs.x || 0;
        y = y || o.attrs.y || 0;
        w = w || o.attrs.width || 0;
        h = h || o.attrs.height || 0;
        zw = zw || o.attrs.xDepth || 0;
        zh = zh || o.attrs.yDepth || 0;

        o.attrs.x = x;
        o.attrs.y = y;
        o.attrs.width = w;
        o.attrs.height = h;
        o.attrs.xDepth = zw;
        o.attrs.yDepth = zh;

        /* The issue of pixel wide gap found between adjacent faces when input params
         * are not all intezers, is solved by adding extra portion in top and side faces.
         * The side face is extended to the left with a pixel wide rectange, whole top
         * end is cut diagonally to avoid overlapping stoke effect. Like wise, the top face
         * is extended below with a pixel height rectangle whose left end is cut diagonally for
         * the same rason as above. Motive was to keep the bounding box intact as intended.
         */
        o._attr(PATH, ['M', x + w, y, 'l', 0, h, -w, 0, 0, -h, 'z']);
        t.attr(PATH, ['M', x, y, 'l', 1, 1, w - 1, 0, 0, -1, zw, -zh, -w, 0, 'z']);
        s.attr(PATH, ['M', x + w - 1, y + 1, 'l', 0, h - 1, 1, 0, zw, -zh, 0, -h, -zw, zh]);

        return this;
      },
          dropShadow = function dropShadow(dx, dy, spread, color) {
        var o = this,
            top = o._.cubetop,
            side = o._.cubeside;

        // Only allow filter based shadow.
        if (o.dropshadow) {
          top.dropshadow(dx, -dy, spread, color);
          side.dropshadow(dx, -dy, spread, color);
        }

        return false;
      };

      group && group.constructor === R.el.constructor ? args[lastArg] = UNDEF : group = UNDEF;

      top = paper.path(shapeDefaultAttrs, group);
      side = paper.path(shapeDefaultAttrs, group);
      face = paper.path(shapeDefaultAttrs, group);

      face._.cubetop = top.follow(face, UNDEF, 'before');
      face._.cubeside = side.follow(face, UNDEF, 'before');

      for (a in R.fn.cubepath.ca) {
        face.ca[a] = R.fn.cubepath.ca[a];
      }

      face._attr = face.attr;

      face.attr = function (name, value) {
        var isObject = (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object';

        if (isObject) {
          value = [];
          value.push(name.x);
          value.push(name.y);
          value.push(name.width);
          value.push(name.height);
          value.push(name.xDepth);
          value.push(name.yDepth);
          if (name.noGradient !== UNDEF) {
            face.attrs.noGradient = name.noGradient;
          }
        }

        if (name === UNDEF && value === UNDEF) {
          return this.attrs;
        } else if (value === UNDEF) {
          return this.attrs[name];
        }

        if (isObject) {
          generateCubepath.apply(this, value);
        } else if (name === 'drop-shadow') {
          dropShadow.apply(this, [].concat(value));
        }
        face._attr(name);

        return this;
      };

      // return face.attr(CUBEPATH, [args[0], args[1], args[2], args[3], args[4], args[5]]);
      return generateCubepath.apply(face, [args[0], args[1], args[2], args[3], args[4], args[5]]);
    },
    fn: {
      // Return the bounding box of the back face of the 3D shape.
      // This is an internal function, which is not implemented to the complete level, as such
      // there is no proper definition the function is supposed to do, hence it is prefixed with
      // an '_' and named as _getBBox2
      _getBBox2: function _getBBox2() {
        var shape = this,
            sideBox = shape._.cubeside.getBBox(),
            topBox = shape._.cubetop.getBBox(),
            bbox = shape.getBBox();

        // Calculate the backface bbox like object consisting of x,y width, height
        // using the sideBox,topBox,bBox
        return {
          x: bbox.x + topBox.height,
          y: bbox.y - sideBox.width,
          width: bbox.width,
          height: bbox.height
        };
      }
    },
    ca: {
      'stroke-linejoin': function strokeLinejoin() {
        // We force the linejoin to always be round. Otherwise, the cube
        // edges will look horrible.
        return {
          'stroke-linejoin': 'round'
        };
      },

      'fill': function fill(color, nogradient) {
        var o = this,
            top = o._.cubetop,
            side = o._.cubeside,
            attr = o._attr(CUBEPATH) || [0, 0, 0, 0, 0, 0],
            width = attr[2],
            zw = attr[4],
            zh = attr[5],
            rgba;

        if (nogradient === UNDEF) {
          nogradient = o._attr('noGradient');
        }
        color = R.color(color);

        if (nogradient) {
          o._attr(FILL, color);
          top.attr(FILL, R.tintshade(color, -0.78).rgba);
          side.attr(FILL, R.tintshade(color, -0.65).rgba);
        } else {
          // Since the color has been already calculated in object form,
          // we manually recalculate the rgba here since re-sending object
          // to Raphael's tintshade can cause it to return stale result
          // from its cache.
          rgba = 'opacity' in color ? 'rgba(' + [color.r, color.g, color.b, color.opacity] + ')' : 'rgb(' + [color.r, color.g, color.b] + ')';

          o._attr(FILL, [270, R.tintshade(rgba, 0.55).rgba, R.tintshade(rgba, -0.65).rgba].join('-'));
          side.attr(FILL, [270, R.tintshade(rgba, -0.75).rgba, R.tintshade(rgba, -0.35).rgba].join('-'));
          top.attr(FILL, [45 + R.deg(mathAtan2(zh, zw + width)), R.tintshade(rgba, -0.78).rgba, R.tintshade(rgba, 0.22).rgba].join('-'));
          /**
           * @note
          // This is the gradient calculation mapping that accounts for
          // the skew of the top face.
          o.attr(FILL, [285, R.tintshade(rgba, .55).rgba,
              R.tintshade(rgba, -.65).rgba].join('-'));
          side.attr(FILL, [50 + R.deg(mathAtan2(height + zh, zw)),
              R.tintshade(rgba, -.45).rgba,
              R.tintshade(rgba, -.75).rgba].join('-'));
          top.attr(FILL, [R.deg(mathAtan2(zh, zw + width)),
              R.tintshade(rgba, -.85).rgba,
              R.tintshade(rgba, .35).rgba].join('-'));
          */
        }

        // We return false so that the attribute is not applied to the
        // composite shape's leading element (the front face.)
        return false;
      }
    }
  }, {
    name: ARCPATH,
    // args: x, y, r1, r2, start, end, group
    arcpath: function arcpath() {
      return this.path(UNDEF, R._lastArgIfGroup(arguments));
    },

    ca: function ca(x, y, r1, r2) {
      var d = r2,
          // val
      path,
          dr = d - 90,
          radians = Math.PI * (dr / 180),
          endx = x + r1 * Math.cos(radians),
          endy = y + r1 * Math.sin(radians),
          largeArc = d > 180 ? 1 : 0;

      path = [M, x, y - r1, A, r1, r1, 0, largeArc, 1, endx, endy];

      return {
        path: path
      };
    }
  }, {
    name: 'scroller',
    /*
     * Generate a composite collection of object to provide scrollbar
     * functionality on SVG.
     *
     * ~param {number} x
     * ~param {number} y
     * ~param {number} w
     * ~param {number} h
     * ~param {boolean} horiz
     * ~param {object} options
     * - showButtons:boolean
     * - displayStyleFlat:boolean
     * - scrollRatio:number
     * - scrollPosition:number
     * ~param {RaphaelElement} parent
     */
    scroller: function scroller(x, y, w, h, horiz, options, parent) {
      var paper = this,
          o = paper.group('scroller', parent),
          attrs = o.attrs,
          scroller = o._.scroller = {},
          orientation = horiz && HORIZONTAL || VERTICAL,
          _trackAnim,
          _anchorAnimAttr = {},
          _dragstart,
          _dragaxis,
          a;

      // Create the scroller track and setup click behavior on track region.
      scroller.track = paper.rect(o).mousedown(function (evt) {
        var orientation = attrs[SCROLL_ORIENTATION],
            pos = attrs[SCROLL_POSITION],
            dx;

        dx = orientation === HORIZONTAL ? evt.layerX || evt.x : evt.layerY || evt.y;
        dx = (dx - scroller.anchorOffset) / scroller.trackLength;

        _trackAnim = R.animation({
          'scroll-position': dx
        }, 2000 * mathAbs(pos - dx), 'easeIn');
        o.animate(_trackAnim);

        eve(EVE_SCROLLSTART + o.id, o, pos);
      }).mouseup(scroller._mouseupTrack = function () {
        this.stop(_trackAnim);
        eve(EVE_SCROLLEND + this.id, this, attrs[SCROLL_POSITION]);
      }, o, true);

      // Create the track and anchor elements as the will always be needed!
      // Setup drag behavior of the anchor.
      scroller.anchor = paper.rect(o).drag(function (event) {
        _anchorAnimAttr[SCROLL_POSITION] = _dragstart + event.data[_dragaxis] / scroller.trackLength;
        // o.animate(_anchorAnimAttr, 0);
        o.attr(_anchorAnimAttr);
      }, function (event) {
        _dragaxis = attrs[SCROLL_ORIENTATION] === HORIZONTAL ? 0 : 1;
        eve(EVE_SCROLLSTART + o.id, o, _dragstart = attrs[SCROLL_POSITION]);
        event.stopPropagation();
      }, function () {
        eve(EVE_SCROLLEND + o.id, o, _dragstart = attrs[SCROLL_POSITION]);
      });

      // Add the custom functions.
      for (a in R.fn.scroller.fn) {
        o[a] = R.fn.scroller.fn[a];
      }
      // Add the custom attributes.
      for (a in R.fn.scroller.ca) {
        o.ca[a] = R.fn.scroller.ca[a];
      }

      // Set initial attributes to cover dependency of scroll-orientation.
      attrs[SCROLL_ORIENTATION] = orientation;
      attrs['stroke-width'] = 1;
      o.ca[SCROLL_REPAINT] = o.ca['scroll-repaint-' + orientation];

      !R.is(options, OBJECT) && (options = {});
      return o.attr({
        ishot: true,
        'scroll-display-buttons': options.showButtons && 'arrow' || NONE,
        'scroll-display-style': options.displayStyleFlat && FLAT || '3d',
        'scroll-ratio': toFloat(options.scrollRatio) || 1,
        'scroll-position': toFloat(options.scrollPosition) || 0,
        'scroll-repaint': [x, y, w, h]
      });
    },

    fn: {
      scroll: function scroll(callback, scope) {
        var o = this,
            scroller = o._.scroller;
        scope = scope || o;
        scroller.callback = function () {
          return callback.apply(scope, arguments);
        };
        return o;
      },

      remove: function remove() {
        var o = this,
            scroller = o._.scroller,
            key;

        o.attr('scroll-display-buttons', NONE);
        scroller.track.unmouseup(scroller._mouseupTrack);
        for (key in scroller) {
          scroller[key] && scroller[key].remove && scroller[key].remove();
          scroller[key] = null;
        }

        delete o._.scroller;
        R.el.remove.apply(o, arguments);
      }
    },

    ca: {
      'stroke-width': function strokeWidth() {
        return false;
      },

      'drop-shadow': function dropShadow(ox, oy, spread, color, s, g) {
        this._.scroller.track.attr('drop-shadow', [ox, oy, spread, color, s, g]);
        return false;
      },

      'scroll-display-style': function scrollDisplayStyle(value) {
        var o = this,
            attrs = o.attrs,
            currentStyle = attrs[SCROLL_DISPLAY_STYLE],
            fill = attrs.fill;

        value = {
          flat: FLAT,
          '3d': '3d',
          transparent: TRANSPARENT
        }[value] || currentStyle;

        // In case of change in value, and if already filled, re-fill.
        if (fill && value !== currentStyle) {
          attrs[SCROLL_DISPLAY_STYLE] = value;
          o.attr(FILL, fill);
        }

        return {
          'scroll-display-style': value
        };
      },

      'scroll-display-buttons': function scrollDisplayButtons(value) {
        var o = this,
            paper = o.paper,
            scroller = o._.scroller,
            attrs = o.attrs,
            currentDisplayButtons = attrs[SCROLL_DISPLAY_BUTTONS],
            repaint = attrs[SCROLL_REPAINT],
            _anim0,
            _anim1;

        // For first-run, attrs will have UNDEF. Hence, set it to none. This will ensure that the toggling
        // logic will work from the start.
        currentDisplayButtons === UNDEF && (currentDisplayButtons = NONE);

        // Validate the input.
        value = {
          none: NONE,
          arrow: 'arrow'
        }[value] || currentDisplayButtons;

        // This is a simple job! If button is needed, draw the elements and
        // if not then remove them. We first check change in this attr's
        // value. That saves us needless check whether the elements to be
        // removed exists or not.
        if (value !== currentDisplayButtons) {
          attrs[SCROLL_DISPLAY_BUTTONS] = value; // set for repaint
          if (value === NONE && scroller.start) {
            scroller.arrowstart.remove();
            delete scroller.arrowstart;

            scroller.arrowend.remove();
            delete scroller.arrowend;

            scroller.start.unmouseup(scroller._mouseupStart);
            scroller.start.remove();
            delete scroller.start;

            scroller.end.unmouseup(scroller._mouseupEnd);
            scroller.end.remove();
            delete scroller.end;
          } else {
            /** @todo make scroll button anim duration based on width
               or height */
            scroller.arrowstart = paper.polypath(o);
            scroller.arrowend = paper.polypath(o);

            // For scroller animation on button click, we run two sets.
            // The first animation ensures that the anchor moves 20% for
            // interaction for botton-less touchpads.
            // and then the second set of animation becomes cancelable
            // by mouse up.
            scroller.start = paper.rect(o).mousedown(function () {
              var pos;
              if ((pos = attrs[SCROLL_POSITION]) === 0) {
                return;
              }

              o.animate({
                'scroll-position': pos - 0.1
              }, 100).animate(_anim0 = R.animation({
                'scroll-position': 0
              }, 4500 * pos, 'easeIn'));
              eve(EVE_SCROLLSTART + o.id, o, pos);
            }).mouseup(scroller._mouseupStart = function () {
              o.stop(_anim0);
              eve(EVE_SCROLLEND + o.id, o, attrs[SCROLL_POSITION]);
            }, o, true);
            scroller.end = paper.rect(o).mousedown(function () {
              var pos;
              if ((pos = attrs[SCROLL_POSITION]) === 1) {
                return;
              }

              o.animate({
                'scroll-position': pos + 0.1
              }, 100).animate(_anim1 = R.animation({
                'scroll-position': 1
              }, 4500 * (1 - pos), 'easeIn'));
              eve(EVE_SCROLLSTART + o.id, o, pos);
            }).mouseup(scroller._mouseupEnd = function () {
              o.stop(_anim1);
              eve(EVE_SCROLLEND + o.id, o, attrs[SCROLL_POSITION]);
            }, o, true);
            // if the scroller has been filled before, we need to
            // re-fill it! Else the new elements will look odd
            if (attrs.fill) {
              o.attr(FILL, attrs.fill);
            }
          }

          // Repaint on change of buttons
          if (repaint) {
            o.attr(SCROLL_REPAINT, repaint);
          }
        }

        return {
          'scroll-display-buttons': value
        };
      },

      'scroll-orientation': function scrollOrientation(value) {
        var o = this,
            attrs = o.attrs,
            repaint = attrs[SCROLL_REPAINT],
            currentOrientation = attrs[SCROLL_ORIENTATION];

        value = {
          horizontal: HORIZONTAL,
          vertical: VERTICAL
        }[value] || currentOrientation;

        // Register change in orientation and redraw.
        if (currentOrientation !== value) {
          o.ca[SCROLL_REPAINT] = o.ca['scroll-repaint-' + value];
          if (repaint) {
            repaint[2] = repaint[2] + repaint[3];
            repaint[3] = repaint[2] - repaint[3];
            repaint[2] = repaint[2] - repaint[3];
            o.attr(SCROLL_REPAINT, repaint);
          }
          // if the scroller has been filled before, we need to
          // re-fill it! Else the new elements will look odd
          if (attrs.fill) {
            o.attr(FILL, attrs.fill);
          }
        }

        return {
          'scroll-orientation': value
        };
      },

      'scroll-ratio': function scrollRatio(value) {
        var o = this,
            attrs = o.attrs,
            currentRatio = attrs[SCROLL_RATIO],
            repaint = attrs[SCROLL_REPAINT];

        // We validate the scroll-position value. Restricting it strictly
        // between 0 and 1. But not exactly 0 as that would mean zero
        // dimension anchor!
        /** @todo replace the static 0.01 min ratio with a dynamic one. */
        value = value > 1 ? 1 : value < 0.01 ? 0.01 : toFloat(value);

        // On change of ratio on a painted scroller, we need to resize
        // and reposition the anchor. Thankfully, the calculation of the
        // new anchor dimension is fairly simple when we take the scroller's
        // total dimension as reference.
        if (repaint && value !== currentRatio) {
          attrs[SCROLL_RATIO] = value;
          // Note that the anchor is padded by half a pixel, as such,
          // the calculation is done accordingly.
          /** @todo
           * store butt
           */
          // anchor.attr(wOrh, value * (anchorWidth + 1) / currentRatio - 1);
          // since position percentage remains same, we need to set the
          // 'force' flag of positioning to true.
          o.attr(SCROLL_REPAINT, repaint);
        }

        return {
          'scroll-ratio': value
        };
      },

      'scroll-position': function scrollPosition(value, _force) {
        var o = this,
            attrs = o.attrs,
            horiz = attrs[SCROLL_ORIENTATION] === HORIZONTAL,
            repaint = attrs[SCROLL_REPAINT],
            currentPosition = attrs[SCROLL_POSITION],
            scroller = o._.scroller,
            anchor = scroller.anchor,
            button;

        // Positionhas to be validated between 0 and 1, else anchor will
        // spill out of area!
        value = value > 1 ? 1 : value < 0 ? 0 : toFloat(value);
        isNaN(value) && (value = currentPosition);

        // On change of value, we recalculate the anchor dimension (width or
        // height based on directionality) from the painted originals.
        // Buttons' presence has to be accounted for.
        // We can avoid complicated ratio calculation by retrieving the
        // already calculated result from the anchor dimension.
        if (repaint && (currentPosition !== value || _force)) {
          button = scroller.start && scroller.start.attr(horiz && WIDTH || HEIGHT) || 0;
          horiz && anchor.attr('x', repaint[0] + button + (repaint[2] - 2 * button - anchor.attr(WIDTH)) * value + 0.5) || anchor.attr('y', repaint[1] + button + (repaint[3] - 2 * button - anchor.attr(HEIGHT)) * value + 0.5);

          // Raise event and execute callback on position change.
          if (!_force && attrs[SCROLL_RATIO] < 1) {
            eve(EVE_SCROLLCHANGE + o.id, o, value);
            scroller.callback && scroller.callback(value);
          }
        }

        return {
          'scroll-position': value
        };
      },

      r: function r(value) {
        var o = this,
            scroller = o._.scroller;

        scroller.track.attr('r', value);
        scroller.anchor.attr('r', o.attrs[SCROLL_DISPLAY_BUTTONS] === NONE && value || 0);

        return false;
      },

      'scroll-repaint-horizontal': function scrollRepaintHorizontal(x, y, w, h) {
        var o = this,
            attrs = o.attrs,
            scroller = o._.scroller,
            ratio = attrs[SCROLL_RATIO],
            position = attrs[SCROLL_POSITION],
            button = 0,
            track = w * ratio,
            nobutton = attrs[SCROLL_DISPLAY_BUTTONS] === NONE;

        w && (w -= 1);
        x && (x += 0.5);
        h && (h -= 1);
        y && (y += 0.5);

        // The track forms the base of the scroller and as such, occupies
        // entire space.
        scroller.track.attr({
          width: w,
          height: h,
          y: y,
          x: x
        }).crisp();

        // Draw buttons if needed and also perform calculations that the
        // presence of button will affect anchor.
        if (!nobutton) {
          button = mathMin(h, w * 0.5);
          track -= button * 2 * ratio;

          scroller.start.attr({
            width: button,
            height: h,
            x: x,
            y: y
          });
          scroller.arrowstart.attr(POLYPATH, [3, x + button * 0.5, y + h * 0.5, button * 0.25, 180]);
          scroller.end.attr({
            width: button,
            height: h,
            x: x + w - button,
            y: y
          });
          scroller.arrowend.attr(POLYPATH, [3, x + w - button * 0.5, y + button * 0.5, button * 0.25, 0]);
        }

        // The anchor position is calculated in full (ratio included).
        // This saves needless function/attr call.
        scroller.trackLength = w - 2 * button - track;
        scroller.trackOffset = x + button + 0.5;
        scroller.anchorOffset = scroller.trackOffset + (track - 1) * 0.5;
        scroller.anchor.attr({
          height: h,
          width: track - 1,
          y: y,
          x: scroller.trackOffset + scroller.trackLength * position
        }).crisp();
      },

      'scroll-repaint-vertical': function scrollRepaintVertical(x, y, w, h) {
        var o = this,
            attrs = o.attrs,
            scroller = o._.scroller,
            ratio = attrs[SCROLL_RATIO],
            position = attrs[SCROLL_POSITION],
            button = 0,
            track = h * ratio,
            nobutton = attrs[SCROLL_DISPLAY_BUTTONS] === NONE;

        w && (w -= 1);
        x && (x += 0.5);
        h && (h -= 1);
        y && (y += 0.5);

        // The track forms the base of the scroller and as such, occupies
        // entire space.
        scroller.track.attr({
          width: w,
          height: h,
          y: y,
          x: x
        }).crisp();

        // Draw buttons if needed and also perform calculations that the
        // presence of button will affect anchor.
        if (!nobutton) {
          button = mathMin(w, h * 0.5);
          track -= button * 2 * ratio;
          scroller.start.attr({
            width: w,
            height: button,
            x: x,
            y: y
          });
          scroller.arrowstart.attr(POLYPATH, [3, x + w * 0.5, y + button * 0.5, button * 0.25, 90]);
          scroller.end.attr({
            width: w,
            height: button,
            x: x,
            y: y + h - button
          });
          scroller.arrowend.attr(POLYPATH, [3, x + w * 0.5, y + h - button * 0.5, button * 0.25, -90]);
        }

        // The anchor position is calculated in full (ratio included).
        // This saves needless function/attr call.
        scroller.trackLength = h - 2 * button - track;
        scroller.trackOffset = y + button + 0.5;
        scroller.anchorOffset = scroller.trackOffset + (track - 1) * 0.5;
        scroller.anchor.attr({
          height: track - 1 < 0 ? 0 : track - 1,
          width: w,
          y: scroller.trackOffset + scroller.trackLength * position,
          x: x
        }).crisp();
      },

      fill: function fill(color) {
        var o = this,
            attrs = o.attrs,
            scroller = o._.scroller,
            repaint = attrs[SCROLL_REPAINT],
            flat = attrs[SCROLL_DISPLAY_STYLE] === FLAT,
            horiz = attrs[SCROLL_ORIENTATION] === HORIZONTAL,
            setter = { // will use single obj as setter (save mem)
          stroke: NONE
        },
            strokeCompensation;

        // For touch devices, we increase accessibility by adding an
        // increased area of transparent stroke
        if (hasTouch && repaint && (strokeCompensation = 16 - repaint[horiz && 3 || 2]) > 3) {
          setter.stroke = TRACKER_FILL;
          setter['stroke-width'] = strokeCompensation;
        }

        // Parse color. Pass it via tintshade to get standard rgba text
        color = R.color(color);
        color.error && (color = R.color('#000000'));
        color = 'opacity' in color ? 'rgba(' + [color.r, color.g, color.b, color.opacity] + ')' : 'rgb(' + [color.r, color.g, color.b] + ')';

        // Individually calculate the fill gradients of various elements
        // using tint/shade of the base color and set it on the scroller
        // elements.
        // Note that we multiply gradient angle with boolean. Neat trick to
        // set them zero when boolean is false.
        setter.fill = flat && color || [90 * horiz, R.tintshade(color, 0.15).rgba, color].join('-');
        setter.stroke = R.tintshade(color, -0.75).rgba;
        scroller.track.attr(setter);

        setter.fill = flat && R.tintshade(color, -0.6).rgba || [270 * horiz, R.tintshade(color, 0.3).rgba + ':40', R.tintshade(color, -0.7).rgba].join('-');
        setter.stroke = R.tintshade(color, -0.6).rgba;
        scroller.anchor.attr(setter);
        // reset stroke
        setter.stroke = NONE;

        // Now, if buttons are available, we fill the tracker and the
        // arrows.
        if (attrs[SCROLL_DISPLAY_BUTTONS] !== NONE) {
          setter.fill = TRACKER_FILL;
          scroller.start.attr(setter);
          scroller.end.attr(setter);

          setter.fill = R.tintshade(color, -0.4).rgba;
          scroller.arrowstart.attr(setter);
          scroller.arrowend.attr(setter);
        }

        // return false to prevent default.
        return false;
      }
    }
  }, {
    name: 'button',

    /*
     * Renders a Raphael composite button element.
     *
     * ~param {number} x
     * ~param {number} y
     * ~param {string} labelText
     * ~param {string} symbolName
     * ~param {object} options
     * Supports the following option attributes during construction
     * - symbolPadding
     * - horizontalPadding
     * - verticalPadding
     * - width
     * - height
     * - r
     * - symbolPosition,
     * - symbolPadding
     * - disabled
     * ~param {RaphaelElement} parent
     */
    button: function button(x, y, labelText, symbolName, options, parent) {
      var paper = this,
          o = paper.group('button', parent),
          a;

      o._.button = {
        bound: paper.rect(o),
        tracker: paper.rect(o).attr({
          fill: TRACKER_FILL,
          stroke: TRACKER_FILL,
          cursor: 'pointer'
        }).data('compositeButton', o)
      };

      !R.is(options, OBJECT) && (options = {});

      // We are adding the fn/ca before .define does so that the attributes of repaint are available.
      for (a in R.fn.button.fn) {
        o[a] = R.fn.button.fn[a];
      }
      for (a in R.fn.button.ca) {
        o.ca[a] = R.fn.button.ca[a];
      }

      return o.attr({
        ishot: true,
        'button-padding': [options.horizontalPadding, options.verticalPadding],
        'button-label': labelText,
        'button-symbol': symbolName,
        'button-disabled': options.disabled || 'false',
        'button-symbol-position': options.symbolPosition,
        'button-symbol-padding': options.symbolPadding
      }).attr('button-repaint', [x, y, options.width, options.height, options.r]);
    },

    data: {
      hoverin: function hoverin() {
        var o = this,
            button = o._.button,
            callback = button.hoverbackIn,
            hover = o._hover || {};

        if (hover.fill || hover.stroke || hover['stroke-width'] || hover.cursor) {
          hover.fill && o.bottom.attr('fill', hover.fill) && button.symbol.attr('fill', hover.fill);
          hover.stroke && o.bottom.attr('stroke', hover.stroke) && button.symbol.attr('stroke', hover.stroke);
          hover['stroke-width'] && o.bottom.attr('stroke-width', hover['stroke-width']) && button.symbol.attr('stroke-width', hover['stroke-width']);
          hover.cursor && button.tracker.attr('cursor', hover.cursor);
          callback && callback();
        } else {
          callback && callback(arguments) === false || o.attr('fill', 'hover');
        }
        o.hovered = true;
      },
      hoverout: function hoverout() {
        var o = this,
            button = o._.button,
            callback = button.hoverbackOut,
            normal = o._normal || {};

        if (normal.fill || normal.stroke || normal['stroke-width'] || normal.cursor) {
          normal.fill && o.bottom.attr('fill', normal.fill) && button.symbol.attr('fill', normal.fill);
          normal.stroke && o.bottom.attr('stroke', normal.stroke) && button.symbol.attr('stroke', normal.stroke);
          normal['stroke-width'] && o.bottom.attr('stroke-width', normal['stroke-width']) && button.symbol.attr('stroke-width', normal['stroke-width']);
          normal.cursor && button.tracker.attr('cursor', normal.cursor);
          callback && callback();
        } else {
          callback && callback(arguments) === false || o.attr('fill', (o.pressed || o.active) && 'active' || 'normal');
        }
        o.hovered = false;
      },
      mousedown: function mousedown() {
        var o = this,
            button = o._.button,
            pressed = o._pressed || {};

        if (pressed.fill || pressed.stroke || pressed['stroke-width'] || pressed.cursor) {
          pressed.fill && o.bottom.attr('fill', pressed.fill) && button.symbol.attr('fill', pressed.fill);
          pressed.stroke && o.bottom.attr('stroke', pressed.stroke) && button.symbol.attr('stroke', pressed.stroke);
          pressed['stroke-width'] && o.bottom.attr('stroke-width', pressed['stroke-width']) && button.symbol.attr('stroke-width', pressed['stroke-width']);
          pressed.cursor && button.tracker.attr('cursor', pressed.cursor);
        } else {
          o.attr('fill', 'active');
        }
        o.pressed = true;
      },
      mouseup: function mouseup() {
        var o = this,
            button = o._.button,
            callback = button.callback,
            normal = o._normal || {};

        if (normal.fill || normal.stroke || normal['stroke-width'] || normal.cursor) {
          normal.fill && o.bottom.attr('fill', normal.fill) && button.symbol.attr('fill', normal.fill);
          normal.stroke && o.bottom.attr('stroke', normal.stroke) && button.symbol.attr('stroke', normal.stroke);
          normal['stroke-width'] && o.bottom.attr('stroke-width', normal['stroke-width']) && button.symbol.attr('stroke-width', normal['stroke-width']);
          normal.cursor && button.tracker.attr('cursor', normal.cursor);
        } else {
          o.attr('fill', o.hovered && 'hover' || o.active && 'active' || 'normal');
        }
        o.pressed = false;
        callback && callback(arguments);
      },
      mousemove: function mousemove() {
        var o = this,
            button = o._.button,
            callback = button.mousemove;

        callback && callback(arguments);
      }
    },

    fn: {
      tooltip: function tooltip() {
        R.el.tooltip && R.el.tooltip.apply(this._.button.tracker, arguments);
        return this;
      },

      buttonclick: function buttonclick(callback, scope) {
        var o = this,
            button = o._.button;
        scope = scope || o;
        button.callback = function () {
          return callback.apply(scope, arguments);
        };
        return o;
      },

      labelcss: function labelcss() {
        var button = this._.button,
            label = button.label;

        button.cssArg = arguments;
        label && label.css.apply(label, arguments);

        return this.attr('button-repaint', this.attrs['button-repaint']);
      },

      buttonhover: function buttonhover(callbackIn, callbackOut, scopeIn, scopeOut, callbackMove, scopeMove) {
        var o = this,
            button = o._.button;

        scopeIn = scopeIn || o;
        scopeOut = scopeOut || o;
        scopeMove = scopeMove || o;
        callbackMove && (button.mousemove = function () {
          return callbackMove.apply(scopeMove, arguments);
        });
        button.hoverbackIn = function () {
          return callbackIn.apply(scopeIn, arguments);
        };
        button.hoverbackOut = function () {
          return callbackOut.apply(scopeOut, arguments);
        };
        return o;
      },

      remove: function remove() {
        var o = this,
            button = o._.button,
            key;

        o.attr('button-disabled', 'true');

        for (key in button) {
          button[key] && button[key].remove && button[key].remove();
          button[key] = null;
        }

        delete o._.button;
        R.el.remove.apply(o, arguments);
      }
    },

    ca: {
      'button-active': function buttonActive(value) {
        var o = this;
        o.attr('fill', (o.active = !!value) ? 'active' : o.hovered && 'hover' || 'normal');
      },

      'button-disabled': function buttonDisabled(value) {
        var o = this,
            paper = o.paper,
            button = o._.button,
            tracker = button.tracker,
            attr = o.attrs['button-disabled'],
            events = paper.button.data,
            disabled = o._disabled || {};

        value = buttonDisabledAttrs[value];
        attr = buttonDisabledAttrs[attr];

        // Ensure that invalid values are ignored
        if (value === UNDEF || value === attr) {
          return;
        }

        switch (value) {
          case true:
            if (disabled.fill || disabled.stroke || disabled['stroke-width'] || disabled.cursor) {
              disabled.fill && o.bottom.attr('fill', disabled.fill) && button.symbol.attr('fill', disabled.fill);
              disabled.stroke && o.bottom.attr('stroke', disabled.stroke) && button.symbol.attr('stroke', disabled.stroke);
              disabled['stroke-width'] && o.bottom.attr('stroke-width', disabled['stroke-width'] && button.symbol.attr('fill', disabled.fill));
              disabled.cursor && button.tracker.attr('cursor', disabled.cursor);
            } else {
              tracker.attr('fill', 'rgba(204,204,205,.5)');
            }

            tracker.unmousedown(events.mousedown).unmouseup(events.mouseup).unhover(events.hoverin, events.hoverout).unmousemove(events.mousemove);
            break;
          case false:
            tracker.attr('fill', TRACKER_FILL).mousedown(events.mousedown, o).mouseup(events.mouseup, o, true).hover(events.hoverin, events.hoverout, o, o).mousemove(events.mousemove, o);
            break;
        }
      },

      'button-label': function buttonLabel(text) {
        var o = this,
            button = o._.button,
            attrs = o.attrs,
            label = button.label,
            cssArg = button.cssArg,
            repaint = o.attrs['button-repaint'];

        text = toStr(text || BLANK);

        if (text === NONE) {
          label && (button.label = label.remove());
        } else if (text) {
          !label && (label = button.label = o.paper.text(o).insertBefore(button.tracker));
          label.attr({
            text: text,
            'text-anchor': 'middle',
            'vertical-align': 'middle'
          });
          cssArg && cssArg.length && label.css.apply(label, cssArg);
        }

        if (repaint && attrs['button-label'] !== text) {
          o.attr('button-repaint', repaint);
        }
      },

      'button-symbol': function buttonSymbol(name) {
        var o = this,

        // attrs = o.attrs,
        button = o._.button,
            symbol = button.symbol,
            repaint = o.attrs['button-repaint'];

        name = toStr(name || BLANK);

        if (name === NONE) {
          symbol && (button.symbol = symbol.remove());
          delete button.symbol;
        } else if (name && !symbol) {
          symbol = button.symbol = o.paper.symbol(o).insertAfter(button.bound);
        }

        if (repaint /* && attrs['button-symbol'] !== name */) {
            o.attr('button-repaint', repaint);
          }
      },

      'button-symbol-position': function buttonSymbolPosition(position) {
        return {
          'button-symbol-position': {
            top: 'top',
            right: 'right',
            bottom: 'bottom',
            left: 'left',
            none: 'none'
          }[toStr(position).toLowerCase()] || NONE
        };
      },

      'button-symbol-padding': function buttonSymbolPadding(value) {
        return {
          'button-symbol-padding': toFloat(value)
        };
      },

      'button-padding': function buttonPadding(px, py) {
        return {
          'button-padding': [(px === null || px === UNDEF) && (px = 5) || toFloat(px), (py === null || py === UNDEF) && px || toFloat(py)]
        };
      },

      'button-repaint': function buttonRepaint(x, y, w, h, r) {
        var o = this,
            button = o._.button,
            bound = button.bound,
            label = button.label,
            symbol = button.symbol,
            attrs = o.attrs,
            attrPads = attrs['button-padding'],
            padX = attrPads[0],
            padY = attrPads[1],
            symX,
            symY,
            symD,
            symR,
            padSym,
            bbox,
            obj;

        // In case a specific coord is not provided, set them to zero.
        x === UNDEF && (x = 0);
        y === UNDEF && (y = 0);

        if (w === UNDEF || h === UNDEF) {
          bbox = label && label.getBBox() || { width: 0, height: 0 };
          w === UNDEF && (w = padX * 2 + bbox.width);
          h === UNDEF && (h = padY * 2 + bbox.height);
        }

        obj = R.crispBound(x, y, w, h, bound.attr('stroke-width'));
        obj.r = r = R.pick(r, mathRound(mathMin(h, w) * 0.1));
        x = obj.x;
        y = obj.y;
        w = obj.width;
        h = obj.height;

        label && label.attr({
          x: x + w / 2,
          y: y + h / 2
        });

        if (symbol) {
          // auto alculate symbol radius
          !R.is(padSym = attrs['button-symbol-padding'], 'finite') && (padSym = h * 0.2);
          symD = h - padY;
          symR = symD * 0.5;

          switch (attrs['button-symbol-position'] + (label && '+' || '-')) {
            case 'right+':
              w += symR * 2 + padY;
              symX = x + w - symR - padX;
              symY = y + h * 0.5;
              label.attr('transform', ['t', -(symD + padSym), 0]);
              break;

            case 'left+':
              w += symR * 2 + padY;
              symX = x + padX + symR;
              symY = y + h * 0.5;
              label.attr('transform', ['t', symD + padSym, 0]);
              break;

            case 'top+':
              h += symR * 2 + padSym;
              symX = x + w * 0.5;
              symY = y + attrPads[1] + symR;
              label.attr('transform', ['t', 0, symD + padSym]);
              break;

            case 'bottom+':
              h += symR * 2 + padSym;
              symX = x + w * 0.5;
              symY = y + h - padY - symR;
              label.attr('transform', ['t', 0, -(symD + padSym)]);
              break;

            default:
              // none
              symX = x + w * 0.5;
              symY = y + h * 0.5;
          }

          symbol.attr('symbol', [attrs['button-symbol'], symX, symY, symR]);
        }

        button.bound.attr(obj);
        button.tracker.attr(obj);
      },

      fill: function fill(color, labelFill, symbolFill, hover, disableGradient) {
        var o = this,
            button = o._.button,
            bound = button.bound,
            symbol = button.symbol,
            label = button.label,
            state = {
          normal: button.gradient,
          active: button.gradientActive,
          hover: button.gradientHover
        }[color];
        if (!state) {
          if (!disableGradient) {
            color = R.getRGB(color);
            color.error && (color = R.color('#cccccc'));
            color = 'opacity' in color ? 'rgba(' + [color.r, color.g, color.b, color.opacity] + ')' : 'rgb(' + [color.r, color.g, color.b] + ')';
          }

          button.gradient = disableGradient ? color : [90, R.tintshade(color, -0.8).rgba + ':0', R.tintshade(color, 0.8).rgba + ':100'].join('-');
          button.gradientActive = [270, R.tintshade(color, -0.8).rgba + ':0', R.tintshade(color, 0.8).rgba + ':100'].join('-');
          hover = R.getRGB(hover);
          hover.error && (hover = color) || (hover = 'opacity' in hover ? 'rgba(' + [hover.r, hover.g, hover.b, hover.opacity] + ')' : 'rgb(' + [hover.r, hover.g, hover.b] + ')');
          button.gradientHover = disableGradient ? hover : [90, R.tintshade(hover, -0.9).rgba + ':0', R.tintshade(hover, 0.7).rgba + ':100'].join('-');
          symbolFill = symbolFill || R.tintshade(color, 0.2).rgba;
          labelFill = labelFill || R.tintshade(color, -0.2).rgba;

          button.symbolFill = symbolFill;
          button.labelFill = labelFill;

          state = (o.pressed || o.active) && button.gradientActive || o.hovered && button.gradienthover || button.gradient;
        }

        bound.attr('fill', state);
        symbol && symbol.attr('fill', button.symbolFill);
        label && label.attr('fill', button.labelFill);
        return false;
      },

      stroke: function stroke(color, forSymbol) {
        var button = this._.button,
            symbol = button.symbol;

        color = R.color(color);
        color.error && (color = R.color('#999999'));

        button.bound.attr(STROKE, color);
        symbol && symbol.attr(STROKE, forSymbol || color);

        return false;
      },

      'stroke-width': function strokeWidth(value, forSymbol) {
        var button = this._.button,
            symbol = button.symbol;

        button.bound.attr('stroke-width', value);
        button.tracker.attr('stroke-width', value);
        symbol && symbol.attr('stroke-width', forSymbol);

        return false;
      },

      config: function config(obj) {
        var o = this;

        obj.hover && (o._hover = {
          fill: obj.hover.fill,
          stroke: obj.hover.stroke,
          'stroke-width': obj.hover['stroke-width'],
          cursor: obj.hover.cursor
        });

        obj.disabled && (o._disabled = {
          fill: obj.disabled.fill,
          stroke: obj.disabled.stroke,
          'stroke-width': obj.disabled['stroke-width'],
          cursor: obj.disabled.cursor
        });

        obj.pressed && (o._pressed = {
          fill: obj.pressed.fill,
          stroke: obj.pressed.stroke,
          'stroke-width': obj.pressed['stroke-width'],
          cursor: obj.pressed.cursor
        });

        obj.normal && (o._normal = {
          fill: obj.normal.fill,
          stroke: obj.normal.stroke,
          'stroke-width': obj.normal['stroke-width'],
          cursor: obj.normal.cursor
        });

        obj.symbol && (obj.symbol = {
          stroke: obj.normal.stroke,
          'stroke-width': obj.normal['stroke-width']
        });
      }
    }
  }, {
    // Name of the component goes here.
    name: 'trianglepath',

    // Constructor of the component goes here. Must be same name as the name of the component.
    trianglepath: function trianglepath() {
      // args: [x1, y1, x2, y2, x3, y3, r1, r2, r3]
      var paper = this,
          args = arguments,
          group = R._lastArgIfGroup(args),
          face = paper.path(group);

      return face.attr('trianglepath', [args[0], args[1], args[2], args[3], args[4], args[5], args[6] || 0, args[7] || 0, args[8] || 0]);
    },

    fn: {
      sides: function sides() {
        // Use p2pdistance library function to compute sides of a triangle.
        var points = this._args;
        return [p2pdistance(points[0], points[1], points[2], points[3]), // p1, p2
        p2pdistance(points[2], points[3], points[4], points[5]), // p2, p3
        p2pdistance(points[4], points[5], points[0], points[1]) // p3, p1
        ];
      },

      enclosedAngles: function enclosedAngles() {
        // Returns the three angles of a triangle formed by the given sides
        var edges = this._sides;
        return [mathAcos((mathPow(edges[0], 2) + mathPow(edges[2], 2) - mathPow(edges[1], 2)) / (2 * edges[0] * edges[2])), mathAcos((mathPow(edges[0], 2) + mathPow(edges[1], 2) - mathPow(edges[2], 2)) / (2 * edges[0] * edges[1])), mathAcos((mathPow(edges[2], 2) + mathPow(edges[1], 2) - mathPow(edges[0], 2)) / (2 * edges[2] * edges[1]))];
      },

      semiperimeter: function semiperimeter() {
        // Returns the semiperimeter of triangle
        var sides = this._sides || this.sides();
        return (sides[0] + sides[1] + sides[2]) / 2;
      }
    },

    ca: {
      trianglepath: function trianglepath(x1, y1, x2, y2, x3, y3, r1, r2, r3) {
        /* Create the triangle path with the provided vertices.
         * Make rounded triangle corners if radius is provided.
         * r1, r2, r3 are the radii of respective vertices.
         */
        if (r1 || r2 || r3) {
          // Store arguments in trianglepath element
          this._args = arguments;

          // Calculate length of all sides of the triangle
          this._sides = this.sides();

          // Get all the angles of the triangle
          var angles = this.enclosedAngles(),
              curveDistance,
              curvePoints,
              inradius,
              s = this.semiperimeter();

          // Calculate inradius of triangle
          inradius = mathSqrt(s * (s - this._sides[0]) * (s - this._sides[1]) * (s - this._sides[2])) / s;

          // Get distance of points of curves from corresponding vertices
          // Impose an upper limit on radius which is inradius of triangle
          curveDistance = [mathMin(r1, inradius) / mathTan(angles[0] / 2), mathMin(r2, inradius) / mathTan(angles[1] / 2), mathMin(r3, inradius) / mathTan(angles[2] / 2)];

          // Get coordinates of the points of curve on the triangle
          curvePoints = [pointAtLength(x1, y1, x3, y3, curveDistance[0]), pointAtLength(x1, y1, x2, y2, curveDistance[0]), pointAtLength(x2, y2, x1, y1, curveDistance[1]), pointAtLength(x2, y2, x3, y3, curveDistance[1]), pointAtLength(x3, y3, x2, y2, curveDistance[2]), pointAtLength(x3, y3, x1, y1, curveDistance[2])];

          // Draw the triangle path with rounded corners
          this.attr({
            path: [M, curvePoints[0].x, curvePoints[0].y, Q, x1, y1, curvePoints[1].x, curvePoints[1].y, L, curvePoints[2].x, curvePoints[2].y, Q, x2, y2, curvePoints[3].x, curvePoints[3].y, L, curvePoints[4].x, curvePoints[4].y, Q, x3, y3, curvePoints[5].x, curvePoints[5].y, L, curvePoints[0].x, curvePoints[0].y]
          });
        } else {
          this.attr({
            path: [M, x1, y1, L, x2, y2, x3, y3, Z]
          });
        }
      }
    }
  }]);
  // eslint-disable-next-line no-unused-vars
  R.ca[TEXTBOUND] = function (fill, stroke, strokeWidth, padding, cornerRadius, dasharray, opacity) {
    var o = this,
        paper = o.paper,
        bound = o._.textbound;

    if (this.type !== 'text') {
      return;
    }

    if ((!stroke || stroke === NONE) && (!fill || fill === NONE)) {
      o._.textbound = bound && bound.unfollow(o).remove();
      return false;
    }
    // Store the attributes value for future reference
    o.attrs[TEXTBOUND] = arguments;

    (!strokeWidth || !R.is(strokeWidth, 'finite')) && (strokeWidth = 0);
    (!cornerRadius || !R.is(cornerRadius, 'finite')) && (cornerRadius = 0);
    !bound && (bound = o._.textbound = paper.rect(0, 0, 0, 0, o.group).follow(o, R.ca[TEXTBOUND].reposition, 'before'));

    bound.attr({
      'stroke': stroke,
      'stroke-width': strokeWidth,
      'fill': fill,
      'shape-rendering': strokeWidth === 1 && CRISP || BLANK,
      r: cornerRadius
    });
    opacity !== UNDEF && bound.attr('opacity', opacity);
    dasharray && bound.attr('stroke-dasharray', dasharray);

    // Call the repositioning function
    R.ca[TEXTBOUND].reposition.call(bound, o.attr(), o);
    return false;
  };

  R.ca[TEXTBOUND].reposition = function (params, leader) {
    var o = this,
        updates = {},
        attr,
        padding,
        padX,
        padY,
        bbox,
        w,
        h;

    // check visibility first
    if (params[HAS]('visibility')) {
      o.attr('visibility', params.visibility);
    }

    // filter out the attributes that affects text-bound.
    if (!(params[HAS](TEXTBOUND) || params[HAS]('x') || params[HAS]('y') || params[HAS]('text') || params[HAS]('text-anchor') || params[HAS]('text-align') || params[HAS]('font-size') || params[HAS]('line-height') || params[HAS]('vertical-align') || params[HAS]('transform') || params[HAS]('rotation'))) {
      return;
    }

    attr = leader.attrs[TEXTBOUND];
    padding = toStr(attr && attr[3] || '0').split(commaseparator);
    padX = toFloat(padding[0]) || 0;
    padY = R.pick(toFloat(padding[1]), padX);
    bbox = leader.getBBox();
    w = bbox.width;
    h = bbox.height;

    // In case bounding box failed to return value, we do not need to change position.
    if (!isNaN(w)) {
      updates.x = bbox.x - padX;
      updates.y = bbox.y - padY;
      updates.width = w + padX * 2;
      updates.height = h + padY * 2;
    }

    o.attr(updates);
  };

  R.fn.symbol = function () {
    // name, x, y, (r || w , h)
    var paper = this,
        args = arguments,
        lastArg = args.length - 1,
        group = args[lastArg],
        o;

    group && group.constructor === R.el.constructor ? args[lastArg] = UNDEF : group = UNDEF;

    o = paper.path(UNDEF, group);
    o.ca.symbol = R.fn.symbol.ca.symbol;
    return args.length === !!group + 0 ? o : o.attr('symbol', args);
  };

  R.fn.getSuggestiveRotation = function () {
    var arg, angle, x, y;

    arg = arguments[0];
    if (arguments.length === 1) {
      angle = arg.angle;
      x = arg.x;
      y = arg.y;
    } else {
      angle = arg;
      x = arguments[1];
      y = arguments[2];
    }

    angle = angle || 0;

    return RStr + angle + COMMA + x + COMMA + y;
  };

  R.fn.symbol.cache = {
    '': R._cacher(function (x, y, r, h) {
      return arguments.length > 3 ? ['M', x, y, 'h', r, 'v', h, 'h', -r, 'v', -h, 'z'] : ['M', x - r, y - r, 'h', r *= 2, 'v', r, 'h', -r, 'v', -r, 'z'];
    })
  };
  R.fn.symbol.ca = {
    symbol: function symbol(name) {
      var o = this,
          args = R.is(name, OBJECT) && arguments.length === 1 && !R.is(name, 'function') ? name : arguments,
          symbolFn,
          symbolData;

      args === name && (name = args[0]);

      symbolFn = R.is(name, 'function') && name || R.fn.symbol.cache[name] || R.fn.symbol.cache[''];
      symbolData = symbolFn && symbolFn.apply(R, arraySlice.call(args, 1));

      R.is(symbolData, 'array') || R.is(symbolData, 'string') ? o.attr('path', symbolData) : symbolData && o.attr(symbolData);
    }
  };

  R.addSymbol = function (name, fn) {
    var items,
        cache = R.fn.symbol.cache,
        alias = [],
        i;

    items = R.is(fn, 'function') && (items = {}, items[name] = fn, items) || name;
    for (i in items) {
      fn = items[i];
      cache[i] = R.is(fn, 'function') && R._cacher(fn, R) || (alias.push(i), fn);
    }
    i = alias.pop();
    while (i) {
      cache[i] = cache[cache[i]];
      i = alias.pop();
    }
  };

  if (R.svg) {
    p2srep = '$1';

    litepathsetter = function litepathsetter(path) {
      var o = this;

      if (!path) {
        path = 'M0,0';
      } else if (typeof path === 'string') {
        path = path.replace(p2s, p2srep);
      } else {
        path.toString = path2string;
      }

      o.node.setAttribute('d', path.toString());
      // don't need to return anything as the attrbute is already applied. Nothing other need to be changes
    };
    // eslint-disable-next-line no-unused-vars
    R._engine.litepath = function (path, svg, zoom, group) {
      var el = createNode('path'),
          p;

      (group || svg).canvas.appendChild(el);

      p = new Element(el, svg, group);
      p.type = LITEPATH;
      p.id = el.raphaelid = R._oid++;
      el.raphael = true;

      setFillAndStroke(p, {
        fill: NONE,
        stroke: '#000'
      });

      return p;
    };

    R._getPath.litepath = function (el) {
      return R.parsePathString(el.node.getAttribute('d'));
    };
  } else if (R.vml) {
    // eslint-disable-next-line no-unused-vars
    p2srep = function p2srep(cmd, $1) {
      return s2vcmd[$1] || $1;
    };

    vmlTransformHelper = function vmlTransformHelper() {
      var o = this;
      o._transform.apply(o, arguments);
      o._.bcoord && (o.node.coordsize = o._.bcoord);
      return o;
    };

    litepathsetter = function litepathsetter(path) {
      var o = this;

      if (!path) {
        path = 'M0,0';
      } else if (typeof path === 'string') {
        path = path.replace(p2s, p2srep);
      } else {
        path.toString = path2string;
      }

      o.node.path = path;
      return o;
    };
    // eslint-disable-next-line no-unused-vars
    R._engine.litepath = function (pathString, vml, zoom, group) {
      var el = createNode('shape'),
          s = el.style,
          p = new Element(el, vml, group),
          attr = {
        fill: NONE,
        stroke: '#000'
      },
          skew;

      s.cssText = CSSFLOOD;
      zoom = toFloat(zoom);
      if (isNaN(zoom)) {
        el.coordsize = COORD21600;
      } else {
        p._.bzoom = zoom;
        s.width = '1px';
        s.height = '1px';
        el.coordsize = p._.bcoord = zoom + SPACE + zoom;
      }
      el.coordorigin = vml.coordorigin;

      p.type = LITEPATH;
      p.id = el.raphaelid = R._oid++;
      el.raphael = true;

      p._transform = p.transform;
      p.transform = vmlTransformHelper;

      R._setFillAndStroke(p, attr);
      (group || vml).canvas.appendChild(el);

      skew = createNode('skew');
      skew.on = true;
      el.appendChild(skew);
      p.skew = skew;
      return p;
    };

    R._getPath.litepath = function (el) {
      return R.parsePathString(el.node.path || BLANK);
    };
  }

  // pathString
  R.fn[LITEPATH] = function (path, zoom, group) {
    var paper = this,
        out;

    if (zoom && zoom.constructor === Element) {
      group = zoom;
      zoom = UNDEF;
    }
    if (path && path.constructor === Element) {
      group = path;
      path = BLANK;
    }

    // create element and update the custom attribute.
    out = R._engine[LITEPATH](path, this, zoom, group);
    out.ca[LITEPATH] = litepathsetter;

    path && out.attr(LITEPATH, R.is(path, ARRAY) ? [path] : path);
    return paper.__set__ && this.__set__.push(out), paper._elementsById[out.id] = out;
  };
};

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/***/ }),
/* 400 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports['default'] = function (R) {
  // Custom attribute to mark an element as tracker equivalent.
  R.ca.ishot = function (val) {
    if (this.removed) {
      return false;
    }
    var o = this,
        node = o.node,
        child;
    val = val || '';
    node.ishot = val;
    switch (o.type) {
      case 'group':
        child = o.bottom;
        while (child) {
          child.attr('ishot', val);
          child = child.next;
        }
        break;
      case 'text':
        if (R.svg) {
          child = node.getElementsByTagName('tspan')[0];
          while (child) {
            child.ishot = val;
            child = child.nextSibling;
          }
        }
    }
    return false;
  };
};

/***/ }),
/* 401 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__(9);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(10);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2['default'] === "function" && typeof _iterator2['default'] === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2['default'] === "function" && obj.constructor === _symbol2['default'] && obj !== _symbol2['default'].prototype ? "symbol" : typeof obj; };

exports['default'] = function (R) {
  var UNDEF,
      win = window,
      doc = win.document,
      isIE = /msie/i.test(win.navigator.userAgent) && !win.opera,
      isVML = R.type === 'VML',
      NONE = 'none',
      ABSOLUTE = 'absolute',
      BLANK = '',
      PX = 'px',
      styleAttrMap = {
    'cursor': 'cursor'
  },
      styleAttrNumericMap = {
    x: 'left',
    y: 'top',
    strokeWidth: 'borderThickness',
    'stroke-width': 'borderThickness',
    width: 'width',
    height: 'height'
  },
      styleAttrColorMap = {
    fill: 'backgroundColor',
    stroke: 'borderColor',
    color: 'color'
  },
      defaultElementStyle = {
    left: 0,
    top: 0,
    padding: 0,
    border: NONE,
    margin: 0,
    outline: NONE,
    '-webkit-apperance': NONE,
    position: ABSOLUTE,
    zIndex: 20
  },


  /**
   * Fixes color values by appending hash wherever needed
   */
  hashify = function hashify(color) {
    return color && color.replace(/^#?([a-f0-9]+)/ig, '#$1') || NONE;
  },
      garbageBin,
      // HTML element

  /**
   * This function is used to create html DOM
   *
   * @param {string} tagName the name of the HTML tag
   * @param {Object} attributes Object contain all attribute name and value
   * @param {DOMobject} parentElement parent node of the newly created element
   */
  createElement = function createElement(tagName, attributes, css, parentElement) {
    var elem = doc.createElement(tagName),
        x;
    // apply all attribute
    for (x in attributes) {
      if (styleAttrNumericMap[x]) {
        elem.style[x] = attributes[x];
      } else {
        elem.setAttribute(x, attributes[x]);
      }
    }
    for (x in css) {
      elem.style[x] = css[x];
    }
    // append in parent element
    parentElement && parentElement.appendChild && parentElement.appendChild(elem);
    return elem;
  },


  /**
   * Discard an element by moving it to the bin and delete
   * @param {Object} The HTML node to discard
   */
  discardElement = function discardElement(element) {
    // create a garbage bin element, not part of the DOM
    if (!garbageBin) {
      garbageBin = createElement('div');
    }

    // move the node and empty bin
    if (element) {
      garbageBin.appendChild(element);
    }
    garbageBin.innerHTML = '';
  },


  /**
   * Set or get an attribute or an object of attributes. Can't use jQuery attr because
   * it attempts to set expando properties on the SVG element, which is not allowed.
   *
   * @param {Object} elem The DOM element to receive the attribute(s)
   * @param {string|object} prop The property or an abject of key-value pairs
   * @param {string} value The value if a single property is set
   */
  _attr = function _attr(elem, prop, value) {
    var key, ret;

    // if the prop is a string
    if (typeof prop === 'string') {
      // set the value
      if (value !== UNDEF && value !== null) {
        elem.setAttribute(prop, value);

        // get the value
      } else if (elem && elem.getAttribute) {
        // elem not defined when printing pie demo...
        ret = elem.getAttribute(prop);
      }

      // else if prop is defined, it is a hash of key/value pairs
    } else if (prop !== UNDEF && prop !== null && (typeof prop === 'undefined' ? 'undefined' : _typeof(prop)) === 'object') {
      for (key in prop) {
        elem.setAttribute(key, prop[key]);
      }
    }
    return ret;
  },
      _HTMLElement;

  _HTMLElement = function HTMLElement(node, group, attrs) {
    var wrapper = this,
        element;

    if (group && group instanceof _HTMLElement) {
      group = group.element;
    }
    element = wrapper.element = createElement(node, attrs, defaultElementStyle, group);
    element.ishot = 'true';
    wrapper.nodeName = node.toLowerCase();
    wrapper.added = Boolean(group);
  };

  _HTMLElement.prototype = {
    attr: function attr(hash) {
      var wrapper = this,
          element = wrapper.element,
          restore = {},
          key,
          val,
          value,
          skipAttr,
          state,
          optionArr,
          optionString,
          i,
          len,
          ele;

      // getter
      if ((typeof hash === 'undefined' ? 'undefined' : _typeof(hash)) !== 'object') {
        // @todo: The attr is function is not defined! What is it supposed to do?
        return wrapper[hash] || _attr(element, hash);
      }

      // super-setter
      for (key in hash) {
        value = hash[key];
        if (styleAttrMap[key]) {
          switch (key) {
            case 'cursor':
              if (value === 'pointer' && isVML) {
                value = 'hand';
              }
              break;
          }
          element.style[styleAttrMap[key]] = value;
          skipAttr = true;
        } else if (styleAttrNumericMap[key]) {
          element.style[styleAttrNumericMap[key]] = value + PX;
          skipAttr = true;
        } else if (styleAttrColorMap[key]) {
          element.style[styleAttrColorMap[key]] = hashify(value);
          skipAttr = true;
        } else if (/^visibility$/i.test(key)) {
          state = value === 'hidden';
          element.style.display = state ? 'none' : '';
          wrapper.hidden = state;
          skipAttr = true;
        } else if (/^opacity$/i.test(key)) {
          element.style.opacity = value;
          if (isIE) {
            val = Number(value) * 100;
            element.style.filter = 'progid:DXImageTransform.Microsoft.Alpha(Opacity=' + val + ')';
          }

          skipAttr = true;
        } else if (/^innerhtml$/i.test(key)) {
          // IE < 9 does not allow options string to be added as innerHTML of the select element.
          if (isVML && element.nodeName.toLowerCase() == 'select') {
            // Parse all options using regex and create the option element
            // and then add the option element to the select element
            optionArr = value.match(/<option\s?[\s\S]*?(\/>|><\/option>|>[\s\S]*?<\/option>)/ig);
            // Remove all child nodes before adding new nodes
            while (element.firstChild) {
              element.removeChild(element.firstChild);
            }
            for (i = 0, len = optionArr.length; i < len; i += 1) {
              optionString = optionArr[i];
              ele = doc.createElement('option');

              if (/<option\s([\s\S]*[\'\"])\s*?(\/>|>[\s\S]*<\/option>)/ig.test(optionString)) {
                ele.value = optionString.replace(/<option\s([\s\S]*[\'\"])\s*?(\/>|>[\s\S]*<\/option>)/ig, '$1').replace(/[\s\S]*value\s*\=\s*[\'\"]([\s\S]*)[\'\"]/, '$1');
              }
              ele.text = optionString.replace(/<option\s*[\s\S]*[\'\"]?\s*?[\/>|\>]([\s\S]*)<\/option>/ig, '$1 ');
              element.options.add(ele);
            }
          } else {
            element.nodeName.toLowerCase() !== 'input' && value !== UNDEF && (element.innerHTML = value || BLANK);
          }
          skipAttr = true;
        } else if (/^text$/i.test(key)) {
          if (element.nodeName.toLowerCase() !== 'input') {
            element.innerHTML = '';
            value !== UNDEF && element.appendChild(doc.createTextNode(value));
          }
          skipAttr = true;
        } else if (/^type$/i.test(key) && isIE && wrapper.added) {
          // not in ie
          skipAttr = true;
        }

        if (skipAttr) {
          restore[key] = value;
          delete hash[key];
          skipAttr = false;
        }
      }

      for (key in hash) {
        element.setAttribute(key, hash[key]);
      }

      for (key in restore) {
        wrapper[key] = hash[key] = restore[key];
        delete restore[key];
      }
      return this;
    },

    val: function val(set) {
      var wrapper = this,
          element = wrapper.element,
          getter = set === UNDEF;

      if (wrapper.nodeName === 'input' && element.getAttribute('type') === 'checkbox') {
        return getter ? wrapper.checked() ? 1 : 0 : wrapper.checked(set);
      }

      return getter ? element.value : (element.value = set, wrapper);
    },

    checked: function checked(set) {
      var wrapper = this,
          element = wrapper.element;
      return set === UNDEF ? element.checked : (set ? element.setAttribute('checked', 'checked') : element.removeAttribute('checked'), wrapper);
    },

    css: function css(hash, val) {
      var wrapper = this,
          element = wrapper.element,
          styleObj = element.style,
          key;

      if ((typeof hash === 'undefined' ? 'undefined' : _typeof(hash)) === 'object') {
        for (key in hash) {
          styleObj[key] = hash[key];
        }
      } else if (key) {
        if (val !== UNDEF) {
          styleObj[key] = val;
        }
      }
      return wrapper;
    },

    translate: function translate(x, y) {
      var wrapper = this,
          element = wrapper.element;

      if (x !== UNDEF) {
        element.style.left = x + PX;
      }
      if (y !== UNDEF) {
        element.style.top = y + PX;
      }

      return wrapper;
    },

    add: function add(group, prepend) {
      var wrapper = this,
          element = this.element,
          parent = group.element;

      if (prepend) {
        parent.insertBefore(element, parent.firstChild);
      } else {
        parent.appendChild(element);
      }

      wrapper.added = true;
      return wrapper;
    },

    hide: function hide() {
      this.element.style.display = 'none';
      return this;
    },

    show: function show() {
      this.element.style.display = '';
      return this;
    },

    focus: function focus() {
      if (typeof this.element.focus === 'function') {
        this.element.focus();
      } else {
        _domEvent2['default'].fire(this.element, 'focus');
      }
    },

    destroy: function destroy() {
      var wrapper = this,
          element = wrapper.element || {};

      // remove events
      element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = element.onblur = element.onfocus = null;

      // remove from dom
      // @todo: discardElement is not defined! :(
      element = discardElement(element);
      delete wrapper.element;
      return null;
    },

    on: isVML ? function (eventType, handler) {
      var wrapper = this;

      // simplest possible event model for internal use
      wrapper.element['on' + eventType] = function () {
        var evt = win.event;
        evt.target = evt.srcElement;
        handler(evt);
      };
      return wrapper;
    } : function (eventType, handler) {
      var fn = handler,
          wrapper = this;
      // touch
      if (_lib.hasTouch && eventType === 'click') {
        eventType = 'touchstart';
        fn = function fn(e) {
          e.preventDefault();
          handler();
        };
      }
      // simplest possible event model for internal use
      wrapper.element['on' + eventType] = fn;
      return wrapper;
    },

    bind: function bind(event, handler, data) {
      _domEvent2['default'].listen(this.element, event, handler, data);
      return this;
    },

    unbind: function unbind(event, handler) {
      _domEvent2['default'].unlisten(this.element, event, handler);
      return this;
    },

    trigger: function trigger(event, eventObj) {
      _domEvent2['default'].fire(this.element, event, eventObj);
      return this;
    },

    fadeIn: function fadeIn(transition, callback) {
      var duration = transition === 'fast' ? 400 : 1000;

      this.show();
      this.attr({ opacity: 0 });
      _dom2['default'].animate(this.element, { opacity: 1 }, duration, 'linear', callback);
    },

    animate: function animate(params, ms, easing, callback) {
      _dom2['default'].animate(this.element, params, ms, easing, callback);
    }
  };

  _HTMLElement.prototype.constructor = _HTMLElement;

  R.fn.html = function (node, attrs, css, group) {
    var rootAttr = {},
        wrapper,
        prop;

    // type cannot be updated post addition
    if (attrs && 'type' in attrs) {
      rootAttr.type = attrs.type;
      delete attrs.type;
    }

    wrapper = new _HTMLElement(node, group, rootAttr).css(css).attr(attrs);

    for (prop in rootAttr) {
      attrs[prop] = rootAttr[prop];
    }

    return wrapper;
  };
};

var _domEvent = __webpack_require__(34);

var _domEvent2 = _interopRequireDefault(_domEvent);

var _lib = __webpack_require__(5);

var _dom = __webpack_require__(209);

var _dom2 = _interopRequireDefault(_dom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/***/ }),
/* 402 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _componentInterface = __webpack_require__(6);

var _componentInterface2 = _interopRequireDefault(_componentInterface);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */


/**
 * Creates class for ChartMessage
 */
var ChartMessage = function (_ComponentInterface) {
  _inherits(ChartMessage, _ComponentInterface);

  function ChartMessage() {
    _classCallCheck(this, ChartMessage);

    return _possibleConstructorReturn(this, _ComponentInterface.apply(this, arguments));
  }

  /**
   * Sets the name of the component
   * @return {string} name
   */
  ChartMessage.prototype.getName = function getName() {
    return 'chartMessage';
  };

  /**
   * Sets the type of the component
   * @return {string} type
   */


  ChartMessage.prototype.getType = function getType() {
    return 'chartMessage';
  };

  return ChartMessage;
}(_componentInterface2['default']);

exports['default'] = ChartMessage;

/***/ }),
/* 403 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _assign = __webpack_require__(13);

var _assign2 = _interopRequireDefault(_assign);

var _componentInterface = __webpack_require__(6);

var _componentInterface2 = _interopRequireDefault(_componentInterface);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var math = Math,
    mathAbs = math.abs,
    mathRound = math.round,
    mathMax = math.max,
    mathMin = math.min,
    UNDEF = void 0;

function getCrispPath(path, width) {
  var isCrisped = false,
      oddWidth = width % 2,
      value,
      roundValue;

  if (path[1] === path[4]) {
    value = path[1];
    roundValue = mathRound(value);
    path[1] = path[4] = oddWidth ? roundValue > value ? roundValue - 0.5 : roundValue + 0.5 : roundValue;
    isCrisped = true;
  }
  if (path[2] === path[5]) {
    value = path[2];
    roundValue = mathRound(value);
    path[2] = path[5] = oddWidth ? roundValue > value ? roundValue - 0.5 : roundValue + 0.5 : roundValue;
    isCrisped = true;
  }
  return {
    path: path,
    isCrisped: isCrisped
  };
}

var AxisRefVisuals = function (_ComponentInterface) {
  _inherits(AxisRefVisuals, _ComponentInterface);

  function AxisRefVisuals() {
    _classCallCheck(this, AxisRefVisuals);

    return _possibleConstructorReturn(this, _ComponentInterface.apply(this, arguments));
  }

  AxisRefVisuals._hasElements = function _hasElements(elemArr, id) {
    var i;
    for (i = 0; i < elemArr.length; i++) {
      if (elemArr[i].id === id) {
        return elemArr[i];
      }
    }
    return false;
  };

  AxisRefVisuals.prototype._calculatePath = function _calculatePath(obj, value, plotLineWidth, getPixelOptions, axis) {
    var axisRefVisualsComp = this,
        axisConfig = axis.config,
        isVertical = axisConfig.isVertical,
        canvas = axisRefVisualsComp.getLinkedParent(),
        chart = axisRefVisualsComp.getFromEnv('chart'),
        chartConfig = chart.config,
        canvasBottom = canvas.config.canvasBottom || chartConfig.canvasBottom,
        canvasLeft = canvas.config.canvasLeft || chartConfig.canvasLeft,
        canvasRight = canvas.config.canvasRight || chartConfig.canvasRight,
        canvasTop = canvas.config.canvasTop || chartConfig.canvasTop,
        crispPath;

    crispPath = getCrispPath(['M', isVertical ? canvasLeft : axis.getPixel(value, getPixelOptions), isVertical ? axis.getPixel(value, getPixelOptions) : canvasTop, 'L', isVertical ? canvasRight : axis.getPixel(value, getPixelOptions), isVertical ? axis.getPixel(value, getPixelOptions) : canvasBottom], plotLineWidth);
    obj.path = crispPath.path;

    obj['shape-rendering'] = crispPath.isCrisped ? 'crisp' : UNDEF;
    return obj;
  };

  AxisRefVisuals.prototype._hasPlotLine = function _hasPlotLine(id, value, lineArr) {
    var i;

    for (i = 0; i < (lineArr && lineArr.length); i++) {
      if (value === lineArr[i].value) {
        return this._accessPlotLineElems(id + 'plotline' + value);
      }
    }
    return false;
  };

  AxisRefVisuals.prototype._accessPlotLineElems = function _accessPlotLineElems(id, remove) {
    var axisRefVisualsComp = this,
        plotLineElem,
        i,
        plotLines = axisRefVisualsComp.getGraphicalElement('plotLines');

    !plotLines && (plotLines = []);
    for (i = 0; i < plotLines.length; i++) {
      if (plotLines[i].id === id) {
        plotLineElem = plotLines[i];
        remove && this.removeGraphicalElement(plotLineElem);
        return plotLineElem;
      }
    }
    return false;
  };

  AxisRefVisuals.prototype._drawPlotLine = function _drawPlotLine(axis, id) {
    var axisRefVisualsComp = this,
        config = axisRefVisualsComp.config,
        chart = axisRefVisualsComp.getFromEnv('chart'),
        paper = axisRefVisualsComp.getFromEnv('paper'),
        animType = chart.config.animationObj.animType,
        axisPlotLineContainerBottom = axisRefVisualsComp.getLinkedParent().getContainer('lineBottomGroup'),

    // axisPlotLineContainerTop = axisConfig.axisPlotLineContainerTop,
    axisPlotLineContainer,
        i,
        lineOb,
        elem,
        value,
        hasPlotLine,
        axisAttrObj,
        axisAttrObjPre,
        oldLineArr = config['oldLineArr_' + id],
        callback = function callback() {
      this.remove();
    },
        currentLineArr = axis.getComponentInfo('line');

    // Remove the old plotLines
    for (i = 0; i < (oldLineArr && oldLineArr.length); i++) {
      lineOb = oldLineArr[i];
      value = lineOb.value;
      hasPlotLine = axisRefVisualsComp._hasPlotLine(id, value, currentLineArr);
      axisAttrObj = {
        opacity: 0
      };
      axisRefVisualsComp._calculatePath(axisAttrObj, value, lineOb['stroke-width'], {
        wrtVisible: true
      }, axis);

      if (!hasPlotLine) {
        elem = axisRefVisualsComp._accessPlotLineElems(id + 'plotline' + value, true);
        axisRefVisualsComp.getFromEnv('animationManager').registerAnimation([{
          animType: animType,
          data: [{
            el: elem,
            attrs: axisAttrObj,
            callback: callback
          }]
        }], 'axis');
      }
    }

    // Create new plotLines or use existing ones
    for (i = 0; i < currentLineArr.length; i++) {
      lineOb = currentLineArr[i];
      value = lineOb.value;
      hasPlotLine = axisRefVisualsComp._hasPlotLine(id, value, oldLineArr);
      axisAttrObj = {
        opacity: lineOb.opacity,
        'shape-rendering': lineOb['shape-rendering'],
        stroke: lineOb.stroke,
        'stroke-dasharray': lineOb['stroke-dasharray'],
        'stroke-width': lineOb['stroke-width']
      };
      axisAttrObjPre = (0, _assign2['default'])({}, axisAttrObj);
      axisAttrObjPre.opacity = 0;
      axisRefVisualsComp._calculatePath(axisAttrObj, value, lineOb['stroke-width'], {
        wrtVisible: true
      }, axis);
      axisRefVisualsComp._calculatePath(axisAttrObjPre, value, lineOb['stroke-width'], {
        wrtVisible: true,
        preValue: true
      }, axis);
      axisPlotLineContainer = axisPlotLineContainerBottom;
      if (hasPlotLine) {
        axisRefVisualsComp.getFromEnv('animationManager').registerAnimation([{
          animType: animType,
          data: [{
            el: hasPlotLine,
            attrs: axisAttrObj
          }]
        }], 'axis');
      } else {
        elem = axisRefVisualsComp.addGraphicalElement('plotLines', paper.path(axisAttrObjPre, axisPlotLineContainer), true);
        elem.id = id + 'plotline' + value;
        chart.getFromEnv('animationManager').registerAnimation([{
          animType: animType,
          data: [{
            el: elem,
            attrs: axisAttrObj
          }]
        }], chart.state === 'initial' ? 'initial' : 'axis');
      }
    }
    config['oldLineArr_' + id] = currentLineArr;
  };

  AxisRefVisuals.prototype._drawPlotBand = function _drawPlotBand(axis, id) {
    var axisRefVisualsComp = this,
        chart = axisRefVisualsComp.getFromEnv('chart'),
        chartConfig = chart.config,
        paper = chart.getFromEnv('paper'),
        animType = chart.get('config', 'animationObj').animType,
        axisConfig = axis.config,
        bandObj,
        value,
        axisAttrObj,
        bandWidth,
        canvas = axisRefVisualsComp.getLinkedParent(),
        canvasLeft = canvas.config.canvasLeft || chartConfig.canvasLeft,
        canvasTop = canvas.config.canvasTop || chartConfig.canvasTop,
        canvasHeight = canvas.config.canvasHeight || chartConfig.canvasHeight,
        canvasWidth = canvas.config.canvasWidth || chartConfig.canvasWidth,
        isVertical = axisConfig.isVertical,
        isReverse = axisConfig.isReverse,
        pvr = axis.config.pvr,
        bandElems,
        i,
        axisBandContainer = canvas.getContainer('bandGroup'),
        state = chart.state,
        hookFn = function hookFn(axisAttrObj) {
      this.show();
      this.attr(axisAttrObj);
    },
        bandElemArr = axisRefVisualsComp.getGraphicalElement('plotBands'),
        bandArr = axis.getComponentInfo('band');

    !bandElemArr && (bandElemArr = []);
    for (i = 0; i < bandArr.length; i++) {
      bandObj = bandArr[i];
      value = bandObj.value;

      axisAttrObj = {
        fill: bandObj.fill,
        'stroke-width': bandObj['stroke-width']
      };
      bandWidth = bandObj.bandWidth;
      if (isVertical) {
        // y-axis
        axisAttrObj.x = canvasLeft;
        axisAttrObj.y = axis.getPixel(isReverse ? value + mathAbs(bandWidth) : value, {
          wrtVisible: true
        });
        axisAttrObj.width = canvasWidth;
        axisAttrObj.height = mathAbs(bandWidth * pvr);
      } else {
        // x-axis
        axisAttrObj.x = axis.getPixel(value, { wrtVisible: true });
        axisAttrObj.y = canvasTop;
        axisAttrObj.width = mathAbs(bandWidth * pvr);
        axisAttrObj.height = canvasHeight;
      }
      bandElems = AxisRefVisuals._hasElements(bandElemArr, id + i);
      if (!bandElems) {
        axisAttrObj.opacity = 0;
        bandElems = axisRefVisualsComp.addGraphicalElement('plotBands', paper.rect(axisAttrObj, axisBandContainer), true);
        bandElems.id = id + i;
      }

      if (state === 'resize') {
        axisRefVisualsComp.getFromEnv('animationManager').registerAnimation([{
          animType: animType,
          data: [{
            el: bandElems,
            attrs: axisAttrObj
          }]
        }], 'default');
      } else {
        axisRefVisualsComp.getFromEnv('animationManager').registerAnimation([{
          animType: animType,
          data: [{
            el: bandElems,
            attrs: {
              opacity: 1,
              from: 'final'
            },
            animConfig: [{
              hookFn: hookFn.bind(bandElems, axisAttrObj)
            }]
          }]
        }], 'final');
      }
    }

    // if (state !== 'resize') {
    //   for (i = 0; i < (bandElemArr && bandElemArr.length); i++) {
    //     bandElems = bandElemArr[i];
    //     bandElems && axisRefVisualsComp.getFromEnv('animationManager').registerAnimation([{
    //       animType: animType,
    //       data: [{
    //         el: bandElems,
    //         attrs: {
    //           opacity: 0,
    //           from: 'initial'
    //         }
    //       }]
    //     }], 'initial');
    //   }
    // }
  };

  AxisRefVisuals.prototype._drawTrendLine = function _drawTrendLine(axis, id) {
    var axisRefVisualsComp = this,
        trendArr = axis.getComponentInfo('trend'),
        i,
        markerObj,
        labelObj,
        axisConfig = axis.config,
        axisDrawingAttrObj,
        axisTextAttrObj,
        startValuePixel,
        isTrendZone,
        endValuePixel,
        startValue,
        endValue,
        fixedTrendLabelPos,
        fixedTrendLabelPosRight,
        isOpposit = axisConfig.isOpposit,
        crispPath,
        axisPadding = axisConfig.labelPadding,
        chart = axisRefVisualsComp.getFromEnv('chart'),
        chartConfig = chart.config,
        animType = chart.get('config', 'animationObj').animType,
        canvas = axisRefVisualsComp.getLinkedParent(),
        canvasBottom = canvas.config.canvasBottom || chartConfig.canvasBottom,
        canvasLeft = canvas.config.canvasLeft || chartConfig.canvasLeft,
        canvasRight = canvas.config.canvasRight || chartConfig.canvasRight,
        canvasTop = canvas.config.canvasTop || chartConfig.canvasTop,
        axisTrendContainerTop = canvas.getContainer('trendTopGroup'),
        axisTrendContainerBottom = canvas.getContainer('trendBottomGroup'),
        axisTrendContainer,
        axisTrendLabelContainer = axisConfig.axisTrendLabelContainer,
        paper = chart.getFromEnv('paper'),
        axisDimention = axisConfig.axisDimention || {},
        checkForLimit = axis._isZoomed(),
        getLimit = axis.getVisibleConfig(),
        maxPx,
        minPx,
        showOnTop,
        valueOnRight,
        style = axisConfig.trend.trendStyle,
        state = chart.state,
        css = {
      fontFamily: style.fontFamily,
      fontSize: style.fontSize,
      lineHeight: style.lineHeight,
      fontWeight: style.fontWeight,
      fontStyle: style.fontStyle
    },
        hookFn = function hookFn(attr, group) {
      this.show();
      this.attr(attr);
      group && group.appendChild(this);
    },
        trendElemsArr = axisRefVisualsComp.getGraphicalElement('trendElems'),
        trendTextElemsArr = axisRefVisualsComp.getGraphicalElement('trendTextElems'),
        trendElems,
        trendTextElems,
        drawTrendLabels = axisConfig.drawTrendLabels,
        trendlines = axisConfig.trendLines,
        vtrendlines = axisConfig.vTrendLines;

    !trendElemsArr && (trendElemsArr = []);
    !trendTextElemsArr && (trendTextElemsArr = []);

    if (vtrendlines) {
      fixedTrendLabelPos = isOpposit ? (axisDimention.opposite || canvasBottom) - (axisConfig.trendBottomPadding || 0) : (axisDimention.y || canvasBottom) + (axisConfig.trendBottomPadding || 0);
    } else {
      fixedTrendLabelPos = isOpposit ? (axisDimention.opposite || canvasLeft) + (axisPadding || 0) : (axisDimention.x || canvasLeft) - (axisPadding || 0);
      fixedTrendLabelPosRight = isOpposit ? (axisDimention.x || canvasRight) + (axisPadding || 0) : (axisDimention.opposite || canvasRight) + (axisPadding || 0);
    }

    if (checkForLimit) {
      maxPx = mathMax(axis.getPixel(getLimit.minValue, { wrtVisible: true }), axis.getPixel(getLimit.maxValue, { wrtVisible: true }));
      minPx = mathMin(axis.getPixel(getLimit.minValue, { wrtVisible: true }), axis.getPixel(getLimit.maxValue, { wrtVisible: true }));
    }

    if (state !== 'resize') {
      for (i = 0; i < (trendElemsArr && trendElemsArr.length); i++) {
        trendElems = trendElemsArr[i];
        trendElems && chart.getFromEnv('animationManager').registerAnimation([{
          animType: animType,
          data: [{
            el: trendElems,
            attrs: {
              opacity: 0
            }
          }]
        }], 'initial');
      }
      for (i = 0; i < (trendTextElemsArr && trendTextElemsArr.length); i++) {
        trendTextElems = trendTextElemsArr[i];
        trendTextElems && chart.getFromEnv('animationManager').registerAnimation([{
          animType: animType,
          data: [{
            el: trendTextElems,
            attrs: {
              opacity: 0
            }
          }]
        }], 'initial');
      }
    }

    for (i = 0; i < trendArr.length; i++) {
      markerObj = trendArr[i].marker;
      labelObj = trendArr[i].label;

      axisDrawingAttrObj = {
        fill: markerObj.fill || '',
        stroke: markerObj.stroke || '',
        'stroke-width': markerObj.strokeWidth,
        'stroke-dasharray': markerObj.strokeDashArray,
        'shape-rendering': markerObj.shapeRendering
      };

      axisTextAttrObj = {
        fill: labelObj.fill || '',
        text: labelObj.text,
        'text-anchor': labelObj.textAnchor,
        'text-bound': labelObj.textBound
      };
      isTrendZone = markerObj.isZone;
      startValue = markerObj.startValue;
      endValue = markerObj.endValue;

      if (vtrendlines) {
        startValuePixel = axis.getPixel(axisConfig.hasBreakPoints ? axis._getRelativeBreakValue(startValue) : startValue, { wrtVisible: true });
        endValuePixel = endValue ? axis.getPixel(axisConfig.hasBreakPoints ? axis._getRelativeBreakValue(endValue) : endValue, { wrtVisible: true }) : 0;

        axisTextAttrObj.y = fixedTrendLabelPos;
        axisTextAttrObj['vertical-align'] = 'top';

        if (endValue !== undefined && endValue !== '' && endValue !== startValue && isTrendZone) {
          axisDrawingAttrObj.path = ['M', startValuePixel, canvasTop, 'L', startValuePixel, canvasBottom, 'L', endValuePixel, canvasBottom, 'L', endValuePixel, canvasTop, 'Z'];

          axisTextAttrObj.x = startValuePixel + (endValuePixel - startValuePixel) / 2;
        } else {
          // trend line
          crispPath = endValue ? getCrispPath(['M', startValuePixel, canvasTop, 'L', endValuePixel, canvasBottom], markerObj.strokeWidth) : getCrispPath(['M', startValuePixel, canvasTop, 'L', startValuePixel, canvasBottom], markerObj.strokeWidth);
          axisDrawingAttrObj.path = crispPath.path;

          axisTextAttrObj.x = endValue ? endValuePixel : startValuePixel;
        }
        // checking if the text is out of viewport
        if (checkForLimit && (!drawTrendLabels || axisTextAttrObj.x > maxPx || axisTextAttrObj.x < minPx)) {
          axisTextAttrObj.text = '';
        }
      } else if (trendlines) {
        startValuePixel = axis.getPixel(startValue, { wrtVisible: true });
        endValuePixel = endValue ? axis.getPixel(endValue, { wrtVisible: true }) : 0;
        valueOnRight = labelObj.valueOnRight;

        if (endValue !== UNDEF && endValue !== '' && endValue !== startValue && isTrendZone) {
          // trend zone
          axisDrawingAttrObj.path = ['M', canvasLeft, startValuePixel, 'L', canvasRight, startValuePixel, 'L', canvasRight, endValuePixel, 'L', canvasLeft, endValuePixel, 'Z'];

          axisTextAttrObj.x = valueOnRight ? fixedTrendLabelPosRight : fixedTrendLabelPos;
          axisTextAttrObj.y = startValuePixel + (endValuePixel - startValuePixel) / 2;
        } else {
          // trend line
          crispPath = endValue ? getCrispPath(['M', canvasLeft, startValuePixel, 'L', canvasRight, endValuePixel, 'Z'], markerObj.strokeWidth) : getCrispPath(['M', canvasLeft, startValuePixel, 'L', canvasRight, startValuePixel, 'Z'], markerObj.strokeWidth);
          axisDrawingAttrObj.path = crispPath.path;

          axisTextAttrObj.x = valueOnRight ? fixedTrendLabelPosRight : fixedTrendLabelPos;
          axisTextAttrObj.y = endValue ? valueOnRight ? endValuePixel : startValuePixel : startValuePixel;
        }
        // checking if the text is out of viewport
        if (checkForLimit && (!drawTrendLabels || axisTextAttrObj.y > maxPx || axisTextAttrObj.y < minPx)) {
          axisTextAttrObj.text = '';
        }
      }
      // if show on top or bottom set the container accordingly
      showOnTop = trendArr[i].showOnTop;
      if (!chart.is3D && (showOnTop === 1 || axisConfig.showTrendlinesOnTop === 1)) {
        axisTrendContainer = axisTrendContainerTop;
      } else {
        axisTrendContainer = axisTrendContainerBottom;
      }
      trendElems = AxisRefVisuals._hasElements(trendElemsArr, id + i);
      if (!trendElems) {
        axisDrawingAttrObj.opacity = 0;
        trendElems = axisRefVisualsComp.addGraphicalElement('trendElems', paper.path(axisDrawingAttrObj, axisTrendContainer), true);
        trendElems.id = id + i;
      }

      if (state === 'resize') {
        chart.getFromEnv('animationManager').registerAnimation([{
          animType: animType,
          data: [{
            el: trendElems,
            attrs: axisDrawingAttrObj
          }]
        }], 'default');
      } else {
        chart.getFromEnv('animationManager').registerAnimation([{
          animType: animType,
          data: [{
            el: trendElems,
            attrs: {
              opacity: 1
            },
            animConfig: [{
              hookFn: hookFn.bind(trendElems, axisDrawingAttrObj, axisTrendContainer)
            }]
          }]
        }], 'final');
      }
      trendTextElems = AxisRefVisuals._hasElements(trendTextElemsArr, id + i);
      if (!trendTextElems) {
        axisTextAttrObj.opacity = 0;
        trendTextElems = axisRefVisualsComp.addGraphicalElement('trendTextElems', paper.text(axisTextAttrObj, axisTrendLabelContainer), true).css(css);
        trendTextElems.id = id + i;
        trendTextElemsArr.push(trendTextElems);
      }

      if (labelObj.toolText !== '') {
        trendTextElems.tooltip(labelObj.toolText).trackTooltip(true);
      } else {
        trendTextElems.trackTooltip(false);
      }

      if (state === 'resize') {
        chart.getFromEnv('animationManager').registerAnimation([{
          animType: animType,
          data: [{
            el: trendTextElems,
            attrs: axisTextAttrObj
          }]
        }], 'default');
      } else {
        chart.getFromEnv('animationManager').registerAnimation([{
          animType: animType,
          data: [{
            el: trendTextElems,
            attrs: {
              opacity: 1
            },
            animConfig: [{
              hookFn: hookFn.bind(trendTextElems, axisTextAttrObj)
            }]
          }]
        }], 'final');
      }
    }

    // if (state !== 'resize') {
    //   for (i = 0; i < (trendElemsArr && trendElemsArr.length); i++) {
    //     trendElems = trendElemsArr[i];
    //     trendElems && chart.getFromEnv('animationManager').registerAnimation([{
    //       animType: animType,
    //       data: [{
    //         el: trendElems,
    //         attrs: {
    //           opacity: 0
    //         }
    //       }]
    //     }], 'initial');
    //   }
    //   for (i = 0; i < (trendTextElemsArr && trendTextElemsArr.length); i++) {
    //     trendTextElems = trendTextElemsArr[i];
    //     trendTextElems && chart.getFromEnv('animationManager').registerAnimation([{
    //       animType: animType,
    //       data: [{
    //         el: trendTextElems,
    //         attrs: {
    //           opacity: 0
    //         }
    //       }]
    //     }], 'initial');
    //   }
    // }
  };

  AxisRefVisuals.prototype._drawCategoryVline = function _drawCategoryVline(axis, id) {
    var axisRefVisualsComp = this,
        i,
        chart = axisRefVisualsComp.getFromEnv('chart'),
        paper = chart.getFromEnv('paper'),
        chartConfig = chart.config,
        animType = chart.get('config', 'animationObj').animType,
        vLineArr = axis.getComponentInfo('catVLine'),
        markerObj,
        labelObj,
        vLineTextAttrObj,
        crispPath,
        axisConfig = axis.config,
        isHorizontal = axisConfig.isVertical,
        canvas = axisRefVisualsComp.getLinkedParent(),
        canvasBottom = canvas.config.canvasBottom || chartConfig.canvasBottom,
        canvasLeft = canvas.config.canvasLeft || chartConfig.canvasLeft,
        canvasRight = canvas.config.canvasRight || chartConfig.canvasRight,
        canvasTop = canvas.config.canvasTop || chartConfig.canvasTop,
        canvasHeight = canvas.config.canvasHeight || chartConfig.canvasHeight,
        canvasWidth = canvas.config.canvasWidth || chartConfig.canvasWidth,
        posRelCategory,
        vLineContainer,
        axisPlotLineContainerTop = canvas.getContainer('lineTopGroup'),
        axisPlotLineContainer = canvas.getContainer('lineBottomGroup'),
        isRelativeAxisInverse = axisConfig.isRelativeAxisInverse,
        borderPadding = 2,
        vLineElems,
        vLineLabelElems,
        vlineLabelContainer = axisConfig.vlineLabelContainer,
        state = chart.state,
        hookFn = function hookFn(attr, group) {
      this.show();
      this.attr(attr);
      group && group.appendChild(this);
    },
        vLineElemsArr = axisRefVisualsComp.getGraphicalElement('vLineElems'),
        vLineLabelElemsArr = axisRefVisualsComp.getGraphicalElement('vLineLabelElems'),
        vLineDrawingAttrObj;

    !vLineElemsArr && (vLineElemsArr = []);
    !vLineLabelElemsArr && (vLineLabelElemsArr = []);

    if (state !== 'resize') {
      for (i = 0; i < (vLineElemsArr && vLineElemsArr.length); i++) {
        vLineElems = vLineElemsArr[i];
        vLineElems && chart.getFromEnv('animationManager').registerAnimation([{
          animType: animType,
          data: [{
            el: vLineElems,
            attrs: {
              opacity: 0
            }
          }]
        }], 'initial');
      }
      for (i = 0; i < (vLineLabelElemsArr && vLineLabelElemsArr.length); i++) {
        vLineLabelElems = vLineLabelElemsArr[i];
        vLineLabelElems && chart.getFromEnv('animationManager').registerAnimation([{
          animType: animType,
          data: [{
            el: vLineLabelElems,
            attrs: {
              opacity: 0
            }
          }]
        }], 'initial');
      }
    }

    for (i = 0; i < vLineArr.length; i++) {
      markerObj = vLineArr[i].marker;
      labelObj = vLineArr[i].label;

      vLineDrawingAttrObj = {
        opacity: markerObj.opacity,
        stroke: markerObj.stroke,
        'stroke-width': markerObj['stroke-width'],
        'stroke-dasharray': markerObj['stroke-dasharray']
      };
      vLineTextAttrObj = {
        text: labelObj.value,
        opacity: labelObj.opacity,
        'text-anchor': labelObj['text-anchor'],
        'vertical-align': labelObj['vertical-align'],
        'text-bound': labelObj['text-bound']
      };
      posRelCategory = axis.getPixel(markerObj.value, { wrtVisible: true });

      if (markerObj.showOnTop) {
        vLineContainer = axisPlotLineContainerTop;
      } else {
        vLineContainer = axisPlotLineContainer;
      }

      if (isHorizontal) {
        crispPath = getCrispPath(['M', canvasLeft, posRelCategory, 'L', canvasRight, posRelCategory], markerObj['stroke-width']);
        vLineDrawingAttrObj.path = crispPath.path;
        vLineTextAttrObj.x = canvasLeft + canvasWidth * (isRelativeAxisInverse ? 1 - labelObj.position : labelObj.position);
        vLineTextAttrObj.y = posRelCategory;
      } else {
        crispPath = getCrispPath(['M', posRelCategory, canvasTop, 'L', posRelCategory, canvasBottom], markerObj['stroke-width']);
        vLineDrawingAttrObj.path = crispPath.path;
        vLineTextAttrObj.x = posRelCategory;
        vLineTextAttrObj.y = canvasTop + canvasHeight * (isRelativeAxisInverse ? 1 - labelObj.position : labelObj.position);
      }
      vLineDrawingAttrObj['shape-rendering'] = crispPath.isCrisped ? 'crisp' : UNDEF;
      if (labelObj['text-anchor'] == 'start') {
        vLineTextAttrObj.x += borderPadding;
      } else if (labelObj['text-anchor'] == 'end') {
        vLineTextAttrObj.x -= borderPadding;
      }
      if (labelObj['vertical-align'] == 'top') {
        vLineTextAttrObj.Y += borderPadding;
      } else if (labelObj['vertical-align'] == 'bottom') {
        vLineTextAttrObj.Y -= borderPadding;
      }
      vLineElems = AxisRefVisuals._hasElements(vLineElemsArr, id + i);
      if (!vLineElems) {
        vLineDrawingAttrObj.opacity = 0;
        vLineElems = axisRefVisualsComp.addGraphicalElement('vLineElems', paper.path(vLineDrawingAttrObj, vLineContainer), true);
        vLineElems.id = id + i;
      }

      if (state === 'resize') {
        chart.getFromEnv('animationManager').registerAnimation([{
          animType: animType,
          data: [{
            el: vLineElems,
            attrs: vLineDrawingAttrObj
          }]
        }], 'default');
      } else {
        chart.getFromEnv('animationManager').registerAnimation([{
          animType: animType,
          data: [{
            el: vLineElems,
            attrs: {
              opacity: markerObj.opacity
            },
            animConfig: [{
              hookFn: hookFn.bind(vLineElems, vLineDrawingAttrObj, vLineContainer)
            }]
          }]
        }], 'final');
      }

      if (labelObj.value) {
        vLineTextAttrObj.transform = paper.getSuggestiveRotation(labelObj.rotation, vLineTextAttrObj.x, vLineTextAttrObj.y);

        vLineLabelElems = AxisRefVisuals._hasElements(vLineLabelElemsArr, id + i);
        if (!vLineLabelElems) {
          vLineTextAttrObj.opacity = 0;
          vLineLabelElems = axisRefVisualsComp.addGraphicalElement('vLineLabelElems', paper.text(vLineTextAttrObj, vlineLabelContainer), true).css(labelObj.css);
          vLineLabelElems.id = id + i;
        }

        if (state === 'resize') {
          chart.getFromEnv('animationManager').registerAnimation([{
            animType: animType,
            data: [{
              el: vLineLabelElems,
              attrs: vLineTextAttrObj
            }]
          }], 'default');
        } else {
          chart.getFromEnv('animationManager').registerAnimation([{
            animType: animType,
            data: [{
              el: vLineLabelElems,
              attrs: {
                opacity: 1
              },
              animConfig: [{
                hookFn: hookFn.bind(vLineLabelElems, vLineTextAttrObj)
              }]
            }]
          }], 'final');
        }
      }
    }

    if (state !== 'resize') {
      for (i = 0; i < (vLineElemsArr && vLineElemsArr.length); i++) {
        vLineElems = vLineElemsArr[i];
        vLineElems && chart.getFromEnv('animationManager').registerAnimation([{
          animType: animType,
          data: [{
            el: vLineElems,
            attrs: {
              opacity: 0
            }
          }]
        }], 'initial');
      }
      for (i = 0; i < (vLineLabelElemsArr && vLineLabelElemsArr.length); i++) {
        vLineLabelElems = vLineLabelElemsArr[i];
        vLineLabelElems && chart.getFromEnv('animationManager').registerAnimation([{
          animType: animType,
          data: [{
            el: vLineLabelElems,
            attrs: {
              opacity: 0
            }
          }]
        }], 'initial');
      }
    }
  };

  AxisRefVisuals.prototype._drawCategoryPlotBand = function _drawCategoryPlotBand(axis, id) {
    var axisRefVisualsComp = this,
        chart = axisRefVisualsComp.getFromEnv('chart'),
        paper = chart.getFromEnv('paper'),
        chartConfig = chart.config,
        animType = chart.get('config', 'animationObj').animType,
        catBandArr = axis.getComponentInfo('catBand'),
        axisConfig = axis.config,
        canvas = axisRefVisualsComp.getLinkedParent(),

    // canvasBottom = canvas.config.canvasBottom || chartConfig.canvasBottom,
    canvasLeft = canvas.config.canvasLeft || chartConfig.canvasLeft,
        canvasRight = canvas.config.canvasRight || chartConfig.canvasRight,
        canvasTop = canvas.config.canvasTop || chartConfig.canvasTop,
        canvasHeight = canvas.config.canvasHeight || chartConfig.canvasHeight,
        canvasWidth = canvas.config.canvasWidth || chartConfig.canvasWidth,
        axisBandContainer = canvas.getContainer('bandGroup'),
        catBandObj,
        loopMin,
        loopMax,
        bandWidth,
        increment,
        axisAttrObj,
        pvr = axis.pvr,
        isVertical = axisConfig.isVertical,
        state = chart.state,
        catBandElemsArr = axisRefVisualsComp.getGraphicalElement('catBandElems'),
        hookFn = function hookFn(attr, group) {
      this.show();
      this.attr(attr);
      group && group.appendChild(this);
    },
        catBandElems,

    // min,
    max,
        _i,
        i;
    !catBandElemsArr && (catBandElemsArr = []);
    for (i = 0; i < catBandArr.length; i++) {
      catBandObj = catBandArr[i];
      loopMin = catBandObj.loopMin;
      loopMax = catBandObj.loopMax;
      _i = catBandObj.i;
      increment = catBandObj.categoryIncrement;
      // min = catBandObj.min;
      max = catBandObj.max;

      // calculate the band width
      if (_i === loopMin) {
        // without the padding there is a gap before the starting plotband
        bandWidth = increment + mathAbs(axis.getValue(0)) + 1;
      } else if (_i === loopMax) {
        bandWidth = increment + mathAbs(axis.getValue(canvasRight - canvasLeft) - max);
      } else {
        bandWidth = increment;
      }

      axisAttrObj = {
        fill: catBandObj.fill,
        'stroke-width': catBandObj['stroke-width']
      };

      // attached attributes
      if (isVertical) {
        // y-axis
        axisAttrObj.x = canvasLeft;
        axisAttrObj.y = _i === loopMax ? axis.getPixel(_i - mathAbs(increment), { wrtVisible: true }) : axis.getPixel(_i - mathAbs(bandWidth), { wrtVisible: true });
        axisAttrObj.width = canvasWidth;
        axisAttrObj.height = mathAbs(bandWidth * pvr);
      } else {
        // x-axis
        axisAttrObj.x = _i === loopMax ? axis.getPixel(_i - mathAbs(increment), { wrtVisible: true }) : axis.getPixel(_i - mathAbs(bandWidth), { wrtVisible: true });
        axisAttrObj.y = canvasTop;
        axisAttrObj.width = mathAbs(bandWidth * pvr);
        axisAttrObj.height = canvasHeight;
      }

      catBandElems = AxisRefVisuals._hasElements(catBandElemsArr, id + i);
      if (!catBandElems) {
        axisAttrObj.opacity = 0;
        catBandElems = axisRefVisualsComp.addGraphicalElement('catBandElems', paper.path(axisAttrObj, axisBandContainer), true);
        catBandElems.id = id + i;
      }

      if (state === 'resize') {
        chart.getFromEnv('animationManager').registerAnimation([{
          animType: animType,
          data: [{
            el: catBandElems,
            attrs: axisAttrObj
          }]
        }], 'default');
      } else {
        chart.getFromEnv('animationManager').registerAnimation([{
          animType: animType,
          data: [{
            el: catBandElems,
            attrs: {
              opacity: 1
            },
            animConfig: [{
              hookFn: hookFn.bind(catBandElems, axisAttrObj, axisBandContainer)
            }]
          }]
        }], 'final');
      }
    }

    if (state !== 'resize') {
      for (i = 0; i < (catBandElemsArr && catBandElemsArr.length); i++) {
        catBandElems = catBandElemsArr[i];
        catBandElems && chart.getFromEnv('animationManager').registerAnimation([{
          animType: animType,
          data: [{
            el: catBandElems,
            attrs: {
              opacity: 0
            }
          }]
        }], 'initial');
      }
    }
  };

  AxisRefVisuals.prototype.createGroup = function createGroup() {
    var axisRefVisualsComp = this,
        canvas = axisRefVisualsComp.getLinkedParent(),
        axes = canvas.getAxes(),
        chart = axisRefVisualsComp.getFromEnv('chart'),
        paper = chart.getFromEnv('paper'),
        chartConfig = chart.config,
        animType = chart.get('config', 'animationObj').animType,
        canvasLeft = canvas.config.canvasLeft || chartConfig.canvasLeft,
        canvasTop = canvas.config.canvasTop || chartConfig.canvasTop,
        canvasHeight = canvas.config.canvasHeight || chartConfig.canvasHeight,
        canvasWidth = canvas.config.canvasWidth || chartConfig.canvasWidth,
        axisReferenceVisualsBottom = canvas.getChildContainer('axisReferenceVisualsBottom'),
        axisReferenceVisualsTop = canvas.getChildContainer('axisReferenceVisualsTop'),
        redraw = function redraw() {
      axisRefVisualsComp.asyncDraw();
    },
        i,
        ii;

    if (!axisReferenceVisualsBottom.attrs['clip-rect']) {
      axisReferenceVisualsBottom.attr({
        'clip-rect': canvasLeft + ',' + canvasTop + ',' + canvasWidth + ',' + canvasHeight
      });
    } else {
      chart.getFromEnv('animationManager').registerAnimation([{
        animType: animType,
        data: [{
          el: axisReferenceVisualsBottom,
          attrs: {
            'clip-rect': canvasLeft + ',' + canvasTop + ',' + canvasWidth + ',' + canvasHeight
          }
        }]
      }], 'axis');
    }

    if (!axisReferenceVisualsTop.attrs['clip-rect']) {
      axisReferenceVisualsTop.attr({
        'clip-rect': canvasLeft + ',' + canvasTop + ',' + canvasWidth + ',' + canvasHeight
      });
    } else {
      chart.getFromEnv('animationManager').registerAnimation([{
        animType: animType,
        data: [{
          el: axisReferenceVisualsTop,
          attrs: {
            'clip-rect': canvasLeft + ',' + canvasTop + ',' + canvasWidth + ',' + canvasHeight
          }
        }]
      }], 'axis');
    }

    axisReferenceVisualsTop.attr({
      'clip-rect': canvasLeft + ',' + canvasTop + ',' + canvasWidth + ',' + canvasHeight
    });

    !canvas.getContainer('bandGroup') && canvas.addContainer('bandGroup', paper.group('bands', axisReferenceVisualsBottom));
    !canvas.getContainer('lineBottomGroup') && canvas.addContainer('lineBottomGroup', paper.group('lines', axisReferenceVisualsBottom));
    !canvas.getContainer('trendBottomGroup') && canvas.addContainer('trendBottomGroup', paper.group('trends', axisReferenceVisualsBottom));

    !canvas.getContainer('lineTopGroup') && canvas.addContainer('lineTopGroup', paper.group('lines', axisReferenceVisualsTop));
    !canvas.getContainer('trendTopGroup') && canvas.addContainer('trendTopGroup', paper.group('trends', axisReferenceVisualsTop));

    if (!axisRefVisualsComp.config.isListeningToAxis) {
      for (i = 0, ii = axes.length; i < ii; i++) {
        axes[i].axis.addEventListener('visiblerangeset', redraw);
      }
      axisRefVisualsComp.config.isListeningToAxis = true;
    }
  };

  AxisRefVisuals.prototype.draw = function draw(onlyY) {
    var axisRefVisualsComp = this,
        parent = axisRefVisualsComp.getLinkedParent(),
        axes = parent.getAxes(),
        i,
        axis,
        len = axes.length;
    len > 0 && axisRefVisualsComp.createGroup();

    for (i = 0; i < len; i++) {
      axis = axes[i].axis;
      // Skipping the drawing of refvisuals related to yaxis
      if (onlyY && !axis.config.isVertical) {
        continue;
      }
      axisRefVisualsComp._drawPlotLine(axis, 'axis_' + i);
      axisRefVisualsComp._drawPlotBand(axis, 'axis_' + i);
      axisRefVisualsComp._drawCategoryPlotBand(axis, 'axis_' + i);
      axisRefVisualsComp._drawCategoryVline(axis, 'axis_' + i);
      axisRefVisualsComp._drawTrendLine(axis, 'axis_' + i);
    }
  };

  return AxisRefVisuals;
}(_componentInterface2['default']);

exports['default'] = AxisRefVisuals;

/***/ }),
/* 404 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = __webpack_require__(52)
  , $find   = __webpack_require__(84)(5)
  , KEY     = 'find'
  , forced  = true;
// Shouldn't skip holes
if(KEY in [])Array(1)[KEY](function(){ forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn/*, that = undefined */){
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(130)(KEY);

/***/ }),
/* 405 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__(9);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(10);

var _symbol2 = _interopRequireDefault(_symbol);

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _typeof = typeof _symbol2['default'] === "function" && typeof _iterator2['default'] === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2['default'] === "function" && obj.constructor === _symbol2['default'] && obj !== _symbol2['default'].prototype ? "symbol" : typeof obj; };

var _lib = __webpack_require__(5);

var _componentInterface = __webpack_require__(6);

var _componentInterface2 = _interopRequireDefault(_componentInterface);

var _eventApi = __webpack_require__(7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var UNDEF = void 0,
    convertColor = _lib.graphics.convertColor,
    RGBtoHex = _lib.graphics.RGBtoHex,
    HEXtoRGB = _lib.graphics.HEXtoRGB,
    getLightColor = _lib.graphics.getLightColor,
    getValidColor = _lib.graphics.getValidColor,
    compositionKeys = {},
    TRACKER_FILL = 'rgba(192,192,192,' + (_lib.isIE ? 0.002 : 0.000001) + ')',
    legendManager = void 0,
    FORMER_SLIDER_INDEX = false,
    LATER_SLIDER_INDEX = true,
    PERCENT_STR = '%',
    COMMA_STR = ',',
    DEF_COLOR = '#000000',
    hasOwnProp = {}.hasOwnProperty,
    M = 'M',
    L = 'L',
    animType = 'easeIn',
    componentPoolFactory = void 0,
    universalPool = {};

// Utility functions

/*
 * Recursively merges two objects.
 * Source is object from where the properties will be copied and sink is destination object where the props are to
 * be copied. If the property is already present in sink, it wont copy the property.
 *
 * Example:                         After merging the sink will be changed and returned
 * src = {      | sink = {      |   sink = {
 *  a: 1,       |   b: 33,      |       a: 1,
 *  b: 2,       |   c: 44,      |       b: 33,
 *  obj1: {     |   obj2: {     |       c: 44,
 *      m: 1,   |       w: 11,  |       obj1: {
 *      n: 2    |       x: 22   |           m: 1,
 *  },          | }             |           n: 2
 *  obj2: {     |               |       },
 *      x: 1,   |               |       obj2: {
 *      y: 2,   |               |           w: 11,
 *      z: 3    |               |           x: 22,
 *  }           |               |           y: 2,
 * }            |               |           z: 3
 *              |               |       }
 *              |               |   }
 *
 * @param: source {Object} - The object from where the props are to be copied
 * @param: sink {Object} - The object where the props are to be merged
 * @return {Object} - The reference to the sink object which was passed
 */
function merge(source, sink) {
  (function rec(source, sink) {
    var sourceVal, prop;

    for (prop in source) {
      // Iterates for every property in souce
      if (!hasOwnProp.call(source, prop)) {
        // Igoners if the property does not belong to the object directly, it might resides on the prototype
        // chain
        continue;
      }

      sourceVal = source[prop];
      if (sink[prop] === UNDEF) {
        // Assigns the value / ref if the value of the same property is UNDEF (it's not checked whether
        // the key is directly or indirectly present on the object) in the sink.
        sink[prop] = sourceVal;
      } else if ((typeof sourceVal === 'undefined' ? 'undefined' : _typeof(sourceVal)) === 'object' && sourceVal !== null) {
        // If the value is another object recursively perform the merging.

        // @todo check if the value is function, array etc. If it happens this will execute unpredictively,
        // Its not implmented because it would more condition.
        rec(sourceVal, sink[prop]);
      }
    }
  })(source, sink);

  return sink;
}

/*
 * Takes care of sanity checking of the color to some extent.
 * If no color is passed, ie called as getValidHexColor() it returns the default color. If incorrect color is passed
 * it returns false.
 *
 * @param code {String} - color code in string
 * @return {String | Boolean} - false if invalid color is passed, otherwise the same color or default color if no
 *                              no color is passed
 */
function getValidHexColor(code) {
  var color = code || DEF_COLOR;

  return getValidColor(color) || DEF_COLOR;
}

/*
 * Returns the opposite LIGHT color of a color. If the color is alraedy light, wont get much difference.
 *
 * @param code {String} - color code in string
 * @return {String} - Lightest (approx) color code of the color sent
 */
function getOppositeColor(code) {
  return getLightColor(code, 1);
}

function getColorBetween(range1, range2, value) {
  /* jshint newcap: false */
  var value1 = range1.value,
      code1 = range1.code,
      rgb1 = HEXtoRGB(code1),
      value2 = range2.value,
      code2 = range2.code,
      rgb2 = HEXtoRGB(code2),
      diff,
      rgb;

  diff = value2 - value1;

  rgb = [Math.round(rgb1[0] + (rgb2[0] - rgb1[0]) / diff * (value - value1)), Math.round(rgb1[1] + (rgb2[1] - rgb1[1]) / diff * (value - value1)), Math.round(rgb1[2] + (rgb2[2] - rgb1[2]) / diff * (value - value1))];

  return RGBtoHex(rgb);
  /* jshint newcap: true */
}

function normalizeFontSizeAppend(obj) {
  var fontSize = obj.fontSize + '',
      normalizeFontSize;

  if (!fontSize) {
    return obj;
  }

  normalizeFontSize = fontSize.replace(/(\d+)(px)*/, '$1px');
  obj.fontSize = normalizeFontSize;

  return obj;
}

function isInvalid(arg) {
  if (arg === UNDEF || typeof arg === 'undefined' || arg === null || isNaN(arg)) {
    return true;
  }

  return false;
}

compositionKeys.CAPTION = 'CAPTION';
compositionKeys.LEGEND_BODY = 'LEGEND_BODY';
compositionKeys.AXIS_LABEL = 'LEGEND_LABEL';
compositionKeys.LEGEND_AXIS = 'LEGEND_AXIS';
compositionKeys.RANGE = 'RANGE';
compositionKeys.AXIS_VALUE = 'AXIS_VALUE';

legendManager = function () {
  var chart,
      defaultConf = {};

  defaultConf.legendCarpetConf = {
    spreadFactor: 0.85,
    allowDrag: false,
    captionAlignment: 'center',
    padding: {
      v: 3,
      h: 3
    },
    style: {
      'fill': '#e4d9c1',
      'stroke': '#c4b89d'
    }
  };

  defaultConf.legendCaptionConf = {
    spreadFactor: 0.2,
    padding: {
      v: 2,
      h: 2
    },
    style: {
      fill: '#786B50',
      fontFamily: 'sans-serif',
      fontSize: '12px',
      fontWeight: 'bold',
      fontStyle: 'normal'
    },
    bound: {
      style: {
        stroke: 'none'
      }
    }
  };

  defaultConf.legendBodyConf = {
    spreadFactor: 0.8,
    padding: {
      v: 2,
      h: 2
    },
    bound: {
      style: {
        stroke: 'none'
      }
    }
  };

  defaultConf.legendAxisConf = {
    legendAxisHeight: 11,
    spreadFactor: 0.4,
    padding: {
      v: 1,
      h: 1
    },
    style: {
      stroke: 'none',
      'stroke-opacity': 0,
      'stroke-width': 1
    },
    line: {
      grooveLength: 3,
      offset: 8,
      style: {
        stroke: 'rgba(255, 255, 255, 0.65)',
        'stroke-width': 1.5
      }
    },
    shadow: {
      style: {
        stroke: 'none',
        fill: (0, _lib.toRaphaelColor)({
          FCcolor: {
            alpha: '25,0,0',
            angle: 360,
            color: '000000,FFFFFF,FFFFFF',
            ratio: '0,30,40'
          }
        })
      }
    },
    bound: {
      style: {
        stroke: 'none'
      }
    }
  };

  defaultConf.sliderGroupConf = {
    showTooltip: 1,
    outerCircle: {
      rFactor: 1.4,
      style: {
        fill: TRACKER_FILL,
        stroke: '#757575',
        'stroke-width': 3
      }
    },
    innerCircle: {
      rFactor: 0.65,
      style: {
        fill: TRACKER_FILL,
        stroke: '#FFFFFF'
      }
    }
  };

  defaultConf.axisTextItemConf = {
    spreadFactor: 0.3,
    padding: {
      v: 1,
      h: 1
    },
    style: {
      fill: '#786B50',
      fontFamily: 'sans-serif',
      fontSize: '12px',
      fontWeight: 'normal',
      fontStyle: 'normal'
    }
  };

  function normalizePreprocessedData(confArr) {
    var numberFormatter = chart.getFromEnv('number-formatter'),
        index,
        length,
        rawVal;

    for (index = 0, length = confArr.length; index < length; index++) {
      rawVal = confArr[index].maxvalue;

      if (!rawVal) {
        continue;
      }

      confArr[index].maxvalue = numberFormatter.getCleanValue(rawVal);
    }
  }

  return {
    init: function init(options) {
      chart = options.chart;
      // layers = chart.graphics;
      // components = chart.components;
    },

    // setConf: function (conf) {
    //   config = conf;
    // },

    legacyDataParser: function legacyDataParser(data, extremes) {
      var colormanagerConf = {},
          numberFormatter = chart.getFromEnv('number-formatter'),
          colorConfArr,
          colorConf,
          startColor,
          endColor,
          index,
          validColor,
          length,
          colorRange,
          value,
          dispValue,
          mapByPercent,
          isMaxValPresent;

      if (!data) {
        return false;
      }

      colormanagerConf.mapByPercent = mapByPercent = !!(0, _lib.pluckNumber)(data.mapbypercent, 0);
      colorConfArr = data.color || [];

      if (data.minvalue === UNDEF) {
        data.minvalue = extremes.min !== UNDEF ? mapByPercent ? 0 : extremes.min : 0;
      }

      if (data.maxvalue === UNDEF) {
        data.maxvalue = extremes.max !== UNDEF ? mapByPercent ? 100 : extremes.max : 100;
      }

      isMaxValPresent = false;
      for (index = 0, length = colorConfArr.length; index < length; index++) {
        if (colorConfArr[index].maxvalue) {
          isMaxValPresent = true;
          break;
        }
      }

      if (!isMaxValPresent) {
        colorConfArr = [];
      }

      startColor = data.code;

      colorRange = colormanagerConf.colorRange = [];
      colormanagerConf.gradient = !!(0, _lib.pluckNumber)(data.gradient, 1);

      // If no additional color array is provided as part of generating the gradient, creates the start and
      // end value to create the gradient
      if (!colorConfArr.length) {
        if (startColor) {
          // If start color is mentioned, create a gradient starting from default color to the mentioned
          // color
          endColor = getValidHexColor(startColor);
          startColor = getValidHexColor();
        } else {
          // If no color is mentioned, create a gradient of two opposite color
          startColor = getValidHexColor();
          endColor = getOppositeColor(startColor);
        }

        colorConfArr.push({
          code: endColor,
          maxvalue: data.maxvalue,
          label: UNDEF
        });
      } else {
        startColor = getValidHexColor(startColor);
      }

      normalizePreprocessedData(colorConfArr);

      colorConfArr = colorConfArr.sort(function (m, n) {
        return m.maxvalue - n.maxvalue;
      });

      value = dispValue = data.minvalue && numberFormatter.getCleanValue(data.minvalue);
      dispValue = (value !== UNDEF || value !== null) && (mapByPercent ? value + PERCENT_STR : numberFormatter.legendValue(value));
      colorRange.push({
        code: (0, _lib.dehashify)(startColor),
        value: value,
        displayValue: dispValue,
        label: data.startlabel
      });

      for (index = 0, length = colorConfArr.length; index < length; index++) {
        colorConf = colorConfArr[index];
        validColor = getValidHexColor(colorConf.code || colorConf.color);

        value = dispValue = colorConf.maxvalue;

        if (isNaN(parseInt(value, 10))) {
          continue;
        }

        dispValue = (value !== UNDEF || value !== null) && (mapByPercent ? value + PERCENT_STR : numberFormatter.legendValue(value));

        colorRange.push({
          code: (0, _lib.dehashify)(validColor),
          value: value,
          displayValue: dispValue,
          label: colorConf.label || colorConf.displayvalue
        });
      }

      colorRange[colorRange.length - 1].label = data.endlabel || colorConf.label;

      return colormanagerConf;
    },

    getDefaultConf: function getDefaultConf(key) {
      return defaultConf[key];
    }
  };
}();

componentPoolFactory = function componentPoolFactory(chart) {
  var chartId = chart.chartInstance.id,
      pool = universalPool[chartId] || (universalPool[chartId] = {});

  return function () {
    var elemTypes,
        actions = {},
        paper;

    elemTypes = {
      KEY_RECT: 'rect',
      KEY_TEXT: 'text',
      KEY_GROUP: 'group',
      KEY_CIRCLE: 'circle',
      KEY_PATH: 'path'
    };

    actions[elemTypes.KEY_RECT] = function (group) {
      return paper.rect(group);
    };

    actions[elemTypes.KEY_TEXT] = function (attr, group) {
      return paper.text(attr, group);
    };

    actions[elemTypes.KEY_GROUP] = function (groupName, parentGroup) {
      return paper.group(groupName, parentGroup);
    };

    actions[elemTypes.KEY_CIRCLE] = function (group) {
      return paper.circle(group);
    };

    actions[elemTypes.KEY_PATH] = function (pathStr, group) {
      return paper.path(pathStr, group);
    };

    function _hideRecursive() {
      var keyLevel1, keyLevel2, objLevel1, val, index, length;

      for (keyLevel1 in pool) {
        objLevel1 = pool[keyLevel1];

        for (keyLevel2 in objLevel1) {
          val = objLevel1[keyLevel2];

          if (val instanceof Array) {
            for (index = 0, length = val.length; index < length; index++) {
              val[index] && val[index].hide();
            }
          } else {
            val.hide();
          }
        }
      }
    }

    return {
      init: function init(renderer) {
        paper = renderer;

        _hideRecursive();
      },

      emptyPool: function emptyPool() {
        pool = universalPool[chartId] = {};
      },

      getChart: function getChart() {
        return chart;
      },

      getComponent: function getComponent(id, elemType, storeTillReCall) {
        var idSpecificPool = pool[id],
            multiInstance,
            instance,
            inst,
            instanceRetrieved = 0;

        if (!idSpecificPool) {
          idSpecificPool = pool[id] = {};
        }

        instance = idSpecificPool[elemType];

        if (instance && !(instance instanceof Array) || instance instanceof Array && instance.length > 0) {
          return function () {
            if (storeTillReCall) {
              inst = instance[instanceRetrieved++];
              if (inst) {
                return inst.show();
              } else {
                return instance[instanceRetrieved] = actions[elemType].apply(this, arguments);
              }
            }

            return instance.show();
          };
        }

        return function () {
          if (storeTillReCall) {
            multiInstance = idSpecificPool[elemType] || (idSpecificPool[elemType] = []);
            instance = actions[elemType].apply(this, arguments);
            multiInstance.push(instance);

            return instance.show();
          }

          return idSpecificPool[elemType] = actions[elemType].apply(this, arguments);
        };
      },

      hideAll: function hideAll() {
        _hideRecursive();
      },

      getKeys: function getKeys() {
        return elemTypes;
      }
    };
  }();
};

function LegendBase(carpet, componentPool) {
  this.carpet = carpet;
  this._componentPool = componentPool;
}

LegendBase.prototype.constructor = LegendBase;

LegendBase.prototype.draw = function (options) {
  options.componentPool = this._componentPool;
  return this.carpet.draw(options);
};

LegendBase.prototype.getLogicalSpace = function (options, recalculate) {
  options.componentPool = this._componentPool;
  return this.carpet.getLogicalSpace(options, recalculate);
};

LegendBase.prototype.dispose = function () {
  this.carpet && this.carpet.group && this.carpet.group.remove();
  this._componentPool.emptyPool();
};

function LegendCarpet(conf) {
  this.conf = conf;
  this._id = 'GL_CARPET';

  // Save the components which are the building block of the whole legend. Like: The background rect,
  // text, slider, color axis etc.
  this.compositionsByCategory = {};
  this.node = UNDEF;
  this.group = UNDEF;
  this._lSpace = UNDEF;
  this.autoRecalculate = false;
  this.groupName = 'fc-gradient-legend';
  this.moveInstructions = {};
}

LegendCarpet.prototype.constructor = LegendCarpet;

LegendCarpet.prototype.addCompositions = function (instance, category) {
  this.compositionsByCategory[category] = instance;
};

LegendCarpet.prototype.getBoundingBox = function (options) {
  var conf = this.conf,
      spreadFactor = conf.spreadFactor,
      refSide = options.refSide,
      alignment = options.alignment,
      refOffset = options.refOffset,
      x = options.x,
      y = options.y,
      lWidth;

  lWidth = conf.width = refSide * spreadFactor;

  if (alignment && (x === UNDEF || x === null)) {
    x = (refOffset + refSide) / 2 - lWidth / 2;
  }

  return {
    width: lWidth,
    height: options.maxOtherSide,
    x: x,
    y: y
  };
};

LegendCarpet.prototype.getPostCalcDecisions = function (bBox, componentsArea) {
  var conf = this.conf,
      padding = conf.padding,
      cat,
      totalHeightTaken = 0;

  for (cat in componentsArea) {
    totalHeightTaken += componentsArea[cat].height || 0;
  }

  bBox.height = totalHeightTaken + 2 * padding.v;
};

LegendCarpet.prototype.getLogicalSpace = function (options, recalculate) {
  var lSpace = this._lSpace,
      conf = this.conf,
      padding = conf.padding,
      compositionsByCategory = this.compositionsByCategory,
      composition,
      bBox,
      effectivePlotArea,
      compositionLSPace,
      compositionHeight = 0,
      componentsArea = {},
      category,
      compositionPlotArea,

  // autoRecalculate,
  heightNotUsed = 0;

  if (lSpace && !recalculate) {
    lSpace.isImpure = true;
    // If logical space has already been calculated and recalculate flag is on, return without recalculating.
    return lSpace;
  } /* else {
    autoRecalculate = false;
    } */

  lSpace = this._lSpace = bBox = this.getBoundingBox(options);

  if (isInvalid(lSpace.x) || isInvalid(lSpace.y) || isInvalid(lSpace.height) || isInvalid(lSpace.width)) {
    this.autoRecalculate = true;
  }

  // Copy the props
  effectivePlotArea = merge(bBox, {});

  // The logical rect inside which the composition are drawn
  effectivePlotArea.height -= 2 * padding.v;
  effectivePlotArea.width -= 2 * padding.h;
  effectivePlotArea.x += padding.h;
  effectivePlotArea.y += padding.v;

  for (category in compositionsByCategory) {
    composition = compositionsByCategory[category];

    compositionPlotArea = merge(effectivePlotArea, {});
    compositionPlotArea.y += compositionHeight;
    compositionHeight = effectivePlotArea.height * composition.conf.spreadFactor;
    compositionPlotArea.height = compositionHeight + heightNotUsed;

    compositionLSPace = composition.getLogicalSpace(merge(compositionPlotArea, {}), options, recalculate);

    heightNotUsed = compositionPlotArea.height - compositionLSPace.height;

    componentsArea[category] = compositionLSPace;

    compositionHeight = compositionLSPace.height;
  }

  this.getPostCalcDecisions(bBox, componentsArea);

  this._lSpace = bBox;
  return bBox;
};

LegendCarpet.prototype.setupDragging = function () {
  var group = this.group,
      dx = 0,
      dy = 0,
      idx = 0,
      idy = 0;

  group.css({ cursor: 'move' });
  group.drag(function (_dx, _dy) {
    dx = _dx;
    dy = _dy;
    group.attr({
      transform: 't' + (idx + dx) + ',' + (idy + dy)
    });
  }, function () {
    idx += dx;
    idy += dy;
  }, _lib.stubFN);
};

LegendCarpet.prototype.draw = function (options) {
  var conf = this.conf,
      compositionsByCategory = this.compositionsByCategory,
      paper = options.paper,
      parentGroup = options.parentGroup,
      componentPool = options.componentPool,
      chart = componentPool.getChart(),
      group,

  // node,
  category,
      composition,
      lSpace,

  // compositionRes,
  animDuration = chart.get('config', 'animationObj').duration,
      instanceFn,
      keys = componentPool.getKeys();

  this.getLogicalSpace(options, this.autoRecalculate);
  lSpace = this._lSpace;

  instanceFn = componentPool.getComponent(this._id, keys.KEY_GROUP);
  this.group = group = instanceFn(this.groupName, parentGroup);

  group.attr({
    opacity: 0
  });

  group.animate({
    opacity: 1
  }, animDuration, animType);

  // The main rect outside all the composition
  instanceFn = componentPool.getComponent(this._id, keys.KEY_RECT);
  this.node = instanceFn(group).attr(lSpace).css(conf.style);

  for (category in compositionsByCategory) {
    composition = compositionsByCategory[category];

    composition.draw(conf.captionAlignment, lSpace, {
      colorRange: options.colorRange,
      numberFormatter: options.numberFormatter,
      paper: paper,
      parentLayer: group,
      smartLabel: options.smartLabel,
      moveInstructions: this.moveInstructions[category],
      componentPool: options.componentPool
    });
  }

  conf.allowDrag && this.setupDragging();
  return this.node;
};

function VerticalLegendCarpet() {
  LegendCarpet.apply(this, arguments);
}

VerticalLegendCarpet.prototype = (0, _create2['default'])(LegendCarpet.prototype);
VerticalLegendCarpet.prototype.constructor = VerticalLegendCarpet;

VerticalLegendCarpet.prototype.getBoundingBox = function (options) {
  var conf = this.conf,
      spreadFactor = conf.spreadFactor,
      refSide = options.refSide,
      alignment = options.alignment,
      refOffset = options.refOffset,
      x = options.x,
      y = options.y,
      lHeight;

  lHeight = conf.height = refSide * spreadFactor;

  if (alignment && (y === UNDEF || y === null)) {
    y = (refOffset + refSide) / 2 - lHeight / 2;
  }

  return {
    width: options.maxOtherSide,
    height: lHeight,
    x: x,
    y: y
  };
};

VerticalLegendCarpet.prototype.getPostCalcDecisions = function (bBox, componentsArea) {
  var conf = this.conf,
      padding = conf.padding,
      maxWidth = Number.NEGATIVE_INFINITY,
      width,
      cat,
      move = this.moveInstructions,
      diff;

  LegendCarpet.prototype.getPostCalcDecisions.apply(this, arguments);

  for (cat in componentsArea) {
    width = componentsArea[cat].width;
    maxWidth = maxWidth < width ? width : maxWidth;
  }

  bBox.width = maxWidth + 2 * padding.h;

  for (cat in componentsArea) {
    width = componentsArea[cat].width;
    diff = maxWidth - width;
    if (diff) {
      move[cat] = 't' + diff / 2 + ',0';
    }
  }
};

function LegendCaption(text, conf) {
  this.rawText = text;
  this.conf = conf;
  this._id = 'GL_CAPTION';

  this.node = UNDEF;
  this.bound = UNDEF;
  this._lSpace = UNDEF;
}

LegendCaption.prototype.constructor = LegendCaption;

LegendCaption.LEFT = {
  x: function x(smartText, boundingBox) {
    return boundingBox.x + smartText.width / 2 + 2;
  }
};

LegendCaption.RIGHT = {
  x: function x(smartText, boundingBox) {
    return boundingBox.x + boundingBox.width - smartText.width / 2 - 2;
  }
};

LegendCaption.CENTER = {
  x: function x() {
    var boundingBox = arguments[1];
    return boundingBox.x + boundingBox.width / 2;
  }
};

LegendCaption.prototype.getLogicalSpace = function (bBox, options, recalculate) {
  var conf = this.conf,
      padding = conf.padding,
      lSpace = this._lSpace,
      text = this.rawText,
      componentPool = options.componentPool,
      chart = componentPool.getChart(),
      smartLabel,
      effectivePlotArea,
      smartText,
      copyOfStyle;

  if (lSpace && !recalculate) {
    lSpace.isImpure = true;
    // If logical space has already been calculated and recalculate flag is on, return without recalculating.
    return lSpace;
  }

  lSpace = this._lSpace = {
    bound: {
      height: 0,
      width: 0
    },

    node: {
      logicArea: UNDEF,
      smartText: UNDEF
    }
  };

  smartLabel = options.smartLabel;

  if (!text) {
    return lSpace.bound;
  }

  effectivePlotArea = merge(bBox, {});

  // The logical rect inside which the composition are drawn
  effectivePlotArea.height -= 2 * padding.v;
  effectivePlotArea.width -= 2 * padding.h;
  effectivePlotArea.x += padding.h;
  effectivePlotArea.y += padding.v;

  smartLabel.useEllipsesOnOverflow(chart.config.useEllipsesWhenOverflow);
  copyOfStyle = merge(this.conf.style, {});
  normalizeFontSizeAppend(copyOfStyle);

  smartLabel.setStyle(this._metaStyle = copyOfStyle);
  smartText = smartLabel.getSmartText(text, effectivePlotArea.width, effectivePlotArea.height);

  effectivePlotArea.height = smartText.height;
  effectivePlotArea.width = smartText.width;

  bBox.height = smartText.height + 2 * padding.v;
  bBox.width = smartText.width + 2 * padding.h;

  lSpace.node.smartText = smartText;
  lSpace.node.logicArea = effectivePlotArea;
  lSpace.bound = bBox;

  return bBox;
};

LegendCaption.prototype.draw = function () {
  var conf = this.conf,

  // smartLabel,
  // paper,
  layer,
      boundAttr = conf.bound || {},
      group,
      bound,
      instanceFn,
      boundingArea,
      lSpace,
      normalizedX,
      x,
      bBox,
      options,
      node,
      componentPool,
      keys;

  if (arguments.length >= 3) {
    x = arguments[0];
    bBox = arguments[1];
    options = arguments[2];
  } else if (arguments.length >= 2) {
    x = arguments[0];
    options = arguments[1];
  }

  // smartLabel = options.smartLabel;
  // paper = options.paper;
  layer = options.parentLayer;
  componentPool = options.componentPool;
  keys = componentPool.getKeys();

  // Separate group for caption and the bounding rect
  instanceFn = componentPool.getComponent(this._id, keys.KEY_GROUP);
  this.group = group = instanceFn('legend-caption', layer).css(conf.style);

  // group = paper.group('legend-caption', layer);

  this.getLogicalSpace(bBox, options);
  lSpace = this._lSpace;

  node = lSpace.node;
  boundingArea = lSpace.bound;

  // Bounding rect
  instanceFn = componentPool.getComponent(this._id, keys.KEY_RECT);
  this.bound = bound = instanceFn(group).attr(boundingArea).css(boundAttr.style);
  // bound = this.bound = paper.rect(boundingArea, group).css(boundAttr.style);

  normalizedX = typeof x === 'string' ? LegendCaption[x.toUpperCase()].x(node.smartText, bBox || node.logicArea) : x;

  instanceFn = componentPool.getComponent(this._id, keys.KEY_TEXT);
  this.node = instanceFn({}, group).attr({
    text: node.smartText.text,
    x: normalizedX,
    y: node.logicArea.y + node.smartText.height / 2,
    lineHeight: this._metaStyle.lineHeight,
    fill: conf.style.fill
  });

  return {
    group: group,
    bound: bound,
    node: this.node
  };
};

function LegendBody(colorRange, conf, childTextConf) {
  this.colorRange = colorRange;
  this.conf = conf;
  this.childTextConf = childTextConf;
  this._id = 'GL_BODY';

  this.bound = UNDEF;
  this.compositionsByCategory = {};
  this._lSpace = UNDEF;
}

// Space calculation order
LegendBody.SC_STACK = [compositionKeys.AXIS_LABEL, compositionKeys.LEGEND_AXIS, compositionKeys.AXIS_VALUE];

LegendBody.DARW_STACK = [compositionKeys.AXIS_VALUE, compositionKeys.LEGEND_AXIS, compositionKeys.AXIS_LABEL];

LegendBody.prototype.constructor = LegendBody;

LegendBody.prototype.addCompositions = function (instance, category) {
  this.compositionsByCategory[category] = instance;
};

LegendBody.prototype.getCompositionPlotAreaFor = function (effectivePlotArea) {
  var plotArea;

  plotArea = merge(effectivePlotArea, {});

  return function (compositionAreaOffset, sf) {
    compositionAreaOffset = compositionAreaOffset || {};

    plotArea.y += compositionAreaOffset.height || 0;
    plotArea.height = effectivePlotArea.height * sf;

    return plotArea;
  };
};

LegendBody.prototype.getSpaceTaken = function (spaceObj) {
  return spaceObj.height;
};

LegendBody.prototype.updateEffectivePlotArea = function (bBox, effectivePlotArea, val) {
  var conf = this.conf,
      padding = conf.padding;

  effectivePlotArea.height = val;
  bBox.height = val + 2 * padding.v;
};

LegendBody.prototype.getLogicalSpace = function (bBox, options, recalculate) {
  var lSpace = this._lSpace,
      conf = this.conf,
      padding = conf.padding,
      compositionsByCategory = this.compositionsByCategory,
      composition,
      compositionPlotArea,
      compositionAreaOffset,
      effectivePlotArea,
      getCompositionPlotArea,
      spaceTaken = 0,
      index,
      length;

  if (lSpace && !recalculate) {
    lSpace.isImpure = true;
    // If logical space has already been calculated and recalculate flag is on, return without recalculating.
    return lSpace;
  }

  lSpace = this._lSpace = {
    bound: {
      height: 0,
      width: 0
    },

    node: {
      logicArea: UNDEF
    }
  };

  effectivePlotArea = merge(bBox, {});

  // The logical rect inside which the composition are drawn
  effectivePlotArea.height -= 2 * padding.v;
  effectivePlotArea.width -= 2 * padding.h;
  effectivePlotArea.x += padding.h;
  effectivePlotArea.y += padding.v;

  getCompositionPlotArea = this.getCompositionPlotAreaFor(effectivePlotArea);

  options.colorRange = this.colorRange;

  for (index = 0, length = LegendBody.SC_STACK.length; index < length; index++) {
    if (!(composition = compositionsByCategory[LegendBody.SC_STACK[index]])) {
      continue;
    }

    compositionPlotArea = getCompositionPlotArea(compositionAreaOffset, composition.conf.spreadFactor);
    compositionAreaOffset = composition.getLogicalSpace(merge(compositionPlotArea, {}), options, recalculate);

    spaceTaken += this.getSpaceTaken(compositionAreaOffset);
  }

  this.updateEffectivePlotArea(bBox, effectivePlotArea, spaceTaken);

  lSpace.node.logicArea = effectivePlotArea;
  lSpace.bound = bBox;

  return bBox;
};

LegendBody.prototype.draw = function () {
  var childTextConf = this.childTextConf,
      conf = this.conf,
      boundStyle = conf.bound.style || {},
      compositionsByCategory = this.compositionsByCategory,

  // paper,
  layer,
      bound,

  // colorRange,
  composition,
      legendBodyGroup,
      bBox,
      componentPool,
      lSpace,

  // x,
  options,
      index,
      length,
      instanceFn,
      keys;

  if (arguments.length >= 3) {
    // x = arguments[0];
    bBox = arguments[1];
    options = arguments[2];
  } else if (arguments.length >= 2) {
    // x = arguments[0];
    options = arguments[1];
  }

  // paper = options.paper;
  layer = options.parentLayer;
  // colorRange = options.colorRange;
  componentPool = options.componentPool;
  keys = componentPool.getKeys();

  this.getLogicalSpace(bBox, options);
  lSpace = this._lSpace;
  instanceFn = componentPool.getComponent(this._id, keys.KEY_GROUP);
  legendBodyGroup = instanceFn('legend-body', layer).attr({
    transform: 't0,0'
  }).css(childTextConf.style);
  // legendBodyGroup = paper.group('legend-body', layer);

  instanceFn = componentPool.getComponent(this._id, keys.KEY_RECT);
  this.bound = bound = instanceFn(legendBodyGroup).attr(lSpace.bound).css(boundStyle);
  // bound = this.bound = paper.rect(lSpace.bound, legendBodyGroup).css(boundStyle);

  options.colorRange = this.colorRange;
  options.parentLayer = legendBodyGroup;
  for (index = 0, length = LegendBody.DARW_STACK.length; index < length; index++) {
    if (!(composition = compositionsByCategory[LegendBody.DARW_STACK[index]])) {
      continue;
    }

    composition.draw(options);
  }

  if (options.moveInstructions) {
    legendBodyGroup.attr({
      transform: options.moveInstructions
    });
  }

  return {
    bound: bound,
    group: legendBodyGroup
  };
};

function VerticalLegendBody() {
  LegendBody.apply(this, arguments);
}

VerticalLegendBody.prototype = (0, _create2['default'])(LegendBody.prototype);
VerticalLegendBody.prototype.constructor = VerticalLegendBody;

VerticalLegendBody.prototype.getCompositionPlotAreaFor = function (effectivePlotArea) {
  var plotArea;

  plotArea = merge(effectivePlotArea, {});

  return function (compositionAreaOffset, sf) {
    compositionAreaOffset = compositionAreaOffset || {};

    plotArea.x += compositionAreaOffset.width || 0;
    plotArea.width = effectivePlotArea.width * sf;

    return plotArea;
  };
};

VerticalLegendBody.prototype.updateEffectivePlotArea = function (bBox, effectivePlotArea, val) {
  var conf = this.conf,
      padding = conf.padding;

  effectivePlotArea.width = val;
  bBox.width = val + 2 * padding.h;
};

VerticalLegendBody.prototype.getSpaceTaken = function (spaceObj) {
  return spaceObj.width;
};

function LegendLabels(conf) {
  this.conf = conf;
  this._id = 'GL_LABELS';
}

LegendLabels.prototype.constructor = LegendLabels;

LegendLabels.prototype.getEffectivePlotArea = function (area) {
  var conf = this.conf,
      padding = conf.padding;

  // The logical rect inside which the composition are drawn
  area.height -= 2 * padding.v;
  area.width -= 2 * padding.h;
  area.x += padding.h;
  area.y += padding.v;
  this.node = [];

  return area;
};

LegendLabels.prototype.getLogicalSpace = function (bBox, options, recalculate) {
  var lSpace = this._lSpace,
      conf = this.conf,
      padding = conf.padding,
      cRange,
      smartLabel,
      crDataObj,
      index,
      length,
      labelHeights = [],
      leftBound,
      rightBound,
      plotArea,
      label,
      valueRatio,
      stop,
      zerothStop,
      lsTexts,
      maxHeight,
      effectivePlotArea,
      testSmartLabel,

  // noOfLabels = 0,
  nextRefPoint,
      currPoint,
      leftStop,
      smartText,
      ni,
      copyOfStyle,
      componentPool = options.componentPool,
      chart = componentPool.getChart(),
      normalizedDataArr = [];

  if (lSpace && !recalculate) {
    lSpace.isImpure = true;
    // If logical space has already been calculated and recalculate flag is on, return without recalculating.
    return lSpace;
  }

  cRange = options.colorRange;
  smartLabel = options.smartLabel;
  valueRatio = cRange.getCumulativeValueRatio();
  crDataObj = cRange.colorRange;

  lSpace = this._lSpace = {
    bound: {
      height: 0,
      width: 0
    },

    node: {
      logicArea: UNDEF,
      smartTexts: []
    }
  };

  lsTexts = lSpace.node.smartTexts;

  plotArea = merge(bBox, {});

  // The logical rect inside which the composition are drawn
  effectivePlotArea = this.getEffectivePlotArea(plotArea);

  smartLabel.useEllipsesOnOverflow(chart.config.useEllipsesWhenOverflow);
  copyOfStyle = merge(conf.style, {});
  normalizeFontSizeAppend(this._metaStyle = copyOfStyle);

  smartLabel.setStyle(copyOfStyle);
  testSmartLabel = smartLabel.getSmartText('W');

  for (index = 0, length = crDataObj.length; index < length; index++) {
    label = crDataObj[index].label;

    if (!label) {
      lsTexts[index] = UNDEF;
      continue;
    }

    // noOfLabels++;
    normalizedDataArr.push({
      oriIndex: index,
      label: label
    });
  }

  length = normalizedDataArr.length;

  if (length === 0) {
    return {
      height: 0,
      width: 0
    };
  }

  if (length > 1) {
    stop = (valueRatio[normalizedDataArr[length - 1].oriIndex] - valueRatio[normalizedDataArr[0].oriIndex]) / 2 * effectivePlotArea.width / 100;
  } else {
    stop = Math.max(valueRatio[normalizedDataArr[0].oriIndex], 100 - valueRatio[normalizedDataArr[0].oriIndex]) / 2 * effectivePlotArea.width / 100;
  }

  zerothStop = stop;

  // first scale Label
  smartText = smartLabel.getSmartText(normalizedDataArr[0].label, zerothStop, effectivePlotArea.height);
  smartText.x = valueRatio[normalizedDataArr[0].oriIndex] * effectivePlotArea.width / 100;
  leftBound = smartText.x + smartText.width;
  labelHeights.push(smartText.height);
  lsTexts[normalizedDataArr[0].oriIndex] = smartText;

  // last scale label
  smartText = smartLabel.getSmartText(normalizedDataArr[length - 1].label, zerothStop, effectivePlotArea.height);
  smartText.x = valueRatio[normalizedDataArr[length - 1].oriIndex] * effectivePlotArea.width / 100;
  rightBound = smartText.x - smartText.width;
  labelHeights.push(smartText.height);
  lsTexts[normalizedDataArr[length - 1].oriIndex] = smartText;

  leftStop = leftBound;
  for (index = 1; index < length - 1; index++) {
    label = normalizedDataArr[index].label;
    ni = normalizedDataArr[index].oriIndex;

    smartText = UNDEF;

    nextRefPoint = index + 1 === length - 1 ? rightBound : valueRatio[normalizedDataArr[index + 1].oriIndex] * effectivePlotArea.width / 100;

    currPoint = valueRatio[normalizedDataArr[index].oriIndex] * effectivePlotArea.width / 100;

    stop = Math.min(currPoint - leftStop, nextRefPoint - currPoint);

    if (stop > 2 * testSmartLabel.width) {
      smartText = smartLabel.getSmartText(label, stop, effectivePlotArea.height);
      smartText.x = valueRatio[ni] * effectivePlotArea.width / 100;

      leftStop = stop;
      labelHeights.push(smartText.height);
    }

    lsTexts[normalizedDataArr[index].oriIndex] = smartText;
  }

  maxHeight = Math.max.apply(Math, labelHeights);

  effectivePlotArea.height = maxHeight;
  bBox.height = maxHeight + 2 * padding.v;

  lSpace.node.logicArea = effectivePlotArea;
  lSpace.bound = bBox;

  return bBox;
};

LegendLabels.prototype.draw = function () {
  var layer,
      bound,
      conf = this.conf,
      boundStyle = conf.bound && conf.bound.style || {
    stroke: 'none'
  },

  // cRange,
  componentPool,
      legendLabelsGroup,
      bBox,
      smartText,
      lSpace,

  // crDataObj,
  // valueRatio,
  options,
      index,
      logicArea,
      lsTexts,
      length,
      pos = {},
      instanceFn,
      keys;

  if (arguments.length >= 2) {
    bBox = arguments[0];
    options = arguments[1];
  } else if (arguments.length >= 1) {
    options = arguments[0];
  }

  // paper = options.paper;
  layer = options.parentLayer;
  // cRange = options.colorRange;
  // valueRatio = cRange.getCumulativeValueRatio();
  // crDataObj = cRange.colorRange;
  componentPool = options.componentPool;
  keys = componentPool.getKeys();

  this.getLogicalSpace(bBox, options);
  lSpace = this._lSpace;
  logicArea = lSpace.node.logicArea;
  lsTexts = lSpace.node.smartTexts;

  instanceFn = componentPool.getComponent(this._id, keys.KEY_GROUP);
  legendLabelsGroup = instanceFn('legend-labels', layer);

  instanceFn = componentPool.getComponent(this._id, keys.KEY_RECT);
  this.bound = bound = instanceFn(legendLabelsGroup).attr(lSpace.bound).css(boundStyle);

  // legendLabelsGroup.transform('R0');

  instanceFn = componentPool.getComponent(this._id, keys.KEY_TEXT, true);
  for (index = 0, length = lsTexts.length; index < length; index++) {
    smartText = lsTexts[index];

    if (!smartText) {
      continue;
    }

    pos.y = logicArea.y + smartText.height / 2;

    if (index === length - 1) {
      pos.x = logicArea.x + smartText.x - smartText.width / 2;
    } else if (index) {
      pos.x = logicArea.x + smartText.x;
    } else {
      pos.x = logicArea.x + smartText.x + smartText.width / 2;
    }

    this.node.push(instanceFn({}, legendLabelsGroup).attr({
      text: smartText.text,
      x: pos.x,
      y: pos.y,
      lineHeight: this._metaStyle.lineHeight,
      fill: conf.style.fill
    }).transform('R0'));
  }

  return {
    group: legendLabelsGroup,
    bound: bound,
    node: this.node
  };
};

function VerticalLegendLabels() {
  LegendLabels.apply(this, arguments);
}

VerticalLegendLabels.prototype = (0, _create2['default'])(LegendLabels.prototype);
VerticalLegendLabels.prototype.constructor = VerticalLegendLabels;

VerticalLegendLabels.prototype.getLogicalSpace = function (bBox, options, recalculate) {
  var lSpace = this._lSpace,
      conf = this.conf,
      padding = conf.padding,
      cRange,
      smartLabel,
      crDataObj,
      index,
      length,
      labelHeights = [],
      leftBound,
      rightBound,
      plotArea,
      label,
      valueRatio,
      stop,
      zerothStop,
      lsTexts,
      maxHeight,
      effectivePlotArea,
      testSmartLabel,

  // noOfLabels = 0,
  nextRefPoint,
      currPoint,
      leftStop,
      smartText,
      ni,
      copyOfStyle,
      componentPool = options.componentPool,
      chart = componentPool.getChart(),
      normalizedDataArr = [];

  if (lSpace && !recalculate) {
    lSpace.isImpure = true;
    // If logical space has already been calculated and recalculate flag is on, return without recalculating.
    return lSpace;
  }

  cRange = options.colorRange;
  smartLabel = options.smartLabel;
  valueRatio = cRange.getCumulativeValueRatio();
  crDataObj = cRange.colorRange;

  lSpace = this._lSpace = {
    bound: {
      height: 0,
      width: 0
    },

    node: {
      logicArea: UNDEF,
      smartTexts: []
    }
  };

  lsTexts = lSpace.node.smartTexts;

  plotArea = merge(bBox, {});

  // The logical rect inside which the composition are drawn
  effectivePlotArea = this.getEffectivePlotArea(plotArea);

  smartLabel.useEllipsesOnOverflow(chart.config.useEllipsesWhenOverflow);
  copyOfStyle = merge(conf.style, {});
  normalizeFontSizeAppend(this._metaStyle = copyOfStyle);

  smartLabel.setStyle(copyOfStyle);
  testSmartLabel = smartLabel.getSmartText('W');

  for (index = 0, length = crDataObj.length; index < length; index++) {
    label = crDataObj[index].label;

    if (!label) {
      lsTexts[index] = UNDEF;
      continue;
    }

    // noOfLabels++;
    normalizedDataArr.push({
      oriIndex: index,
      label: label
    });
  }

  length = normalizedDataArr.length;

  if (length === 0) {
    return {
      height: 0,
      width: 0
    };
  }

  if (length > 1) {
    stop = (valueRatio[normalizedDataArr[length - 1].oriIndex] - valueRatio[normalizedDataArr[0].oriIndex]) / 2 * effectivePlotArea.height / 100;
  } else {
    stop = Math.max(valueRatio[normalizedDataArr[0].oriIndex], 100 - valueRatio[normalizedDataArr[0].oriIndex]) / 2 * effectivePlotArea.height / 100;
  }

  zerothStop = stop;

  // first scale Label
  smartText = smartLabel.getSmartText(normalizedDataArr[0].label, zerothStop, effectivePlotArea.width);
  smartText.y = valueRatio[normalizedDataArr[0].oriIndex] * effectivePlotArea.height / 100;
  leftBound = smartText.y + smartText.width;
  labelHeights.push(smartText.height);
  lsTexts[normalizedDataArr[0].oriIndex] = smartText;

  // last scale label
  smartText = smartLabel.getSmartText(normalizedDataArr[length - 1].label, zerothStop, effectivePlotArea.width);
  smartText.y = valueRatio[normalizedDataArr[length - 1].oriIndex] * effectivePlotArea.height / 100;
  rightBound = smartText.y - smartText.width;
  labelHeights.push(smartText.height);
  lsTexts[normalizedDataArr[length - 1].oriIndex] = smartText;

  leftStop = leftBound;
  for (index = 1; index < length - 1; index++) {
    label = normalizedDataArr[index].label;
    ni = normalizedDataArr[index].oriIndex;

    smartText = UNDEF;

    nextRefPoint = index + 1 === length - 1 ? rightBound : valueRatio[normalizedDataArr[index + 1].oriIndex] * effectivePlotArea.height / 100;

    currPoint = valueRatio[normalizedDataArr[index].oriIndex] * effectivePlotArea.height / 100;

    stop = Math.min(currPoint - leftStop, nextRefPoint - currPoint);

    if (stop > 2 * testSmartLabel.width) {
      smartText = smartLabel.getSmartText(label, stop, effectivePlotArea.width);
      smartText.y = valueRatio[ni] * effectivePlotArea.height / 100;

      leftStop = stop;
      labelHeights.push(smartText.height);
    }

    lsTexts[normalizedDataArr[index].oriIndex] = smartText;
  }

  maxHeight = Math.max.apply(Math, labelHeights);

  effectivePlotArea.width = maxHeight;
  bBox.width = maxHeight + 2 * padding.v;

  lSpace.node.logicArea = effectivePlotArea;
  lSpace.bound = bBox;

  return bBox;
};

VerticalLegendLabels.prototype.draw = function () {
  var layer,
      bound,
      conf = this.conf,
      boundStyle = conf.bound && conf.bound.style || {
    stroke: 'none'
  },

  // cRange,
  componentPool,
      legendLabelsGroup,
      bBox,
      smartText,
      lSpace,

  // crDataObj,
  // valueRatio,
  options,
      index,
      logicArea,
      lsTexts,
      length,
      pos = {},
      instanceFn,
      keys;

  if (arguments.length >= 2) {
    bBox = arguments[0];
    options = arguments[1];
  } else if (arguments.length >= 1) {
    options = arguments[0];
  }

  // paper = options.paper;
  layer = options.parentLayer;
  // cRange = options.colorRange;
  // valueRatio = cRange.getCumulativeValueRatio();
  // crDataObj = cRange.colorRange;
  componentPool = options.componentPool;
  keys = componentPool.getKeys();

  this.getLogicalSpace(bBox, options);
  lSpace = this._lSpace;
  logicArea = lSpace.node.logicArea;
  lsTexts = lSpace.node.smartTexts;

  instanceFn = componentPool.getComponent(this._id, keys.KEY_GROUP);
  legendLabelsGroup = instanceFn('legend-labels', layer);

  instanceFn = componentPool.getComponent(this._id, keys.KEY_RECT);
  this.bound = bound = instanceFn(legendLabelsGroup).attr(lSpace.bound).css(boundStyle);

  instanceFn = componentPool.getComponent(this._id, keys.KEY_TEXT, true);
  for (index = 0, length = lsTexts.length; index < length; index++) {
    smartText = lsTexts[index];

    if (!smartText) {
      continue;
    }

    pos.x = logicArea.x + smartText.height / 2;

    if (index === length - 1) {
      pos.y = logicArea.y + smartText.y - smartText.width / 2;
    } else if (index) {
      pos.y = logicArea.y + smartText.y;
    } else {
      pos.y = logicArea.y + smartText.y + smartText.width / 2;
    }

    this.node.push(instanceFn({}, legendLabelsGroup).attr({
      text: smartText.text,
      x: pos.x,
      y: pos.y,
      lineHeight: this._metaStyle.lineHeight,
      fill: conf.style.fill
    }).transform('R270,' + pos.x + ',' + pos.y));
  }

  return {
    group: legendLabelsGroup,
    bound: bound,
    node: this.node
  };
};

function LegendValues() {
  LegendLabels.apply(this, arguments);
  this._id = 'GL_VALUES';
}

LegendValues.prototype = (0, _create2['default'])(LegendLabels.prototype);
LegendValues.prototype.constructor = LegendValues;

LegendValues.prototype.getLogicalSpace = function (bBox, options, recalculate) {
  var lSpace = this._lSpace,
      conf = this.conf,
      padding = conf.padding,
      componentPool = options.componentPool,
      chart = componentPool.getChart(),
      cRange,
      smartLabel,
      crDataObj,
      smartText,
      index,
      length,
      valueRatio,
      stop,
      nextRefPoint,
      currPoint,
      zerothStop,
      labelHeights = [],
      leftBound,
      leftStop,
      rightBound,
      maxHeight,
      effectivePlotArea,
      val,
      dispValue,
      testSmartLabel,
      copyOfStyle,
      lsTexts;

  if (lSpace && !recalculate) {
    lSpace.isImpure = true;
    // If logical space has already been calculated and recalculate flag is on, return without recalculating.
    return lSpace;
  }

  cRange = options.colorRange;
  smartLabel = options.smartLabel;
  crDataObj = cRange.colorRange;
  valueRatio = cRange.getCumulativeValueRatio();

  lSpace = this._lSpace = {
    bound: {
      height: 0,
      width: 0
    },

    node: {
      logicArea: UNDEF,
      smartTexts: []
    }
  };

  lsTexts = lSpace.node.smartTexts;
  effectivePlotArea = merge(bBox, {});

  // The logical rect inside which the composition are drawn
  effectivePlotArea.height -= 2 * padding.v;
  effectivePlotArea.width -= 2 * padding.h;
  effectivePlotArea.x += padding.h;
  effectivePlotArea.y += padding.v;

  smartLabel.useEllipsesOnOverflow(chart.config.useEllipsesWhenOverflow);
  copyOfStyle = merge(conf.style, {});
  normalizeFontSizeAppend(this._metaStyle = copyOfStyle);

  smartLabel.setStyle(copyOfStyle);
  testSmartLabel = smartLabel.getSmartText('W');

  length = crDataObj.length;
  zerothStop = stop = (valueRatio[length - 1] - valueRatio[0]) / 2 * effectivePlotArea.width / 100;

  // first scale Label
  dispValue = crDataObj[0].displayValue;
  smartText = smartLabel.getSmartText(typeof dispValue !== 'string' && dispValue !== UNDEF && dispValue.toString() || dispValue, zerothStop, effectivePlotArea.height);
  smartText.x = valueRatio[0] * effectivePlotArea.width / 100;
  leftBound = smartText.x + smartText.width;
  labelHeights.push(smartText.height);
  lsTexts[0] = smartText;

  // last scale label
  smartText = smartLabel.getSmartText(crDataObj[length - 1].displayValue, zerothStop, effectivePlotArea.height);
  smartText.x = valueRatio[length - 1] * effectivePlotArea.width / 100;
  rightBound = smartText.x - smartText.width;
  labelHeights.push(smartText.height);
  lsTexts[length - 1] = smartText;

  leftStop = leftBound;
  for (index = 1; index < length - 1; index++) {
    smartText = UNDEF;

    val = crDataObj[index].displayValue;

    nextRefPoint = index + 1 === length - 1 ? rightBound : valueRatio[index + 1] * effectivePlotArea.width / 100;
    currPoint = valueRatio[index] * effectivePlotArea.width / 100;

    stop = Math.min(currPoint - leftStop, nextRefPoint - currPoint);

    if (stop > 1.5 * testSmartLabel.width) {
      smartText = smartLabel.getSmartText(val, 2 * stop, effectivePlotArea.height);
      smartText.x = valueRatio[index] * effectivePlotArea.width / 100;
      leftStop = stop;
      labelHeights.push(smartText.height);
    }

    lsTexts[index] = smartText;
  }

  maxHeight = Math.max.apply(Math, labelHeights);

  effectivePlotArea.height = maxHeight;
  bBox.height = maxHeight + 2 * padding.v;

  lSpace.node.logicArea = effectivePlotArea;
  lSpace.bound = bBox;

  return bBox;
};

LegendValues.prototype.draw = function () {
  var conf = this.conf,
      boundStyle = conf.bound && conf.bound.style || {
    stroke: 'none'
  },
      keys,
      pos = {},

  // paper,
  layer,
      bound,
      legendValuesGroup,
      componentPool,
      bBox,
      lSpace,

  // smartLabel,
  logicArea,
      options,
      cRange,
      valueRatio,
      index,
      length,
      smartTexts,
      smartText,
      instanceFn;

  if (arguments.length >= 2) {
    bBox = arguments[0];
    options = arguments[1];
  } else if (arguments.length >= 1) {
    options = arguments[0];
  }

  // paper = options.paper;
  layer = options.parentLayer;
  // smartLabel = options.smartLabel;
  cRange = options.colorRange;
  // numberFormatter = options.numberFormatter,
  valueRatio = cRange.getCumulativeValueRatio();
  componentPool = options.componentPool;
  keys = componentPool.getKeys();

  this.getLogicalSpace(bBox, options);
  lSpace = this._lSpace;
  logicArea = lSpace.node.logicArea;
  smartTexts = lSpace.node.smartTexts;

  instanceFn = componentPool.getComponent(this._id, keys.KEY_GROUP);
  legendValuesGroup = instanceFn('legend-values', layer);

  instanceFn = componentPool.getComponent(this._id, keys.KEY_RECT);
  this.bound = bound = instanceFn(legendValuesGroup).attr(lSpace.bound).css(boundStyle);

  instanceFn = componentPool.getComponent(this._id, keys.KEY_TEXT, true);
  for (index = 0, length = valueRatio.length; index < length; index++) {
    smartText = smartTexts[index];

    if (!smartText) {
      continue;
    }

    pos.y = logicArea.y + smartText.height / 2;

    if (index === length - 1) {
      pos.x = logicArea.x + smartText.x - smartText.width / 2;
    } else if (index) {
      pos.x = logicArea.x + smartText.x;
    } else {
      pos.x = logicArea.x + smartText.x + smartText.width / 2;
    }

    instanceFn({}, legendValuesGroup).attr({
      text: smartText.text,
      x: pos.x,
      y: pos.y,
      lineHeight: this._metaStyle.lineHeight,
      fill: conf.style.fill
    });
  }

  return {
    group: legendValuesGroup,
    bound: bound
  };
};

function VerticalLegendValues() {
  LegendValues.apply(this, arguments);
  this._id = 'GL_VALUES';
}

VerticalLegendValues.prototype = (0, _create2['default'])(LegendValues.prototype);
VerticalLegendValues.prototype.constructor = VerticalLegendValues;

VerticalLegendValues.prototype.getLogicalSpace = function (bBox, options, recalculate) {
  var lSpace = this._lSpace,
      conf = this.conf,
      padding = conf.padding,
      componentPool = options.componentPool,
      chart = componentPool.getChart(),
      cRange,
      smartLabel,
      crDataObj,
      smartText,
      index,
      length,
      valueRatio,
      stop,
      nextRefPoint,
      currPoint,
      effectivePlotArea,
      zerothStop,
      labelWidths = [],
      topBound,
      topStop,
      maxWidth,
      bottomBound,
      val,
      copyOfStyle,
      testSmartLabel,
      lsTexts;

  if (lSpace && !recalculate) {
    lSpace.isImpure = true;
    // If logical space has already been calculated and recalculate flag is on, return without recalculating.
    return lSpace;
  }

  cRange = options.colorRange;
  smartLabel = options.smartLabel;
  crDataObj = cRange.colorRange;
  valueRatio = cRange.getCumulativeValueRatio();

  lSpace = this._lSpace = {
    bound: {
      height: 0,
      width: 0
    },

    node: {
      logicArea: UNDEF,
      smartTexts: []
    }
  };

  lsTexts = lSpace.node.smartTexts;
  effectivePlotArea = merge(bBox, {});

  // The logical rect inside which the composition are drawn
  effectivePlotArea.height -= 2 * padding.v;
  effectivePlotArea.width -= 2 * padding.h;
  effectivePlotArea.x += padding.h;
  effectivePlotArea.y += padding.v;

  smartLabel.useEllipsesOnOverflow(chart.config.useEllipsesWhenOverflow);
  copyOfStyle = merge(conf.style, {});
  normalizeFontSizeAppend(copyOfStyle);

  smartLabel.setStyle(this._metaStyle = copyOfStyle);
  testSmartLabel = smartLabel.getSmartText('W');

  length = crDataObj.length;
  zerothStop = stop = (valueRatio[length - 1] - valueRatio[0]) / 2 * effectivePlotArea.height / 100;

  // first scale Label
  smartText = smartLabel.getSmartText(crDataObj[0].displayValue, effectivePlotArea.width, zerothStop);
  smartText.y = valueRatio[0] * effectivePlotArea.height / 100;
  topBound = smartText.y + smartText.width;
  labelWidths.push(smartText.width);
  lsTexts[0] = smartText;

  // last scale label
  smartText = smartLabel.getSmartText(crDataObj[length - 1].displayValue, effectivePlotArea.width, zerothStop);
  smartText.y = valueRatio[length - 1] * effectivePlotArea.height / 100;
  bottomBound = smartText.y - smartText.height;
  labelWidths.push(smartText.width);
  lsTexts[length - 1] = smartText;

  topStop = topBound;
  for (index = 1; index < length - 1; index++) {
    smartText = UNDEF;

    val = crDataObj[index].displayValue;

    nextRefPoint = index + 1 === length - 1 ? bottomBound : valueRatio[index + 1] * effectivePlotArea.height / 100;
    currPoint = valueRatio[index] * effectivePlotArea.height / 100;

    stop = Math.min(currPoint - topStop, nextRefPoint - currPoint);

    if (stop > 2 * testSmartLabel.height) {
      smartText = smartLabel.getSmartText(val, effectivePlotArea.width, 2 * stop);
      smartText.y = valueRatio[index] * effectivePlotArea.height / 100;

      topStop = stop;
      labelWidths.push(smartText.width);
    }

    lsTexts[index] = smartText;
  }

  maxWidth = Math.max.apply(Math, labelWidths);

  effectivePlotArea.width = maxWidth;
  bBox.width = maxWidth + 2 * padding.h;

  lSpace.node.logicArea = effectivePlotArea;
  lSpace.bound = bBox;

  return bBox;
};

VerticalLegendValues.prototype.draw = function () {
  var layer,
      bound,
      conf = this.conf,
      boundStyle = conf.bound && conf.bound.style || {
    stroke: 'none'
  },
      legendValuesGroup,
      bBox,
      lSpace,

  // smartLabel,
  logicArea,
      options,
      cRange,
      valueRatio,
      smartTexts,
      smartText,
      index,
      length,
      pos = {},
      componentPool,
      instanceFn,
      keys;

  if (arguments.length >= 2) {
    bBox = arguments[0];
    options = arguments[1];
  } else if (arguments.length >= 1) {
    options = arguments[0];
  }

  // paper = options.paper;
  layer = options.parentLayer;
  // smartLabel = options.smartLabel,
  cRange = options.colorRange;
  valueRatio = cRange.getCumulativeValueRatio();
  componentPool = options.componentPool;
  keys = componentPool.getKeys();

  this.getLogicalSpace(bBox, options);
  lSpace = this._lSpace;
  logicArea = lSpace.node.logicArea;
  smartTexts = lSpace.node.smartTexts;

  instanceFn = componentPool.getComponent(this._id, keys.KEY_GROUP);
  legendValuesGroup = instanceFn('legend-values', layer);

  instanceFn = componentPool.getComponent(this._id, keys.KEY_RECT);
  this.bound = bound = instanceFn(legendValuesGroup).attr(lSpace.bound).css(boundStyle);

  instanceFn = componentPool.getComponent(this._id, keys.KEY_TEXT, true);
  for (index = 0, length = valueRatio.length; index < length; index++) {
    smartText = smartTexts[index];

    if (!smartText) {
      continue;
    }

    pos.x = logicArea.x + smartText.width / 2;

    if (index === length - 1) {
      pos.y = logicArea.y + smartText.y - smartText.height / 2;
    } else if (index) {
      pos.y = logicArea.y + smartText.y;
    } else {
      pos.y = logicArea.y + smartText.y + smartText.height / 2;
    }

    instanceFn({}, legendValuesGroup).attr({
      text: smartText.text,
      x: pos.x,
      y: pos.y,
      lineHeight: this._metaStyle.lineHeight,
      fill: conf.style.fill
    });
  }

  return {
    group: legendValuesGroup,
    bound: bound
  };
};

function LegendAxis(conf) {
  this.conf = conf;
  this._id = 'FL_AXIS';

  this.node = UNDEF;
  this.shadow = UNDEF;
  this.markerLine = UNDEF;
  this.compositionsByCategory = {};
}

LegendAxis.prototype.constructor = LegendAxis;

LegendAxis.prototype.addCompositions = function (instance, category) {
  this.compositionsByCategory[category] = instance;
};

LegendAxis.prototype.getLogicalSpace = function () {
  var bBox = arguments[0],
      recalculate = arguments[2],
      lSpace = this._lSpace,
      conf = this.conf,
      padding = conf.padding,
      heightTakenLower,
      heightTakenUpper,
      heightTaken,
      axisThickness = conf.legendAxisHeight,
      compositionsByCategory = this.compositionsByCategory,
      sliderG,
      effectivePlotArea,
      slider,
      sliderSpace,
      sliderExtraDiam = 0;

  if (lSpace && !recalculate) {
    lSpace.isImpure = true;
    // If logical space has already been calculated and recalculate flag is on, return without recalculating.
    return lSpace;
  }

  lSpace = this._lSpace = {
    bound: {
      height: 0,
      width: 0
    },

    node: {
      logicArea: UNDEF
    }
  };

  effectivePlotArea = merge(bBox, {});

  // The logical rect inside which the composition are drawn
  effectivePlotArea.height -= 2 * padding.v;
  effectivePlotArea.width -= 2 * padding.h;
  effectivePlotArea.x += padding.h;
  effectivePlotArea.y += padding.v;

  heightTakenLower = axisThickness / 2 + conf.line.offset;
  heightTakenUpper = axisThickness / 2;

  sliderG = compositionsByCategory[compositionKeys.RANGE];
  if (sliderG) {
    slider = sliderG.sliders['false'];
    sliderSpace = slider.conf.outerCircle.rFactor * axisThickness;
    heightTakenUpper += sliderExtraDiam = Math.max(sliderSpace / 2 - axisThickness / 2, 0);
  }

  // @todo Change the height and width of bBox
  effectivePlotArea.y += sliderExtraDiam;
  effectivePlotArea.height = heightTaken = heightTakenUpper + heightTakenLower + sliderExtraDiam;
  bBox.height = heightTaken + 2 * padding.v;

  lSpace.node.logicArea = effectivePlotArea;
  lSpace.bound = bBox;

  return bBox;
};

LegendAxis.prototype.getDrawableAxisArea = function (parentBoundingRect) {
  var conf = this.conf,
      x = parentBoundingRect.x,
      y = parentBoundingRect.y,
      width = parentBoundingRect.width,
      height = conf.legendAxisHeight,
      r = conf.legendAxisHeight / 2;

  return {
    x: x,
    y: y,
    width: width,
    height: height,
    r: r
  };
};

LegendAxis.prototype.preDrawingRangeParam = function (drawableArea) {
  var y = drawableArea.y + drawableArea.height / 2,
      calculationBase = drawableArea.height;

  return {
    y: y,
    calculationBase: calculationBase,
    rangeStart: drawableArea.x,
    rangeEnd: drawableArea.x + drawableArea.width,
    prop: 'y'
  };
};

LegendAxis.prototype.getScaleMarkerPathStr = function (oriAxisRect, valueRatio) {
  var axisRect = merge(oriAxisRect, {}),
      conf = this.conf,
      lineAttr = conf.line,
      index,
      length,
      ratio,
      covered,
      markerStartY,
      tickStr = '',
      lineStr = '';

  axisRect.x += axisRect.r;
  axisRect.width -= 2 * axisRect.r;
  markerStartY = axisRect.y + axisRect.height;

  for (index = 0, length = valueRatio.length; index < length; index++) {
    ratio = valueRatio[index];
    covered = axisRect.x + ratio * axisRect.width / 100;

    tickStr += M + covered + COMMA_STR + (markerStartY - lineAttr.grooveLength) + L + covered + COMMA_STR + (markerStartY + lineAttr.offset);
  }

  lineStr += M + axisRect.x + COMMA_STR + (markerStartY + lineAttr.offset) + L + (axisRect.x + axisRect.width) + COMMA_STR + (markerStartY + lineAttr.offset);

  return tickStr + lineStr;
};

LegendAxis.prototype.getColorGradient = function (colorRange) {
  return {
    axis: colorRange.getBoxFill(),
    shadow: (0, _lib.toRaphaelColor)({
      FCcolor: {
        alpha: '25,0,0',
        angle: 90,
        color: '000000,FFFFFF,FFFFFF',
        ratio: '0,30,40'
      }
    })
  };
};

LegendAxis.prototype.draw = function () {
  var layer,

  // bound,
  conf = this.conf,
      boundAttr = conf.bound || {},
      lineAttr = conf.line,
      boundStyle = boundAttr.style || {},

  // node,
  bBox,
      category,
      compositionsByCategory = this.compositionsByCategory,
      cRange,
      valueRatio,
      composition,

  // compositionMes,
  legendAxisGroup,
      rangeParams,
      grad,
      oriAxisRect,
      lSpace,
      options,
      instanceFn,
      keys,
      componentPool,
      scaleLine;

  if (arguments.length >= 2) {
    bBox = arguments[0];
    options = arguments[1];
  } else if (arguments.length >= 1) {
    options = arguments[0];
  }

  // paper = options.paper;
  layer = options.parentLayer;
  cRange = options.colorRange;
  valueRatio = cRange.getCumulativeValueRatio();
  componentPool = options.componentPool;
  keys = componentPool.getKeys();

  this.getLogicalSpace(bBox, options);
  lSpace = this._lSpace;

  instanceFn = componentPool.getComponent(this._id, keys.KEY_GROUP);
  legendAxisGroup = instanceFn('legend-axis', layer);
  // legendAxisGroup = paper.group('legend-axis', layer);

  instanceFn = componentPool.getComponent(this._id, keys.KEY_RECT, true);

  this.bound = instanceFn(legendAxisGroup).attr(lSpace.bound).css(boundStyle);
  // bound = this.bound = paper.rect(lSpace.bound, legendAxisGroup).css(boundStyle);

  oriAxisRect = this.getDrawableAxisArea(lSpace.node.logicArea);
  grad = this.getColorGradient(cRange);
  conf.style.fill = grad.axis;
  conf.shadow.style.fill = grad.shadow;

  // node = this.node = paper.rect(oriAxisRect, legendAxisGroup).css(conf.style);
  // this.shadow = paper.rect(oriAxisRect, legendAxisGroup).css(conf.shadow.style);
  this.node = instanceFn(legendAxisGroup).attr(oriAxisRect).css(conf.style);
  this.shadow = instanceFn(legendAxisGroup).attr(oriAxisRect).css(conf.shadow.style);

  scaleLine = this.getScaleMarkerPathStr(oriAxisRect, valueRatio);
  instanceFn = componentPool.getComponent(this._id, keys.KEY_PATH);
  instanceFn('M0,0', legendAxisGroup).attr({ path: scaleLine }).css(lineAttr.style);

  for (category in compositionsByCategory) {
    composition = compositionsByCategory[category];

    switch (category) {
      case compositionKeys.RANGE:
        rangeParams = this.preDrawingRangeParam(oriAxisRect);

        options[rangeParams.prop] = rangeParams[rangeParams.prop];
        options.key = rangeParams.prop;
        options.rCalcBase = rangeParams.calculationBase;
        options.parentLayer = legendAxisGroup;

        composition.draw(rangeParams.rangeStart, rangeParams.rangeEnd, options);
    }
  }
};

function VerticalLegendAxis() {
  LegendAxis.apply(this, arguments);
}

VerticalLegendAxis.prototype = (0, _create2['default'])(LegendAxis.prototype);
VerticalLegendAxis.prototype.constructor = VerticalLegendAxis;

VerticalLegendAxis.prototype.getLogicalSpace = function () {
  var bBox = arguments[0],
      recalculate = arguments[2],
      lSpace = this._lSpace,
      conf = this.conf,
      padding = conf.padding,
      widthTakenLower,
      widthTakenUpper,
      widthTaken,
      axisThickness = conf.legendAxisHeight,
      compositionsByCategory = this.compositionsByCategory,
      sliderG,
      slider,
      effectivePlotArea,
      sliderSpace,
      sliderExtraDiam = 0;

  if (lSpace && !recalculate) {
    lSpace.isImpure = true;
    // If logical space has already been calculated and recalculate flag is on, return without recalculating.
    return lSpace;
  }

  lSpace = this._lSpace = {
    bound: {
      height: 0,
      width: 0
    },

    node: {
      logicArea: UNDEF
    }
  };

  effectivePlotArea = merge(bBox, {});

  // The logical rect inside which the composition are drawn
  effectivePlotArea.height -= 2 * padding.v;
  effectivePlotArea.width -= 2 * padding.h;
  effectivePlotArea.x += padding.h;
  effectivePlotArea.y += padding.v;

  widthTakenLower = axisThickness / 2 + conf.line.offset;
  widthTakenUpper = axisThickness / 2;

  sliderG = compositionsByCategory[compositionKeys.RANGE];
  if (sliderG) {
    slider = sliderG.sliders['false'];
    sliderSpace = slider.conf.outerCircle.rFactor * axisThickness;
    widthTakenUpper += sliderExtraDiam = Math.max(sliderSpace / 2 - axisThickness / 2, 0);
  }

  effectivePlotArea.x += sliderExtraDiam;
  effectivePlotArea.width = widthTaken = widthTakenUpper + widthTakenLower + sliderExtraDiam;
  bBox.width = widthTaken + 2 * padding.v;

  lSpace.node.logicArea = effectivePlotArea;
  lSpace.bound = bBox;

  return bBox;
};

VerticalLegendAxis.prototype.getDrawableAxisArea = function (parentBoundingRect) {
  var conf = this.conf;

  return {
    x: parentBoundingRect.x,
    y: parentBoundingRect.y,
    width: conf.legendAxisHeight,
    height: parentBoundingRect.height,
    r: conf.legendAxisHeight / 2
  };
};

VerticalLegendAxis.prototype.getScaleMarkerPathStr = function (oriAxisRect, valueRatio) {
  var axisRect = merge(oriAxisRect, {}),
      conf = this.conf,
      lineAttr = conf.line,
      index,
      ratio,
      length,
      markerStartX,
      covered,
      tickStr = '',
      lineStr = '';

  axisRect.y += axisRect.r;
  axisRect.height -= 2 * axisRect.r;
  markerStartX = axisRect.x + axisRect.width;

  for (index = 0, length = valueRatio.length; index < length; index++) {
    ratio = valueRatio[index];
    covered = axisRect.y + ratio * axisRect.height / 100;

    tickStr += M + (markerStartX - lineAttr.grooveLength) + COMMA_STR + covered + L + (markerStartX + lineAttr.offset) + COMMA_STR + covered;
  }

  lineStr += M + (markerStartX + lineAttr.offset) + COMMA_STR + axisRect.y + L + (markerStartX + lineAttr.offset) + COMMA_STR + (axisRect.y + axisRect.height);

  return tickStr + lineStr;
};

VerticalLegendAxis.prototype.getColorGradient = function (colorRange) {
  return {
    axis: colorRange.getBoxFill(true),
    shadow: (0, _lib.toRaphaelColor)({
      FCcolor: {
        alpha: '25,0,0',
        angle: 360,
        color: '000000,FFFFFF,FFFFFF',
        ratio: '0,30,40'
      }
    })
  };
};

VerticalLegendAxis.prototype.preDrawingRangeParam = function (drawableArea) {
  var x = drawableArea.x + drawableArea.width / 2,
      calculationBase = drawableArea.width;

  return {
    x: x,
    calculationBase: calculationBase,
    rangeStart: drawableArea.y,
    rangeEnd: drawableArea.y + drawableArea.height,
    prop: 'x'
  };
};

function Slider(sliderIndex, options, id) {
  this.conf = options.conf;
  this.sliderIndex = sliderIndex;
  this.rangeGroup = options.sliderGroup;
  this._id = id;

  this.node = UNDEF;
  this.tracker = UNDEF;
  this.currPos = 0;
  this.swing = [];
}

Slider.prototype.constructor = Slider;

Slider.prototype.updateSwingRange = function (index, value) {
  this.swing[+index] = value;
};

// @todo: Who should be responsible for reset, range or individual slider
// Slider.prototype.reset = function () {
//     var node = this.node,
//         tracker = this.tracker,
//         conf = this.conf,
//         dragAPI;

//     if (!node) {
//         return;
//     }

//     node.attr({
//         transform: 't0,0'
//     });

//     this.currPos = 0;
//     this.swing = [];

// };

Slider.prototype.draw = function (rangeStart, scaleVal, position, options) {
  var layer = options.parentLayer,
      conf = this.conf,
      ocConf = conf.outerCircle,
      icConf = conf.innerCircle,
      ocRadius = Math.ceil(ocConf.rFactor * options.rCalcBase / 2),
      icRadius = Math.ceil(icConf.rFactor * options.rCalcBase / 2),
      icThickness = ocRadius - icRadius,
      group,
      rangeGroup = this.rangeGroup,
      sliderIndex = this.sliderIndex,
      dragAPI,
      strokeWidthOffset,
      x,
      y,
      tracker,
      instanceFn,
      iniRange,
      componentPool = options.componentPool,
      keys = componentPool.getKeys();

  conf.outerRadius = ocRadius;
  conf.innerRadius = icRadius;

  this._scaleVal = scaleVal;

  icConf.style['stroke-width'] = icThickness;
  strokeWidthOffset = Math.ceil(ocConf.style['stroke-width'] / 2);
  icRadius += strokeWidthOffset;

  instanceFn = componentPool.getComponent(this._id, keys.KEY_GROUP);
  group = this.node = instanceFn('fc-gl-slider', layer).attr({
    'cursor': 'pointer',
    'transform': 't0,0'
  });

  if (options.key === 'x') {
    x = position;
    y = rangeStart;
    y += sliderIndex ? -icRadius : +icRadius;
    iniRange = y;
  } else {
    x = rangeStart;
    y = position;
    x += sliderIndex ? -icRadius : +icRadius;
    iniRange = x;
  }

  rangeGroup.initRange(this, iniRange);

  instanceFn = componentPool.getComponent(this._id, keys.KEY_CIRCLE, true);
  instanceFn(group).attr({
    cx: x,
    cy: y,
    r: ocRadius
  }).css(ocConf.style);
  instanceFn(group).attr({
    cx: x,
    cy: y,
    r: icRadius
  }).css(icConf.style);

  tracker = this.tracker = instanceFn(group).attr({
    cx: x,
    cy: y,
    r: ocRadius + 5,
    ishot: true,
    fill: TRACKER_FILL,
    stroke: 0,
    cursor: 'pointer'
  }).trackTooltip(!!conf.showTooltip).tooltip(scaleVal, null, null, true);

  this._dragAPI = dragAPI = this.getDragAPI(options.key === 'x');

  tracker.undrag();
  tracker.drag(dragAPI.dragging, dragAPI.dragStart, dragAPI.dragEnd);

  return {
    translateAscending: ocRadius + strokeWidthOffset
  };
};

Slider.prototype.getDragAPI = function (verticalDragging) {
  var self = this,
      node = self.node,
      index = self.sliderIndex,
      range = self.rangeGroup,
      swing,
      lastDisplacement,
      timeoutId,
      innerRadius = self.conf.innerRadius,
      spaceSaved = innerRadius,
      isDragged;

  return {
    dragging: function dragging(event) {
      var left, right, d;

      event.stopPropagation();
      event.preventDefault();

      if (verticalDragging) {
        d = event.data[1];
      } else {
        d = event.data[0];
      }

      if (index) {
        left = swing[0] - swing[1] + spaceSaved;
        right = 0;
      } else {
        left = 0;
        right = swing[1] - swing[0] - spaceSaved;
      }

      if (self.currPos + d < left || self.currPos + d > right) {
        return;
      }

      node.attr({
        transform: verticalDragging ? 't0,' + (self.currPos + d) : 't' + (self.currPos + d) + ',' + 0
      });

      lastDisplacement = d;

      timeoutId && clearTimeout(timeoutId);
      timeoutId = setTimeout(function () {
        range.updateWhenInRest(self, self.currPos + d);
      }, 100);

      self.tracker.tooltip(range.updateWhenInMove(self, self.currPos + d), null, null, true);
      isDragged = true;

      return true;
    },

    dragStart: function dragStart(event) {
      event.stopPropagation();
      event.preventDefault();

      node.attr({
        transform: verticalDragging ? 't0,' + self.currPos : 't' + self.currPos + ',' + 0
      });

      swing = swing || self.swing;

      isDragged = false;

      range.dragStarted(self);
    },

    dragEnd: function dragEnd() {
      var newPos;
      range.dragCompleted(self, isDragged, self.currPos + lastDisplacement);

      if (!isDragged) {
        return;
      }

      timeoutId && clearTimeout(timeoutId);
      timeoutId = setTimeout(function () {
        range.updateWhenInRest(self, self.currPos);
      }, 100);

      self.currPos += lastDisplacement;
      newPos = swing[+index] + self.currPos;
      range.updateRange(self, newPos);
    }
  };
};

function SliderGroup(conf) {
  var sliderConf = conf,
      options = {};

  this._id = 'GL_SG1';
  this.conf = conf;

  options.conf = sliderConf;

  this.extremes = [];
  this.sliders = {};

  options.sliderGroup = this;
  this.valueRange = [];
  this.callbacks = [];

  this.sliders[FORMER_SLIDER_INDEX] = new Slider(FORMER_SLIDER_INDEX, options, this._id + '_' + +FORMER_SLIDER_INDEX);
  this.sliders[LATER_SLIDER_INDEX] = new Slider(LATER_SLIDER_INDEX, options, this._id + '_' + +LATER_SLIDER_INDEX);
}

SliderGroup.prototype.constructor = SliderGroup;

SliderGroup.prototype.initRange = function (slider, updatedRange) {
  var sliderIndex = slider.sliderIndex;

  this.extremes[+sliderIndex] = updatedRange;
};

SliderGroup.prototype.updateRange = function (slider, updatedRange) {
  var sliderIndex = slider.sliderIndex,
      sliders = this.sliders,
      s = sliders[!sliderIndex];

  s.updateSwingRange(sliderIndex, updatedRange);
};

SliderGroup.prototype.reset = function () {
  var options = {};

  options.conf = this.conf;
  options.sliderGroup = this;

  // @todo do it from a more generalized way
  this.sliders[FORMER_SLIDER_INDEX] = new Slider(FORMER_SLIDER_INDEX, options, this._id + '_' + +FORMER_SLIDER_INDEX);
  this.sliders[LATER_SLIDER_INDEX] = new Slider(LATER_SLIDER_INDEX, options, this._id + '_' + +LATER_SLIDER_INDEX);

  this.draw.apply(this, this._drawParams);
};

SliderGroup.prototype.clearListeners = function () {
  this.callbacks.length = 0;
};

SliderGroup.prototype.draw = function (rangeStart, rangeEnd, options) {
  var sliders = this.sliders,
      lSlider = sliders[FORMER_SLIDER_INDEX],
      rSlider = sliders[LATER_SLIDER_INDEX],
      cRange = options.colorRange,
      colorRange = cRange.colorRange,
      componentPool = options.componentPool,
      chart = this._fcChart = componentPool.getChart(),
      oneSliderMes;

  this.getValueFormPixel = function (valueStart, valueEnd, pixelStart, pixelEnd) {
    var unit = (valueEnd - valueStart) / (pixelEnd - pixelStart);

    this.getValueFormPixel = function (pixel) {
      return valueStart + unit * pixel;
    };
  };

  this.updateWhenInMove = function (numberFormatter, mapByPercent) {
    this.updateWhenInMove = function (slider, val) {
      var extremes = this.extremes,
          sliderIndex = slider.sliderIndex,
          nVal,
          value;

      if (sliderIndex) {
        nVal = extremes[1] - extremes[0] + val;
      } else {
        nVal = val;
      }

      value = this.getValueFormPixel(nVal);

      if (!mapByPercent) {
        value = numberFormatter.legendValue(value);
      } else {
        value = parseFloat(value).toFixed(2) + PERCENT_STR;
      }

      return value;
    };
  };

  this._drawParams = [rangeStart, rangeEnd, options];
  this.updateWhenInMove(chart.components.numberFormatter, cRange.mapByPercent);

  oneSliderMes = lSlider.draw(rangeStart, colorRange[0].displayValue, options[options.key], options);
  oneSliderMes = rSlider.draw(rangeEnd, colorRange[colorRange.length - 1].displayValue, options[options.key], options);

  lSlider.swing = this.extremes.slice(0);
  rSlider.swing = this.extremes.slice(0);

  this.getValueFormPixel(colorRange[0].value, colorRange[colorRange.length - 1].value, this.extremes[0], this.extremes[1]);

  return oneSliderMes;
};

SliderGroup.prototype.registerListener = function (fn, context, params) {
  this.callbacks.push({
    fn: fn,
    context: context,
    params: params || []
  });
};

SliderGroup.prototype.updateWhenInRest = function (slider, val) {
  var sliders = this.sliders,
      extremes = this.extremes,
      sliderIndex = slider.sliderIndex,
      lValue,
      rValue,
      cIndex,
      cLength,
      callbacks = this.callbacks,
      cb,
      params;

  if (sliderIndex) {
    lValue = sliders[!sliderIndex].currPos;
    rValue = extremes[1] - extremes[0] + val;
  } else {
    lValue = val;
    rValue = extremes[1] - extremes[0] + sliders[!sliderIndex].currPos;
  }

  for (cIndex = 0, cLength = callbacks.length; cIndex < cLength; cIndex++) {
    cb = callbacks[cIndex];
    params = cb.params.slice(0);
    params.unshift(this.getValueFormPixel(rValue));
    params.unshift(this.getValueFormPixel(lValue));
    cb.fn.apply(cb.context, params);
  }
};

SliderGroup.prototype.dragStarted = function (self) {
  var sliders = this.sliders,
      extremes = this.extremes,
      conf = self.conf,
      chart = this._fcChart;

  (0, _eventApi.triggerEvent)('legendpointerdragstart', chart.chartInstance, {
    pointerIndex: +self.sliderIndex,
    pointers: [{
      value: this.getValueFormPixel(sliders['false'].currPos)
    }, {
      value: this.getValueFormPixel(extremes[1] - extremes[0] + sliders['true'].currPos)
    }],
    legendPointerHeight: conf.outerRadius,
    legendPointerWidth: conf.innerRadius,
    outerRadius: conf.outerRadius,
    innerRadius: conf.innerRadius
  }, [chart.id]);
};

SliderGroup.prototype.dragCompleted = function (self, isDragged, newVal) {
  var sliders = this.sliders,
      extremes = this.extremes,
      conf = self.conf,
      minValue = this.getValueFormPixel(sliders['false'].currPos),
      maxValue = this.getValueFormPixel(extremes[1] - extremes[0] + sliders['true'].currPos),
      chart = this._fcChart,
      newMinValue,
      newMaxValue;

  if (!self.sliderIndex) {
    newMinValue = this.getValueFormPixel(newVal);
    newMaxValue = maxValue;
  } else {
    newMinValue = minValue;
    newMaxValue = this.getValueFormPixel(extremes[1] - extremes[0] + newVal);
  }

  if (isDragged) {
    (0, _eventApi.triggerEvent)('legendrangeupdated', chart.chartInstance, {
      previousMinValue: minValue,
      previousMaxValue: maxValue,
      minValue: newMinValue,
      maxValue: newMaxValue
    }, [chart.id]);
  }

  (0, _eventApi.triggerEvent)('legendpointerdragstop', chart.chartInstance, {
    pointerIndex: +self.sliderIndex,
    pointers: [{
      value: minValue
    }, {
      value: maxValue
    }],
    legendPointerHeight: conf.outerRadius,
    legendPointerWidth: conf.innerRadius,
    outerRadius: conf.outerRadius,
    innerRadius: conf.innerRadius
  }, [chart.id]);
};

function ColorRange(data, options, chart) {
  var numberFormatter = chart.getFromEnv('number-formatter'),
      index,
      length,
      range,
      min,
      max,
      minRange,
      maxRange,
      minValue,
      maxValue,
      mapByPercent;

  this.data = data;
  this.options = options || {};
  mapByPercent = this.mapByPercent = !!data.mapByPercent;
  this.appender = '';

  min = this.mapByPercent ? 0 : options.min;
  max = this.mapByPercent ? 100 : options.max;

  if (data.colorRange.length === 2) {
    minRange = data.colorRange[0];
    maxRange = data.colorRange[1];

    minValue = minRange.value = isInvalid(minRange.value) ? min : minRange.value;
    maxValue = maxRange.value = isInvalid(maxRange.value) ? max : maxRange.value;

    if (minValue === maxValue) {
      minValue = minRange.value = min;
      maxValue = maxRange.value = max;
    }

    minRange.displayValue = mapByPercent ? minValue + PERCENT_STR : numberFormatter.legendValue(minValue);
    maxRange.displayValue = mapByPercent ? maxValue + PERCENT_STR : numberFormatter.legendValue(maxValue);
  }

  if (isInvalid(min) && isInvalid(minRange.value) || isInvalid(max) && isInvalid(minRange.value) || !data.gradient) {
    this._preparationGoneWrong = true;
  } else {
    this._preparationGoneWrong = false;
  }

  range = this.colorRange = data.colorRange.sort(function (m, n) {
    return m.value - n.value;
  });
  this.valueRatio = UNDEF;
  this.values = [];

  for (index = 0, length = range.length; index < length; index++) {
    this.values.push(range[index].value);
  }
}

ColorRange.prototype.constructor = ColorRange;

ColorRange.prototype.getValueRatio = function () {
  var colorRange = this.colorRange,
      currentRange,
      index,
      length = colorRange.length,
      ratio = this.valueRatio,
      maxValue = colorRange[length - 1].value,
      minValue = colorRange[0].value,
      range = maxValue - minValue,
      itemValuePercent,
      lastValue = 0;

  if (ratio) {
    return ratio;
  }

  ratio = this.valueRatio = [];
  for (index = 0; index < length; index++) {
    currentRange = colorRange[index];
    itemValuePercent = (currentRange.value - minValue) / range;

    ratio.push((itemValuePercent - lastValue) * 100);
    lastValue = itemValuePercent;
  }

  return ratio;
};

ColorRange.prototype.getCumulativeValueRatio = function () {
  var colorRange = this.colorRange,
      currentRange,
      index,
      length = colorRange.length,
      firstValue = colorRange[0].value,
      lastValue = colorRange[length - 1].value,
      ratio = [];

  for (index = 0; index < length; index++) {
    currentRange = colorRange[index];
    ratio.push((currentRange.value - firstValue) / (lastValue - firstValue) * 100);
  }
  return ratio;
};

ColorRange.prototype.getBoxFill = function (isVertical) {
  var colorRange = this.colorRange,
      currentRange,
      index,
      length = colorRange.length,
      color = [],
      raphColorArg,
      angle;

  angle = isVertical ? 90 : 0;

  for (index = 0; index < length; index++) {
    currentRange = colorRange[index];
    color.push(currentRange.code);
  }

  raphColorArg = {
    FCcolor: {
      alpha: '100,100,100',
      angle: angle,
      color: color.join(COMMA_STR),
      ratio: this.getValueRatio().join(COMMA_STR)
    }
  };

  return (0, _lib.toRaphaelColor)(raphColorArg);
};

ColorRange.prototype.getColorByValue = function (nVal) {
  var valueArr = this.values,
      colorRange = this.colorRange,
      length,
      index,
      rangeOutSideColor,
      color;

  if (nVal === UNDEF || nVal === null) {
    return;
  }

  for (index = 0, length = valueArr.length; index < length; index++) {
    if (nVal === valueArr[index]) {
      color = colorRange[index].code;
      break;
    } else if (!index && nVal < valueArr[index]) {
      rangeOutSideColor = true;
      break;
    } else if (index === length - 1 && nVal > valueArr[index]) {
      rangeOutSideColor = true;
      break;
    } else if (nVal > valueArr[index] && nVal < valueArr[index + 1]) {
      color = getColorBetween(colorRange[index], colorRange[index + 1], nVal);
      break;
    }
  }

  if (rangeOutSideColor) {
    return;
  }

  return color;
};

function GradientLegend() {
  LegendBase.apply(this, arguments);
}

GradientLegend.prototype = (0, _create2['default'])(LegendBase.prototype);
GradientLegend.prototype.constructor = GradientLegend;

var GLegend = function (_ComponentInterface) {
  _inherits(GLegend, _ComponentInterface);

  function GLegend() {
    _classCallCheck(this, GLegend);

    var _this = _possibleConstructorReturn(this, _ComponentInterface.call(this));

    _this.enabled = false;
    return _this;
  }

  GLegend.prototype.init = function init(options) {
    var componentAPI = this,
        iapi = options.chart,
        dataExtremes,
        cr,
        nData,
        fcChart;

    /*
     * Performs 2nd level of initialization.
     * Injects the colorRange in the API object.
     *
     * @param de {Object} - A simple key value pair needed for 2nd level of init. See the above dataExtremes obj
     */
    function continueInit(de) {
      // Extracts raw FC Chart data and parse it to prepare data for colorRange. This kind of acts like a
      // adapter.
      componentAPI.data = options.chart.jsonData.colorrange;
      nData = componentAPI.nData = legendManager.legacyDataParser(componentAPI.data, de);

      if (!nData) {
        // If no valid data is present, sets a flag not to draw the legend . This will be read by subsequent
        // calls.
        componentAPI._dontPlot = true;
        return;
      }

      // Starts prepaeparing the drawOptions object which is needed during the final drawing and space
      // management.
      componentAPI.drawOptions = {
        smartLabel: iapi.getFromEnv('smartLabel'),
        colorRange: componentAPI.colorRange = cr = new ColorRange(nData, de, fcChart),
        maxOtherSide: de.maxOtherSide
      };

      componentAPI._dontPlot = false;
      cr && cr._preparationGoneWrong && (componentAPI._dontPlot = true);

      componentAPI._recalculateLogicalSpace = true;

      // Parse all the legend releted attrs.
      componentAPI._configure();
    }

    // Initiates the legend manager by providing the access to the chart object.
    legendManager.init(options);

    // Saves the reference of chart for internal use, in case
    fcChart = componentAPI._chart = options.chart;
    componentAPI._cpool = componentPoolFactory(fcChart);

    if (!(dataExtremes = options.dataExtremes)) {
      // If the dataExtremes is not provided, return the function for 2nd level of init
      return continueInit;
    }

    // If provided perform the 2nd level of init internally by giving the feel to the user that init happened
    // in one single shot
    continueInit(dataExtremes);
  };

  /*
      * Parses all the FC attributes for gradient legend
      */


  GLegend.prototype._configure = function _configure() {
    var componentAPI = this,
        chart = componentAPI._chart,
        chartAttrs = chart.jsonData.chart,
        conf = componentAPI.conf = {},
        outCanvasBaseFont = chartAttrs.outcnvbasefont,
        outCanvasBaseFontSize = chartAttrs.outcnvbasefontsize,
        outCanvasBaseFontColor = chartAttrs.outcnvbasefontcolor,
        labelStyle = chart.config.dataLabelStyle,
        fColor,
        fFamily,
        fSize,
        fWeight,
        cfColor,
        cfFamily,
        cfSize,
        cfWeight,
        axisBorderColor,
        axisBorderAlpha;

    conf.caption = (0, _lib.pluck)(chartAttrs.legendcaption);
    conf.legendPosition = (0, _lib.pluck)(chartAttrs.legendposition, 'bottom').toLowerCase();
    conf.showLegend = (0, _lib.pluckNumber)(chartAttrs.showlegend, 1);
    conf.interactiveLegend = (0, _lib.pluckNumber)(chartAttrs.interactivelegend, 1);
    conf.showLegendLabels = (0, _lib.pluckNumber)(chartAttrs.showlegendlabels, 1);

    fColor = chartAttrs.legenditemfontcolor || outCanvasBaseFontColor;
    fFamily = chartAttrs.legenditemfont || outCanvasBaseFont;
    fSize = chartAttrs.legenditemfontsize || outCanvasBaseFontSize;
    fWeight = (0, _lib.pluckNumber)(chartAttrs.legenditemfontbold, 0);

    cfColor = chartAttrs.legendcaptionfontcolor || outCanvasBaseFontColor;
    cfFamily = chartAttrs.legendcaptionfont || outCanvasBaseFont;
    cfSize = chartAttrs.legendcaptionfontsize || outCanvasBaseFontSize;
    cfWeight = (0, _lib.pluckNumber)(chartAttrs.legendcaptionfontbold, 1);

    axisBorderColor = chartAttrs.legendaxisbordercolor ? (0, _lib.hashify)((0, _lib.dehashify)(chartAttrs.legendaxisbordercolor)) : UNDEF;

    axisBorderAlpha = axisBorderColor ? (0, _lib.pluckNumber)(chartAttrs.legendaxisborderalpha, 100) / 100 : UNDEF;

    // We do this like this so that, it becomes easy to override the default configuartion. The default conf was
    // created in this format.
    conf.axisTextItemConf = {
      style: {
        fill: fColor ? convertColor((0, _lib.pluck)(fColor)) : labelStyle.color,
        fontFamily: fFamily ? (0, _lib.pluck)(fFamily) : labelStyle.fontFamily,
        fontSize: fSize ? (0, _lib.pluckNumber)(fSize) : labelStyle.fontSize.match(/\d+/)[0],
        fontWeight: fWeight ? 'bold' : labelStyle.fontWeight
      }
    };

    conf.legendCaptionConf = {
      style: {
        fill: cfColor ? convertColor((0, _lib.pluck)(cfColor)) : labelStyle.color,
        fontFamily: cfFamily ? (0, _lib.pluck)(cfFamily) : labelStyle.fontFamily,
        fontSize: cfSize ? (0, _lib.pluckNumber)(cfSize) : labelStyle.fontSize.match(/\d+/)[0],
        fontWeight: cfWeight ? 'bold' : labelStyle.fontWeight,
        fontStyle: 'normal'
      }
    };

    conf.legendAxisConf = {
      legendAxisHeight: 11,
      style: {
        stroke: axisBorderColor,
        'stroke-opacity': axisBorderAlpha
      },
      line: {
        style: {
          stroke: convertColor((0, _lib.pluck)(chartAttrs.legendscalelinecolor, 'FFF8E9'), (0, _lib.pluckNumber)(chartAttrs.legendscalelinealpha, 100)),
          'stroke-width': (0, _lib.pluckNumber)(chartAttrs.legendscalelinethickness)
        }
      }
    };

    conf.sliderGroupConf = {
      showTooltip: (0, _lib.pluckNumber)(chartAttrs.showtooltip, 1),
      outerCircle: {
        rFactor: (0, _lib.pluckNumber)(chartAttrs.sliderdiameterfactor),
        style: {
          stroke: convertColor((0, _lib.pluck)(chartAttrs.legendpointerbordercolor, '757575'), (0, _lib.pluckNumber)(chartAttrs.legendpointerborderalpha, 100))
        }
      },
      innerCircle: {
        rFactor: (0, _lib.pluckNumber)(chartAttrs.sliderholediameterfactor),
        style: {
          stroke: convertColor((0, _lib.pluck)(chartAttrs.legendpointercolor, 'FFFFFF'), (0, _lib.pluckNumber)(chartAttrs.legendpointeralpha, 100))
        }
      }
    };

    conf.legendCarpetConf = {
      spreadFactor: (0, _lib.pluckNumber)(chartAttrs.legendspreadfactor),
      allowDrag: !!(0, _lib.pluckNumber)(chartAttrs.legendallowdrag, 0),
      captionAlignment: (0, _lib.pluck)(chartAttrs.legendcaptionalignment, 'center'),
      style: {
        'fill': convertColor((0, _lib.pluck)(chartAttrs.legendbgcolor, 'e4d9c1'), (0, _lib.pluckNumber)(chartAttrs.legendbgalpha, 100)),
        'stroke': convertColor((0, _lib.pluck)(chartAttrs.legendbordercolor, 'c4b89d'), (0, _lib.pluckNumber)(chartAttrs.legendborderalpha, 100)),
        'stroke-width': (0, _lib.pluckNumber)(chartAttrs.legendborderthickness, 1)
      }
    };
  };

  /*
   * This takes care of the instance creation of various component based on attrs. Dependency injection /
   * component injection is managed from here.
   * This is not meant to be called from outside. This gets called internally.
   */


  GLegend.prototype.postConfigureInit = function postConfigureInit() {
    var componentAPI = this,
        conf = componentAPI.conf,
        caption,
        carpet,
        axis,
        sGroup,

    // gl,
    ovrdConf,
        ovrdTextConf,
        body,
        labels,
        values;

    // Container for the component instances.
    componentAPI.elem = {};

    // The details of the various components and their relationship is written at the top.

    if (conf.caption) {
      // If caption is present, create a instance of the same
      ovrdConf = merge(legendManager.getDefaultConf('legendCaptionConf'), conf.legendCaptionConf);
      caption = new LegendCaption(conf.caption, ovrdConf);
    }

    if (conf.interactiveLegend) {
      // If interactiveLegend is attr is present, creates the sliders of the legend.

      // Override the default conf with the user given one.
      ovrdConf = merge(legendManager.getDefaultConf('sliderGroupConf'), conf.sliderGroupConf);
      componentAPI.elem.sGroup = sGroup = new SliderGroup(ovrdConf);
      componentAPI.listeners && componentAPI.listeners.length > 0 && sGroup.registerListener.apply(sGroup, componentAPI.listeners);
    }

    ovrdConf = merge(legendManager.getDefaultConf('legendCarpetConf'), conf.legendCarpetConf);

    if (conf.legendPosition === 'bottom') {
      // If the legend to be placed at bottom

      // The reference side would be width and will be covered the complete canvasWidth.
      // The max of other side is given by maxOtherSide.
      // The margin is taken from canvasLeft
      componentAPI.drawOptions.refSideKey = 'canvasWidth';
      componentAPI.drawOptions.refOffsetKey = 'canvasLeft';

      // Creates a horizontal capet, axis, labels and values component
      carpet = new LegendCarpet(ovrdConf);

      ovrdTextConf = merge(legendManager.getDefaultConf('axisTextItemConf'), conf.axisTextItemConf);

      body = new LegendBody(componentAPI.drawOptions.colorRange, legendManager.getDefaultConf('legendBodyConf'), ovrdTextConf);

      axis = new LegendAxis(merge(legendManager.getDefaultConf('legendAxisConf'), conf.legendAxisConf));

      conf.showLegendLabels && (labels = new LegendLabels(ovrdTextConf));
      values = new LegendValues(ovrdTextConf);
    } else {
      // If the legend to be placed at bottom

      // The reference side would be height and will be covered the complete canvasWidth.
      // The max of other side is given by maxOtherSide.
      // The margin is taken from canvasTop
      componentAPI.drawOptions.refSideKey = 'canvasHeight';
      componentAPI.drawOptions.refOffsetKey = 'canvasTop';

      ovrdTextConf = merge(legendManager.getDefaultConf('axisTextItemConf'), conf.axisTextItemConf);

      carpet = new VerticalLegendCarpet(ovrdConf);
      body = new VerticalLegendBody(componentAPI.drawOptions.colorRange, legendManager.getDefaultConf('legendBodyConf'), ovrdTextConf);

      axis = new VerticalLegendAxis(merge(legendManager.getDefaultConf('legendAxisConf'), conf.legendAxisConf));

      conf.showLegendLabels && (labels = new VerticalLegendLabels(ovrdTextConf));
      values = new VerticalLegendValues(ovrdTextConf);
    }

    // If the slider group is defined, inject as component. Slider group is component of axis.
    sGroup && axis.addCompositions(sGroup, compositionKeys.RANGE);

    // Adds component to the body if available
    labels && body.addCompositions(labels, compositionKeys.AXIS_LABEL);
    body.addCompositions(axis, compositionKeys.LEGEND_AXIS);
    body.addCompositions(values, compositionKeys.AXIS_VALUE);

    // Adds the body and the caption to the carpet
    caption && carpet.addCompositions(caption, compositionKeys.CAPTION);
    carpet.addCompositions(body, compositionKeys.LEGEND_BODY);

    // Finally creates the gradient legend.
    componentAPI.elem.gl = new GradientLegend(carpet, componentAPI._cpool);
  };

  GLegend.prototype.notifyWhenUpdate = function notifyWhenUpdate(fn, context, params) {
    var componentAPI = this,
        rGroup;

    rGroup = componentAPI.elem && componentAPI.elem.sGroup;
    if (rGroup) {
      rGroup.registerListener(fn, context, params);
    } else {
      componentAPI.listeners = [fn, context, params];
    }
  };

  GLegend.prototype.dispose = function dispose() {
    var componentAPI = this;

    componentAPI.elem && componentAPI.elem.gl && componentAPI.elem.gl.dispose();
    componentAPI.elem = {};
  };

  GLegend.prototype.getLogicalSpace = function getLogicalSpace(maxOtherSide) {
    var componentAPI = this,
        conf = componentAPI.conf,
        zeroArea = {
      height: 0,
      width: 0
    },
        drawOptions = componentAPI.drawOptions,
        refSideKey,
        chart = componentAPI._chart,
        refOffsetKey;

    // @todo redundancy in calculating the reference side. Make it from a organized procedure call.
    if (!componentAPI._recalculateLogicalSpace) {
      refSideKey = drawOptions.refSideKey;
      refOffsetKey = drawOptions.refOffsetKey;

      componentAPI.drawOptions.refSide = chart.config[refSideKey];
      componentAPI.drawOptions.refOffset = chart.config[refOffsetKey];

      componentAPI._logicalArea = componentAPI.elem.gl.getLogicalSpace(componentAPI.drawOptions, true);
      return componentAPI._logicalArea || zeroArea;
    }

    if (componentAPI._dontPlot) {
      return zeroArea;
    }

    componentAPI._recalculateLogicalSpace = false;
    componentAPI.postConfigureInit();

    if (!conf.showLegend) {
      return zeroArea;
    }

    refSideKey = drawOptions.refSideKey;
    refOffsetKey = drawOptions.refOffsetKey;

    componentAPI.drawOptions.refSide = chart.config[refSideKey];
    componentAPI.drawOptions.refOffset = chart.config[refOffsetKey];

    componentAPI.drawOptions.maxOtherSide = maxOtherSide || componentAPI.drawOptions.maxOtherSide;
    return componentAPI.elem.gl && (componentAPI._logicalArea = componentAPI.elem.gl.getLogicalSpace(componentAPI.drawOptions, true));
  };

  GLegend.prototype.resetLegend = function resetLegend() {
    var componentAPI = this,
        rGroup;

    rGroup = componentAPI.elem && componentAPI.elem.sGroup;
    if (rGroup) {
      rGroup.reset();
    }
  };

  GLegend.prototype.clearListeners = function clearListeners() {
    var componentAPI = this,
        rGroup;

    rGroup = componentAPI.elem && componentAPI.elem.sGroup;
    if (rGroup) {
      rGroup.clearListeners();
    }
  };

  GLegend.prototype.draw = function draw(x, y, options) {
    var componentAPI = this,
        conf = componentAPI.conf,
        measurement,
        node;

    if (componentAPI._dontPlot) {
      return;
    }

    componentAPI._cpool.init(options.paper);

    if (!conf.showLegend) {
      componentAPI.enabled = false;
      return;
    }

    componentAPI.drawOptions.paper = options.paper;
    componentAPI.drawOptions.parentGroup = options.parentGroup;
    componentAPI.drawOptions.x = x;
    componentAPI.drawOptions.y = y;
    componentAPI.drawOptions.maxOtherSide = componentAPI.drawOptions.maxOtherSide || options.maxOtherSide;

    node = componentAPI.elem.gl.draw(componentAPI.drawOptions);
    measurement = node.getBBox();

    conf.xPos = measurement.x;
    conf.yPos = measurement.y;
    conf.height = measurement.height;
    conf.width = measurement.width;

    componentAPI.enabled = true;
  };

  return GLegend;
}(_componentInterface2['default']);

exports['default'] = GLegend;

/***/ }),
/* 406 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _caption = __webpack_require__(212);

var _caption2 = _interopRequireDefault(_caption);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var SubCaption = function (_Caption) {
  _inherits(SubCaption, _Caption);

  function SubCaption() {
    _classCallCheck(this, SubCaption);

    return _possibleConstructorReturn(this, _Caption.apply(this, arguments));
  }

  SubCaption.prototype.getName = function getName() {
    return 'subCaption';
  };

  return SubCaption;
}(_caption2['default']);

exports['default'] = SubCaption;

/***/ }),
/* 407 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _componentInterface = __webpack_require__(6);

var _componentInterface2 = _interopRequireDefault(_componentInterface);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var Background = function (_ComponentInterface) {
  _inherits(Background, _ComponentInterface);

  function Background() {
    _classCallCheck(this, Background);

    return _possibleConstructorReturn(this, _ComponentInterface.apply(this, arguments));
  }

  Background.prototype.getName = function getName() {
    return 'background';
  };

  return Background;
}(_componentInterface2['default']);

exports['default'] = Background;

/***/ }),
/* 408 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _lib = __webpack_require__(5);

var _chartPaletteColors = __webpack_require__(213);

var defaultPaletteOptions = _interopRequireWildcard(_chartPaletteColors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * parseColorMix method parses the color mix formula and returns
 * an array of colors depending of the constituents specified in
 * the formula.
 * @param aColor Actual color on which calculations will be based on.
 * @param mix Formula containing the mix of colors.
 * Example: ('943A0A','{light-50},FFFFFF,{color},{dark-25}')
 * @return Array of colors containing the required mix of colors (in RGB) - not HEX
 */
function parseColorMix(aColor, mix) {
        // Create a return array
        var rtnArr = [],
            strConsts = ColorManager.stringConstants,
            dashIndex,
            intensity,

        // Now, split into main tokens
        tokens,
            colors,
            j,
            defToken,
            defColor,
            token,
            color,
            removeBrecReg,
            i;

        // Remove all spaces from the formula
        mix = mix.replace(/\s/g, strConsts.BLANK);
        // Convert to lower case for case insensitive comparison
        mix = mix.toLowerCase();
        // If mix is blank, UNDEF or null, return the single color
        if (mix === strConsts.BLANK || mix === null || typeof mix === 'undefined') {
                rtnArr = [aColor];
        } else {
                // Now, split into main tokens
                tokens = mix.split(strConsts.COMMASTRING);
                // split COlors into Array
                colors = aColor.split(strConsts.COMMASTRING);
                j = Math.max(tokens.length, colors.length, 1);
                defToken = tokens[0];
                defColor = colors[0];
                removeBrecReg = /[\{\}]/ig;

                // Iterate through each token to check what it is.
                for (i = 0; i < j; i++) {
                        // Remove { and } from token.
                        token = (tokens[i] || defToken).replace(removeBrecReg, '');
                        color = colors[i] || defColor;
                        // Now, based on what token is, we take action
                        if (token === 'color') {
                                // If actual color
                                rtnArr.push(color);
                        } else if (token.substr(0, 5) === 'light') {
                                // Need to find lighter shade
                                // First find the intensity, which the user has specified.
                                // Get dash index
                                dashIndex = token.indexOf('-');
                                intensity = dashIndex === -1 ? 1 : token.substr(dashIndex + 1, token.length - dashIndex);
                                // Now in actual method, 0 means lightest and 1 means normal. So, we've to reverse
                                intensity = 100 - intensity;
                                // Push the lighter color in array
                                rtnArr.push(_lib.graphics.getLightColor(color, intensity));
                        } else if (token.substr(0, 4) === 'dark') {
                                // Need to find darker shade
                                // First find the intensity, which the user has specified.
                                // Get dash index
                                dashIndex = token.indexOf('-');
                                intensity = dashIndex === -1 ? 1 : token.substr(dashIndex + 1, token.length - dashIndex);
                                // Now in actual method, 0 means darkest and 1 means normal. So, we've to reverse
                                intensity = 100 - intensity;
                                // Push the darker color in array
                                rtnArr.push(_lib.graphics.getDarkColor(color, intensity));
                        } else {
                                // User has himself given a normal hex color code.
                                // So, convert and append
                                rtnArr.push(token);
                        }
                }
        }
        // Return array
        return rtnArr;
}

/**
 * parseAlphaList method takes a list of alphas separated
 * by comma and returns an array of the individual alphas
 * @param    strAlphas    List of alphas separated by comma e.g.,
 * 20,30,40 etc.
 * @param numColors Number of colors for which we've to build
 * the alpha list
 * @return An array whose each cell contains a single
 * alpha value (validated).
 */
function parseAlphaList(strAlphas, numColors) {
        // Input list of alpha
        // Extract the input alphas
        var arrInputAlphas = strAlphas.split(ColorManager.stringConstants.COMMASTRING),

        // Final list
        arrAlphas = [],

        // Count of valid alphas
        alpha,
            usedAlpha = 100,

        // Loop variable
        i;
        // Change the alpha matrix to number (from string base)
        for (i = 0; i < numColors; i++) {
                // Get the alpha
                alpha = (0, _lib.pluckNumber)(arrInputAlphas[i]);
                // Now, if the alpha is non-numeric or UNDEF, we set our own values
                // alpha = (isNaN(alpha) || (alpha == UNDEF)) ? 100 : Number(alpha);
                if (ColorManager.defined(alpha)) {
                        usedAlpha = alpha;
                }
                // Store it in the array
                arrAlphas[i] = usedAlpha;
        }
        // Return the array
        return arrAlphas.join();
}

/**
 * parseRatioList method takes a list of color division ratios
 * (on base of 100%) separated by comma and returns an array of
 * the individual ratios (on base of 255 hex).
 * @param strRatios List of ratios (on base of 100%) separated by
 * comma e.g., 20,40,40 or 5,5,90 etc.
 * @param numColors Number of colors for which we've to build
 * the ratio list
 * @return An array whose each cell contains a single
 * ratio value (on base of 255 hex).
 */
function parseRatioList(strRatios, numColors) {
        // Arrays to store input and final ratio
        // Split the user input ratios
        var arrInputRatios = strRatios.split(ColorManager.stringConstants.COMMASTRING),
            arrRatios = [],

        // Sum of ratios
        sumRatio = 0,
            ratio,

        // Loop variable
        i;
        // First, check if all ratios are numbers and calculate sum
        for (i = 0; i < numColors; i++) {
                // Get the ratio
                ratio = arrInputRatios[i];
                // Now, if the ratio is non-numeric or UNDEF, we set our own values
                ratio = isNaN(ratio) || typeof ratio === 'undefined' ? 0 : Math.abs(Number(ratio));
                // If ratio is greater than 100, restrict it to 100
                ratio = ratio > 100 ? 100 : ratio;
                // Allot it to final array
                arrRatios[i] = ratio;
                // Add to sum
                sumRatio += ratio;
        }
        // Total ratio inputted by user should not exceed 100
        sumRatio = sumRatio > 100 ? 100 : sumRatio;
        // If more colors are present than the number of ratios, we need to
        // proportionately append the rest of values
        if (arrInputRatios.length < numColors) {
                for (i = arrInputRatios.length; i < numColors; i++) {
                        arrRatios[i] = (100 - sumRatio) / (numColors - arrInputRatios.length);
                }
        }
        // Now, convert ratio percentage to actual values from 0 to 255 (Hex base)
        arrRatios[-1] = 0;

        // Return the ratios array
        return arrRatios.join();
}

var ColorManager = function () {
        function ColorManager(chart) {
                _classCallCheck(this, ColorManager);

                this.linkedItems = {
                        iapi: chart
                };
                this.parseColorMix = parseColorMix;
                this.parseAlphaList = parseAlphaList;
                this.parseRatioList = parseRatioList;

                this.configure();

                this.paletteColors = ['AFD8F8', 'F6BD0F', '8BBA00', 'FF8E46', '008E8E', 'D64646', '8E468E', '588526', 'B3AA00', '008ED6', '9D080D', 'A186BE', 'CC6600', 'FDC689', 'ABA000', 'F26D7D', 'FFF200', '0054A6', 'F7941C', 'CC3300', '006600', '663300', '6DCFF6'];
        }

        ColorManager.prototype.configure = function configure() {
                var cm = this,
                    strConsts = ColorManager.stringConstants,
                    iapi = cm.linkedItems.iapi,
                    dataObj = iapi.jsonData,
                    FCChartObj = dataObj.chart || {},
                    pO = cm.paletteOptions = ColorManager.extend((0, _lib.extend2)({}, defaultPaletteOptions), iapi.defaultPaletteOptions || {}),
                    themeColor = cm.themeEnabled = FCChartObj.palettethemecolor;

                cm.paletteIndex = (FCChartObj.palette > 0 && FCChartObj.palette < 6 ? FCChartObj.palette : (0, _lib.pluckNumber)(iapi.paletteIndex, 1)) - 1;

                cm.iterator = 0;

                cm.paletteColors = pO.paletteColors[cm.themeEnabled ? 0 : cm.paletteIndex];
                if (ColorManager.defined(FCChartObj.palettecolors) && FCChartObj.palettecolors !== strConsts.BLANK) {
                        cm.paletteColors = FCChartObj.palettecolors.split(/\s*\,\s*/);
                }
                cm.paletteLen = cm.paletteColors.length;
                cm.useFlatColors = (0, _lib.pluckNumber)(FCChartObj.useflatdataplotcolor, iapi.useFlatColor, 0);

                if (themeColor) {
                        cm.paletteIndex = 5;
                        // Color
                        pO.bgColor[5] = _lib.graphics.getLightColor(themeColor, 35) + strConsts.COMMASTRING + _lib.graphics.getLightColor(themeColor, 10);
                        pO.bgAngle[5] = 270;
                        pO.bgRatio[5] = strConsts.BGRATIOSTRING;
                        pO.bgAlpha[5] = '50,50';
                        pO.canvasBgColor[5] = strConsts.COLOR_WHITE;
                        pO.canvasBgAngle[5] = 0;
                        pO.canvasBgAlpha[5] = strConsts.HUNDREDSTRING;
                        pO.canvasBgRatio[5] = strConsts.BLANK;
                        // Color
                        pO.canvasBorderColor[5] = _lib.graphics.getDarkColor(themeColor, 80);
                        pO.canvasBorderAlpha[5] = 100;
                        pO.showShadow[5] = 1;
                        // Color???
                        pO.divLineColor[5] = _lib.graphics.getDarkColor(themeColor, 20);
                        pO.divLineAlpha[5] = 40;
                        // Color
                        pO.altHGridColor[5] = _lib.graphics.getLightColor(themeColor, 20);
                        pO.altHGridAlpha[5] = 15;
                        // Color
                        pO.altVGridColor[5] = _lib.graphics.getLightColor(themeColor, 80);
                        pO.altVGridAlpha[5] = 10;
                        pO.anchorBgColor[5] = strConsts.COLOR_WHITE;
                        pO.toolTipBgColor[5] = strConsts.COLOR_WHITE;
                        // Color
                        pO.toolTipBorderColor[5] = _lib.graphics.getDarkColor(themeColor, 80);
                        // Color
                        pO.baseFontColor[5] = themeColor.split && themeColor.split(strConsts.COMMASTRING)[0];
                        // Color
                        pO.borderColor[5] = _lib.graphics.getDarkColor(themeColor, 60);
                        pO.borderAlpha[5] = 50;
                        pO.legendBgColor[5] = strConsts.COLOR_WHITE;
                        // Color
                        pO.legendBorderColor[5] = _lib.graphics.getDarkColor(themeColor, 80);
                        pO.plotGradientColor[5] = strConsts.COLOR_WHITE;
                        // Color
                        pO.plotBorderColor[5] = _lib.graphics.getDarkColor(themeColor, 85);
                        // Color
                        pO.plotFillColor[5] = _lib.graphics.getDarkColor(themeColor, 85);
                        // -------------- For 3D Chart --------------//
                        pO.bgColor3D[5] = strConsts.COLOR_WHITE;
                        pO.bgAlpha3D[5] = strConsts.HUNDREDSTRING;
                        pO.bgAngle3D[5] = 90;
                        pO.bgRatio3D[5] = strConsts.BLANK;
                        // Color ???
                        pO.canvasBgColor3D[5] = _lib.graphics.getLightColor(themeColor, 20);
                        // Color ???
                        pO.canvasBaseColor3D[5] = _lib.graphics.getLightColor(themeColor, 40);
                        // Color ???
                        pO.divLineColor3D[5] = _lib.graphics.getDarkColor(themeColor, 20);
                        pO.divLineAlpha3D[5] = 40;
                        // Color ???
                        pO.legendBgColor3D[5] = strConsts.COLOR_WHITE;
                        // Color ???
                        pO.legendBorderColor3D[5] = _lib.graphics.getDarkColor(themeColor, 80);
                        pO.toolTipbgColor3D[5] = strConsts.COLOR_WHITE;
                        // Color ???
                        pO.toolTipBorderColor3D[5] = _lib.graphics.getDarkColor(themeColor, 80);
                        // Color ???
                        pO.baseFontColor3D[5] = themeColor.split && themeColor.split(strConsts.COMMASTRING)[0];
                        pO.anchorBgColor3D[5] = strConsts.COLOR_WHITE;

                        // Gauges
                        pO.tickColor && (pO.tickColor[5] = _lib.graphics.getDarkColor(themeColor, 90));
                        pO.trendDarkColor && (pO.trendDarkColor[5] = _lib.graphics.getDarkColor(themeColor, 90));
                        pO.trendLightColor && (pO.trendLightColor[5] = _lib.graphics.getLightColor(themeColor, pO.TrendLightShadeOffset));
                        pO.msgLogColor && (pO.msgLogColor[5] = _lib.graphics.getLightColor(themeColor, 80));
                        // Chart specific colors
                        // Angular Gauge Chart
                        pO.dialColor && (pO.dialColor[5] = _lib.graphics.getDarkColor(themeColor, 95) + ',FFFFFF,' + _lib.graphics.getDarkColor(themeColor, 95));
                        pO.dialBorderColor && (pO.dialBorderColor[5] = _lib.graphics.getDarkColor(themeColor, 95) + ',FFFFFF,' + _lib.graphics.getDarkColor(themeColor, 95));
                        pO.pivotColor && (pO.pivotColor[5] = _lib.graphics.getLightColor(themeColor, 95) + ',FFFFFF,' + _lib.graphics.getLightColor(themeColor, 95));
                        pO.pivotBorderColor && (pO.pivotBorderColor[5] = _lib.graphics.getDarkColor(themeColor, 95) + ',FFFFFF,' + _lib.graphics.getDarkColor(themeColor, 95));
                        // Linear Gauge
                        pO.pointerBorderColor && (pO.pointerBorderColor[5] = _lib.graphics.getDarkColor(themeColor, 75));
                        pO.pointerBgColor && (pO.pointerBgColor[5] = _lib.graphics.getDarkColor(themeColor, 75));
                        // Thermometer gauge
                        pO.thmBorderColor && (pO.thmBorderColor[5] = _lib.graphics.getDarkColor(themeColor, 90));
                        pO.thmFillColor && (pO.thmFillColor[5] = _lib.graphics.getLightColor(themeColor, 55));
                        // Thermometer gauge
                        pO.gaugeBorderColor && (pO.gaugeBorderColor[5] = _lib.graphics.getDarkColor(themeColor, 90));
                        pO.gaugeFillColor && (pO.gaugeFillColor[5] = _lib.graphics.getLightColor(themeColor, 55));
                        // Cylinder gauge
                        pO.cylFillColor && (pO.cylFillColor[5] = _lib.graphics.getLightColor(themeColor, 55));
                        pO.periodColor && (pO.periodColor[5] = _lib.graphics.getLightColor(themeColor, 10));
                        // Methods for win loss chart only ???
                        pO.winColor && (pO.winColor[5] = '666666');
                        pO.lossColor && (pO.lossColor[5] = 'CC0000');
                        pO.drawColor && (pO.drawColor[5] = '666666');
                        pO.scorelessColor && (pO.scorelessColor[5] = 'FF0000');

                        // Gantt Chart
                        pO.gridColor && (pO.gridColor[5] = _lib.graphics.getLightColor(themeColor, 30));
                        pO.categoryBgColor && (pO.categoryBgColor[5] = _lib.graphics.getLightColor(themeColor, 10));
                        pO.dataTableBgColor && (pO.dataTableBgColor[5] = _lib.graphics.getLightColor(themeColor, 10));
                        pO.gridResizeBarColor && (pO.gridResizeBarColor[5] = _lib.graphics.getDarkColor(themeColor, 90));
                        pO.scrollBarColor && (pO.scrollBarColor[5] = _lib.graphics.getLightColor(themeColor, 50));
                }
        };

        /**
         * getColor find the relevant required color from a given entity/element
         * key eg. bgColor, canvasBgColor, plotBorderColor etc.
         * @param {string} key the name of entity/element to retrieve color
         * @return {string} hexcolor
         */


        ColorManager.prototype.getColor = function getColor(key) {
                // Return color
                return this.paletteOptions[key][this.paletteIndex];
        };

        /**
         * getPlotColor find the relevant required color for chart's dataplot
         * from a given index or auto generate after incrementing index by 1
         * @param {number} index of the color in paletteColors Array
         * @return {string} hexcolor
         */


        ColorManager.prototype.getPlotColor = function getPlotColor(index) {
                var cm = this,
                    paletteColors = cm.paletteColors,
                    strColor = cm.useFlatColors ? cm.getColor('plotFillColor') : paletteColors[index % cm.paletteLen];

                // Get the color
                if (!strColor) {
                        // If iterator is out of bound, reset it to 0
                        if (cm.iterator === cm.paletteLen) {
                                cm.iterator = 0;
                        }
                        strColor = paletteColors[cm.iterator];
                        // Increment iterator
                        cm.iterator += 1;
                }
                // Return color
                return strColor;
        };

        return ColorManager;
}();

ColorManager.stringConstants = {
        BLANK: '',
        COMMASTRING: ',',
        BGRATIOSTRING: '0,100',
        COLOR_WHITE: 'FFFFFF',
        HUNDREDSTRING: '100'
};

ColorManager.defined = function (obj) {
        return typeof obj !== 'undefined' && obj !== null;
};

ColorManager.extend = function (a, b) {
        var n;
        if (!a) {
                a = {};
        }
        for (n in b) {
                a[n] = b[n];
        }
        return a;
};

exports['default'] = ColorManager;

/***/ }),
/* 409 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _componentInterface = __webpack_require__(6);

var _componentInterface2 = _interopRequireDefault(_componentInterface);

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */

var BLANKSTRING = '',
    PXSTRING = 'px',
    DASH_DEF = 'none',
    convertColor = _lib.graphics.convertColor,
    NORMALSTRING = 'normal',
    POSITION_START = _lib.preDefStr.POSITION_START,
    POSITION_TOP = _lib.preDefStr.POSITION_TOP,
    POSITION_BOTTOM = _lib.preDefStr.POSITION_BOTTOM,
    POSITION_END = _lib.preDefStr.POSITION_END;
/**
 * Creates Quadrant class needed for XY charts
 */

var Quadrant = function (_ComponentInterface) {
  _inherits(Quadrant, _ComponentInterface);

  /**
   * Constructor function of Quadrant class
   */
  function Quadrant() {
    _classCallCheck(this, Quadrant);

    var _this = _possibleConstructorReturn(this, _ComponentInterface.call(this));

    var quadrant = _this;

    quadrant.pIndex = 1;

    quadrant.components = {};

    quadrant.conf = {};

    quadrant.graphics = {};
    return _this;
  }

  /**
   * Quadrant configuration parser
   */


  Quadrant.prototype.configure = function configure() {
    var borderColor,
        borderPadding,
        borderRadius,
        backgroundColor,
        borderDash,
        fontBdrColor,
        bgColor,
        borderThickness,
        tlConfig,
        trConfig,
        blConfig,
        brConfig,
        quadrantLabelTL,
        quadrantLabelTR,
        quadrantLabelBL,
        quadrantLabelBR,
        quadrantXVal,
        quadrantYVal,
        quadrantLineColor,
        quadrantLineThickness,
        quadrantLineDashLen,
        quadrantLineIsDashed,
        quadrantLineDashGap,
        dashStyle,
        drawQuadrant,
        quadrant = this,
        quadrantConfig = quadrant.conf,
        chart = quadrant.getFromEnv('chart'),
        chartConfig = chart.config,
        chartAttr = chart.jsonData.chart,
        canvas = chart.getChildren('canvas')[0],
        canvasConf = canvas.config,
        inCanvasStyle = chartConfig.dataLabelStyle,
        smartLabel = chart.getFromEnv('smartLabel');

    drawQuadrant = quadrantConfig.enabled = (0, _lib.pluckNumber)(chartAttr.drawquadrant, 0);

    if (drawQuadrant) {
      // Quadrant related properties
      // maximum allowed values for the axes and drawing occurs only when the values are whitin this range.
      quadrantXVal = (0, _lib.pluckNumber)(chartAttr.quadrantxval);
      quadrantYVal = (0, _lib.pluckNumber)(chartAttr.quadrantyval);

      quadrantLineColor = convertColor((0, _lib.pluck)(chartAttr.quadrantlinecolor, canvasConf.canvasBorderColor), (0, _lib.pluck)(chartAttr.quadrantlinealpha, chartAttr.quadrantlinealpha, _lib.HUNDREDSTRING));
      quadrantLineThickness = (0, _lib.pluckNumber)(chartAttr.quadrantlinethickness, canvasConf.canvasBorderThickness);
      quadrantLineIsDashed = (0, _lib.pluckNumber)(chartAttr.quadrantlinedashed, chartAttr.quadrantlineisdashed, 0);
      quadrantLineDashLen = (0, _lib.pluckNumber)(chartAttr.quadrantlinedashlen, 4);
      quadrantLineDashGap = (0, _lib.pluckNumber)(chartAttr.quadrantlinedashgap, 2);
      dashStyle = quadrantLineIsDashed ? (0, _lib.getDashStyle)(quadrantLineDashLen, quadrantLineDashGap) : DASH_DEF;

      quadrantConfig.xVal = quadrantXVal;
      quadrantConfig.yVal = quadrantYVal;
      quadrantConfig.quadrantLineColor = quadrantLineColor;
      quadrantConfig.quadrantLineThickness = quadrantLineThickness;
      quadrantConfig.dashStyle = dashStyle;
      // pluck the text for quadrant labels
      quadrantLabelTL = (0, _lib.getValidValue)(chartAttr.quadrantlabeltl, BLANKSTRING);
      quadrantLabelTR = (0, _lib.getValidValue)(chartAttr.quadrantlabeltr, BLANKSTRING);
      quadrantLabelBL = (0, _lib.getValidValue)(chartAttr.quadrantlabelbl, BLANKSTRING);
      quadrantLabelBR = (0, _lib.getValidValue)(chartAttr.quadrantlabelbr, BLANKSTRING);

      quadrantConfig.quadrantLabelPadding = (0, _lib.pluckNumber)(chartAttr.quadrantlabelpadding, 3);

      // Draw the quadrant labels.
      smartLabel.useEllipsesOnOverflow(chartConfig.useEllipsesWhenOverflow);
      smartLabel.setStyle(inCanvasStyle);
      if (quadrantLabelTL !== BLANKSTRING) {
        fontBdrColor = (0, _lib.getFirstValue)(chartAttr.quadrantlabeltlbordercolor, chartAttr.quadrantlabelbordercolor, BLANKSTRING);
        bgColor = (0, _lib.pluck)(chartAttr.quadrantlabeltlbgcolor, chartAttr.quadrantlabelbgcolor);
        borderThickness = (0, _lib.pluckNumber)(chartAttr.quadrantlabeltlborderthickness, chartAttr.quadrantlabelborderthickness, 1);
        fontBdrColor = fontBdrColor ? convertColor(fontBdrColor, (0, _lib.pluckNumber)(chartAttr.quadrantlabeltlborderalpha, chartAttr.quadrantlabelborderalpha, chartAttr.quadrantlabeltlalpha, chartAttr.quadrantlabelalpha, 100)) : BLANKSTRING;

        tlConfig = quadrantConfig.tlConfig;

        if (!tlConfig) {
          tlConfig = quadrantConfig.tlConfig = {
            enabled: true,
            styleObj: {}
          };
        }

        tlConfig.label = quadrantLabelTL;
        tlConfig.styleObj.fontSize = (0, _lib.pluck)((0, _lib.pluckNumber)(chartAttr.quadrantlabeltlfontsize, chartAttr.quadrantlabelfontsize), parseInt(inCanvasStyle.fontSize, 10)) + PXSTRING;
        tlConfig.styleObj.lineHeight = inCanvasStyle.lineHeight;
        tlConfig.styleObj.fontFamily = (0, _lib.pluck)(chartAttr.quadrantlabeltlfont, chartAttr.quadrantlabelfont, inCanvasStyle.fontFamily);
        tlConfig.styleObj.color = convertColor((0, _lib.pluck)(chartAttr.quadrantlabeltlfontcolor, chartAttr.quadrantlabelfontcolor, inCanvasStyle.color), (0, _lib.pluckNumber)(chartAttr.quadrantlabeltlfontalpha, chartAttr.quadrantlabelfontalpha, 100));
        tlConfig.styleObj.fontWeight = (0, _lib.pluckNumber)(chartAttr.quadrantlabeltlfontbold, chartAttr.quadrantlabelfontbold) ? 'bold' : NORMALSTRING;
        tlConfig.styleObj.fontStyle = (0, _lib.pluckNumber)(chartAttr.quadrantlabeltlfontitalic, chartAttr.quadrantlabelfontitalic) ? 'italic' : NORMALSTRING;
        // sets the line height
        (0, _lib.setLineHeight)(tlConfig.styleObj);

        borderColor = fontBdrColor;
        borderPadding = (0, _lib.pluckNumber)(chartAttr.quadrantlabeltlborderpadding, chartAttr.quadrantlabelborderpadding, 2);
        borderRadius = (0, _lib.pluckNumber)(chartAttr.quadrantlabeltlborderradius, chartAttr.quadrantlabelborderradius, 0);
        backgroundColor = bgColor ? convertColor(bgColor, (0, _lib.pluckNumber)(chartAttr.quadrantlabeltlbgalpha, chartAttr.quadrantlabelbgalpha, chartAttr.quadrantlabeltlalpha, chartAttr.quadrantlabelalpha, 100)) : BLANKSTRING;
        borderDash = (0, _lib.pluckNumber)(chartAttr.quadrantlabeltlborderdashed, chartAttr.quadrantlabelborderdashed, 0) ? (0, _lib.getDashStyle)((0, _lib.pluckNumber)(chartAttr.quadrantlabeltlborderdashlen, chartAttr.quadrantlabelborderdashlen, 4), (0, _lib.pluckNumber)(chartAttr.quadrantlabeltlborderdashgap, chartAttr.quadrantlabelborderdashgap, 2)) : DASH_DEF;

        tlConfig['text-bound'] = [backgroundColor, borderColor, borderThickness, borderPadding, borderRadius, borderDash];
      } else {
        quadrantConfig.tlConfig && (quadrantConfig.tlConfig.label = quadrantLabelTL);
      }

      if (quadrantLabelTR !== BLANKSTRING) {
        fontBdrColor = (0, _lib.getFirstValue)(chartAttr.quadrantlabeltrbordercolor, chartAttr.quadrantlabelbordercolor, BLANKSTRING);
        bgColor = (0, _lib.pluck)(chartAttr.quadrantlabeltrbgcolor, chartAttr.quadrantlabelbgcolor);
        borderThickness = (0, _lib.pluckNumber)(chartAttr.quadrantlabeltrborderthickness, chartAttr.quadrantlabelborderthickness, 1);
        fontBdrColor = fontBdrColor ? convertColor(fontBdrColor, (0, _lib.pluckNumber)(chartAttr.quadrantlabeltrborderalpha, chartAttr.quadrantlabelborderalpha, chartAttr.quadrantlabeltralpha, chartAttr.quadrantlabelalpha, 100)) : BLANKSTRING;

        trConfig = quadrantConfig.trConfig;

        if (!trConfig) {
          trConfig = quadrantConfig.trConfig = {
            enabled: true,
            styleObj: {}
          };
        }

        trConfig.label = (0, _lib.getValidValue)(chartAttr.quadrantlabeltr, BLANKSTRING);
        trConfig.styleObj.fontSize = (0, _lib.pluck)((0, _lib.pluckNumber)(chartAttr.quadrantlabeltrfontsize, chartAttr.quadrantlabelfontsize), parseInt(inCanvasStyle.fontSize, 10)) + PXSTRING;
        trConfig.styleObj.lineHeight = inCanvasStyle.lineHeight;
        trConfig.styleObj.fontFamily = (0, _lib.pluck)(chartAttr.quadrantlabeltrfont, chartAttr.quadrantlabelfont, inCanvasStyle.fontFamily);
        trConfig.styleObj.color = convertColor((0, _lib.pluck)(chartAttr.quadrantlabeltrfontcolor, chartAttr.quadrantlabelfontcolor, inCanvasStyle.color), (0, _lib.pluckNumber)(chartAttr.quadrantlabeltrfontalpha, chartAttr.quadrantrabelfontalpha, 100));

        trConfig.styleObj.fontWeight = (0, _lib.pluckNumber)(chartAttr.quadrantlabeltrfontbold, chartAttr.quadrantlabelfontbold) ? 'bold' : NORMALSTRING;
        trConfig.styleObj.fontStyle = (0, _lib.pluckNumber)(chartAttr.quadrantlabeltrfontitalic, chartAttr.quadrantlabelfontitalic) ? 'italic' : NORMALSTRING;
        // sets the line height
        (0, _lib.setLineHeight)(trConfig.styleObj);

        borderColor = fontBdrColor;
        borderPadding = (0, _lib.pluckNumber)(chartAttr.quadrantlabeltrborderpadding, chartAttr.quadrantlabelborderpadding, 2);
        borderRadius = (0, _lib.pluckNumber)(chartAttr.quadrantlabeltrborderradius, chartAttr.quadrantlabelborderradius, 0);
        backgroundColor = bgColor ? convertColor(bgColor, (0, _lib.pluckNumber)(chartAttr.quadrantlabeltrbgalpha, chartAttr.quadrantlabelbgalpha, chartAttr.quadrantlabeltralpha, chartAttr.quadrantlabelalpha, 100)) : BLANKSTRING;
        borderDash = (0, _lib.pluckNumber)(chartAttr.quadrantlabeltrborderdashed, chartAttr.quadrantlabelborderdashed, 0) ? (0, _lib.getDashStyle)((0, _lib.pluckNumber)(chartAttr.quadrantlabeltrborderdashlen, chartAttr.quadrantlabelborderdashlen, 4), (0, _lib.pluckNumber)(chartAttr.quadrantlabeltrborderdashgap, chartAttr.quadrantlabelborderdashgap, 2)) : DASH_DEF;

        trConfig['text-bound'] = [backgroundColor, borderColor, borderThickness, borderPadding, borderRadius, borderDash];
      } else {
        quadrantConfig.trConfig && (quadrantConfig.trConfig.label = quadrantLabelTR);
      }

      if (quadrantLabelBL !== BLANKSTRING) {
        fontBdrColor = (0, _lib.getFirstValue)(chartAttr.quadrantlabelblbordercolor, chartAttr.quadrantlabelbordercolor, BLANKSTRING);
        bgColor = (0, _lib.pluck)(chartAttr.quadrantlabelblbgcolor, chartAttr.quadrantlabelbgcolor);
        borderThickness = (0, _lib.pluckNumber)(chartAttr.quadrantlabelblborderthickness, chartAttr.quadrantlabelborderthickness, 1);
        fontBdrColor = fontBdrColor ? convertColor(fontBdrColor, (0, _lib.pluckNumber)(chartAttr.quadrantlabelblborderalpha, chartAttr.quadrantlabelborderalpha, chartAttr.quadrantlabelblalpha, chartAttr.quadrantlabelalpha, 100)) : BLANKSTRING;

        blConfig = quadrantConfig.blConfig;

        if (!blConfig) {
          blConfig = quadrantConfig.blConfig = {
            enabled: true,
            styleObj: {}
          };
        }

        blConfig.label = quadrantLabelBL;
        blConfig.styleObj.fontSize = (0, _lib.pluck)((0, _lib.pluckNumber)(chartAttr.quadrantlabelblfontsize, chartAttr.quadrantlabelfontsize), parseInt(inCanvasStyle.fontSize, 10)) + PXSTRING;
        blConfig.styleObj.lineHeight = inCanvasStyle.lineHeight;
        blConfig.styleObj.fontFamily = (0, _lib.pluck)(chartAttr.quadrantlabelblfont, chartAttr.quadrantlabelfont, inCanvasStyle.fontFamily);
        blConfig.styleObj.color = convertColor((0, _lib.pluck)(chartAttr.quadrantlabelblfontcolor, chartAttr.quadrantlabelfontcolor, inCanvasStyle.color), (0, _lib.pluckNumber)(chartAttr.quadrantlabelblfontalpha, chartAttr.quadrantlabelfontalpha, 100));
        blConfig.styleObj.fontWeight = (0, _lib.pluckNumber)(chartAttr.quadrantlabelblfontbold, chartAttr.quadrantlabelfontbold) ? 'bold' : NORMALSTRING;
        blConfig.styleObj.fontStyle = (0, _lib.pluckNumber)(chartAttr.quadrantlabelblfontitalic, chartAttr.quadrantlabelfontitalic) ? 'italic' : NORMALSTRING;
        // set line height
        (0, _lib.setLineHeight)(blConfig.styleObj);

        borderColor = fontBdrColor;
        borderPadding = (0, _lib.pluckNumber)(chartAttr.quadrantlabelblborderpadding, chartAttr.quadrantlabelborderpadding, 2);
        borderRadius = (0, _lib.pluckNumber)(chartAttr.quadrantlabelblborderradius, chartAttr.quadrantlabelborderradius, 0);
        backgroundColor = bgColor ? convertColor(bgColor, (0, _lib.pluckNumber)(chartAttr.quadrantlabelblbgalpha, chartAttr.quadrantlabelbgalpha, chartAttr.quadrantlabelblalpha, chartAttr.quadrantlabelalpha, 100)) : BLANKSTRING;
        borderDash = (0, _lib.pluckNumber)(chartAttr.quadrantlabelblborderdashed, chartAttr.quadrantlabelborderdashed, 0) ? (0, _lib.getDashStyle)((0, _lib.pluckNumber)(chartAttr.quadrantlabelblborderdashlen, chartAttr.quadrantlabelborderdashlen, 4), (0, _lib.pluckNumber)(chartAttr.quadrantlabelblborderdashgap, chartAttr.quadrantlabelborderdashgap, 2)) : DASH_DEF;

        blConfig['text-bound'] = [backgroundColor, borderColor, borderThickness, borderPadding, borderRadius, borderDash];
      } else {
        quadrantConfig.blConfig && (quadrantConfig.blConfig.label = quadrantLabelBL);
      }

      if (quadrantLabelBR !== BLANKSTRING) {
        fontBdrColor = (0, _lib.getFirstValue)(chartAttr.quadrantlabelbrbordercolor, chartAttr.quadrantlabelbordercolor, BLANKSTRING);
        bgColor = (0, _lib.pluck)(chartAttr.quadrantlabelbrbgcolor, chartAttr.quadrantlabelbgcolor);
        borderThickness = (0, _lib.pluckNumber)(chartAttr.quadrantlabelbrborderthickness, chartAttr.quadrantlabelborderthickness, 1);
        fontBdrColor = fontBdrColor ? convertColor(fontBdrColor, (0, _lib.pluckNumber)(chartAttr.quadrantlabelbrborderalpha, chartAttr.quadrantlabelborderalpha, chartAttr.quadrantlabelbralpha, chartAttr.quadrantlabelalpha, 100)) : BLANKSTRING;

        brConfig = quadrantConfig.brConfig;

        if (!brConfig) {
          brConfig = quadrantConfig.brConfig = {
            enabled: true,
            styleObj: {}
          };
        }

        brConfig.label = (0, _lib.getValidValue)(chartAttr.quadrantlabelbr, BLANKSTRING);

        brConfig.styleObj.fontSize = (0, _lib.pluck)((0, _lib.pluckNumber)(chartAttr.quadrantlabelbrfontsize, chartAttr.quadrantlabelfontsize), parseInt(inCanvasStyle.fontSize, 10)) + PXSTRING;
        brConfig.styleObj.lineHeight = inCanvasStyle.lineHeight;
        brConfig.styleObj.fontFamily = (0, _lib.pluck)(chartAttr.quadrantlabelbrfont, chartAttr.quadrantlabelfont, inCanvasStyle.fontFamily);
        brConfig.styleObj.color = convertColor((0, _lib.pluck)(chartAttr.quadrantlabelbrfontcolor, chartAttr.quadrantlabelfontcolor, inCanvasStyle.color), (0, _lib.pluckNumber)(chartAttr.quadrantlabelbrfontalpha, chartAttr.quadrantrabelfontalpha, 100));
        brConfig.styleObj.fontWeight = (0, _lib.pluckNumber)(chartAttr.quadrantlabelbrfontbold, chartAttr.quadrantlabelfontbold) ? 'bold' : NORMALSTRING;
        brConfig.styleObj.fontStyle = (0, _lib.pluckNumber)(chartAttr.quadrantlabelbrfontitalic, chartAttr.quadrantlabelfontitalic) ? 'italic' : NORMALSTRING;
        // set the line height
        (0, _lib.setLineHeight)(brConfig.styleObj);

        backgroundColor = bgColor ? convertColor(bgColor, (0, _lib.pluckNumber)(chartAttr.quadrantlabelbrbgalpha, chartAttr.quadrantlabelbgalpha, chartAttr.quadrantlabelbralpha, chartAttr.quadrantlabelalpha, 100)) : BLANKSTRING;

        borderColor = fontBdrColor;
        borderPadding = (0, _lib.pluckNumber)(chartAttr.quadrantlabelbrborderpadding, chartAttr.quadrantlabelborderpadding, 2);
        borderRadius = (0, _lib.pluckNumber)(chartAttr.quadrantlabelbrborderradius, chartAttr.quadrantlabelborderradius, 0);
        borderDash = (0, _lib.pluckNumber)(chartAttr.quadrantlabelbrborderdashed, chartAttr.quadrantlabelborderdashed, 0) ? (0, _lib.getDashStyle)((0, _lib.pluckNumber)(chartAttr.quadrantlabelbrborderdashlen, chartAttr.quadrantlabelborderdashlen, 4), (0, _lib.pluckNumber)(chartAttr.quadrantlabelbrborderdashgap, chartAttr.quadrantlabelborderdashgap, 2)) : DASH_DEF;

        brConfig['text-bound'] = [backgroundColor, borderColor, borderThickness, borderPadding, borderRadius, borderDash];
      } else {
        quadrantConfig.brConfig && (quadrantConfig.brConfig.label = quadrantLabelBR);
      }
    }
  };

  /**
   * Calculates coordinates before drawing
   * @return {Object} instance of class Quadrant
   */


  Quadrant.prototype._preDraw = function _preDraw() {
    var quadrantXVal,
        quadrantYVal,
        labelWidthPart1,
        labelWidthPart2,
        labelHeightPart1,
        labelHeightPart2,
        FALSE = false,
        quadrant = this,
        quadrantConfig = quadrant.conf,
        chart = quadrant.getFromEnv('chart'),
        xAxis = chart.getChildren('xAxis')[0],
        yAxis = chart.getChildren('yAxis')[0],
        xAxisLimit = xAxis.getLimit(),
        yAxisLimit = yAxis.getLimit(),
        xMax = xAxisLimit.max,
        yMax = yAxisLimit.max,
        xMin = xAxisLimit.min,
        yMin = yAxisLimit.min,
        chartConfig = chart.config,
        canvasWidth = chartConfig.canvasWidth,
        canvasHeight = chartConfig.canvasHeight,
        quadrantLabelPadding = quadrantConfig.quadrantLabelPadding,
        tlConfig = quadrantConfig.tlConfig,
        trConfig = quadrantConfig.trConfig,
        blConfig = quadrantConfig.blConfig,
        brConfig = quadrantConfig.brConfig;

    quadrantXVal = quadrantConfig.xVal || (quadrantConfig.xVal = (xMin + xMax) / 2);
    quadrantYVal = quadrantConfig.yVal || (quadrantConfig.yVal = (yMin + yMax) / 2);

    if (quadrantYVal >= yMin && quadrantYVal <= yMax && quadrantXVal >= xMin && quadrantXVal <= xMax) {
      labelWidthPart1 = canvasWidth / (xMax - xMin) * (quadrantXVal - xMin);
      labelWidthPart2 = canvasWidth - labelWidthPart1;

      labelHeightPart2 = canvasHeight / (yMax - yMin) * (quadrantYVal - yMin);
      labelHeightPart1 = canvasHeight - labelHeightPart2;

      // remove the padding amount and compute the available dimensions.
      labelWidthPart1 -= quadrantLabelPadding;
      labelWidthPart2 -= quadrantLabelPadding;
      labelHeightPart1 -= quadrantLabelPadding;
      labelHeightPart2 -= quadrantLabelPadding;

      if (labelHeightPart1 < 0 || labelWidthPart1 < 0) {
        tlConfig.enabled = FALSE;
      }
      if (labelHeightPart1 < 0 || labelWidthPart2 < 0) {
        trConfig.enabled = FALSE;
      }
      if (labelHeightPart2 < 0 || labelWidthPart1 < 0) {
        blConfig.enabled = FALSE;
      }
      if (labelHeightPart2 < 0 || labelWidthPart1 < 0) {
        brConfig.enabled = FALSE;
      }
    } else {
      quadrantConfig.enabled = FALSE;
    }
    return quadrant;
  };

  /**
   * Creates Containers where the self graphics are appended
   */


  Quadrant.prototype._createGroups = function _createGroups() {
    var quadrant = this,
        chart = quadrant.getFromEnv('chart'),
        paper = quadrant.getFromEnv('paper'),
        quadrantContainer = chart.getChildren('canvas')[0].getChildContainer('quadrantGroup');

    !quadrant.getContainer('quadrantLineGroup') && quadrant.addContainer('quadrantLineGroup', paper.group('quadrantLineGroup', quadrantContainer));

    !quadrant.getContainer('quadrantTLGroup') && quadrant.addContainer('quadrantTLGroup', paper.group('quadrantTLGroup', quadrantContainer));

    !quadrant.getContainer('quadrantTRGroup') && quadrant.addContainer('quadrantTRGroup', paper.group('quadrantTRGroup', quadrantContainer));

    !quadrant.getContainer('quadrantBLGroup') && quadrant.addContainer('quadrantBLGroup', paper.group('quadrantBLGroup', quadrantContainer));

    !quadrant.getContainer('quadrantBRGroup') && quadrant.addContainer('quadrantBRGroup', paper.group('quadrantBRGroup', quadrantContainer));
  };

  /**
   * Draws the graphics of Quadrant component
   */


  Quadrant.prototype.draw = function draw() {
    var quadrant = this._preDraw(),
        // do the pre-draw calculations.
    quadrantConfig = quadrant.conf,
        chart = quadrant.getFromEnv('chart'),
        chartConfig = chart.config,
        reverseXAxis = chartConfig.reverseXAxis,
        smartText,
        smartLabel = quadrant.getFromEnv('smartLabel'),
        animationManager = quadrant.getFromEnv('animationManager'),
        graphics = quadrant.graphics,
        tlLabel = graphics.tlLabel,
        trLabel = graphics.trLabel,
        blLabel = graphics.blLabel,
        brLabel = graphics.brLabel,
        chartState = chart.state,
        textDirection = chartConfig.textDirection,
        xAxis = chart.getChildren('xAxis')[0],
        yAxis = chart.getChildren('yAxis')[0],
        paper = quadrant.getFromEnv('paper'),
        quadrantContainer = chart.getChildren('canvas')[0].getChildContainer('quadrantGroup'),
        quadrantLineGroup,
        quadrantTLGroup,
        quadrantTRGroup,
        quadrantBLGroup,
        quadrantBRGroup,
        tlConfig = quadrantConfig.tlConfig || {},
        trConfig = quadrantConfig.trConfig || {},
        blConfig = quadrantConfig.blConfig || {},
        brConfig = quadrantConfig.brConfig || {},

    // quadrant labels
    quadrantLabelTL = tlConfig.enabled && tlConfig.label,
        quadrantLabelTR = trConfig.enabled && trConfig.label,
        quadrantLabelBL = blConfig.enabled && blConfig.label,
        quadrantLabelBR = brConfig.enabled && brConfig.label,
        offsetLeft = chartConfig.canvasLeft,
        offsetTop = chartConfig.canvasTop,
        padding = quadrantConfig.quadrantLabelPadding,
        xAxisLimit = xAxis.getLimit(),
        yAxisLimit = yAxis.getLimit(),
        xAxisMax = reverseXAxis ? xAxisLimit.min : xAxisLimit.max,
        xAxisMin = reverseXAxis ? xAxisLimit.max : xAxisLimit.min,
        yAxisMax = yAxisLimit.max,
        yAxisMin = yAxisLimit.min,

    // max and min values of axes in pixels.
    xMin = xAxis.getPixel(xAxisMin) + padding,
        xMax = xAxis.getPixel(xAxisMax) - padding,
        yMin = yAxis.getPixel(yAxisMin) - padding,
        yMax = yAxis.getPixel(yAxisMax) + padding,
        quadXPos = xAxis.getPixel(quadrantConfig.xVal),
        quadYPos = yAxis.getPixel(quadrantConfig.yVal),
        quadLeftWidth = quadXPos - xMin,
        quadRightWidth = xMax - quadXPos,
        quadTopHeight = quadYPos - yMax,
        quadBottomHeight = yMin - quadYPos,
        horizontalQuadLine = graphics.horizontalQuadLine,
        verticalQuadLine = graphics.verticalQuadLine,
        hookFnShow = function hookFnShow() {
      this.show();
    },
        hookFnHide = function hookFnHide() {
      this.hide();
    },
        animationObj = chart.get('config', 'animationObj'),
        animType = animationObj.animType;

    quadrant._createGroups();

    quadrantLineGroup = quadrant.getContainer('quadrantLineGroup');
    quadrantTLGroup = quadrant.getContainer('quadrantTLGroup');
    quadrantTRGroup = quadrant.getContainer('quadrantTRGroup');
    quadrantBLGroup = quadrant.getContainer('quadrantBLGroup');
    quadrantBRGroup = quadrant.getContainer('quadrantBRGroup');

    if (quadrantConfig.enabled) {
      if (chartState === 'initial') {
        quadrantContainer.attr('opacity', 0);
      }
      animationManager.registerAnimation([{
        animType: animType,
        data: [{
          el: quadrantContainer,
          attrs: {
            opacity: 0
          },
          animConfig: [{
            hookFn: hookFnShow
          }]
        }]
      }], 'initial');

      animationManager.registerAnimation([{
        animType: animType,
        data: [{
          el: quadrantContainer,
          attrs: {
            opacity: 1
          }
        }]
      }], 'final');

      // drawing the lines.
      if (!horizontalQuadLine) {
        horizontalQuadLine = graphics.horizontalQuadLine = paper.path(quadrantLineGroup);
      }

      animationManager.registerAnimation([{
        animType: animType,
        data: [{
          el: horizontalQuadLine,
          attrs: {
            path: 'M' + offsetLeft + ' ' + quadYPos + 'h' + chartConfig.canvasWidth,
            stroke: quadrantConfig.quadrantLineColor,
            'stroke-dasharray': quadrantConfig.dashStyle,
            'stroke-width': quadrantConfig.quadrantLineThickness,
            'stroke-linecap': 'butt'
          }
        }]
      }], chartState === 'resize' ? 'default' : 'axis');

      if (!verticalQuadLine) {
        verticalQuadLine = graphics.verticalQuadLine = paper.path(quadrantLineGroup);
      }

      animationManager.registerAnimation([{
        animType: animType,
        data: [{
          el: verticalQuadLine,
          attrs: {
            path: 'M' + quadXPos + ' ' + offsetTop + 'v' + chartConfig.canvasHeight,
            stroke: quadrantConfig.quadrantLineColor,
            'stroke-width': quadrantConfig.quadrantLineThickness,
            'stroke-dasharray': quadrantConfig.dashStyle,
            'stroke-linecap': 'butt'
          }
        }]
      }], chartState === 'resize' ? 'default' : 'axis');

      // draw the labels of the quadrant along with applying the cosmetics and trim using smartLabel
      if (quadrantLabelTL) {
        animationManager.registerAnimation([{
          animType: animType,
          data: [{
            el: quadrantTLGroup,
            attrs: {
              opacity: 1
            },
            animConfig: [{
              hookFn: hookFnShow
            }]
          }]
        }], 'final');

        if (!tlLabel) {
          tlLabel = graphics.tlLabel = paper.text(quadrantTLGroup).attr({
            'text-anchor': POSITION_START,
            'vertical-align': POSITION_TOP
          }).css(quadrantConfig.tlConfig.styleObj);
        }
        smartLabel.useEllipsesOnOverflow(chartConfig.useEllipsesWhenOverflow);
        smartLabel.setStyle(quadrantConfig.tlConfig.styleObj);
        smartText = smartLabel.getSmartText(quadrantLabelTL, quadLeftWidth, quadTopHeight);

        quadrantLabelTL && animationManager.registerAnimation([{
          animType: animType,
          data: [{
            el: tlLabel,
            attrs: {
              x: xMin,
              y: yMax,
              text: smartText.text,
              direction: textDirection,
              'text-bound': quadrantConfig.tlConfig['text-bound']
            }
          }]
        }], 'plot');
      } else {
        tlLabel && animationManager.registerAnimation([{
          animType: animType,
          data: [{
            el: quadrantTLGroup,
            attrs: {
              opacity: 0
            },
            callback: hookFnHide
          }]
        }], 'initial');
      }
      if (quadrantLabelTR) {
        animationManager.registerAnimation([{
          animType: animType,
          data: [{
            el: quadrantTRGroup,
            attrs: {
              opacity: 1
            },
            animConfig: [{
              hookFn: hookFnShow
            }]
          }]
        }], 'final');

        if (!trLabel) {
          trLabel = graphics.trLabel = paper.text(quadrantTRGroup).attr({
            'text-anchor': POSITION_END,
            'vertical-align': POSITION_TOP,
            direction: textDirection
          }).css(quadrantConfig.trConfig.styleObj);
        }
        smartLabel.setStyle(quadrantConfig.trConfig.styleObj);
        smartText = smartLabel.getSmartText(quadrantLabelTR, quadRightWidth, quadTopHeight);

        quadrantLabelTR && animationManager.registerAnimation([{
          animType: animType,
          data: [{
            el: trLabel,
            attrs: {
              x: xMax,
              y: yMax,
              text: smartText.text,
              'text-bound': quadrantConfig.trConfig['text-bound']
            }
          }]
        }], 'plot');
      } else {
        trLabel && animationManager.registerAnimation([{
          animType: animType,
          data: [{
            el: quadrantTRGroup,
            attrs: {
              opacity: 0
            },
            callback: hookFnHide
          }]
        }], 'initial');
      }

      if (quadrantLabelBL) {
        animationManager.registerAnimation([{
          animType: animType,
          data: [{
            el: quadrantBLGroup,
            attrs: {
              opacity: 1
            },
            animConfig: [{
              hookFn: hookFnShow
            }]
          }]
        }], 'final');

        if (!blLabel) {
          blLabel = graphics.blLabel = paper.text(quadrantBLGroup).attr({
            'text-anchor': POSITION_START,
            'vertical-align': POSITION_BOTTOM,
            direction: textDirection
          }).css(quadrantConfig.blConfig.styleObj);
        }
        smartLabel.setStyle(quadrantConfig.blConfig.styleObj);
        smartText = smartLabel.getSmartText(quadrantLabelBL, quadLeftWidth, quadBottomHeight);

        quadrantLabelBL && animationManager.registerAnimation([{
          animType: animType,
          data: [{
            el: blLabel,
            attrs: {
              x: xMin,
              y: yMin,
              text: smartText.text,
              'text-bound': quadrantConfig.blConfig['text-bound']
            }
          }]
        }], 'plot');
      } else {
        blLabel && animationManager.registerAnimation([{
          animType: animType,
          data: [{
            el: quadrantBLGroup,
            attrs: {
              opacity: 0
            },
            callback: hookFnHide
          }]
        }], 'initial');
      }

      if (quadrantLabelBR) {
        animationManager.registerAnimation([{
          animType: animType,
          data: [{
            el: quadrantBRGroup,
            attrs: {
              opacity: 1
            },
            animConfig: [{
              hookFn: hookFnShow
            }]
          }]
        }], 'final');

        if (!brLabel) {
          brLabel = graphics.brLabel = paper.text(quadrantBRGroup).attr({
            'text-anchor': POSITION_END,
            'vertical-align': POSITION_BOTTOM,
            direction: textDirection
          }).css(quadrantConfig.brConfig.styleObj);
        }
        smartLabel.setStyle(quadrantConfig.brConfig.styleObj);
        smartText = smartLabel.getSmartText(quadrantLabelBR, quadRightWidth, quadBottomHeight);

        quadrantLabelBR && animationManager.registerAnimation([{
          animType: animType,
          data: [{
            el: brLabel,
            attrs: {
              x: xMax,
              y: yMin,
              text: smartText.text,
              'text-bound': quadrantConfig.brConfig['text-bound']
            }
          }]
        }], 'plot');
      } else {
        brLabel && animationManager.registerAnimation([{
          animType: animType,
          data: [{
            el: quadrantBRGroup,
            attrs: {
              opacity: 0
            },
            callback: hookFnHide
          }]
        }], 'initial');
      }
    } else {
      quadrantContainer && animationManager.registerAnimation([{
        animType: animType,
        data: [{
          el: quadrantContainer,
          attrs: {
            opacity: 0
          },
          callback: hookFnHide
        }]
      }], 'initial');
    }
  };

  return Quadrant;
}(_componentInterface2['default']);

exports['default'] = Quadrant;

/***/ }),
/* 410 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__(9);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(10);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2['default'] === "function" && typeof _iterator2['default'] === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2['default'] === "function" && obj.constructor === _symbol2['default'] && obj !== _symbol2['default'].prototype ? "symbol" : typeof obj; };

var _lib = __webpack_require__(5);

var _constructor = __webpack_require__(79);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */
/**
 * @private
 * @module fusioncharts.renderer.javascript.numberformatter
 * @requires fusioncharts.renderer.javascript.lib
 */

var UNDEF = void 0,

// global = this,
// lib = global.hcLib,
// UNDEF,
mathAbs = Math.abs,
    mathPow = Math.pow,
    mathRound = Math.round,
    ONESTRING = '1',
    BLANK = '',
    ZEROSTRING = '0',
    DECIMALSTRING = '.',
    COMMASTRING = ',',
    MINUSSTR = '-',
    regescape = function regescape(text) {
  return text && text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
},

// store for all number formater indexed by it's configuration hash key
NFStore = {},

/**
 * Objects mapped to a hash key will only have string type value for all properties
 * @param  {Object} obj Object with all string type property value only
 * @return {string}     Derived hash key from the object
 */
objToHash = function objToHash(obj) {
  var hashArr = [],
      i;
  for (i in obj) {
    hashArr.push(i + '_' + obj[i]);
  }
  hashArr.sort();
  return hashArr.join(',');
},

/**
 * This method creates a clone object with all property names in lower case. This doesn't work for
 * nested object properties.
 * @param  {Object} obj Object with all string type property value only
 * @return {Object}     Cloned object.
 */
objToLowerCase = function objToLowerCase(obj) {
  var clone = {},
      i;
  for (i in obj) {
    clone[i.toLowerCase()] = obj[i];
  }
  return clone;
},


/** @todo Use predefined Strings. */
TWOSTRING = '2',
    AUTOSTRING = 'auto',
    formatNumber = void 0,
    formatNumberScale = void 0,
    convertNumberSeps = void 0,
    formatDecimals = void 0,
    formatCommas = void 0,
    numberFormatDefaults = {
  formatnumber: ONESTRING,
  formatnumberscale: ONESTRING,
  forcenumberscale: ZEROSTRING,
  defaultnumberscale: BLANK,
  numberscaleunit: ['K', 'M'], // 'K,M',
  numberscalevalue: [1000, 1000], // '1000,1000',
  numberprefix: BLANK,
  numbersuffix: BLANK,
  // Decimals default value is different in different charts
  decimals: BLANK,
  forcedecimals: ZEROSTRING,
  yaxisvaluedecimals: TWOSTRING,
  decimalseparator: DECIMALSTRING,
  thousandseparator: COMMASTRING,
  // thousandSeparatorPosition new attribute added in numberFormatter
  // this defines the placement of thousandSeparator, defaultValue = 3
  // accepts comma separated value
  thousandseparatorposition: [3],
  indecimalseparator: BLANK,
  inthousandseparator: BLANK,
  sformatnumber: ONESTRING,
  sformatnumberscale: ZEROSTRING,
  sforcenumberscale: ZEROSTRING,
  sdefaultnumberscale: BLANK,
  snumberscaleunit: ['K', 'M'],
  snumberscalevalue: [1000, 1000],
  snumberprefix: BLANK,
  snumbersuffix: BLANK,
  sdecimals: TWOSTRING,
  sforcedecimals: ZEROSTRING,
  syaxisvaluedecimals: TWOSTRING,

  xFormatNumber: ZEROSTRING,
  xFormatNumberScale: ZEROSTRING,
  xforcenumberscale: ZEROSTRING,
  xDefaultNumberScale: BLANK,
  xNumberScaleUnit: ['K', 'M'],
  xNumberScaleValue: [1000, 1000],
  xNumberPrefix: BLANK,
  xNumberSuffix: BLANK
},
    numberFormatOverrides = {
  mscombidy2d: {
    formatnumberscale: ONESTRING
  }
};
/**
 * class definition for NumberFormatter
 */

var NumberFormatter = function () {
  /**
   * constructor function
   * @param {Object} iapi         chart object
   * @param {Object} customAttrs  attributes to configure number formatter
   */
  function NumberFormatter(iapi, customAttrs) {
    _classCallCheck(this, NumberFormatter);

    var nf = this,
        chartName = iapi.name,
        csConfigBuffer,
        csConf = nf.csConf = (0, _lib.extend2)({}, numberFormatDefaults),
        overrideConf = numberFormatOverrides[chartName];
    nf.cleaneValueCacheStore = {};
    nf.percentStrCacheStore = {};
    if (overrideConf) {
      csConfigBuffer = (0, _lib.extend2)(csConf, overrideConf);
      csConf = csConfigBuffer;
    }

    this.linkedItems = {
      iapi: iapi
    };
    nf.configure(customAttrs);
  }
  /**
   * function to configure this component
   * @param {Object} customAttrs  attributes to configure number formatter
   */


  NumberFormatter.prototype.configure = function configure(customAttrs) {
    var nf = this,
        iapi = nf.linkedItems.iapi,
        dataObj = iapi.jsonData,
        chartObj = customAttrs || dataObj.chart,
        chartName = iapi.name,
        csConf = nf.csConf,
        isMultyAxis,
        numberscaleunit,
        snumberscaleunit,
        xnumberscaleunit,
        ticknumberscaleunit,
        ynumberscaleunit,
        numberscalevalue,
        xnumberscalevalue,
        ticknumberscalevalue,
        ynumberscalevalue,
        thousandseparatorposition,
        snumberscalevalue,
        paramLabels,
        paramLabels2,
        param1,
        param2,
        baseConf,
        length,
        value,
        lastValue,
        scaleRecursively,
        sScaleRecursively,
        xScaleRecursively,
        maxScaleRecursion,
        sMaxScaleRecursion,
        xMaxScaleRecursion,
        scaleSeparator,
        sScaleSeparator,
        xScaleSeparator;

    nf.csConf = csConf;
    nf.useScaleRecursively = iapi.useScaleRecursively;

    // Converting user given numberScaleUnit into array
    if ((0, _lib.getValidValue)(chartObj.numberscaleunit)) {
      numberscaleunit = chartObj.numberscaleunit.split(COMMASTRING);
    }
    if (snumberscaleunit = (0, _lib.getValidValue)(chartObj.snumberscaleunit, chartObj.numberscaleunit)) {
      snumberscaleunit = snumberscaleunit.split(COMMASTRING);
    }
    if (xnumberscaleunit = (0, _lib.getValidValue)(chartObj.xnumberscaleunit, chartObj.numberscaleunit)) {
      xnumberscaleunit = xnumberscaleunit.split(COMMASTRING);
    }
    if (ticknumberscaleunit = (0, _lib.getValidValue)(chartObj.ticknumberscaleunit, chartObj.numberscaleunit)) {
      ticknumberscaleunit = ticknumberscaleunit.split(COMMASTRING);
    }
    if (ynumberscaleunit = (0, _lib.getValidValue)(chartObj.ynumberscaleunit, chartObj.numberscaleunit)) {
      ynumberscaleunit = ynumberscaleunit.split(COMMASTRING);
    }

    // Converting user given numberScaleValue into array
    if ((0, _lib.getValidValue)(chartObj.numberscalevalue)) {
      numberscalevalue = chartObj.numberscalevalue.split(COMMASTRING);
    }
    if (snumberscalevalue = (0, _lib.getValidValue)(chartObj.snumberscalevalue, chartObj.numberscalevalue)) {
      snumberscalevalue = snumberscalevalue.split(COMMASTRING);
    }
    if (xnumberscalevalue = (0, _lib.getValidValue)(chartObj.xnumberscalevalue, chartObj.numberscalevalue)) {
      xnumberscalevalue = xnumberscalevalue.split(COMMASTRING);
    }
    if (ticknumberscalevalue = (0, _lib.getValidValue)(chartObj.ticknumberscalevalue, chartObj.numberscalevalue)) {
      ticknumberscalevalue = ticknumberscalevalue.split(COMMASTRING);
    }
    if (ynumberscalevalue = (0, _lib.getValidValue)(chartObj.ynumberscalevalue, chartObj.numberscalevalue)) {
      ynumberscalevalue = ynumberscalevalue.split(COMMASTRING);
    }
    // Converting user given numberScaleValue into array
    if ((0, _lib.getValidValue)(chartObj.thousandseparatorposition)) {
      thousandseparatorposition = chartObj.thousandseparatorposition.split(COMMASTRING);
      length = thousandseparatorposition.length;
      lastValue = numberFormatDefaults.thousandseparatorposition[0];
      // Filtering the user given values
      while (length--) {
        value = parseInt(thousandseparatorposition[length], 10);
        if (value <= 0) {
          value = lastValue;
        }
        lastValue = thousandseparatorposition[length] = value;
        // thSepPosREGX = DECIMALSEPSTR + value + CLOSEBRACESSTR + thSepPosREGX;
      }
    }

    if (!iapi) {
      iapi = {};
    }

    scaleRecursively = (0, _lib.pluckNumber)(chartObj.scalerecursively, 0);
    sScaleRecursively = (0, _lib.pluckNumber)(chartObj.sscalerecursively, scaleRecursively);
    xScaleRecursively = (0, _lib.pluckNumber)(chartObj.xscalerecursively, scaleRecursively);
    maxScaleRecursion = (0, _lib.pluckNumber)(chartObj.maxscalerecursion, -1);
    sMaxScaleRecursion = (0, _lib.pluckNumber)(chartObj.smaxscalerecursion, maxScaleRecursion);
    xMaxScaleRecursion = (0, _lib.pluckNumber)(chartObj.xmaxscalerecursion, maxScaleRecursion);
    scaleSeparator = (0, _lib.getValidValue)(chartObj.scaleseparator, ' ');
    sScaleSeparator = (0, _lib.getValidValue)(chartObj.sscaleseparator, scaleSeparator);
    xScaleSeparator = (0, _lib.getValidValue)(chartObj.xscaleseparator, scaleSeparator);
    if (!maxScaleRecursion) {
      maxScaleRecursion = -1;
    }

    // create base number formater
    nf.baseConf = baseConf = {
      cacheStore: [],
      formatnumber: (0, _lib.pluck)(chartObj.formatnumber, iapi.formatnumber, csConf.formatnumber),
      formatnumberscale: (0, _lib.pluck)(chartObj.formatnumberscale, iapi.formatnumberscale, csConf.formatnumberscale),
      forcenumberscale: (0, _lib.pluck)(chartObj.forcenumberscale, iapi.forcenumberscale, csConf.forcenumberscale),
      defaultnumberscale: (0, _lib.getFirstValue)(chartObj.defaultnumberscale, iapi.defaultnumberscale, csConf.defaultnumberscale),
      numberscaleunit: (0, _lib.pluck)(numberscaleunit, iapi.numberscaleunit, csConf.numberscaleunit).concat(),
      numberscalevalue: (0, _lib.pluck)(numberscalevalue, iapi.numberscalevalue, csConf.numberscalevalue).concat(),
      numberprefix: (0, _lib.getFirstValue)(chartObj.numberprefix, iapi.numberprefix, csConf.numberprefix),
      numbersuffix: (0, _lib.getFirstValue)(chartObj.numbersuffix, iapi.numbersuffix, csConf.numbersuffix),
      decimalprecision: parseInt(chartObj.decimals === AUTOSTRING ? csConf.decimalprecision : (0, _lib.pluck)(chartObj.decimals, chartObj.decimalprecision, iapi.decimals, csConf.decimals, iapi.decimalprecision, csConf.decimalprecision), 10),
      forcedecimals: (0, _lib.pluck)(chartObj.forcedecimals, iapi.forcedecimals, csConf.forcedecimals),
      decimalseparator: (0, _lib.pluck)(chartObj.decimalseparator, iapi.decimalseparator, csConf.decimalseparator),
      thousandseparator: (0, _lib.pluck)(chartObj.thousandseparator, iapi.thousandseparator, csConf.thousandseparator),
      thousandseparatorposition: (0, _lib.pluck)(thousandseparatorposition, iapi.thousandseparatorposition, csConf.thousandseparatorposition),
      indecimalseparator: (0, _lib.getFirstValue)(chartObj.indecimalseparator, iapi.indecimalseparator, csConf.indecimalseparator),
      inthousandseparator: (0, _lib.getFirstValue)(chartObj.inthousandseparator, iapi.inthousandseparator, csConf.inthousandseparator),
      scalerecursively: scaleRecursively,
      maxscalerecursion: maxScaleRecursion,
      scaleseparator: scaleSeparator
    };

    // create the regex for inthousendseperator
    if ((0, _lib.getValidValue)(baseConf.inthousandseparator)) {
      nf.baseConf._REGinthousandseparator = new RegExp(regescape(baseConf.inthousandseparator), 'g');
    }
    if ((0, _lib.getValidValue)(baseConf.indecimalseparator)) {
      nf.baseConf._REGindecimalseparator = new RegExp(regescape(baseConf.indecimalseparator));
    }

    nf.Y = [];

    /**
     * @todo Do all Multi-Y-Axis calculations.
     */
    if (!isMultyAxis) {
      // Parameters passed with this function
      paramLabels = {
        cacheStore: [],
        formatnumber: baseConf.formatnumber,
        formatnumberscale: baseConf.formatnumberscale,
        forcenumberscale: baseConf.forcenumberscale,
        // defaultnumberscale  : pluck(chartObj.defaultnumberscale, (numberFormatOverrides[chartName] &&
        // numberFormatOverrides[chartName].defaultnumberscale)) ||
        // numberFormatDefaults.defaultnumberscale,
        defaultnumberscale: baseConf.defaultnumberscale,
        numberscaleunit: baseConf.numberscaleunit.concat(),
        numberscalevalue: baseConf.numberscalevalue.concat(),
        numberprefix: baseConf.numberprefix,
        numbersuffix: baseConf.numbersuffix,
        decimalprecision: baseConf.decimalprecision,
        forcedecimals: baseConf.forcedecimals,
        decimalseparator: baseConf.decimalseparator,
        thousandseparator: baseConf.thousandseparator,
        thousandseparatorposition: baseConf.thousandseparatorposition,
        indecimalseparator: baseConf.indecimalseparator,
        inthousandseparator: baseConf.inthousandseparator,
        scalerecursively: scaleRecursively,
        maxscalerecursion: maxScaleRecursion,
        scaleseparator: scaleSeparator
      };
      // scaleRecursively will use only by Widgets.
      if (!iapi.useScaleRecursively || (paramLabels.numberscalevalue && paramLabels.numberscalevalue.length) != (paramLabels.numberscaleunit && paramLabels.numberscaleunit.length)) {
        paramLabels.scalerecursively = scaleRecursively = 0;
      }

      param1 = {
        cacheStore: [],
        formatnumber: paramLabels.formatnumber,
        formatnumberscale: paramLabels.formatnumberscale,
        forcenumberscale: paramLabels.forcenumberscale,
        defaultnumberscale: paramLabels.defaultnumberscale,
        numberscaleunit: paramLabels.numberscaleunit.concat(),
        numberscalevalue: paramLabels.numberscalevalue.concat(),
        numberprefix: paramLabels.numberprefix,
        numbersuffix: paramLabels.numbersuffix,
        decimalprecision: parseInt((0, _lib.pluck)(chartObj.yaxisvaluedecimals, paramLabels.decimalprecision, 2), 10),
        forcedecimals: (0, _lib.pluck)(chartObj.forceyaxisvaluedecimals, paramLabels.forcedecimals),
        decimalseparator: paramLabels.decimalseparator,
        thousandseparator: paramLabels.thousandseparator,
        thousandseparatorposition: paramLabels.thousandseparatorposition.concat(),
        indecimalseparator: paramLabels.indecimalseparator,
        inthousandseparator: paramLabels.inthousandseparator,
        scalerecursively: scaleRecursively,
        maxscalerecursion: maxScaleRecursion,
        scaleseparator: scaleSeparator
      };

      // Parameters for sScale (secondary axis)
      param2 = {
        cacheStore: [],
        formatnumber: (0, _lib.pluck)(chartObj.sformatnumber, iapi.sformatnumber, numberFormatDefaults.sformatnumber),
        formatnumberscale: (0, _lib.pluck)(chartObj.sformatnumberscale, iapi.sformatnumberscale, numberFormatDefaults.sformatnumberscale),
        forcenumberscale: (0, _lib.pluck)(chartObj.sforcenumberscale, iapi.sforcenumberscale, numberFormatDefaults.sforcenumberscale),
        defaultnumberscale: (0, _lib.getFirstValue)(chartObj.sdefaultnumberscale, iapi.sdefaultnumberscale, paramLabels.defaultnumberscale),
        numberscaleunit: (0, _lib.pluck)(snumberscaleunit, iapi.snumberscaleunit, numberFormatDefaults.snumberscaleunit).concat(),
        numberscalevalue: (0, _lib.pluck)(snumberscalevalue, iapi.snumberscalevalue, numberFormatDefaults.snumberscalevalue).concat(),
        numberprefix: (0, _lib.getFirstValue)(chartObj.snumberprefix, iapi.snumberprefix, numberFormatDefaults.snumberprefix),
        numbersuffix: (0, _lib.getFirstValue)(chartObj.snumbersuffix, iapi.snumbersuffix, numberFormatDefaults.snumbersuffix),
        decimalprecision: parseInt((0, _lib.pluck)(chartObj.syaxisvaluedecimals, chartObj.sdecimals, chartObj.decimals, iapi.sdecimals, numberFormatDefaults.sdecimals), 10),
        forcedecimals: (0, _lib.pluck)(chartObj.forcesyaxisvaluedecimals, chartObj.sforcedecimals, chartObj.forcedecimals, iapi.sforcedecimals, numberFormatDefaults.sforcedecimals),
        decimalseparator: (0, _lib.pluck)(chartObj.decimalseparator, iapi.decimalseparator, numberFormatDefaults.decimalseparator),
        thousandseparator: (0, _lib.pluck)(chartObj.thousandseparator, iapi.thousandseparator, numberFormatDefaults.thousandseparator),
        thousandseparatorposition: paramLabels.thousandseparatorposition.concat(),
        indecimalseparator: (0, _lib.pluck)(chartObj.indecimalseparator, iapi.indecimalseparator, numberFormatDefaults.indecimalseparator),
        inthousandseparator: (0, _lib.pluck)(chartObj.inthousandseparator, iapi.inthousandseparator, numberFormatDefaults.inthousandseparator),
        scalerecursively: sScaleRecursively,
        maxscalerecursion: sMaxScaleRecursion,
        scaleseparator: sScaleSeparator
      };

      // MultiAxisLine chart secondary yAxis numberFormatter attribute mapping wrt primary yAxis
      // if (/^(multiaxisline)$/.test(chartName)) {
      //     param2.formatnumber = pluck(chartObj.sformatnumber, chartObj.formatnumber,
      //    iapi.sformatnumber,
      //     numberFormatDefaults.sformatnumber);
      //     param2.formatnumberscale = pluck(chartObj.sformatnumberscale, chartObj.formatnumberscale,
      //     iapi.sformatnumberscale, numberFormatDefaults.sformatnumberscale);
      //     param2.defaultnumberscale = getFirstValue(chartObj.sdefaultnumberscale,
      //    chartObj.defaultnumberscale,
      //     iapi.sdefaultnumberscale, paramLabels.defaultnumberscale);
      //     param2.numberprefix = getFirstValue(chartObj.snumberprefix, chartObj.numberprefix,
      //     iapi.snumberprefix, numberFormatDefaults.snumberprefix);
      //     param2.numbersuffix = getFirstValue(chartObj.snumbersuffix, chartObj.numbersuffix,
      //     iapi.snumbersuffix, numberFormatDefaults.snumbersuffix);
      //     param2.decimalprecision = parseInt(pluck(chartObj.syaxisvaluedecimals,
      //    chartObj.yaxisvaluedecimals,
      //     chartObj.sdecimals, chartObj.decimals, iapi.sdecimals,
      //    numberFormatDefaults.sdecimals), 10);
      //     param2.forcedecimals = pluck(chartObj.forcesyaxisvaluedecimals,
      //    chartObj.forceyaxisvaluedecimals,
      //     chartObj.sforcedecimals, chartObj.forcedecimals, iapi.sforcedecimals,
      //     numberFormatDefaults.sforcedecimals);
      // }
      // For secondary yAxis datalabels
      paramLabels2 = (0, _lib.extend2)({}, param2);
      paramLabels2.decimalprecision = parseInt((0, _lib.pluck)(chartObj.sdecimals, chartObj.decimals, chartObj.syaxisvaluedecimals, iapi.sdecimals, numberFormatDefaults.sdecimals), 10);
      paramLabels2.forcedecimals = (0, _lib.pluck)(chartObj.sforcedecimals, chartObj.forcedecimals, chartObj.forcesyaxisvaluedecimals, iapi.sforcedecimals, numberFormatDefaults.sforcedecimals);
      // add new cache store
      paramLabels2.cacheStore = [];

      // scaleRecursively will use only by Widgets.
      if (!iapi.useScaleRecursively || (param2.numberscalevalue && param2.numberscalevalue.length) != (param2.numberscaleunit && param2.numberscaleunit.length)) {
        param2.scalerecursively = sScaleRecursively = 0;
      }

      /** @todo Instead of testing chart-name, use default values or testing using chart API
      // Adding special attributes for yAxis (scatter and bubble) charts */
      if (/^(bubble|scatter|selectscatter|zoomscatter)$/.test(chartName)) {
        param1.formatnumber = (0, _lib.pluck)(chartObj.yformatnumber, param1.formatnumber);
        param1.formatnumberscale = (0, _lib.pluck)(chartObj.yformatnumberscale, param1.formatnumberscale);
        param1.forcenumberscale = (0, _lib.pluck)(chartObj.yforcenumberscale, param1.forcenumberscale);
        param1.defaultnumberscale = (0, _lib.getFirstValue)(chartObj.ydefaultnumberscale, param1.defaultnumberscale);
        param1.numberscaleunit = (0, _lib.pluck)(ynumberscaleunit, param1.numberscaleunit);
        param1.numberscalevalue = (0, _lib.pluck)(ynumberscalevalue, param1.numberscalevalue);
        param1.numberprefix = (0, _lib.pluck)(chartObj.ynumberprefix, param1.numberprefix);
        param1.numbersuffix = (0, _lib.pluck)(chartObj.ynumbersuffix, param1.numbersuffix);
        //
        paramLabels.formatnumber = (0, _lib.pluck)(chartObj.yformatnumber, paramLabels.formatnumber);
        paramLabels.formatnumberscale = (0, _lib.pluck)(chartObj.yformatnumberscale, paramLabels.formatnumberscale);
        paramLabels.forcenumberscale = (0, _lib.pluck)(chartObj.yforcenumberscale, paramLabels.forcenumberscale);
        paramLabels.defaultnumberscale = (0, _lib.getFirstValue)(chartObj.ydefaultnumberscale, paramLabels.defaultnumberscale);
        paramLabels.numberscaleunit = (0, _lib.pluck)(chartObj.ynumberscaleunit, paramLabels.numberscaleunit.concat());
        paramLabels.numberscalevalue = (0, _lib.pluck)(chartObj.ynumberscalevalue, paramLabels.numberscalevalue.concat());
        paramLabels.numberprefix = (0, _lib.pluck)(chartObj.ynumberprefix, paramLabels.numberprefix);
        paramLabels.numbersuffix = (0, _lib.pluck)(chartObj.ynumbersuffix, paramLabels.numbersuffix);
      }

      // Adding special attributes for secondary yAxis
      /* RED-2036: The below code is commented because of js error in the formatnumberscale is becoming
        * undefined when the sformatnumberscale is not set in chart attributes. Also this line may not have
        * impact so just commenting it for future use if required.
        *  if (/^(mscombidy2d|mscombidy3d)$/.test(chartName)) {
        *        param2.formatnumberscale = pluckNumber(chartObj.sformatnumberscale);
        *        param2.forcenumberscale = pluckNumber(chartObj.sforcenumberscale);
        *  }
        */

      // Fix for some chart decimals default value different
      if (/^(pie2d|pie3d|doughnut2d|doughnut3d|marimekko|pareto2d|pareto3d)$/.test(chartName)) {
        paramLabels.decimalprecision = (0, _lib.pluck)(chartObj.decimals, TWOSTRING);
      }

      // Adjusting numberScaleValue and numberScaleUnit array to be use in
      // the calculation of scaleRecursively
      if (scaleRecursively) {
        paramLabels.numberscalevalue.push(1);
        paramLabels.numberscaleunit.unshift(paramLabels.defaultnumberscale);

        param1.numberscalevalue.push(1);
        param1.numberscaleunit.unshift(param1.defaultnumberscale);
      }
      if (sScaleRecursively) {
        param2.numberscalevalue.push(1);
        param2.numberscaleunit.unshift(param2.defaultnumberscale);

        paramLabels2.numberscalevalue.push(1);
        paramLabels2.numberscaleunit.unshift(paramLabels2.defaultnumberscale);
      }

      nf.Y[0] = {
        yAxisLabelConf: param1,
        dataLabelConf: paramLabels
      };
      nf.Y[1] = {
        yAxisLabelConf: param2,
        dataLabelConf: paramLabels2
      };
      // for backword compatibility issue
      /** @todo: have to be removed after removing all dependency */
      nf.paramLabels = paramLabels;
      nf.param1 = param1;
      nf.param2 = param2;
      nf.paramLabels2 = paramLabels2;
    }

    /** @todo: create paramX & paramScale only if requird  */

    // xAxis Label formatter for scatter type X-y plot charts
    // Parameters for xScale
    nf.paramX = {
      cacheStore: [],
      formatnumber: (0, _lib.pluck)(chartObj.xformatnumber, baseConf.formatnumber),
      formatnumberscale: (0, _lib.pluck)(chartObj.xformatnumberscale, baseConf.formatnumberscale),
      forcenumberscale: (0, _lib.pluck)(chartObj.xforcenumberscale, baseConf.forcenumberscale),
      defaultnumberscale: (0, _lib.getFirstValue)(chartObj.xdefaultnumberscale, baseConf.defaultnumberscale),
      numberscaleunit: (0, _lib.pluck)(xnumberscaleunit, baseConf.numberscaleunit.concat()),
      numberscalevalue: (0, _lib.pluck)(xnumberscalevalue, baseConf.numberscalevalue.concat()),
      numberprefix: (0, _lib.pluck)(chartObj.xnumberprefix, baseConf.numberprefix),
      numbersuffix: (0, _lib.pluck)(chartObj.xnumbersuffix, baseConf.numbersuffix),
      decimalprecision: parseInt((0, _lib.pluck)(chartObj.xaxisvaluedecimals, chartObj.xaxisvaluesdecimals, baseConf.decimalprecision, 2), 10),
      forcedecimals: (0, _lib.pluck)(chartObj.forcexaxisvaluedecimals, 0),
      decimalseparator: baseConf.decimalseparator,
      thousandseparator: baseConf.thousandseparator,
      thousandseparatorposition: baseConf.thousandseparatorposition.concat(),
      indecimalseparator: baseConf.indecimalseparator,
      inthousandseparator: baseConf.inthousandseparator,
      scalerecursively: xScaleRecursively,
      maxscalerecursion: xMaxScaleRecursion,
      scaleseparator: xScaleSeparator
    };

    nf.paramLegend = (0, _lib.extend2)((0, _lib.extend2)({}, baseConf), {
      cacheStore: [],
      decimalprecision: parseInt((0, _lib.pluckNumber)(chartObj.legendvaluedecimals, baseConf.decimalprecision, 2), 10),
      forcedecimals: (0, _lib.pluckNumber)(chartObj.legendvalueforcedecimals, baseConf.forcedecimals, 0),
      formatnumberscale: (0, _lib.pluck)(chartObj.legendvalueformatnumberscale, baseConf.formatnumberscale),
      forcenumberscale: (0, _lib.pluck)(chartObj.legendvalueforcenumberscale, baseConf.forcenumberscale),
      formatnumber: (0, _lib.pluck)(chartObj.legendvalueformatnumber, baseConf.formatnumber)
    });

    if (scaleRecursively) {
      nf.paramLegend.numberscalevalue.push(1);
      nf.paramLegend.numberscaleunit.unshift(nf.paramLegend.defaultnumberscale);
    }

    // scaleRecursively will use only by Widgets.
    if (!iapi.useScaleRecursively || (nf.paramX.numberscalevalue && nf.paramX.numberscalevalue.length) != (nf.paramX.numberscaleunit && nf.paramX.numberscaleunit.length)) {
      nf.paramX.scalerecursively = xScaleRecursively = 0;
    }

    if (xScaleRecursively) {
      nf.paramX.numberscalevalue.push(1);
      nf.paramX.numberscaleunit.unshift(nf.paramX.defaultnumberscale);
    }

    nf.paramScale = {
      cacheStore: [],
      formatnumber: (0, _lib.pluck)(chartObj.tickformatnumber, baseConf.formatnumber),
      formatnumberscale: (0, _lib.pluck)(chartObj.tickformatnumberscale, baseConf.formatnumberscale),
      forcenumberscale: (0, _lib.pluck)(chartObj.tickforcenumberscale, baseConf.forcenumberscale),
      defaultnumberscale: (0, _lib.getFirstValue)(chartObj.tickdefaultnumberscale, baseConf.defaultnumberscale),
      numberscaleunit: (0, _lib.pluck)(ticknumberscaleunit, baseConf.numberscaleunit.concat()),
      numberscalevalue: (0, _lib.pluck)(ticknumberscalevalue, baseConf.numberscalevalue.concat()),
      numberprefix: (0, _lib.pluck)(chartObj.ticknumberprefix, baseConf.numberprefix),
      numbersuffix: (0, _lib.pluck)(chartObj.ticknumbersuffix, baseConf.numbersuffix),
      decimalprecision: parseInt((0, _lib.pluck)(chartObj.tickvaluedecimals, baseConf.decimalprecision, TWOSTRING), 10),
      forcedecimals: (0, _lib.pluck)(chartObj.forcetickvaluedecimals, baseConf.forcedecimals, 0),
      decimalseparator: baseConf.decimalseparator,
      thousandseparator: baseConf.thousandseparator,
      thousandseparatorposition: baseConf.thousandseparatorposition.concat(),
      indecimalseparator: baseConf.indecimalseparator,
      inthousandseparator: baseConf.inthousandseparator,
      scalerecursively: scaleRecursively,
      maxscalerecursion: maxScaleRecursion,
      scaleseparator: scaleSeparator
    };

    // Adjusting numberScaleValue and numberScaleUnit array to be use in
    // the calculation of scaleRecursively
    if (scaleRecursively) {
      nf.paramScale.numberscalevalue.push(1);
      nf.paramScale.numberscaleunit.unshift(nf.paramScale.defaultnumberscale);
    }

    // dateTime parser conf
    nf.timeConf = {
      inputDateFormat: (0, _lib.pluck)(chartObj.inputdateformat, chartObj.dateformat, 'mm/dd/yyyy'),
      outputDateFormat: (0, _lib.pluck)(chartObj.outputdateformat, chartObj.inputdateformat, chartObj.dateformat, 'mm/dd/yyyy'),
      days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
      months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
      daySuffix: ['', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'st']
    };

    // setting an object level cache store for percent value and clean value, since setting
    // them at prototype level will not force them to be cleared during new object creation.
    nf.cleaneValueCacheStore = {};
    nf.percentStrCacheStore = {};
  };
  /**
   * delete all object ref and cache store
   */


  NumberFormatter.prototype.dispose = function dispose() {
    var nf = this;
    // delete y axis params
    if (nf.Y) {
      delete nf.Y;
    }
    // delete cleaneValueCacheStore
    if (nf.cleaneValueCacheStore) {
      delete nf.cleaneValueCacheStore;
    }
    // delete cleaneValueCacheStore
    if (nf.percentStrCacheStore) {
      delete nf.percentStrCacheStore;
    }
    // delete baseConf
    if (nf.paramLabels) {
      delete nf.paramLabels;
    }
    // delete baseConf
    if (nf.param1) {
      delete nf.param1;
    }
    // delete baseConf
    if (nf.param2) {
      delete nf.param2;
    }
    // delete baseConf
    if (nf.paramLabels2) {
      delete nf.paramLabels2;
    }
    // delete baseConf
    if (nf.csConf) {
      delete nf.csConf;
    }
    // delete baseConf
    if (nf.iapi) {
      delete nf.iapi;
    }
    // delete baseConf
    if (nf.baseConf) {
      delete nf.baseConf;
    }
    // delete timeConf
    if (nf.timeConf) {
      delete nf.timeConf;
    }
    // delete paramX
    if (nf.paramX) {
      delete nf.paramX;
    }
    // delete paramScale
    if (nf.paramScale) {
      delete nf.paramScale;
    }
  };
  /**
   * function to parse axis configuration
   * @param {Object} axisObj configuration object
   * @param {number} index   index of y-axis
   */


  NumberFormatter.prototype.parseMLAxisConf = function parseMLAxisConf(axisObj, index) {
    var baseConf = this.baseConf,
        csConf = this.csConf,
        scaleRecursively = (0, _lib.pluckNumber)(axisObj.scalerecursively, baseConf.scalerecursively),
        maxScaleRecursion = (0, _lib.pluckNumber)(axisObj.maxscalerecursion, baseConf.maxscalerecursion),
        scaleSeparator = (0, _lib.getValidValue)(axisObj.scaleseparator, baseConf.scaleseparator),
        paramLabels,
        numberscaleunit,
        numberscalevalue,
        param,
        thousandseparatorposition,
        length,
        value,
        lastValue;

    index = (0, _lib.pluckNumber)(index, this.Y.length);

    if ((0, _lib.getValidValue)(axisObj.numberscaleunit)) {
      numberscaleunit = axisObj.numberscaleunit.split(COMMASTRING);
    }
    // Converting user given numberScaleValue into array
    if ((0, _lib.getValidValue)(axisObj.numberscalevalue)) {
      numberscalevalue = axisObj.numberscalevalue.split(COMMASTRING);
    }
    if (!maxScaleRecursion) {
      maxScaleRecursion = -1;
    }
    // Converting user given numberScaleValue into array
    if ((0, _lib.getValidValue)(axisObj.thousandseparatorposition)) {
      thousandseparatorposition = axisObj.thousandseparatorposition.split(COMMASTRING);
      length = thousandseparatorposition.length;
      lastValue = numberFormatDefaults.thousandseparatorposition[0];
      // Filtering the user given values
      while (length--) {
        value = (0, _lib.pluckNumber)(mathAbs(thousandseparatorposition[length]));
        if (!value) {
          value = lastValue;
        } else {
          lastValue = value;
        }
        thousandseparatorposition[length] = value;
      }
    }
    // Parameters passed with this function
    paramLabels = {
      cacheStore: [],
      formatnumber: (0, _lib.pluck)(axisObj.formatnumber, baseConf.formatnumber),
      formatnumberscale: (0, _lib.pluck)(axisObj.formatnumberscale, baseConf.formatnumberscale),
      forcenumberscale: (0, _lib.pluck)(axisObj.forcenumberscale, baseConf.forcenumberscale),
      // defaultnumberscale  : pluck(chartObj.defaultnumberscale, (numberFormatOverrides[chartName] &&
      // numberFormatOverrides[chartName].defaultnumberscale)) || numberFormatDefaults.defaultnumberscale,
      defaultnumberscale: (0, _lib.getFirstValue)(axisObj.defaultnumberscale, baseConf.defaultnumberscale),
      numberscaleunit: (0, _lib.pluck)(numberscaleunit, baseConf.numberscaleunit).concat(),
      numberscalevalue: (0, _lib.pluck)(numberscalevalue, baseConf.numberscalevalue).concat(),
      numberprefix: (0, _lib.getFirstValue)(axisObj.numberprefix, baseConf.numberprefix),
      numbersuffix: (0, _lib.getFirstValue)(axisObj.numbersuffix, baseConf.numbersuffix),
      forcedecimals: (0, _lib.pluck)(axisObj.forcedecimals, baseConf.forcedecimals),
      decimalprecision: parseInt(axisObj.decimals === AUTOSTRING ? csConf.decimalprecision : (0, _lib.pluck)(axisObj.decimals, baseConf.decimalprecision), 10),
      decimalseparator: (0, _lib.pluck)(axisObj.decimalseparator, baseConf.decimalseparator),
      thousandseparator: (0, _lib.pluck)(axisObj.thousandseparator, baseConf.thousandseparator),
      thousandseparatorposition: (0, _lib.pluck)(thousandseparatorposition, baseConf.thousandseparatorposition),
      indecimalseparator: (0, _lib.getFirstValue)(axisObj.indecimalseparator, baseConf.indecimalseparator),
      inthousandseparator: (0, _lib.getFirstValue)(axisObj.inthousandseparator, baseConf.inthousandseparator),
      scalerecursively: scaleRecursively,
      maxscalerecursion: maxScaleRecursion,
      scaleseparator: scaleSeparator
    };
    // scaleRecursively will use only by Widgets.
    if (!this.useScaleRecursively || (paramLabels.numberscalevalue && paramLabels.numberscalevalue.length) != (paramLabels.numberscaleunit && paramLabels.numberscaleunit.length)) {
      paramLabels.scalerecursively = scaleRecursively = 0;
    }

    param = {
      cacheStore: [],
      formatnumber: paramLabels.formatnumber,
      formatnumberscale: paramLabels.formatnumberscale,
      forcenumberscale: paramLabels.forcenumberscale,
      defaultnumberscale: paramLabels.defaultnumberscale,
      numberscaleunit: paramLabels.numberscaleunit.concat(),
      numberscalevalue: paramLabels.numberscalevalue.concat(),
      numberprefix: paramLabels.numberprefix,
      numbersuffix: paramLabels.numbersuffix,
      decimalprecision: parseInt((0, _lib.pluck)(axisObj.yaxisvaluedecimals, paramLabels.decimalprecision, 2), 10),
      forcedecimals: (0, _lib.pluck)(axisObj.forceyaxisvaluedecimals, paramLabels.forcedecimals),
      decimalseparator: paramLabels.decimalseparator,
      thousandseparator: paramLabels.thousandseparator,
      thousandseparatorposition: paramLabels.thousandseparatorposition.concat(),
      indecimalseparator: paramLabels.indecimalseparator,
      inthousandseparator: paramLabels.inthousandseparator,
      scalerecursively: scaleRecursively,
      maxscalerecursion: maxScaleRecursion,
      scaleseparator: scaleSeparator
    };

    // Adjusting numberScaleValue and numberScaleUnit array to be use in
    // the calculation of scaleRecursively
    if (scaleRecursively) {
      paramLabels.numberscalevalue.push(1);
      paramLabels.numberscaleunit.unshift(paramLabels.defaultnumberscale);

      param.numberscalevalue.push(1);
      param.numberscaleunit.unshift(param.defaultnumberscale);
    }

    this.Y[index] = {
      dataLabelConf: paramLabels,
      yAxisLabelConf: param
    };
  };
  /**
   * function to return percentage string corresponding number
   * @param {number} num    number
   * @return {string}       percent string of given number
   */


  NumberFormatter.prototype.percentValue = function percentValue(num) {
    // don't use 2'nd argument it may conflict with yAxis()'s 2'nd arg
    var rtn = this.percentStrCacheStore[num],
        precision;
    if (rtn === UNDEF) {
      precision = isNaN(this.paramLabels.decimalprecision) ? '2' : this.paramLabels.decimalprecision;
      rtn = this.percentStrCacheStore[num] = formatCommas(formatDecimals(num, precision, this.paramLabels.forcedecimals), this.paramLabels.decimalseparator, this.paramLabels.thousandseparator, this.paramLabels.thousandseparatorposition) + '%';
    }
    return rtn;
  };
  /**
   * function to get a valid value; it returns either null or number
   * configuration of getCleanValue will be same across all dataset/axis
   * @param {number} numStr  string to be checked
   * @param {number} abs     whether return value would be absolute or not
   * @return {number}        returns a valid value
   */


  NumberFormatter.prototype.getCleanValue = function getCleanValue(numStr, abs) {
    var rtn = this.cleaneValueCacheStore[numStr],
        num;
    if (rtn === UNDEF || abs) {
      num = convertNumberSeps(numStr, this.baseConf);
      this.cleaneValueCacheStore[numStr] = rtn = isNaN(num) ? null : abs ? mathAbs(num) : num;
    }
    return rtn;
  };
  /**
   * function to format data label and return formatted value as per the formatter configuration
   * @param {number} num        number to be converted
   * @param {number} axisIndex  index the axis
   * @return {string}           formated string
   */


  NumberFormatter.prototype.dataLabels = function dataLabels(num, axisIndex) {
    var formatterConf = this.Y[axisIndex] || (axisIndex ? this.Y[1] : this.Y[0]),
        rtn;
    formatterConf = formatterConf && formatterConf.dataLabelConf || this.baseConf;
    rtn = formatterConf.cacheStore[num];
    if (rtn === UNDEF) {
      rtn = formatterConf.cacheStore[num] = formatNumber(num, formatterConf);
    }
    return rtn;
  };
  /**
   * function to format y-axis label and return formatted value as per the formatter configuration
   * @param {number} num        number to be converted
   * @param {number} axisIndex  index the axis
   * @return {string}           formated string
   */


  NumberFormatter.prototype.yAxis = function yAxis(num, axisIndex) {
    var formatterConf = this.Y[axisIndex] || (axisIndex ? this.Y[1] : this.Y[0]),
        rtn;
    formatterConf = formatterConf && formatterConf.yAxisLabelConf || this.baseConf;
    rtn = formatterConf.cacheStore[num];
    if (rtn === UNDEF) {
      // Last parameter denotes whether value is axis value or not
      rtn = formatterConf.cacheStore[num] = formatNumber(num, formatterConf, true);
    }
    return rtn;
  };
  // don't use 2'nd argument it may conflict with y axis 2'nd arg
  // refer to use of numberformater during trendline parsing
  /**
   * function to format x-axis numeric label and return formatted value as per the formatter configuration
   * refer to use of numberformater during trendline parsing
   * [don't use 2'nd argument it may conflict with y axis 2'nd arg]
   * @param {number} num        number to be converted
   * @return {string}           formated string
   */


  NumberFormatter.prototype.xAxis = function xAxis(num) {
    var rtn = this.paramX.cacheStore[num];
    if (rtn === UNDEF) {
      // Last parameter denotes whether value is axis value or not
      rtn = this.paramX.cacheStore[num] = formatNumber(num, this.paramX, true);
    }
    return rtn;
  };
  /**
   * function to format secondary y-axis label and return formatted value as per the formatter configuration
   * @param {number} num        number to be converted
   * @return {string}           formated string
   */


  NumberFormatter.prototype.sYAxis = function sYAxis(num) {
    var formatterConf = this.Y[1],
        rtn;
    formatterConf = formatterConf && formatterConf.yAxisLabelConf || this.baseConf;
    rtn = formatterConf.cacheStore[num];
    if (rtn === UNDEF) {
      rtn = formatterConf.cacheStore[num] = formatNumber(num, formatterConf);
    }
    return rtn;
  };
  /**
   * function to format scale label and return formatted value as per the formatter configuration
   * @param {number} num        number to be converted
   * @return {string}           formated string
   */


  NumberFormatter.prototype.scale = function scale(num) {
    var rtn = this.paramScale.cacheStore[num];
    if (rtn === UNDEF) {
      rtn = this.paramScale.cacheStore[num] = formatNumber(num, this.paramScale);
    }
    return rtn;
  };

  /**
   * function to get formatted legend value as per the formatting configuration for legend
   * @param   {number} num    number to be converted
   * @return  {string}        formatted value
   */


  NumberFormatter.prototype.legendValue = function legendValue(num) {
    var rtn = this.paramLegend.cacheStore[num];
    if (rtn === UNDEF) {
      rtn = this.paramLegend.cacheStore[num] = formatNumber(num, this.paramLegend);
    }
    return rtn;
  };
  /**
   * function to return percentage string corresponding number
   * @param {number} num    number to be converted
   * @return {string}       percent string of given number
   */


  NumberFormatter.prototype.legendPercentValue = function legendPercentValue(num) {
    var rtn = this.percentStrCacheStore[num],
        paramLegend = this.paramLegend,
        precision;
    if (rtn === UNDEF) {
      precision = isNaN(paramLegend.decimalprecision) ? '2' : paramLegend.decimalprecision;
      rtn = this.percentStrCacheStore[num] = formatCommas(formatDecimals(num, precision, paramLegend.forcedecimals), paramLegend.decimalseparator, paramLegend.thousandseparator, paramLegend.thousandseparatorposition) + '%';
    }
    return rtn;
  };

  /**
   * getDateValue is the date formatter function which converts date
   * to milliseconds
   *
   * @param {string} date Date to be converted
   * @return {Object} Object with the key ms containing milliseconds
   * and date containing date object
   */


  NumberFormatter.prototype.getDateValue = function getDateValue(date) {
    var dataObj, hour, min, sec, ms;

    // Convert the date provided in argument from any format to
    // supported in 'inputDateFormat' configuration to a standard
    // JavaScript date parseable format
    if (date && !/\//.test(this.timeConf.inputDateFormat)) {
      date = date.replace(new RegExp(this.timeConf.inputDateFormat.replace(/[a-z]/ig, BLANK).slice(0, 1), 'g'), '/');
    }
    date = /^dd/.test(this.timeConf.inputDateFormat) && date && date.replace(/(\d{1,2})\/(\d{1,2})\/(\d{2,4})/, '$2/$1/$3') || date;

    dataObj = new Date(date);
    ms = dataObj.getTime();

    // If date is in time format (hh:mm:ss)
    if (!ms && date && /\:/.test(date)) {
      // Extract hour, min and seconds
      date = date.split(':');
      hour = (0, _lib.pluckNumber)(date[0], 0);
      min = (0, _lib.pluckNumber)(date[1], 0);
      sec = (0, _lib.pluckNumber)(date[2], 0);

      // validate hour, min and sec
      hour = hour > 23 ? hour === 24 && min === 0 && sec === 0 ? hour : 23 : hour;
      min = min > 59 ? 59 : min;
      sec = sec > 59 ? 59 : sec;

      // Using JS Date object to get the milliseconds
      // value of the time
      dataObj = new Date();
      dataObj.setHours(hour);
      dataObj.setMinutes(min);
      dataObj.setSeconds(sec);
      ms = dataObj.getTime();
    }

    return {
      ms: ms,
      date: dataObj
    };
  };
  /**
   * function to get formatted date (in string) as per the configuration
   * @param   {Date}   date       date object to be coverted
   * @param   {string} format     in which format date is to be converted (for example: mm-dd-yy)
   * @return  {string}            string contains formatted date
   */


  NumberFormatter.prototype.getFormattedDate = function getFormattedDate(date, format) {
    var D = (typeof date === 'undefined' ? 'undefined' : _typeof(date)) === 'object' && date || new Date(date),
        timeConf = this.timeConf,
        output = (0, _lib.pluck)(format, timeConf.outputDateFormat),
        year = D.getFullYear(),
        month = D.getMonth(),
        day = D.getDate(),
        nday = D.getDay(),
        min = D.getMinutes(),
        sec = D.getSeconds(),
        hours = D.getHours();

    min = min > 9 ? BLANK + min : ZEROSTRING + min;
    sec = sec > 9 ? BLANK + sec : ZEROSTRING + sec;
    hours = hours > 9 ? BLANK + hours : ZEROSTRING + hours;

    output.match(/dnl/) && (output = output.replace(/dnl/ig, timeConf.days[nday]));
    output.match(/dns/) && (output = output.replace(/dns/ig, timeConf.days[nday] && timeConf.days[nday].substr(0, 3)));
    output.match(/dd/) && (output = output.replace(/dd/ig, day));

    output.match(/mnl/) && (output = output.replace(/mnl/ig, timeConf.months[month]));
    output.match(/mns/) && (output = output.replace(/mns/ig, timeConf.months[month] && timeConf.months[month].substr(0, 3)));
    output.match(/mm/) && (output = output.replace(/mm/ig, month + 1));

    output.match(/yyyy/) && (output = output.replace(/yyyy/ig, year));
    output.match(/yy/) && (output = output.replace(/yy/ig, (year % 1000 % 100 + '').replace(/^(\d)$/, '0$1')));

    output.match(/hh12/) && (output = output.replace(/hh12/ig, hours % 12 || 12));
    output.match(/hh/) && (output = output.replace(/hh/ig, hours));

    output.match(/mn/) && (output = output.replace(/mn/ig, min));
    output.match(/ss/) && (output = output.replace(/ss/ig, sec));
    output.match(/ampm/) && (output = output.replace(/ampm/ig, hours < 12 ? 'AM' : 'PM'));
    output.match(/ds/) && (output = output.replace(/ds/ig, timeConf.daySuffix[day]));

    return output;
  };

  return NumberFormatter;
}();

formatNumber = function formatNumber(num, attributes, isAxisValue) {
  var strNum,

  // Number Scale
  strScale, numList, scaleList, upperIndex, tempNum, tempStr, i, valueArr, decimalPlaceLen, objNum;

  // We convert the number to a valid number
  // If inDecimalsSeparator and in thousandSeparator is given
  // we replace the thousandSeparator and decimalSeparator with
  // proper valid number format
  // num = convertNumberSeps(num, attributes.indecimalseparator, attributes.inthousandseparator);

  // Change for JS Charts:
  // After initial return from getCleanValue, we get either null or a
  // number. So, we validate presence of null only.
  if (num === null) {
    return; // throw TypeError('Not a Valid number');
  }

  // Failsafe conversion of value to proper type.
  num = Number(num);

  // First, if number is to be scaled, scale it
  // Number in String format
  strNum = num + BLANK;

  if (attributes.formatnumberscale == 1) {
    strScale = attributes.defaultnumberscale;
  } else {
    strScale = BLANK;
  }

  // Fix to show the decimal place
  // if there is more than 2 decimal place in data
  // Finding the decimal place in value
  valueArr = strNum.split(DECIMALSTRING)[1];
  decimalPlaceLen = valueArr ? valueArr.length : attributes.forcedecimals ? TWOSTRING : BLANK;

  // Whether to add K (thousands) and M (millions) to a number
  if (attributes.formatnumberscale == 1) {
    // Get the formatted scale and number
    objNum = formatNumberScale(num, attributes.defaultnumberscale, attributes.numberscalevalue, attributes.numberscaleunit, attributes.scalerecursively, attributes.forcenumberscale);
    // Store from return in local primitive variables

    strNum = objNum.value;
    num = objNum.value;
    strScale = objNum.scale;
  }

  if (attributes.scalerecursively && attributes.formatnumberscale !== 0 && attributes.formatnumberscale !== '0') {
    // Store the list of numbers and scales.
    numList = objNum.value;
    scaleList = objNum.scale;

    // Based on max scale recursion, we decide the upper index to which we've to iterate
    upperIndex = attributes.maxscalerecursion == -1 ? numList.length : Math.min(numList.length, attributes.maxscalerecursion);
    // Now, based on whether we've to format decimals and commas.
    if (attributes.formatnumber == 1) {
      // If recursive scaling was applied and format number is true, we need to :
      // - format comma of all values
      // - format decimals of just the last value (last based on max recursion or actual).
      strNum = '';
      for (i = 0; i < upperIndex; i++) {
        // Convert all but first number to absolute values.
        tempNum = i === 0 ? numList[i] : Math.abs(numList[i]);
        tempStr = tempNum + BLANK;
        // If it's the last value, format decimals
        if (i == upperIndex - 1) {
          tempStr = formatDecimals(tempNum, (0, _lib.pluck)(attributes.decimalprecision, decimalPlaceLen), attributes.forcedecimals);
        }
        // Append to strNum after formatting commas
        // We separate the scales using scale separator. The last token doesn't append
        // the scale separator, as we append number suffix after that.
        strNum = strNum + formatCommas(tempStr, attributes.decimalseparator, attributes.thousandseparator, attributes.thousandseparatorposition) + scaleList[i] + (i < upperIndex - 1 ? attributes.scaleseparator : '');
      }
    } else {
      strNum = '';
      for (i = 0; i < upperIndex; i++) {
        // Convert all but first number to absolute values and append to strNum.
        // We separate the scales using scale separator. The last token doesn't append
        // the scale separator, as we append number suffix after that.
        strNum = strNum + (i === 0 ? numList[i] : Math.abs(numList[i]) + BLANK) + scaleList[i] + (i < upperIndex - 1 ? attributes.scaleseparator : '');
      }
    }
    // Now, add scale, number prefix and suffix
    // strNum = numberPrefix + strNum + strScale + numberSuffix;
    strNum = (attributes.numberprefix || BLANK) + strNum + (attributes.numbersuffix || BLANK);
  } else {
    // Now, if we've to format the decimals and commas
    if (attributes.formatnumber == 1) {
      // Format decimals
      strNum = formatDecimals(num, (0, _lib.pluck)(attributes.decimalprecision, decimalPlaceLen), attributes.forcedecimals);
      // Format commas now
      strNum = formatCommas(strNum, attributes.decimalseparator, attributes.thousandseparator, attributes.thousandseparatorposition, isAxisValue);
    }

    // Now, add scale, number prefix and suffix
    // strNum = numberPrefix + strNum + strScale + numberSuffix;
    strNum = (attributes.numberprefix || BLANK) + strNum + strScale + (attributes.numbersuffix || BLANK);
  }
  return strNum;
};

/**
 * formatNumberScale formats the number as per given scale.
 * For example, if number Scale Values are 1000,1000 and
 * number Scale Units are K,M, this method will divide any
 * value over 1000000 using M and any value over 1000 (less than 1M) using K
 * so as to give abbreviated figures.
 * Number scaling lets you define your own scales for numbers.
 * To clarify further, let's consider an example. Say you're plotting
 * a chart which indicates the time taken by a list of automated
 * processes. Each process in the list can take time ranging from a
 * few seconds to few days. And you've the data for each process in
 * seconds itself. Now, if you were to show all the data on the chart
 * in seconds only, it won't appear too legible. What you can do is
 * build a scale of yours and then specify it to the chart. A scale,
 * in human terms, would look something as under:
 * 60 seconds = 1 minute
 * 60 minute = 1 hr
 * 24 hrs = 1 day
 * 7 days = 1 week
 * First you would need to define the unit of the data which you're providing.
 * Like, in this example, you're providing all data in seconds. So, default
 * number scale would be represented in seconds. You can represent it as under:
 * <graph defaultNumberScale='s' ...>
 * Next, the scale for the chart is defined as under:
 * <graph numberScaleValue='60,60,24,7' numberScaleUnit='min,hr,day,wk' >
 * If you carefully see this and match it with our range, whatever numeric
 * figure was present on the left hand side of the range is put in
 * numberScaleValue and whatever unit was present on the right side of
 * the scale has been put under numberScaleUnit - all separated by commas.
 * @param  {number}  intNum             The number to be scaled.
 * @param  {number}  defaultNumberScale Scale of the number provided.
 * @param  {number}  numScaleValues     Incremental list of values (divisors) on
 *                                      which the number will be scaled.
 * @param  {Array}   numScaleUnits      Incremental list of units (depending on the
 *                                      scale values) so that after scaled down the
 *                                      number; still we get the abbreviated figure
 * @param  {boolean} scaleRecursively   Set this to 1 to enable recursive scaling
 *                                      such that data values are broken down into
 *                                      lower level units. Set this to 0 (default)
 *                                      to show value at the topmost unit level
 * @param  {number}  forceNumberScale   It forces the lower value of the numberScaleUnit
 *                                      to be applied to the value.
 * @return {Object}                     contains scaled down value and unit
 */
formatNumberScale = function formatNumberScale(intNum, defaultNumberScale, numScaleValues, numScaleUnits, scaleRecursively, forceNumberScale) {
  // Create an object, which will be returned
  var objRtn = {},

  // Scale Unit to be stored (assume default)
  strScale = defaultNumberScale,
      recLowerScaleValue,
      recTempVal,
      i = 0,
      numScaleValue,
      THOUSAND = 1000,

  // Array of values & scales to be returned.
  arrValues = [],
      arrScales = [],
      carry;
  forceNumberScale = (0, _lib.pluckNumber)(forceNumberScale) || 0;
  if (scaleRecursively) {
    recLowerScaleValue = (0, _lib.pluckNumber)(numScaleValues[0]) || THOUSAND;
    for (i = 0; i < numScaleValues.length; i++) {
      // Garbage handling, if comma  separated value of
      // numberScaleValues is not a number or 0, we use 1000 as the value
      numScaleValue = (0, _lib.pluckNumber)(numScaleValues[i]) || THOUSAND;
      if (Math.abs(Number(intNum)) >= numScaleValue && i < numScaleValues.length - 1) {
        // Carry over from division
        carry = intNum % numScaleValue;
        // Deduct carry over and then divide.
        intNum = (intNum - carry) / numScaleValue;
        // Push to return array if carry is non 0
        if (i === 0 && carry !== 0 && numScaleUnits[i] === BLANK && forceNumberScale) {
          arrValues.push(carry / recLowerScaleValue);
          arrScales.push(numScaleUnits[1] || BLANK);
        } else if (carry !== 0) {
          if (i === 1 && defaultNumberScale === BLANK && forceNumberScale) {
            recTempVal = carry + (arrValues.length ? arrValues.pop() : 0);
            arrScales.pop();
            arrValues.push(recTempVal);
          } else {
            arrValues.push(carry);
          }
          arrScales.push(numScaleUnits[i]);
        }
      } else {
        // This loop executes for first token value (l to r) during recusrive scaling
        // Or, if original number < first number scale value.
        if (i === 0 && defaultNumberScale === BLANK && forceNumberScale) {
          intNum = Number(intNum) / recLowerScaleValue;
          arrValues.push(intNum);
          arrScales.push(numScaleUnits[1] || BLANK);
        } else {
          if (i === 1 && defaultNumberScale === BLANK && forceNumberScale) {
            recTempVal = intNum + (arrValues.length ? arrValues.pop() : 0);
            arrScales.pop();
            arrValues.push(recTempVal);
          } else {
            arrValues.push(intNum);
          }
          arrScales.push(numScaleUnits[i]);
        }
        break;
      }
    }
    // Reverse the arrays - So that lead value stays at 0 index.
    arrValues.reverse();
    arrScales.reverse();
    objRtn.value = arrValues;
    objRtn.scale = arrScales;
  } else {
    // If the scale unit or values have something fed in them
    // we manipulate the scales.
    if (numScaleValues.length === numScaleUnits.length) {
      for (i = 0; i < numScaleValues.length; i++) {
        // Garbage handling, if comma  separated value of
        // numberScaleValues is not a number or 0, we use 1000 as the value
        numScaleValue = (0, _lib.pluckNumber)(numScaleValues[i]) || THOUSAND;
        if (numScaleValue && Math.abs(Number(intNum)) >= numScaleValue) {
          strScale = numScaleUnits[i] || BLANK;
          intNum = Number(intNum) / numScaleValue;
        } else {
          if (i === 0 && defaultNumberScale === BLANK && forceNumberScale) {
            strScale = numScaleUnits[0] || BLANK;
            intNum = Number(intNum) / numScaleValue;
          }
          break;
        }
      }
    }
    // Set the values as properties of objRtn
    objRtn.value = intNum;
    objRtn.scale = strScale;
  }
  return objRtn;
};
/**
* parseNumberScale method checks whether we've been provided
* with number scales. If yes, we parse them and store them in
* local containers.
* @ return Nothing.
*/

// function parseNumberScale(numberScaleValues, numberScaleUnits) {
//     var bNumberScaleDefined, scaleRecursively;
//     //Check if either has been defined
//     if (numberScaleValues.length == 0 || numberScaleUnits.length == 0) {
//         //Set flag to false
//         bNumberScaleDefined = false;
//         scaleRecursively = false;
//     } else {
//         //Set flag to true
//         bNumberScaleDefined = true;
//         //Split the data into arrays
//         attributes.numberscalevalues = new Array();
//         attributes.numberscaleunits = new Array();
//         //Parse the number scale value
//         attributes.numberscalevalues = numberScaleValues.split(',');
//         //Convert all number scale values to numbers as they're
//         //currently in string format.
//         var i;
//         for (i=0; i<attributes.numberscalevalues.length; i++) {
//             attributes.numberscalevalues[i] = Number(attributes.numberscalevalues[i]);
//             //If any of numbers are NaN, set defined to false
//             if (isNaN(attributes.numberscalevalues[i])) {
//                 bNumberScaleDefined = false;
//                 scaleRecursively = false;
//             }
//         }
//         //Parse the number scale unit
//         attributes.numberscaleunits = numberScaleUnits.split(',');
//         //If the length of two arrays do not match, set defined to false.
//         if (attributes.numberscaleunits.length != attributes.numberscalevalues.length) {
//             bNumberScaleDefined = false;
//             scaleRecursively = false;
//         }
//         //Push the default scales at start - Value as 1 (universal divisor)
//         attributes.numberscalevalues.push(1);
//         attributes.numberscaleunits.unshift(this.defaultNumberScale);
//         //If number scale is not defined, clear up
//         if (!bNumberScaleDefined) {
//             delete attributes.numberscaleunits;
//             delete attributes.numberscalevalues;
//         }
//     }
// }

/**
 * formatDecimals method formats the decimal places of a number.
 * Requires the following to be defined:
 * params.decimalSeparator
 * params.thousandSeparator
 * @param {number}intNum Number on which we've to work.
 * @param {number}decimalPrecision Number of decimal places to which we've
 * to format the number to.
 * @param {boolean}forceDecimals Boolean value indicating whether to add decimal
 * padding to numbers which are falling as whole
 * numbers?
 * @return {string}A number with the required number of decimal places
 * in String format. If we return as Number, Flash will remove
 * our decimal padding or un-wanted decimals.
 */
formatDecimals = function formatDecimals(intNum, decimalPrecision, forceDecimals) {
  var tenToPower, strRounded, parts, paddingNeeded, i;

  // if negative decimal precision is sent, we set it to 0, as per
  // FusionCharts Policy
  if (decimalPrecision <= 0) {
    return mathRound(intNum) + BLANK;
    // decimalPrecision = 0;
  }
  // If no decimal places are needed, just round the number and return
  if (isNaN(decimalPrecision)) {
    intNum = intNum + BLANK;
    if (intNum.length > 12 && intNum.indexOf(DECIMALSTRING) != -1) {
      decimalPrecision = 12 - intNum.split(DECIMALSTRING)[0].length;
      tenToPower = mathPow(10, decimalPrecision);
      strRounded = mathRound(intNum * tenToPower) / tenToPower + BLANK;
      intNum = strRounded;
    }
    return intNum;
    // return mathRound (intNum) + BLANKSTRING;
  }
  // Round the number to specified decimal places
  // e.g. 12.3456 to 3 digits (12.346)
  // Step 1: Multiply by 10^decimalPrecision - 12345.6
  // Step 2: Round it - i.e., 12346
  // Step 3: Divide by 10^decimalPrecision - 12.346
  tenToPower = mathPow(10, decimalPrecision);
  strRounded = mathRound(intNum * tenToPower) / tenToPower + BLANK;

  // Now, strRounded might have a whole number or a number with required
  // decimal places. Our next job is to check if we've to force Decimals.
  // If yes, we add decimal padding by adding 0s at the end.
  if (forceDecimals == 1) {
    // Add a decimal point if missing
    // At least one decimal place is required (as we split later on .)
    // 10 -> 10.0
    if (strRounded.indexOf(DECIMALSTRING) == -1) {
      strRounded += '.0';
    }
    // Finally, we start add padding of 0s.
    // Split the number into two parts - pre & post decimal
    parts = strRounded.split(DECIMALSTRING);
    // Get the numbers falling right of the decimal
    // Compare digits in right half of string to digits wanted
    paddingNeeded = decimalPrecision - parts[1].length;
    // Number of zeros to add
    for (i = 1; i <= paddingNeeded; i++) {
      // Add them
      strRounded += ZEROSTRING;
    }
  }
  return strRounded;
};

/**
 * formatCommas method adds proper commas to a number in blocks of 3
 * i.e., 123456 would be formatted as 123,456
 * @param  {string} strNum             The number to be formatted (as string)
 *                                     Why are numbers taken in string format?
 *                                     - Here, we are asking for numbers in string format
 *                                       to preserve the leading and padding 0s of decimals
 *                                       Like as in -20.00, if number is just passed as number,
 *                                       Flash automatically reduces it to -20. But, we've to
 *                                       make sure that we do not disturb the original number.
 * @param  {string} decimalseparator   Specifies the character to be used as
 * @param  {string} thousandseparator  Specifies the character to be used as the thousand separator in a number
 *                                     the decimal separator in a number.
 * @param  {number} thSepPos           It specifies the number of digits after which the separator character
 *                                     should be placed. This attribute can take multiple values.
 *                                     In this case, the first thousand separator is placed after the number
 *                                     of digits specified by the second value. Thereafter, the separators are
 *                                     placed after the number of digits specified by the first value.
 *                                     When this attribute is set to 0, it takes the default value, which is 3,
 *                                     and places the separator after every three digits starting from right.
 * @param  {boolean} isAxisValue       whether the value is axis value or not
 * @return {string}                    Formatted number with commas.
 */
formatCommas = function formatCommas(strNum, decimalseparator, thousandseparator, thSepPos, isAxisValue) {
  // intNum would represent the number in number format
  var intNum = Number(strNum),
      strDecimalPart = BLANK,
      boolIsNegative = false,
      strNumberFloor = BLANK,
      formattedNumber = BLANK,
      startPos = 0,
      endPos = 0,
      minExponentialValue = 1e+15,
      fractionDigits,
      strNumberLen,
      sepPosLen,
      sepDigit;

  // If the number is invalid, return an empty value
  if (isNaN(intNum)) {
    return BLANK;
  }

  // If the number is greater than 10^15, we return the exponential form.
  // Fraction digits are determined based on whether number is an axis value or data label.
  // This is done considering the behaviour in flash version of chart
  if (intNum > minExponentialValue) {
    if (isAxisValue) {
      fractionDigits = 1;
    } else {
      fractionDigits = 14;
    }
    return intNum.toExponential(fractionDigits);
  }

  // Define startPos and endPos
  startPos = 0;
  endPos = strNum.length;

  // Extract the decimal part
  if (strNum.indexOf(DECIMALSTRING) != -1) {
    strDecimalPart = strNum.substring(strNum.indexOf(DECIMALSTRING) + 1, strNum.length);
    endPos = strNum.indexOf(DECIMALSTRING);
  }
  // Now, if the number is negative, get the value into the flag
  if (intNum < 0) {
    boolIsNegative = true;
    startPos = 1;
  }
  // Now, extract the floor of the number
  strNumberFloor = strNum.substring(startPos, endPos);

  strNumberLen = strNumberFloor.length;
  sepPosLen = thSepPos.length - 1;
  sepDigit = thSepPos[sepPosLen];
  if (strNumberLen < sepDigit) {
    formattedNumber = strNumberFloor;
  } else {
    while (strNumberLen >= sepDigit) {
      formattedNumber = (strNumberLen - sepDigit ? thousandseparator : BLANK) + strNumberFloor.substr(strNumberLen - sepDigit, sepDigit) + formattedNumber;
      strNumberLen -= sepDigit;
      sepDigit = (sepPosLen -= 1) <= 0 ? thSepPos[0] : thSepPos[sepPosLen];
      if (strNumberLen < sepDigit) {
        formattedNumber = strNumberFloor.substring(strNumberLen, 0) + formattedNumber;
      }
    }
  }

  // Now, append the decimal part back
  if (strDecimalPart != BLANK) {
    formattedNumber = formattedNumber + decimalseparator + strDecimalPart;
  }
  // Now, if neg num
  if (boolIsNegative === true) {
    formattedNumber = MINUSSTR + formattedNumber;
  }

  // Return
  return formattedNumber;
};

/**
 * convertNumberSeps method helps us convert the separator (thousands and decimal)
 * character from the user specified input separator characters to normal numeric
 * values that Flash can handle. In some european countries, commas are used as
 * decimal separators and dots as thousand separators. In XML, if the user specifies
 * such values, it will give a error while converting to number. So, we accept the
 * input decimal and thousand separator from user, so thatwe can covert it accordingly
 * into the required format.
 * If the number is still not a valid number after converting the characters, we log
 * the error and return 0.
 * @param num Number in string format containing user defined separator characters.
 * @return Number in numeric format.
 */
// convertNumberSeps function modified on [12-04-2011] to fix the issue [FCXTCOMMON-37]
// @todo OLD convertNumberSeps has been commented below, and have to remove after the testing
// of numberFormatter */
convertNumberSeps = function convertNumberSeps(num, conf) {
  // convert the given number to string
  num = num + BLANK;
  if (conf._REGinthousandseparator) {
    num = num.replace(conf._REGinthousandseparator, BLANK);
  }
  // Replace the indecimalseparator value with decimal to perform numeric operations
  if (conf._REGindecimalseparator) {
    num = num.replace(conf._REGindecimalseparator, DECIMALSTRING);
  }
  num = parseFloat(num);
  // parseFloat is used here instead of Number so that parseFloat()'s
  // returning of NaN on blank string can be utilized.
  return isFinite(num) ? num : NaN;
};
/*
function convertNumberSeps (num, indecimalseparator, inthousandseparator) {
    // Replace the indecimalseparator value with decimal to perform numeric operations
    num = indecimalseparator !== BLANKSTRING ?
    num.toString().replace(indecimalseparator, DECIMALSTRING) : num;

    if (inthousandseparator && inthousandseparator.toString) {
        inthousandseparator = inthousandseparator.toString().replace(/(\W)/ig, '\\$1')
    }

    // Replace the inthousandseparator value with decimal to perform numeric operations
    var re = new RegExp(inthousandseparator, 'g');
    num = inthousandseparator !== BLANKSTRING ?
    num.toString().replace(re, BLANKSTRING) : num;

    // old code: intNum = !strNum && strNum !== false && strNum !== 0 ?
    //NaN : Number(strNum);

    return !isNaN(num = parseFloat(num)) && isFinite(num) ? num : NaN;
}
*/

// function addNumberFormatter (fcGlobal) {
// Add formatNumber to the FusionCharts class
_constructor._global.extend(_constructor._global.core, {
  formatNumber: function formatNumber(num, config, axisIndex) {
    config = config && objToLowerCase(config) || {};
    var hashKey = objToHash(config),
        NF,
        formatedStr;
    if (NFStore[hashKey]) {
      NF = NFStore[hashKey];
    } else {
      NFStore[hashKey] = NF = new NumberFormatter(config, { useScaleRecursively: true });
    }
    formatedStr = NF.dataLabels(num, axisIndex);
    return formatedStr;
  }
}, false);

/**
 * add number formater to FusionCharts instance
 * ~todo add dispose methodology for all numberformater created by this method
 * ~param {number} num :Number that will be formatted
 * ~param {string} type: [Optional] predefined set of type described in Notes tab.
 * ~param {object} config : [Optional] Object to override number formatter configurations
 * ~param {number} yAxisIndex : [Optional] Axis index for DY-Axis or Multi-Axis charts.
 */
_constructor._global.extend(_constructor._global.core, /** @lends FusionCharts */{
  /**
   * FusionCharts formats input number based on configurations passed in chart attributes. It may
   * be needed to similarly format other non-chart elements on page using same algorithm. This
   * function is available to be used globally on {@link FusionCharts} object or on a specific
   * instance of FusionCharts Suite XT.
   *
   * When called on the FusionCharts object (`FusionCharts.formatNumber()`,) the default number
   * configuration settings are utilised. These can be overridden by passing additional number
   * format configuration settings as the second parameter. Refer to chart attributes for various
   * number format configurations.
   *
   * When called on an instance of a chart, gauge or map, the number formatting as set by the
   * data of the chart is used. As such, the second parameter (`type`) accepts `xAxisValues`,
   * `yAxisValues` or `dataLabels` to allow formatting to be done specific to them.
   *
   * @group framework
   *
   * @param {number} num - The number that needs to be formatted.
   *
   * @param {string=} [type=datalabels] - A chart can be configured to format numbers differently
   * depending upon where it is being used. The formatting of data values can be different than
   * that of x-axis labels. As such, passing `yaxisvalues`, `xaxisvalues` or `datalabels` as a
   * value of this parameter returns the formatted number accordingly. __Note that this parameter
   * is not available when `formatNumber` is executed on `FusionCharts` object instead of chart
   * instances.
   *
   * @param {Object=} [config] - One can optionally pass additional number formatting attributes
   * as the `config` parameter to override the default number formatting options of a chart.
   * While calling `formatNumber` on `FusionCharts` object, this becomes the second parameter.
   *
   * @param {number} yAxisIndex - index of the yAxis
   * @return {string}           - formatted number (as string)
   *
   * @example
   * console.log(FusionCharts.formatNumber(1234.5)); // logs "1.2K"
   *
   * console.log(FusionCharts.formatNumber(1234.5, {
   *     numberPrefix: "$"
   * })); // logs "$1.2K"
   *
   * @example
   * // Calling number formatter on a chart instance when `renderComplete` event is fired.
   * FusionCharts.ready(function () {
   *     // Render a chart within a chart container `div` element.
   *     var chart = new FusionCharts({
   *         type: 'column2d',
   *         renderAt: 'chart-container-div',
   *         dataFormat: 'json',
   *         dataSource: {
   *             chart: {
   *                 caption: "Quarterly sales summary",
   *                 numberPrefix: "$",
   *                 decimals: "2",
   *                 forceDecimals: "1"
   *             }
   *             data: [
   *                 { label: "Q1", value: "213345"},
   *                 { label: "Q2", value: "192672"},
   *                 { label: "Q3", value: "201238"},
   *                 { label: "Q4", value: "209881"},
   *             ]
   *         },
   *
   *         events: {
   *             renderComplete: function (eventObj) {
   *                 // Call the formatNumber function of the specific chart we rendered.
   *                 console.log(eventObj.sender.formatNumber(1234.5)); // logs "$1.23K"
   *             }
   *         }
   *     });
   *     chart.render();
   * });
   */
  formatNumber: function formatNumber(num, type, config, yAxisIndex) {
    var chartObj = this,
        jsVars = chartObj.jsVars,
        chartInstance = jsVars.instanceAPI || {},
        numberFormatter = chartInstance.numberFormatter,
        dataComp,
        dataObj,
        dataChartTagJSON,
        configHashKey,
        hashKey,
        NF,
        formatedStr;

    configHashKey = objToHash(config);
    config = config && objToLowerCase(config) || {};

    if (configHashKey === BLANK) {
      if (numberFormatter) {
        NF = numberFormatter;
      } else {
        dataComp = chartObj.args.dataSource;
        dataObj = dataComp.data || {};
        dataChartTagJSON = dataObj.chart || {};
        hashKey = objToHash(dataChartTagJSON);
        if (NFStore[hashKey]) {
          NF = NFStore[hashKey];
        } else {
          NFStore[hashKey] = NF = new NumberFormatter(dataChartTagJSON, chartInstance);
        }
      }
    } else {
      dataComp = chartObj.args.dataSource;
      dataObj = dataComp.data || {};
      dataChartTagJSON = dataObj.chart || {};
      dataChartTagJSON = (0, _lib.extend2)((0, _lib.extend2)({}, dataChartTagJSON), config);
      hashKey = objToHash(dataChartTagJSON);
      if (NFStore[hashKey]) {
        NF = NFStore[hashKey];
      } else {
        NFStore[hashKey] = NF = new NumberFormatter(dataChartTagJSON, chartInstance);
      }
    }
    switch ((type && type.toLowerCase ? type : BLANK).toLowerCase()) {
      case 'yaxisvalues':
        formatedStr = NF.yAxis(num, yAxisIndex);
        break;
      case 'xaxisvalues':
        formatedStr = NF.xAxis(num);
        break;
      case 'scale':
        formatedStr = NF.scale(num);
        break;
      default:
        formatedStr = NF.dataLabels(num, yAxisIndex);
        break;
    }
    return formatedStr;
  }
}, true);
// }

// export { addNumberFormatter };
exports['default'] = NumberFormatter;

/***/ }),
/* 411 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _assign = __webpack_require__(13);

var _assign2 = _interopRequireDefault(_assign);

var _lib = __webpack_require__(5);

var _redraphael = __webpack_require__(17);

var _redraphael2 = _interopRequireDefault(_redraphael);

var _componentInterface = __webpack_require__(6);

var _componentInterface2 = _interopRequireDefault(_componentInterface);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var R = _redraphael2['default'],
    UNDEF,
    LINEAR = 'linear',
    animMap = {
  fadeIn: {
    opacity: {
      start: 0,
      end: 1
    }
  },
  fadeOut: {
    opacity: {
      start: 1,
      end: 0
    }
  }
},
    callbackMap = {
  fadeIn: function fadeIn() {
    this && this.show();
  },
  fadeOut: function fadeOut() {
    this && this.hide();
  }
},
    round = Math.round,
    shiftAnimTime = function shiftAnimTime(paramsConfig, duration, shiftTime) {
  var config = (0, _assign2['default'])({}, paramsConfig),
      shiftRatio = shiftTime / duration,
      MAX_SHIFT = 0.2,
      diff;
  if (shiftRatio > MAX_SHIFT) {
    shiftRatio = MAX_SHIFT;
  }
  diff = config.end - config.start;
  config.start *= 1 - shiftRatio;
  config.start += shiftRatio;
  config.end = config.start + (1 - shiftRatio) * diff;
  config.start = round(config.start * 100) / 100;
  config.end = round(config.end * 100) / 100;
  return config;
},
    _applyAnim = function _applyAnim(ob, type, applyCallback) {
  var attrs = animMap[type],
      key = '',
      origCallback,
      origAttr = {};
  if (!attrs || !ob || !ob.el || !ob.el[0]) {
    return;
  }
  for (key in attrs) {
    origAttr[key] = ob.el.attrs[key];
    if (origAttr[key] === UNDEF) {
      origAttr[key] = null;
    }
    // pickEnd = ob.el.attrs[key] || attrs[key].end;
    ob.attrs[key] = attrs[key].end;
    ob.el.attr(key, attrs[key].start);
  }
  // Apply Callback if not disabled or
  // no callback is provided
  origCallback = ob.callback;
  ob.callback = function callback() {
    applyCallback && callbackMap[type] && callbackMap[type].call(this);
    origCallback && origCallback.call && origCallback.call(this);
    this.attr(origAttr);
  };
},
    applyType = function applyType(ob, type) {
  var i,
      delimeter = '-',
      applyCallback = true;
  if (!type) {
    return;
  }
  ob.attrs = ob.attrs || {};
  type = type.split(delimeter);
  if (~type.indexOf('nc')) {
    applyCallback = false;
  }
  for (i = type.length; i--;) {
    _applyAnim(ob, type[i], applyCallback);
  }
  return ob;
},
    applyAttr = function applyAttr(el, attrs, callback, animConfig) {
  animConfig.hookFn && animConfig.hookFn.call(el);
  el.attr(attrs);
  callback && callback.call(el);
},
    animateEl = function animateEl(el, attrs, callback, animConfig, dummyObj, animObj, animationDuration, animType) {
  el.animateWith(dummyObj, animObj, attrs, animationDuration, animType, callback, animConfig);
},
    animateDefault = function animateDefault(el, attrs, callback, animConfig, dummyObj, animObj, animationDuration) {
  el.animateWith(dummyObj, animObj, attrs, animationDuration, 'linear', callback, {
    start: 0.02,
    end: 1,
    smartMorph: animConfig.smartMorph,
    hookFn: animConfig.hookFn
  });
},
    execPreAnimFns = function execPreAnimFns(arr) {
  var i = 0,
      ii = arr.length;
  for (i = 0; i < ii; ++i) {
    arr[i].fn && arr[i].fn.call(arr[i].el);
  }
},

// Function to create dummy animation with which all animation object will sync.
_chartAnimation = function _chartAnimation() {
  var iapi = this,

  // components = iapi.components,
  graphics = iapi.getGraphicalElement(),
      paper = iapi.getFromEnv('paper'),
      animation = iapi.config.animationObj,
      dummyObj,
      animationDuration = animation.duration,
      animObj,
      config = iapi.config,
      animType = config.animationeffect,
      animCallBack = function animCallBack() {
    iapi._animCallBack();
  };

  // Firing callBack for drawing dynamic annotations
  iapi.addJob('anim-callBack', function () {
    iapi._animCallBack();
  }, _lib.priorityList.postRender);

  if (!animationDuration || config.parentElementPause) {
    return;
  }

  animation.animObj = animObj = R.animation({
    x: 0
  }, animationDuration, animType, animCallBack, false);

  animation.animType = animType;

  if (!(dummyObj = graphics.dummyObj)) {
    dummyObj = paper.rect({
      x: 100,
      y: 0,
      width: 10,
      height: 30
    });
    iapi.addGraphicalElement('dummyObj', dummyObj);
    dummyObj.hide();
  } else {
    dummyObj.attr({
      x: 100
    });
  }
  animation.dummyObj = graphics.dummyObj;

  dummyObj.stop(UNDEF, true, true);
  dummyObj.animate(animObj);
  iapi.addJob('set-anim-duration', function () {
    iapi._setAnimDuration();
  }, _lib.priorityList.postRender);
};
animMap.fadein = animMap.fadeIn;
animMap.fadeout = animMap.fadeOut;
/**
 * Animation manager component is responsible for deciding animation timing
 * for each element absed on its slot. The slot type are - initial, axis, plot and final.
 * If any slot is not animating its timing is squeezed i.e time alloted to that
 * particular slot is distributed among other slots.
 * To register animation use this
 * @example
 * animationManager.registerAnimation([{
 *    data: [{
 *      el: someElement,
 *      attrs: attrsObject,
 *      preAnimFn: fn (to be executed before any animation starts),
 *      callback: fn (to be called when animation of element ends),
 *      type: 'fadeIn' or 'fadeOut' (use in case of fading in or out),
 *      animType: 'linear/easeIn', (easing function names)
 *      animConfig: [{
 *        start: 0 - 1,
 *        end: 0 - 1,
 *        hookFn: fn (to be executed just before element animation starts)
 *      }]
 *    }]
 * }]);
 */

var AnimationManager = function (_ComponentInterface) {
  _inherits(AnimationManager, _ComponentInterface);

  function AnimationManager() {
    _classCallCheck(this, AnimationManager);

    return _possibleConstructorReturn(this, _ComponentInterface.apply(this, arguments));
  }

  /**
   * Sets the type of the component
   * @return {string} type
   */
  AnimationManager.prototype.getType = function getType() {
    return 'animationManager';
  };

  /**
   * Sets the configuration of the component
   * @param {Object} animationConfig Conatining the animation rules configuration
   */


  AnimationManager.prototype.configure = function configure(animationConfig) {
    var animationManager = this,
        rules,
        type,
        animationManagerConfig = animationManager.config,
        chartConfig = animationManager.getFromEnv('chartConfig');

    /**
     * The rules define how the time will be distributed amongst various slots.
     * We have 2 kinds of animation rule - static and dynamic.
     * For static rule the start and end is fixed as 0 and 1 respectively.
     * For dynamic, duration is given. Time is calculated from the given duration treating it as percentage of the
     * parent's time.
     */
    rules = animationManager.config.rules = {
      totalTime: 1000,
      draw: {
        'static': [{
          name: 'draw',
          start: 0,
          end: 1,
          child: {
            dynamic: [[{
              name: 'initial',
              duration: 0.125
            }, {
              name: 'middle',
              duration: 0.75,
              child: {
                dynamic: [[{
                  name: 'axis',
                  duration: 0.25
                }, {
                  name: 'plot',
                  duration: 0.75
                }]]
              }
            }, {
              name: 'final',
              duration: 0.125
            }]]
          }
        }]
      },
      'default': {
        'static': [{
          name: 'default',
          start: 0,
          end: 1,
          child: {
            dynamic: [[{
              name: 'initial',
              duration: 0.2
            }, {
              name: 'middle',
              duration: 0.8
            }, {
              name: 'final',
              duration: 0.2
            }]]
          }
        }]
      }
    };
    !animationManagerConfig.workingRules && (animationManagerConfig.workingRules = {});
    !animationManagerConfig.animateArr && (animationManagerConfig.animateArr = []);
    !animationManagerConfig.animationName && (animationManagerConfig.animationName = []);

    for (type in animationConfig) {
      rules[type] = animationConfig[type];
    }
    animationManager.config.ruleType = (0, _lib.pluck)(chartConfig.applicableanimrule, type, 'draw');
  };

  /**
  * init is called when the first time animating elements is send to registerAnimation,
  * so animation manager puts a task in schedular to animate all elements on next thread.
  * If there is scenario of no animation no such task is scheduled and instead animate is called
  * directly which applies attr to all elements and executes all hook functions and callbacks.
  */


  AnimationManager.prototype.init = function init() {
    var self = this,
        chart = this.getFromEnv('chart'),
        startAnimation = function startAnimation() {
      _chartAnimation.call(chart);
      self.animate('draw');
    },
        animDuration = chart.get('config', 'animationObj').duration,
        noAnim = chart.state === 'noAnim';
    // If no animation then draw all received items instantly
    if (!animDuration || noAnim) {
      startAnimation();
    } else {
      self.config.initialized = true;
      self.addJob('start-animation', startAnimation, _lib.priorityList.animation);
    }
  };

  /**
   * Function to reset the animation configurations
   */


  AnimationManager.prototype.reset = function reset() {
    var animationManager = this,
        chart = animationManager.getFromEnv('chart');
    animationManager.config.initialized = false;
    animationManager.config.animateArr.length = 0;
    if (chart) {
      animationManager.config.isSingleStepAnim = chart.config.isSingleStepAnim = false;
    }
  };

  /**
   * Register animation objects,
   * structure
   * @example
   * {
   *    initital: {
   *      data: [{
   *        el: el,
   *        attrs: {}
   *      }]
   *    }
   * }
   * @param {Object} ob The object conatining all the configuration of individual elements
   */


  AnimationManager.prototype.registerAnimObj = function registerAnimObj(ob) {
    var key;
    for (key in ob) {
      this.registerAnimation(ob[key], key);
    }
  };

  /**
   * Prepare the final rules single array where the specific start time is availble
   * @return {Object} The workingRules object conatining the time allotmnet of all the slots of animation
   */


  AnimationManager.prototype.getFinalRules = function getFinalRules() {
    var animationManager = this,
        type = animationManager.config.ruleType,
        animationManagerConfig = animationManager.config,
        appliedType = animationManagerConfig.rules[type] ? type : 'default',
        appliedRules = animationManagerConfig.rules[appliedType],
        workingRules = animationManagerConfig.workingRules = {},
        animationName = animationManagerConfig.animationName,
        _hasAnimation,
        buildDynamicRules,
        buildStaticRules,
        buildWorkingRule;

    /**
     * Function to find if any animation is registered for a given slot in the rule
     * @param {Object} obj Each object against each rules object
     * @param {string} type dynamic/static
     * @return {boolean} If any animation is registered against the current rules object
     */
    _hasAnimation = function hasAnimation(obj, type) {
      var retBool = false,
          objBool,
          animObj,
          i,
          ii,
          j,
          jj;
      if (!obj) {
        return false;
      }
      if (type === 'static') {
        for (i = 0, ii = obj.length; i < ii; i += 1) {
          animObj = obj[i];
          objBool = false;
          if (animationName.indexOf(animObj.name) !== -1) {
            objBool = true;
          } else if (animObj.child) {
            objBool = animObj.hasAnimation = _hasAnimation(animObj.child.dynamic, 'dynamic') || _hasAnimation(animObj.child['static'], 'static');
          }
          retBool = retBool || objBool;
          animObj.hasAnimation = objBool;
        }
      } else if (type === 'dynamic') {
        for (i = 0, ii = obj.length; i < ii; i += 1) {
          for (j = 0, jj = obj[i].length; j < jj; j += 1) {
            animObj = obj[i][j];
            objBool = false;
            if (animationName.indexOf(animObj.name) !== -1) {
              objBool = true;
            } else if (animObj.child) {
              objBool = animObj.hasAnimation = _hasAnimation(animObj.child.dynamic, 'dynamic') || _hasAnimation(animObj.child['static'], 'static');
            }
            retBool = retBool || objBool;
            animObj.hasAnimation = objBool;
          }
        }
      }

      return retBool;
    };

    /**
     * Setting the final time wrt to its parent's start and end.
     * If no animation is attached to the animation slot of one child then its time is distributed to it's other
     * children
     * @param {Object} obj The animation configuration object
     * @param {number} start The start time (in %) given for the specific animation object
     * @param {number} end The end time (in %) given for the specific animation object
     */
    buildDynamicRules = function buildDynamicRules(obj, start, end) {
      var animObj,
          addTime,
          addTimeCounter,
          diff,
          i,
          ii,
          j,
          jj,
          s = 0,
          e = start;

      for (i = 0, ii = obj.length; i < ii; i += 1) {
        addTime = 0;
        addTimeCounter = 0;
        for (j = 0, jj = obj[i].length; j < jj; j += 1) {
          animObj = obj[i][j];
          if (!animObj.hasAnimation) {
            addTime += animObj.duration;
          } else {
            addTimeCounter += 1;
          }
        }
        addTime /= addTimeCounter;
        for (j = 0, jj = obj[i].length; j < jj; j += 1) {
          animObj = obj[i][j];
          if (!animObj.hasAnimation) {
            continue;
          }
          s = e;
          diff = end - start;
          e = s + animObj.duration * diff + addTime;
          workingRules[animObj.name] = {
            start: s,
            end: e,
            animType: animObj.effect,
            transition: animObj.transition
          };
          animObj.child && buildWorkingRule(animObj.child, s, e);
        }
      }
    };

    buildStaticRules = function buildStaticRules(obj, start, end) {
      var animObj, diff, i, ii, s, e;

      for (i = 0, ii = obj.length; i < ii; i += 1) {
        animObj = obj[i];
        s = animObj.start;
        e = animObj.end;
        diff = end - start;
        s = start + s * diff;
        e = start + e * diff;
        workingRules[animObj.name] = {
          start: s,
          end: e,
          animType: animObj.effect,
          transition: animObj.transition
        };
        animObj.child && buildWorkingRule(animObj.child, s, e);
      }
    };
    // Recursion function to create the rules by going through the child object
    buildWorkingRule = function buildWorkingRule(obj, start, end) {
      obj.dynamic && buildDynamicRules(obj.dynamic, start, end);
      obj['static'] && buildStaticRules(obj['static'], start, end);
    };
    _hasAnimation(appliedRules['static'], 'static');
    buildWorkingRule(appliedRules, 0, 1);
    workingRules['default'] = {
      start: 0,
      end: 1
    };
    return workingRules;
  };

  /**
   * Register single animation object
   * @example
   * animationManager.registerOne({
   *  el: myelem,
   *  attrs: {},
   *  callback: myFunction,
   *  animConfig: [{
   *    start: 0.4,
   *    end: 0.8
   *  }]
   * })
   * @param {Object} ob The animation object
   * @param {string} key The slot name
   */


  AnimationManager.prototype.registerOne = function registerOne(ob, key) {
    this.registerAnimation([{
      data: [ob]
    }], key);
  };

  /**
   * api to be used by datasets or other areas to register their animation components
   * Ex.
   * @example
   * animationManager.registerAnimation([{
   *    data: [{
   *      el: someElement,
   *      attrs: attrsObject,
   *      preAnimFn: fn (to be executed before any animation starts),
   *      callback: fn (to be called when animation of element ends),
   *      type: 'fadeIn' or 'fadeOut' (use in case of fading in or out),
   *      animType: 'linear/easeIn', (easing function names)
   *      animConfig: [{
   *        start: 0 - 1,
   *        end: 0 - 1,
   *        hookFn: fn (to be executed just before element animation starts)
   *      }]
   *    }]
   * }]);
   * @param {Object} attrObj The animation configuration object
   * @param {string} component The animation slot
   */


  AnimationManager.prototype.registerAnimation = function registerAnimation(attrObj, component) {
    var i, ln;
    for (i = 0, ln = attrObj.length; i < ln; i += 1) {
      this.config.animateArr.push((attrObj[i].component = component, attrObj[i]));
    }
    this.config.animationName.push(component);
    !this.config.initialized && this.init();
  };

  /**
   * dynamically calculate final timings, depending on their type timings
   */


  AnimationManager.prototype.prepareAnimateArr = function prepareAnimateArr() {
    var animateArr = this.config.animateArr,
        thisAnimateObj,
        rules,
        component,
        i,
        ln,
        j,
        jj,
        transition,
        animEl,
        preAnimArr = this.config.preAnimArr = [];

    rules = this.getFinalRules();
    function manageStartEnd(obj, component) {
      var refComponent,
          diff,
          retObj = {
        start: 0,
        end: 1
      },
          key;
      for (key in obj) {
        if (obj.hasOwnProperty(key)) {
          if (obj[key].syncWith && !rules[obj[key].syncWith]) {
            continue;
          }
          refComponent = obj[key].syncWith;
          retObj.start = obj[key].start === UNDEF ? 0 : obj[key].start;
          retObj.end = obj[key].end === UNDEF ? 1 : obj[key].end;
          retObj.hookFn = obj[key].hookFn || obj.hookFn;
          retObj.smartMorph = obj[key].smartMorph || obj.smartMorph;
          break;
        }
      }
      refComponent = refComponent && rules[refComponent] ? refComponent : component && rules[component] ? component : 'default';
      diff = rules[refComponent].end - rules[refComponent].start;
      retObj.start = rules[refComponent].start + retObj.start * diff;
      retObj.end = rules[refComponent].start + retObj.end * diff;
      return retObj;
    }
    for (i = 0, ln = animateArr.length; i < ln; i += 1) {
      thisAnimateObj = animateArr[i];
      component = thisAnimateObj.component;
      for (j = 0, jj = thisAnimateObj.data.length; j < jj; j += 1) {
        animEl = thisAnimateObj.data[j];
        transition = animEl.type || rules[component] && rules[component].transition;
        if (transition) {
          applyType(animEl, transition);
        }
        if (animEl.preAnimFn) {
          preAnimArr.push({
            el: animEl.el,
            fn: animEl.preAnimFn
          });
        }
        animEl.animConfig && (animEl.animConfig = manageStartEnd(animEl.animConfig, component));
      }
      thisAnimateObj.animType || rules[component] && (thisAnimateObj.animType = rules[component].animType);
      thisAnimateObj.animConfig || (thisAnimateObj.animConfig = [{}]);
      thisAnimateObj.animConfig = manageStartEnd(thisAnimateObj.animConfig, component);
    }
  };

  /**
   * Function to send all elements in animation queue to redraphael
   * to actually animate. At first timing are calculated and then,
   * preAnimFn are executed then it is checked whether animation on / off or
   * single single step and is then animated accordingly
   */


  AnimationManager.prototype.animate = function animate() {
    var chart = this.getFromEnv('chart'),
        animateArr = this.config.animateArr,
        animationObj = chart.get('config', 'animationObj'),
        animObj = animationObj.animObj,
        dummyObj = animationObj.dummyObj,
        animationDuration = chart ? AnimationManager.getDuration(chart, animationObj) : animationObj.duration,
        animType,
        shiftTime = 180,
        thisAnimateObj,
        animConfig,
        callback,
        i,
        ln,
        j,
        jj,
        isSingleStepAnim = this.config.isSingleStepAnim,
        animateOrAttr = !animationDuration ? applyAttr : isSingleStepAnim ? animateDefault : animateEl;

    this.prepareAnimateArr();
    execPreAnimFns(this.config.preAnimArr);
    // Apply the animation after the preparation of the animate array
    for (i = 0, ln = animateArr.length; i < ln; i += 1) {
      thisAnimateObj = animateArr[i];
      for (j = 0, jj = thisAnimateObj.data.length - 1; j <= jj; j += 1) {
        animConfig = thisAnimateObj.data[j].animConfig || thisAnimateObj.animConfig;
        animConfig = shiftAnimTime(animConfig, animationDuration, shiftTime);
        animType = thisAnimateObj.data[j].animType || thisAnimateObj.animType || LINEAR;
        callback = i === ln ? thisAnimateObj.callback || thisAnimateObj.data[j].callback : thisAnimateObj.data[j].callback;
        thisAnimateObj.data[j].preAttrs && thisAnimateObj.data[j].el.attr(thisAnimateObj.data[j].preAttrs);
        thisAnimateObj.data[j].el && animateOrAttr(thisAnimateObj.data[j].el, thisAnimateObj.data[j].attrs, callback || null, animConfig, dummyObj, animObj, animationDuration, animType);
      }
    }
    this.reset();
  };

  /**
   * function to get animation duration
   * @param {Object} chart The chart object
   * @param {Object} animObj The animation object
   * @return {number} time
   */


  AnimationManager.getDuration = function getDuration(chart, animObj) {
    var state = {
      noAnim: true
    },
        duration = animObj.duration;
    return duration * +!state[chart.state];
  };

  /**
   * Function to decide type of animation
   * If the animation is single step or not
   */


  AnimationManager.prototype.setIsSingleStep = function setIsSingleStep() {
    var animationManager = this,
        chart = animationManager.getFromEnv('chart'),
        animOff = !chart.get('config', 'animationObj').duration,
        singleStepAnim = {
      initial: false,
      update: false,
      resize: true,
      legendInteraction: false,
      realTimeUpdate: true
    };
    // saving chart
    // this.chart = chart;
    animationManager.config.isSingleStepAnim = chart.config.isSingleStepAnim = !!singleStepAnim[chart.state] || animOff;
  };

  return AnimationManager;
}(_componentInterface2['default']);

exports['default'] = AnimationManager;

/***/ }),
/* 412 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _lib = __webpack_require__(5);

var _componentInterface = __webpack_require__(6);

var _componentInterface2 = _interopRequireDefault(_componentInterface);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }
/**
 * @private
 *
 * @module fusioncharts.renderer.javascript.alertmanager
 */


var IN_ALERT_RANGE = '1',
    OUT_OF_ALERT_RANGE = '2',
    ACTION_CALLJS = 'calljs',
    ACTION_SHOWANNOTATION = 'showannotation';

var AlertManager = function (_ComponentInterface) {
  _inherits(AlertManager, _ComponentInterface);

  /**
   * constructor fn of this class
   */
  function AlertManager() {
    _classCallCheck(this, AlertManager);

    var _this = _possibleConstructorReturn(this, _ComponentInterface.call(this));

    _this.pIndex = 1;
    return _this;
  }

  AlertManager.prototype.init = function init() {
    this.linkedItems = {
      chart: this.getFromEnv('chart')
    };
  };

  AlertManager.prototype.configure = function configure() {
    var alertManager = this,
        chart = alertManager.linkedItems.chart,
        alerts = chart.get('jsonData', 'alerts'),
        alertArr = alerts && alerts.alert,
        numberFormatter = chart.get('components', 'numberFormatter'),
        config = alertManager.config || (alertManager.config = {}),
        alertCount,
        j,
        alertObj;
    if (alertArr && alertArr.length) {
      config.alertArr = alertArr;
      alertCount = alertArr.length;
      for (j = 0; j < alertCount; j += 1) {
        alertObj = alertArr[j];
        alertObj.minvalue = numberFormatter.getCleanValue(alertObj.minvalue);
        alertObj.maxvalue = numberFormatter.getCleanValue(alertObj.maxvalue);
      }
    } else {
      config.alertArr = [];
    }
  };

  AlertManager.prototype.processRTData = function processRTData(rtData) {
    var alertManager = this,
        chart = alertManager.linkedItems.chart,
        numberFormatter = chart.getFromEnv('number-formatter'),
        i,
        j,
        dsLength,
        dsObj,
        dataLength,
        dataObj,
        val;
    if (rtData && rtData.dataset && rtData.dataset.length) {
      dsLength = rtData.dataset.length;
      for (i = 0; i < dsLength; i += 1) {
        dsObj = rtData.dataset[i];
        if (dsObj.data && dsObj.data.length) {
          dataLength = dsObj.data.length;
          for (j = 0; j < dataLength; j += 1) {
            dataObj = dsObj.data[j];
            val = dataObj && numberFormatter.getCleanValue(dataObj.value);
            if (val !== null) {
              alertManager._doAlert(numberFormatter.getCleanValue(dataObj.value));
            }
          }
        }
      }
    }
  };

  AlertManager.prototype._doAlert = function _doAlert(val) {
    var alertManager = this,
        chart = alertManager.linkedItems.chart,
        config = alertManager.config,
        alertArr = config.alertArr,
        alertCount = alertArr.length,
        alertObj,
        j,
        alertAction;
    for (j = 0; j < alertCount; j += 1) {
      alertObj = alertArr[j];
      alertAction = alertObj.action && alertObj.action.toLowerCase();
      if (alertObj.minvalue <= val && alertObj.maxvalue >= val) {
        if (!(alertObj.occuronce === '1' && alertObj.hasOccurred)) {
          alertObj.hasOccurred = true;
          alertObj.state = IN_ALERT_RANGE;

          switch (alertAction) {
            case ACTION_CALLJS:
              setTimeout((0, _lib.pseudoEval)(alertObj.param));
              break;

            case ACTION_SHOWANNOTATION:
              chart.showAnnotation && chart.showAnnotation(alertObj.param);
              break;
          }
          global.raiseEvent('AlertComplete', {
            alertValue: val,
            alertMaxValue: alertObj.maxvalue,
            alertMinValue: alertObj.minvalue
          }, chart.chartInstance);
        }
      } else {
        if (alertAction === ACTION_SHOWANNOTATION && alertObj.state === IN_ALERT_RANGE) {
          chart.hideAnnotation && chart.hideAnnotation(alertObj.param);
        }
        // Set out of range flag
        alertObj.state = OUT_OF_ALERT_RANGE;
      }
    }
  };

  return AlertManager;
}(_componentInterface2['default']);

exports['default'] = AlertManager;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)))

/***/ }),
/* 413 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _lib = __webpack_require__(5);

var _eventApi = __webpack_require__(7);

var _componentInterface = __webpack_require__(6);

var _componentInterface2 = _interopRequireDefault(_componentInterface);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var UNDEF = void 0,
    TEXT_ANCHOR_MAP = {
  left: _lib.POSITION_START,
  right: _lib.POSITION_END,
  center: _lib.POSITION_MIDDLE
},

// preDefStr = lib.preDefStr,
// R = lib.Raphael,
math = Math,
    mathMin = math.min,
    mathMax = math.max,
    mathFloor = math.floor,
    mathCeil = math.ceil,
    convertColor = _lib.graphics.convertColor,
    dropHash = _lib.regex.dropHash,
    getLightColor = _lib.graphics.getLightColor,
    LEGENDITEMROLLOVER = 'LegendItemRollover',
    LEGENDITEMROLLOUT = 'LegendItemRollout',
    LEGENDITEMCLICKED = 'LegendItemClicked',
    HAND = 'hand',
    POINTER = _lib.preDefStr.POINTER,
    COMMA = ',',
    NONE = 'none',
    LEGENDNAME = 'FCLEGEND_',
    NORMAL = _lib.preDefStr.NORMAL,
    BOLD = _lib.preDefStr.BOLD,
    noneStr = _lib.preDefStr.noneStr,
    COLOR_BLACK = '000000',
    mapSymbolName = _lib.graphics.mapSymbolName,
    rgbaToHex = function rgbaToHex(rgb) {
  rgb = rgb.replace('rgba(', _lib.BLANKSTRING).split(',');
  return '#' + (COLOR_BLACK + (rgb[0] << 16 | rgb[1] << 8 | rgb[2]).toString(16)).slice(-6);
},
    styleValueMap = {
  fontWeight: {
    '1': BOLD,
    '0': NORMAL
  },
  fontStyle: {
    '1': 'italic',
    '0': NORMAL
  },
  textDecoration: {
    '1': 'underline',
    '0': noneStr
  }
},
    TRACKER_FILL = 'rgba(255,0,0,' + (_lib.isIE ? 0.002 : 0.000001) + ')',
    // invisible but clickable
M = 'M',
    L = 'L',
    isDifferent = function isDifferent(savedElementAttrs, currentElementAttrs) {
  return savedElementAttrs.fill !== currentElementAttrs.fill || savedElementAttrs.stroke !== currentElementAttrs.stroke || savedElementAttrs['stroke-width'] !== currentElementAttrs['stroke-width'];
},

// function that will create a symbol path for a legend icon.
_getSymbolPath = function _getSymbolPath(x, y, w, h, seriesType) {
  // TODO: have to add group and group style so that we can replivate the safme as fc
  var path = [M],

  // BLANKSTRING =     BLANKSTRING,
  // dropHash = lib.regex.dropHash,
  // HASHSTRING = lib.HASHSTRING,
  // colorStr = item.color && getFirstColor (typeof item.color === 'string' ?
  //     item.color : item.color.FCcolor.color) || BLANKSTRING,
  // color,
  w1,
      w2,
      h1,
      h2,
      height3,
      cx1,
      cx2,
      cy1,
      cy2,
      d1,
      d2,
      Z = 'Z',
      A = 'A';

  switch (seriesType) {
    case 'column':
    case 'dragcolumn':
    case 'column3d':
      w1 = w * 0.25;
      w2 = w1 * 0.5;
      h1 = h * 0.7;
      h2 = h * 0.4;

      path = path.concat([x, y + h, 'l', 0, -h1, w1, 0, 0, h1, 'z', 'm', w1 + w2, 0, 'l', 0, -h, w1, 0, 0, h, 'z', 'm', w1 + w2, 0, 'l', 0, -h2, w1, 0, 0, h2, 'z']);
      // color.FCcolor.angle = 270;
      break;

    case 'bar2d':
    case 'bar3d':
      w1 = w * 0.3;
      w2 = w * 0.6;
      h1 = h / 4;
      h2 = h1 / 2;
      path = path.concat([x, y, L, x + w2, y, x + w2, y + h1, x, y + h1, Z, M, x, y + h1 + h2, L, x + w, y + h1 + h2, x + w, y + h1 + h2 + h1, x, y + 2 * h1 + h2, Z, M, x, y + 2 * (h1 + h2), L, x + w1, y + 2 * (h1 + h2), x + w1, y + h, x, y + h, Z]);
      break;

    case 'area':
    case 'area3d':
    case 'areaspline':
    case 'dragarea':
      w1 = w * 0.3;
      w2 = w * 0.6;
      h1 = h * 0.6;
      h2 = h * 0.2;
      height3 = h * 0.8;
      path = path.concat([x, y + height3, L, x, y + h1, x + w1, y + h2, x + w2, y + h1, x + w, y + h2, x + w, y + height3, Z]);
      // color.FCcolor.angle = 270;
      break;

    case 'pie2d':
    case 'pie3d':
    case 'doughnut2d':
    case 'doughnut3d':

      w1 = w * 0.5;
      // Radius
      w2 = w1 * 0.9;
      d1 = 1;
      d2 = 1;
      cx1 = x + w1 + d1;
      cy1 = y + w1 - d1;
      cx2 = x + w1 - d2;
      cy2 = y + w1 + d2;

      path = path.concat([M, cx1, cy1, L, cx1, cy1 - w2 + d1, A, w2 - d1, w2 - d1, 0, 0, 1, cx1 + w2 - d1, cy1, Z, M, cx2, cy2, L, cx2, cy2 - w2, A, w2, w2, 0, 1, 0, cx2 + w2, cy2, Z]);

      // color.FCcolor.radialGradient = '1';
      // color.FCcolor.ratio = '0,0,0,100,0';
      break;
    case 'boxandwhisker2d':
      path = path.concat([x, y, L, x + w, y, x + w, y + h, x, y + h, Z]);
      // color = item.color;
      // strokeColor = '#000000';
      break;

    // A square line for every other request.
    default:
      path = path.concat([x, y, L, x + w, y, x + w, y + h, x, y + h, Z]);
    // color.FCcolor.angle = 270;
    // color.FCcolor.ratio = '0,70,30';
  }

  return {
    path: path
    // color: color,
    // strokeWidth: strokeWidth,
    // strokeColor: strokeColor
  };
},
    mergeConf = function mergeConf(source, sink) {
  var key, sourceVal;

  for (key in source) {
    sourceVal = source[key];

    if (sourceVal === UNDEF || sourceVal === null) {
      continue;
    }

    sink[key] = sourceVal;
  }
};

var Legend = function (_ComponentInterface) {
  _inherits(Legend, _ComponentInterface);

  function Legend() {
    _classCallCheck(this, Legend);

    return _possibleConstructorReturn(this, _ComponentInterface.apply(this, arguments));
  }

  Legend.prototype.__setDefaultConfig = function __setDefaultConfig() {
    _ComponentInterface.prototype.__setDefaultConfig && _ComponentInterface.prototype.__setDefaultConfig.call(this);
    var config = this.config;
    if (!config) {
      config = this.config = {};
    }
    config.enabled = true;
    config.symbolWidth = 12;
    config.borderRadius = 1;
    config.backgroundColor = '#FFFFFF';
    config.initialItemX = 0;
    config.title = {
      text: _lib.BLANKSTRING,
      x: 0,
      y: 0,
      padding: 2
    };
    config.scroll = {};
    config.itemStyle = {};
  };

  Legend.prototype.drawLegend = function drawLegend(xPos, yPos) {
    var legend = this,
        chart = legend.getFromEnv('chart'),
        chartConfig = chart.config,
        paper = legend.getFromEnv('paper'),
        config = legend.config,
        legendGroup = chart.getChildContainer().legendGroup,
        itemGroup = legend.getGraphicalElement('itemGroup'),
        box = legend.getGraphicalElement('box'),
        caption = legend.getGraphicalElement('caption'),
        isVertical,
        canvasBottom = chartConfig.height - chartConfig.canvasBottom,
        canvasLeft = chartConfig.canvasLeft,
        canvasWidth = chartConfig.canvasWidth,
        marginLeft = config.chartMarginLeft || 0,
        marginRight = config.chartMarginRight || 0,
        marginBottom = config.chartMarginBottom || 0,
        actionBarHeight = chartConfig.actionBarHeight || 0,
        canvasMarginLeft = config.actualCanvasMarginLeft || 0,
        canvasMarginBottom = chartConfig.actualCanvasMarginBottom || 0,
        canvasMarginRight = chartConfig.actualCanvasMarginRight || 0,
        alignLegendWithCanvas = config.alignLegendWithCanvas,
        chartHeight = chartConfig.height,
        canvasTop = chartConfig.canvasTop,
        width = config.width,
        height = config.height,
        chartBorderWidth = chartConfig.borderWidth,
        r = config.borderRadius,
        backgroundColor = config.backgroundColor,
        borderColor = config.borderColor,
        borderWidth = config.borderWidth || 0,
        legendPos = config.legendPos,
        semiBorder = borderWidth * 0.5,
        translationLimit = borderWidth * 0.5 + 2,
        padding = (0, _lib.pluckNumber)(config.padding, 4),
        halfPad = padding * 0.5,
        scrollConfig = config.scroll,
        scrollEnabled = config.scroll.enabled,
        drawn = config.drawn,
        scrollerWidth = 10,
        crispBox,
        captionX,
        clipSTR1,
        clipSTR2,
        clipH,
        spaceRightLeft,
        attrObj,
        dragInitX,
        dragInitY,
        dragOffsetX,
        dragOffsetY,
        legendAnim,
        animElem,
        x,
        y,
        h,
        xLeft,
        spaceLeftByChart,
        titleStyle,
        legendScrollBar = legend._components.legendScrollBar,
        topSpace = 0,
        bottomSpace = 0,
        oriCanvasLeft = chartConfig.oriCanvasLeft,
        oriCanvasTop = chartConfig.oriTopSpace,
        oriCanvasBottom = chartConfig.oriBottomSpace,
        scrollItem,
        tb = legend.getFromEnv('toolbox'),
        toolBoxApi = legend.getFromEnv('toolBoxAPI'),
        Scroller = toolBoxApi && toolBoxApi.Scroller,
        legendAnimElems = {
      initial: {
        data: []
      },
      plot: {
        data: []
      },
      final: {
        data: []
      }
    },
        captionCss,
        options;
    if (legendPos === _lib.POSITION_RIGHT) {
      config.align = _lib.POSITION_RIGHT;
      config.verticalAlign = _lib.POSITION_MIDDLE;
      isVertical = config.layout = 'vertical';
    }

    if (isVertical) {
      if (xPos === UNDEF) {
        xPos = chartConfig.width - marginRight - canvasMarginRight - width - chartBorderWidth;
      }
      if (yPos === UNDEF) {
        topSpace = (0, _lib.pluckNumber)(oriCanvasTop, canvasTop);
        bottomSpace = (0, _lib.pluckNumber)(oriCanvasBottom, canvasBottom);
        yPos = topSpace + (chartHeight - bottomSpace - topSpace - height) * 0.5 + (config.y || 0);
      }
    } else {
      if (xPos === UNDEF) {
        spaceLeftByChart = chartConfig.width - (marginLeft + canvasMarginLeft + (marginRight + canvasMarginRight));

        spaceRightLeft = alignLegendWithCanvas ? canvasWidth - width : spaceLeftByChart - width;
        xLeft = !alignLegendWithCanvas ? marginLeft + canvasMarginLeft : (0, _lib.pluckNumber)(oriCanvasLeft, canvasLeft);
        xPos = xLeft + spaceRightLeft / 2;
      }

      if (yPos === UNDEF) {
        yPos = chartHeight - height - canvasMarginBottom - marginBottom - actionBarHeight;
      }
    }

    // Crispen the legend box
    crispBox = (0, _lib.crispBound)(xPos, yPos, width, height, borderWidth);
    xPos = crispBox.x;
    yPos = crispBox.y;
    width = crispBox.width;
    height = crispBox.height;
    if (!drawn) {
      legendAnimElems.initial.data.push({
        el: legendGroup,
        attrs: {
          'opacity': 1,
          'fill-opacity': 1,
          'stroke-opacity': 1
        },
        callback: function callback() {
          legendGroup.show();
        },
        animConfig: [{
          hookFn: function hookFn() {
            legendGroup.transform(['T', xPos, yPos]);
          }
        }]
      });
    } else {
      config.xL && (config.xL = mathMin(mathMax(config.xL, translationLimit), chartConfig.width - config.width - translationLimit));

      config.yL && (config.yL = mathMin(mathMax(config.yL, translationLimit), chartConfig.height - config.height - translationLimit));
      // legendAnimElems.push({
      //     el: legendGroup,
      //     attrs: {
      //         'opacity': 0,
      //         'fill-opacity': 0,
      //         'stroke-opacity': 0
      //     },
      //     callback: function () {
      //         this.hide();
      //     },
      //     animType: 'linear',
      //     animConfig: [{
      //         syncWith: 'initial',
      //         start: 0,
      //         end: 1
      //     }]
      // });

      legendAnimElems.plot.data.push({
        el: legendGroup,
        attrs: {
          // 'opacity': 1,
          // 'stroke-opacity': 1,
          // 'fill-opacity': 1
          'transform': ['T', config.xL || xPos, config.yL || yPos]
        },
        callback: function callback() {
          this.show();
        },
        animConfig: [{
          syncWith: 'plot'
        }]
      });
    }
    config.xPos = xPos;
    config.yPos = yPos;

    // chart._addCSSDefinition ('.fusioncharts-legend .fusioncharts-caption',
    //     extend2 ( { 'text-anchor': config.title.align }, config.title.style));

    // legendGroup.attr (classStr, 'fusioncharts-legend');

    legendGroup.attr({
      cursor: config.legendAllowDrag ? 'move' : _lib.BLANKSTRING
    });
    // Add legend dragging events and configuration.
    if (config.legendAllowDrag) {
      if (!config._dragEvtListenerBinded) {
        legendGroup.drag(function (dx, dy) {
          if (config.legendAllowDrag) {
            /** @todo implement tooltip block during drag */
            dragOffsetX = dragInitX + dx;
            dragOffsetY = dragInitY + dy;

            dragOffsetX = mathMin(mathMax(dragOffsetX, translationLimit), chartConfig.width - config.width - translationLimit);

            dragOffsetY = mathMin(mathMax(dragOffsetY, translationLimit), chartConfig.height - config.height - translationLimit);

            legendGroup.transform('t' + dragOffsetX + ',' + dragOffsetY);

            config.xPos = config.xL = dragOffsetX;
            config.yPos = config.yL = dragOffsetY;
          }
        }, function () {
          if (config.legendAllowDrag) {
            dragInitX = config.xL || config.xPos;
            dragInitY = config.yL || config.yPos;
          }
        });
        config._dragEvtListenerBinded = true;
      }
    }

    // store the attrs
    attrObj = {
      x: 0,
      y: 0,
      width: width,
      height: height,
      r: r,
      stroke: borderColor,
      'stroke-width': borderWidth,
      fill: backgroundColor || NONE,
      ishot: config.legendAllowDrag
    };

    // draw the background
    if (!box) {
      box = legend.addGraphicalElement('box', paper.rect(attrObj, legendGroup));
      box.attr({
        'opacity': 0,
        'stroke-opacity': 0,
        'fill-opacity': 0
      });
      legendAnimElems.initial.data.push({
        el: box,
        attrs: {
          'opacity': 1,
          'stroke-opacity': 1,
          'fill-opacity': 1
        }
      });
    } else {
      legendAnimElems.plot.data.push({
        el: box,
        attrs: {
          // x: 0,
          // y: 0,
          width: width,
          height: height,
          r: r,
          stroke: borderColor,
          'stroke-width': borderWidth,
          fill: backgroundColor || NONE
        }
      });
    }
    drawn = config.drawn = true;
    box.shadow(config && config.shadow);

    if (!itemGroup) {
      itemGroup = legend.addGraphicalElement('itemGroup', paper.group('item', legendGroup));
    }

    if (scrollEnabled) {
      scrollItem = {
        conf: {
          isHorizontal: false
        },
        handler: {
          'scroll': function scroll(pos) {
            itemGroup.transform(['T', 0, (clipH - config.totalHeight) * pos]);
          },
          'mousedown': function mousedown(e) {
            e.preventDefault();
            e.stopPropagation();
          }
        }
      };

      legendScrollBar = legend._components.legendScrollBar;
      if (!legendScrollBar) {
        legend._components.legendScrollBar = legendScrollBar = new Scroller(scrollItem.conf, (tb.idCount || 0) + 1, tb.pId).attachEventHandlers(scrollItem.handler);
      }

      clipSTR1 = '0,';
      clipH = height - padding;
      clipSTR2 = COMMA + width + COMMA + clipH;
      itemGroup.attr({ 'clip-rect': clipSTR1 + halfPad + clipSTR2 });
      x = width - scrollerWidth + halfPad - borderWidth;
      y = semiBorder;
      // w = scrollerWidth;
      h = height - borderWidth;
      // horiz = false;
      options = {
        scrollPosition: scrollConfig.scrollPosition || 0,
        scrollRatio: (clipH + padding) / config.totalHeight,
        showButtons: false,
        displayStyleFlat: scrollConfig.flatScrollBars
      };
      legendScrollBar.draw(x, y, {
        height: h,
        scrollRatio: options.scrollRatio,
        startPercent: 0,
        color: config.legendScrollBgColor
      });
      legendGroup.appendChild(legendScrollBar.node);
    } else {
      legendScrollBar && legendScrollBar.node && legendScrollBar.node.hide();
      itemGroup.attr({
        'clip-rect': null
      });
      itemGroup.node && itemGroup.node.removeAttribute('clip-path');
    }

    // draw the caption
    if (config.title && config.title.text !== _lib.BLANKSTRING && config.validLegendItem) {
      switch (config.title.align) {
        case _lib.POSITION_START:
          captionX = padding;
          break;
        case _lib.POSITION_END:
          captionX = width - padding - (scrollEnabled ? scrollerWidth : 0);
          break;
        default:
          captionX = width * 0.5;
      }
      legendGroup.trackTooltip(true);

      titleStyle = config.title.style;
      attrObj = {
        text: config.title.text,
        title: config.title.originalText || _lib.BLANKSTRING,
        x: captionX,
        y: padding,
        fill: config.title.style.color,
        direction: config.textDirection,
        'line-height': titleStyle.lineHeight,
        'vertical-align': _lib.POSITION_TOP,
        'text-anchor': config.title.align
      };

      captionCss = {
        'font-weight': titleStyle.fontWeight,
        'font-style': titleStyle.fontStyle,
        'font-family': titleStyle.fontFamily,
        'font-size': titleStyle.fontSize
      };

      if (!caption) {
        caption = legend.addGraphicalElement('caption', paper.text(attrObj, captionCss, itemGroup));
        legendAnimElems.initial.data.push([{
          el: caption,
          type: 'fadeIn'
        }]);
      } else {
        legendAnimElems.plot.data.push([{
          el: caption,
          attrs: attrObj,
          callback: function callback() {
            this.show();
            this.css(captionCss);
          }
        }]);
      }
      caption.tooltip(config.title.originalText);
    } else {
      if (caption) {
        legendAnimElems.initial.data.push([{
          el: caption,
          type: 'fadeOut',
          callback: function callback() {
            this.hide();
          }
        }]);
      }
    }
    if (!config.showLegend || config.enabled === false) {
      legendAnimElems.initial.data.push({
        el: legendGroup,
        type: 'fadeOut',
        callback: function callback() {
          this.hide();
        }
      });
      return;
    }
    for (legendAnim in legendAnimElems) {
      if (legendAnimElems.hasOwnProperty(legendAnim)) {
        animElem = legendAnimElems[legendAnim];
        this.getFromEnv('animationManager').registerAnimation([animElem], legendAnim);
      }
    }
    this._drawPointLegendItem();
  };

  Legend.prototype.reverseLegendFn = function reverseLegendFn() {
    var legend = this,
        items = legend.config.items || [],
        i,
        tempItems = [],
        len = items.length,
        mainDatasetIndex,
        subDSCount = 0,
        config = legend.config;

    // for(i = 0, j = 0; i < (items && items.length); i++) {

    //     if (items[i].configuration.mainDS) {
    //         arr[j] = {
    //             index: i
    //         };
    //         if (lastIndex !== UNDEF) {
    //             arr[lastIndex].count = count;
    //         }
    //         lastIndex = j;
    //         j++;
    //         count = 0;
    //     }
    //     count ++;
    // }

    // arr[lastIndex].count = count;

    // for (i =  arr.length - 1; i >= 0; i--) {
    //     tempItems = tempItems.concat(items.splice(arr[i].index, arr[i].count));
    // }

    for (i = len - 1; i >= 0; i--) {
      if (items[i].configuration.mainDS) {
        mainDatasetIndex = i;
        tempItems = tempItems.concat(items.splice(mainDatasetIndex, subDSCount + 1));
        subDSCount = 0;
      } else {
        subDSCount++;
      }
    }

    if (tempItems.length) {
      config.orderReversed = true;
      legend.config.items = tempItems.slice(0);
    }
  };

  Legend.prototype._manageLegendPosition = function _manageLegendPosition(allottedSpace) {
    var legend = this,
        config = legend.config,
        hasSubDataset = legend.getFromEnv('chart').hasSubDataset,
        legendPosition = config.legendPos,
        items = legend.config.items,
        reverseLegend = config.reversed,
        dimensions;

    if (reverseLegend) {
      if (hasSubDataset) {
        !config.orderReversed && legend.reverseLegendFn();
      } else {
        items && items.reverse();
      }
    } else {
      if (hasSubDataset && config.orderReversed) {
        legend.reverseLegendFn();
      }
    }

    if (legendPosition === _lib.POSITION_RIGHT) {
      dimensions = legend._placeLegendBlockRight(allottedSpace);
    } else {
      dimensions = legend._placeLegendBlockBottom(allottedSpace);
    }
    return dimensions;
  };

  Legend.prototype._placeLegendBlockBottom = function _placeLegendBlockBottom(availableHeight) {
    var legend = this,
        chart = legend.getFromEnv('chart'),
        chartConfig = chart.config,
        origRenderWidth = chartConfig.width,
        origRenderHeight = chartConfig.height,
        spacingLeft = chartConfig.canvasLeft,
        spacingRight = chartConfig.width - (chartConfig.canvasRight || 0),
        SmartLabel = chart.getFromEnv('smartLabel'),
        config = legend.config,
        marginLeft = config.chartMarginLeft,
        marginRight = config.chartMarginRight,
        marginTop = config.chartMarginTop,
        alignLegendWithCanvas = config.alignLegendWithCanvas,
        minimiseWrappingInLegend = config.minimiseWrappingInLegend,
        legendScale = config.legendScale,
        legendnumcolumns = config.numColumns,
        padding = config.padding,
        allowedMaxHeight = availableHeight * 2,
        padding2 = 2 * padding,
        dimensions = {
      width: padding2,
      height: padding2
    },
        legendCaption = config.title,
        captionPadding = legendCaption.padding,
        itemStyle = config.itemStyle,
        itemFontSize = parseInt(itemStyle.fontSize, 10) || 10,
        itemArr = legend.config.items || [],
        len = itemArr.length,
        symbolPadding = config.oriSymbolPadding,
        textPadding = config.textPadding,
        legendPadding = config.legendPadding,
        canvasMarginRight = chartConfig.canvasMarginRight,
        canvasMarginLeft = chartConfig.canvasMarginLeft,
        yAxis = chart.getChildren.yAxis || [],
        yAxis1Obj = yAxis[0],
        yAxis2Obj = yAxis[1],
        yAxis1 = yAxis1Obj && yAxis1Obj.config || {},
        yAxis2 = yAxis2Obj && yAxis2Obj.config || {},
        title1Width = yAxis1.nameMaxW,
        title2Width = yAxis2.nameMaxW,
        yAxis1NameStyle = yAxis1.name && yAxis1.name.style || {},
        yAxis2NameStyle = yAxis2.name && yAxis2.name.style || {},
        yAxis1Title = yAxis1.axisName || _lib.BLANKSTRING,
        yAxis2Title = yAxis2.axisName || _lib.BLANKSTRING,
        maxWidth = 0,
        totalWidth = 0,
        totalNumber = 0,
        averageWidth = 0,
        perItemWidth = 0,
        maxHeight = 0,
        legendCaptionHeight = 0,
        maxMarkerGutter = 0,
        tempTableStructure = [],
        singleRowLegend = false,
        legendX = 0,
        current = 0,
        item,
        nonItemWidth,
        rowHeight,
        usedHeight,
        legendLineHeight,
        i,
        validLegendItem,
        smartText,

    // todo -correct the flow
    availableWidth = chartConfig.canvasWidth - chartConfig.canvasMarginLeft - chartConfig.canvasMarginRight,
        originalAvailableWidth = availableWidth,
        nonTextElemWidth,
        legendHeight,
        rowIndex,
        colIndex,
        textWidth,
        j,
        yAxisTitleHeight,
        yAxisTitleWidth,
        title1,
        title2,
        symbolWidthSpace,
        numRows,
        numberOfCell,
        tempCurrent,
        captionWidth,
        userConfig,
        itemConfig,
        name,
        scroll;
    config.paddingBottom = chartConfig.height - chartConfig.canvasBottom;
    SmartLabel.useEllipsesOnOverflow(chartConfig.useEllipsesWhenOverflow);
    SmartLabel.setStyle(yAxis1NameStyle);
    title1 = SmartLabel.getOriSize(yAxis1Title);
    SmartLabel.setStyle(yAxis2NameStyle);
    title2 = SmartLabel.getOriSize(yAxis2Title);
    symbolWidthSpace = itemFontSize + 1;
    if (symbolWidthSpace <= 0) {
      symbolWidthSpace = 1;
    }
    availableWidth -= padding2;

    symbolWidthSpace *= legendScale;
    symbolPadding *= legendScale;
    symbolWidthSpace = mathMin(symbolWidthSpace, availableWidth);

    if (symbolWidthSpace <= 0) {
      symbolPadding = symbolWidthSpace = 0;
    }
    config.symbolWidth = symbolWidthSpace;
    config.textPadding = 4;
    config.legendHeight = legendHeight = symbolWidthSpace + 2 * symbolPadding;
    config.rowHeight = rowHeight = mathMax(parseInt(config.itemStyle.lineHeight, 10) || 12, legendHeight);
    nonItemWidth = textPadding + symbolPadding + padding;
    SmartLabel.setStyle(config.itemStyle);
    legendLineHeight = SmartLabel.getOriSize(_lib.TESTSTR).height;
    usedHeight = legendPadding + config.borderWidth / 2 + 1;
    usedHeight = mathMin(usedHeight, availableHeight - legendLineHeight - 8);
    legendPadding = rowHeight * 0.05;
    if (title1 || title2) {
      yAxisTitleHeight = (0, _lib.pluckNumber)(title1.height, 0) > (0, _lib.pluckNumber)(title2.height, 0) ? (yAxisTitleWidth = title1Width) && title1.width : (yAxisTitleWidth = title2Width) && title2.width;
    }
    // When alignlegendwithcanvas is 0 we are checking if yAxisTitle is overlapping with legend or not
    // If it is overlapping then we are also taking yAxisTitleWidth into account

    // todo
    availableWidth = alignLegendWithCanvas ? availableWidth : origRenderWidth - (yAxisTitleHeight + marginTop > origRenderHeight - availableHeight ? 2 * yAxisTitleWidth + marginRight + marginLeft + canvasMarginRight + canvasMarginLeft : marginRight + marginLeft + canvasMarginLeft + canvasMarginRight);
    // (availableWidth < 0.3 * origRenderWidth) && (availableWidth = 0.3 * origRenderWidth);
    config.initialItemY = 0;
    config.initialItemX = 0;
    if (!config.showLegend || len === 0) {
      usedHeight = 0;
      config.height = 0;
      config.width = 0;
    } else {
      for (i = 0; i < len; i += 1) {
        item = itemArr[i];
        itemConfig = item.config || (item.config = {});
        userConfig = item.configuration;
        name = itemConfig.name = (0, _lib.parseUnsafeString)(userConfig.label);
        if (name === _lib.BLANKSTRING || userConfig.enabled === 0 || userConfig.enabled === false) {
          itemConfig.enabled = 0;
          continue;
        } else {
          itemConfig.enabled = 1;
        }
        totalNumber += 1;
        validLegendItem = true;
        smartText = SmartLabel.getOriSize(name);
        maxWidth = mathMax(maxWidth, smartText.width);
        /*
          * We also need to get the maximum height required for rendering all the
          * legend items. This will be helpful to vertically align all the legend
          * items in case of single row legend.
          * In case of { br } or <br /> in series name the row height
          * can increase and that need to be accommodated
          */
        maxHeight = mathMax(maxHeight, mathMin(smartText.height, allowedMaxHeight));
        totalWidth += smartText.width;
      }
      config.validLegendItem = validLegendItem;
      averageWidth = totalWidth / totalNumber;
      nonTextElemWidth = legendHeight + legendPadding + textPadding + symbolPadding + padding2;
      totalWidth += nonTextElemWidth * totalNumber;
      config.x = (spacingLeft - marginLeft - spacingRight + marginRight) / 2;
      config.x = !alignLegendWithCanvas && totalWidth > originalAvailableWidth ? 0 : config.x;

      if (validLegendItem) {
        averageWidth += nonTextElemWidth;
        maxWidth += nonTextElemWidth;
        if (legendnumcolumns > 0 && totalNumber < legendnumcolumns) {
          legendnumcolumns = totalNumber;
        }
        // if there has space to show all legends in one column
        if (totalWidth <= availableWidth && (legendnumcolumns <= 0 || legendnumcolumns === totalNumber)) {
          legendnumcolumns = totalNumber;
          perItemWidth = averageWidth = totalWidth / totalNumber;
          singleRowLegend = true;
          // Here we need to check whether row height need to accomodate a any large texts
          if (maxHeight > rowHeight) {
            // gutter for marker has to be uniform and should not depend
            // on different text heights.
            maxMarkerGutter = (maxHeight - rowHeight) / 2;
            rowHeight = maxHeight;
          }
        } else if (legendnumcolumns > 0 && (perItemWidth = availableWidth / legendnumcolumns) > averageWidth) {
          // if valid numcolumn[there has enough item for legendNumColumns, every item getting minimum space]
          if (perItemWidth > maxWidth) {
            perItemWidth = maxWidth;
          }
        } else if (availableWidth > maxWidth && (minimiseWrappingInLegend || averageWidth * 1.5 > maxWidth)) {
          // try to minimize wrapping
          legendnumcolumns = mathFloor(availableWidth / maxWidth);
          if (totalNumber < legendnumcolumns) {
            legendnumcolumns = totalNumber;
          }
          perItemWidth = maxWidth;
        } else if (availableWidth >= 2 * averageWidth) {
          // there has space for atlest 2 column
          // The number of columns each of width as the averageWidth
          legendnumcolumns = mathFloor(availableWidth / averageWidth);

          if (totalNumber < legendnumcolumns) {
            legendnumcolumns = totalNumber;
          }
          // Provide best width space, which is greater than average width, generally
          // (for numColumns is found above via mathFloor ())
          perItemWidth = mathFloor(availableWidth / legendnumcolumns);

          if (perItemWidth > maxWidth) {
            perItemWidth = maxWidth;
          }
        } else {
          // else only 1 column per row
          legendnumcolumns = 1;
          perItemWidth = availableWidth;
        }
        config.itemWidth = perItemWidth;
        /*
          * Its always best to round off to the next whole number in case of
          * widths used for text wrapping. As there are padding available. It will
          * correctly wraps the text only if more than 1 px of space is required
          */
        textWidth = mathCeil(perItemWidth - nonTextElemWidth);
        if (textWidth < 0) {
          symbolPadding = textWidth = textPadding = 0;
        }
        config.symbolPadding = symbolPadding;
        config.textPadding = textPadding;
        config.width = perItemWidth * legendnumcolumns - legendPadding;
        // Legend Caption space management
        if (legendCaption.oriText !== _lib.BLANKSTRING) {
          SmartLabel.setStyle(legendCaption.style);
          smartText = SmartLabel.getSmartText(legendCaption.oriText, availableWidth, allowedMaxHeight);
          legendCaption.text = smartText.text;
          smartText.tooltext && (legendCaption.originalText = smartText.tooltext);

          captionWidth = smartText.width + padding2;
          // if the caption width has gretter width
          if (config.width < captionWidth) {
            config.initialItemX = (captionWidth - config.width) / 2;
            config.width = captionWidth;
          }
          config.initialItemY = legendCaptionHeight = smartText.height + captionPadding;
        }
        SmartLabel.setStyle(config.itemStyle);
        for (i = 0; i < len; i += 1) {
          item = itemArr[i];
          itemConfig = item.config;
          if (itemConfig.enabled !== 0) {
            if (textWidth === 0) {
              tempTableStructure[current] = true;
              itemConfig.name = _lib.BLANKSTRING;
              j = 1;
              rowIndex = parseInt(current / legendnumcolumns, 10);
              colIndex = current % legendnumcolumns;
              itemConfig._legendX = colIndex * perItemWidth;
              itemConfig._legendY = rowIndex * rowHeight + padding2;
              itemConfig._legendH = j * rowHeight;
              itemConfig._totalWidth = symbolWidthSpace + symbolPadding;
            }
            if (singleRowLegend) {
              smartText = SmartLabel.getOriSize(itemConfig.name);

              if (smartText.height < rowHeight) {
                itemConfig._legendTestY = (rowHeight - smartText.height) / 2;
              }
              itemConfig._markerYGutter = maxMarkerGutter;
              itemConfig._legendX = legendX;
              itemConfig._legendY = padding2;
              itemConfig._legendH = rowHeight;
              itemConfig._totalWidth = symbolWidthSpace + nonItemWidth + smartText.width;
              legendX += smartText.width + nonTextElemWidth;
            } else {
              smartText = SmartLabel.getSmartText(itemConfig.name, textWidth, allowedMaxHeight);
              itemConfig.name = smartText.text;
              smartText.tooltext && (itemConfig.originalText = smartText.tooltext);

              while (tempTableStructure[current] === true) {
                current += 1;
              }
              numberOfCell = smartText.height / rowHeight;
              tempCurrent = current;
              for (j = 0; j < numberOfCell; j += 1, tempCurrent += legendnumcolumns) {
                tempTableStructure[tempCurrent] = true;
              }
              if (smartText.height < rowHeight) {
                itemConfig._legendTestY = (rowHeight - smartText.height) / 2;
              }

              rowIndex = parseInt(current / legendnumcolumns, 10);
              colIndex = current % legendnumcolumns;
              itemConfig._legendX = colIndex * perItemWidth;
              itemConfig._legendY = rowIndex * rowHeight + padding2;
              itemConfig._legendH = j * rowHeight;
              itemConfig._totalWidth = symbolWidthSpace + nonItemWidth + smartText.width;
            }
            current++;
          }
        }
        // legendObj.items = itemArr;
        numRows = singleRowLegend ? 1 : mathCeil(tempTableStructure.length / legendnumcolumns);
        dimensions.height += numRows * rowHeight + legendCaptionHeight;
        config.height = config.totalHeight = dimensions.height;
        config.rowHeight = rowHeight;
        config.legendNumColumns = legendnumcolumns;
        if (config.height - 2 * symbolPadding > availableHeight) {
          config.height = availableHeight;
          scroll = config.scroll || (config.scroll = {});
          scroll.enabled = true;
          scroll.flatScrollBars = config.flatScrollBars;
          scroll.scrollBar3DLighting = config.scrollBar3DLighting;
          config.width = config.width + 12 > availableWidth ? config.width : config.width + 12;
        } else {
          config.scroll.enabled = false;
        }
        usedHeight += config.height;
        config.isActive = true;
        config.enabled = true;
      } else {
        config.enabled = false;
        config.width = 0;
        usedHeight = 0;
      }
    }
    return {
      bottom: usedHeight,
      right: 0
    };
  };

  Legend.prototype._placeLegendBlockRight = function _placeLegendBlockRight(availableWidth) {
    var legend = this,
        legendConf = legend.config,
        chart = legend.getFromEnv('chart'),
        chartConf = chart.config,
        SmartLabel = chart.linkedItems.smartLabel,
        canvasBorderThickness = chart.getChildren('canvas')[0].config.canvasBorderThickness || 0,
        textPadding = legendConf.textPadding,
        captionPadding = legendConf.title.padding,
        symbolPadding = legendConf.oriSymbolPadding,
        legendPadding = legendConf.legendPadding,
        legendScale = legendConf.legendScale,
        itemStyle = legendConf.itemStyle,
        itemFontSize = parseInt(itemStyle.fontSize, 10),
        availableHeight = chartConf.canvasHeight,
        allowedMaxHeight = availableHeight * 2,
        textWidthUsed = 0,
        padding = legendConf.padding,
        padding2 = 2 * padding,
        blockDimensions = {
      width: padding2,
      height: padding2
    },
        dimensions = {},
        validLegendItem = false,
        itemArr = legendConf.items || [],
        len = itemArr.length,
        usedWidth,
        smartText,
        textWidth,
        symbolWidthSpace,

    // rowHeight,
    legendHeight,
        itemConfig,
        name,
        captionWidth,
        userConfig,
        i = 0,
        item;

    availableWidth -= padding2 + legendPadding; // 5 pixel padding from canvas border

    symbolWidthSpace = itemFontSize + 1;
    if (symbolWidthSpace <= 0) {
      symbolWidthSpace = 1;
    }
    symbolWidthSpace *= legendScale;
    symbolPadding *= legendScale;
    symbolWidthSpace = mathMin(symbolWidthSpace, availableWidth);

    if (symbolWidthSpace <= 0) {
      symbolPadding = symbolWidthSpace = 0;
    }
    legendConf.symbolPadding = symbolPadding;
    legendConf.symbolWidth = symbolWidthSpace;
    legendConf.legendHeight = legendHeight = symbolWidthSpace + 2 * symbolPadding;
    legendConf.rowHeight = mathMax(parseInt(legendConf.itemStyle.lineHeight, 10) || 12, legendHeight);

    usedWidth = legendPadding + legendConf.borderWidth / 2 + canvasBorderThickness;

    textWidth = availableWidth - legendHeight - legendPadding - textPadding;
    if (textWidth < 0) {
      textWidth = 0;
    }

    // blockDimensions.width = mathMax (legendHeight, blockDimensions.width);
    SmartLabel.useEllipsesOnOverflow(chartConf.useEllipsesWhenOverflow);
    SmartLabel.setStyle(legendConf.itemStyle);

    // If show legend is false and there are no items
    if (!legendConf.showLegend || len === 0) {
      dimensions.right = 0;
      legendConf.height = 0;
      legendConf.width = 0;
    } else {
      for (i = 0; i < len; i += 1) {
        item = itemArr[i];
        itemConfig = item.config || (item.config = {});
        userConfig = item.configuration;
        name = itemConfig.name = (0, _lib.parseUnsafeString)(userConfig.label);
        itemConfig._legendX = 0;
        itemConfig._legendY = blockDimensions.height;
        if (userConfig.enabled === 0 || userConfig.enabled === false || name === _lib.BLANKSTRING) {
          itemConfig.enabled = 0;
          continue;
        } else {
          itemConfig.enabled = 1;
        }
        validLegendItem = true;
        if (textWidth === 0) {
          blockDimensions.height += itemConfig._legendH = legendHeight;
          itemConfig.name = _lib.BLANKSTRING;
          itemConfig._totalWidth = symbolWidthSpace + symbolPadding;
        } else {
          smartText = SmartLabel.getSmartText(name, textWidth, allowedMaxHeight);
          itemConfig.name = smartText.text;
          smartText.tooltext && (itemConfig.originalText = smartText.tooltext);
          if (smartText.height < legendHeight) {
            itemConfig._legendTestY = (legendHeight - smartText.height) / 2;
          }
          itemConfig._totalWidth = symbolWidthSpace + symbolPadding + textPadding + smartText.width + legendPadding;
          blockDimensions.height += itemConfig._legendH = mathMax(smartText.height, legendHeight);
          textWidthUsed = mathMax(smartText.width, textWidthUsed);
        }
      }
      legendConf.validLegendItem = validLegendItem;
      if (validLegendItem) {
        legendConf.itemWidth = textWidthUsed + legendHeight + legendPadding + textPadding;
        legendConf.width = legendConf.itemWidth + padding2;
        if (legendConf.title.oriText !== _lib.BLANKSTRING) {
          SmartLabel.setStyle(legendConf.title.style);
          smartText = SmartLabel.getSmartText(legendConf.title.oriText, availableWidth, allowedMaxHeight);
          legendConf.title.text = smartText.text;
          smartText.tooltext && (legendConf.title.originalText = smartText.tooltext);
          captionWidth = smartText.width + padding2;

          // if the caption width has gretter width
          if (legendConf.width < captionWidth) {
            legendConf.initialItemX = (captionWidth - legendConf.width) / 2;
            legendConf.width = captionWidth;
          }
          legendConf.initialItemY = smartText.height + captionPadding;
          blockDimensions.height += legendConf.initialItemY;
        }

        legendConf.height = legendConf.totalHeight = blockDimensions.height;

        usedWidth = mathMin(legendConf.width + usedWidth, availableWidth);
        dimensions.right = usedWidth + legendPadding;
        legendConf.isActive = true;
        legendConf.enabled = true;
      } else {
        legendConf.enabled = false;
        legendConf.width = 0;
        dimensions.right = 0;
      }
    }

    return dimensions;
  };

  Legend.prototype.postSpaceManager = function postSpaceManager() {
    var legend = this,
        legendConf = legend.config,
        legendPosition = legendConf.legendPos,
        chart = legend.getFromEnv('chart'),
        availableHeight = chart.config.canvasHeight;
    if (legendPosition === _lib.POSITION_RIGHT) {
      if (legendConf.height > availableHeight) {
        legendConf.height = availableHeight;
        legendConf.scroll.enabled = true;
        legendConf.scroll.flatScrollBars = legendConf.flatScrollBars;
        legendConf.scroll.scrollBar3DLighting = legendConf.scrollBar3DLighting;
        legendConf.width += (legendConf.scroll.scrollBarWidth = 10) + (legendConf.scroll.scrollBarPadding = 2);
      } else {
        legendConf.scroll.enabled = false;
      }
    }
  };

  Legend.prototype.configure = function configure() {
    var legend = this,
        config = legend.config,
        chart = legend.getFromEnv('chart'),
        chartConfig = chart.config,
        style = legend.getFromEnv('style'),
        chartAttr = chart.jsonData.chart || chart.jsonData.map,
        is3d = chart.is3D,
        PXSTRING = 'px',
        colorM = legend.getFromEnv('color-manager'),
        borderColor,
        palleteString = is3d ? _lib.chartPaletteStr.chart3D : _lib.chartPaletteStr.chart2D,
        interactiveLegend,
        borderAlpha,
        backgroundAlpha,
        roundEdges = (0, _lib.pluckNumber)(chartAttr.useroundedges, 0),
        padding = 4,
        outCancolor = style.outCancolor,
        legendPadding = (0, _lib.pluckNumber)(chartAttr.legendpadding, 7),
        legendItemFont = (0, _lib.pluck)(chartAttr.legenditemfont, style.outCanfontFamily),
        legendScale = (0, _lib.pluckNumber)(chartAttr.legendiconscale, 1),
        legendFontSize = (0, _lib.pluckFontSize)(chartAttr.legenditemfontsize, style.fontSize),
        legendFontColor = (0, _lib.pluck)(chartAttr.legenditemfontcolor, outCancolor).replace(/^#?([a-f0-9]+)/ig, '#$1'),
        legendIconBgColor = (0, _lib.pluck)(chartAttr.legendiconbgcolor),
        legendIconBorderColor = (0, _lib.pluck)(chartAttr.legendiconbordercolor),
        legendIconAlpha = (0, _lib.pluck)(chartAttr.legendiconbgalpha, chartAttr.legendiconalpha, 100),
        legendIconBorderAlpha = (0, _lib.pluck)(chartAttr.legendiconborderalpha, chartAttr.legendiconalpha, 100),
        legendIconSides = (0, _lib.pluckNumber)(chartAttr.legendiconsides, 4),
        legendIconBorderThickness = (0, _lib.pluckNumber)(chartAttr.legendiconborderthickness),
        legendIconStartAngle = (0, _lib.pluckNumber)(chartAttr.legendiconstartangle, 45),
        legendItemHoverFontColor = (0, _lib.getFirstColor)((0, _lib.pluck)(chartAttr.legenditemhoverfontcolor, legendFontColor)),
        legendItemFontWeight = styleValueMap.fontWeight[(0, _lib.pluckNumber)(chartAttr.legenditemfontbold, 0)] || _lib.BLANKSTRING,
        legendCaptionFontSize = (0, _lib.pluckFontSize)(chartAttr.legendcaptionfontsize, style.fontSize) + PXSTRING,
        anchorMap;
    // config.enabled = true;
    config.isActive = false;
    config.chartMarginTop = chartConfig.origMarginTop;
    config.chartMarginRight = chartConfig.origMarginRight;
    config.chartMarginBottom = chartConfig.origMarginBottom;
    config.chartMarginLeft = chartConfig.origMarginLeft;
    config.showLegend = (0, _lib.pluckNumber)(chartAttr.showlegend, !chart.dontShowLegendByDefault, 1);
    legendFontSize = legendFontSize + PXSTRING;
    config.legendPos = (0, _lib.pluck)(chartAttr.legendposition, chart.legendposition, _lib.POSITION_BOTTOM).toLowerCase();
    config.numColumns = (0, _lib.pluckNumber)(chartAttr.legendnumcolumns, 0);
    config.xL = config.yL = 0;
    if (legendScale <= 0 || legendScale > 5) {
      legendScale = 1;
    }
    config.drawCustomLegendIcon = (0, _lib.pluckNumber)(chartAttr.drawcustomlegendicon, 0);
    config.customLegendConfig = {
      bgColor: legendIconBgColor,
      borderColor: legendIconBorderColor,
      bgAlpha: legendIconAlpha,
      borderAlpha: legendIconBorderAlpha,
      borderThickness: legendIconBorderThickness,
      startAngle: legendIconStartAngle,
      sides: legendIconSides
    };
    config.legendScale = legendScale;
    config.legendPadding = legendPadding;
    config.oriSymbolPadding = 3;
    config.textPadding = 4;
    config.alignLegendWithCanvas = (0, _lib.pluckNumber)(chartAttr.alignlegendwithcanvas, 1);
    config.itemStyle = {
      color: convertColor(legendFontColor),
      fontFamily: legendItemFont,
      fontSize: legendFontSize,
      fontWeight: legendItemFontWeight
    };
    (0, _lib.setLineHeight)(config.itemStyle);
    config.itemHiddenStyle = {
      fontFamily: legendItemFont,
      fontSize: legendFontSize,
      color: convertColor((0, _lib.pluck)(chartAttr.legenditemhiddencolor, 'cccccc').replace(/^#?([a-f0-9]+)/ig, '#$1')),
      fontWeight: legendItemFontWeight
    };
    (0, _lib.setLineHeight)(config.itemHiddenStyle);
    config.title.style = {
      fontFamily: (0, _lib.pluck)(chartAttr.legendcaptionfont, legendItemFont),
      fontSize: legendCaptionFontSize,
      color: (0, _lib.pluck)(chartAttr.legendcaptionfontcolor, outCancolor).replace(/^#?([a-f0-9]+)/ig, '#$1'),
      fontWeight: styleValueMap.fontWeight[(0, _lib.pluckNumber)(chartAttr.legendcaptionfontbold, 1)] || _lib.BLANKSTRING
    };

    anchorMap = chartAttr.legendcaptionalignment ? chartAttr.legendcaptionalignment.toLowerCase() : TEXT_ANCHOR_MAP.center;
    config.title.align = TEXT_ANCHOR_MAP[anchorMap] || TEXT_ANCHOR_MAP.center;

    config.itemHoverStyle = {
      color: convertColor(legendItemHoverFontColor.replace(/^#?([a-f0-9]+)/ig, '#$1'))
    };
    config.title.style['text-anchor'] = config.title.align;
    config.padding = padding;

    borderColor = (0, _lib.pluck)(chartAttr.legendbordercolor, colorM.getColor(palleteString.legendBorderColor));

    borderAlpha = (0, _lib.pluckNumber)(chartAttr.legendborderalpha, 100);
    backgroundAlpha = (0, _lib.pluckNumber)(chartAttr.legendbgalpha, 100);

    config.backgroundColor = convertColor((0, _lib.pluck)(chartAttr.legendbgcolor, colorM.getColor(palleteString.legendBgColor)), backgroundAlpha);

    config.borderColor = convertColor(borderColor, borderAlpha);
    config.borderWidth = (0, _lib.pluckNumber)(chartAttr.legendborderthickness, !roundEdges || chartAttr.legendbordercolor ? 1 : 0);

    config.borderRadius = (0, _lib.pluckNumber)(roundEdges, 0);
    config.shadow = Boolean((0, _lib.pluckNumber)(chartAttr.legendshadow, 1));
    config.symbol3DLighting = Boolean((0, _lib.pluckNumber)(chartAttr.use3dlighting, chartAttr.useplotgradientcolor, 1));
    if (config.shadow) {
      config.shadow = {
        enabled: config.shadow,
        opacity: mathMax(borderAlpha, backgroundAlpha) / 100
      };
    }
    config.reversed = Boolean((0, _lib.pluckNumber)(chartAttr.reverselegend, 0));
    config.style = {
      padding: padding
    };
    config.lineWidth = (0, _lib.pluckNumber)(chartAttr.linethickness, 2);
    interactiveLegend = config.interactiveLegend = chart.hasInteractiveLegend !== false && Boolean((0, _lib.pluckNumber)(chartAttr.interactivelegend, 1));
    if (!interactiveLegend) {
      config.interactiveLegend = false;
      config.itemStyle.cursor = 'default';
      config.itemHoverStyle.cursor = 'inherit';
    } else {
      config.interactiveLegend = true;
      config.symbolStyle = {
        '_cursor': HAND,
        'cursor': POINTER
      };
    }

    config.borderRadius = (0, _lib.pluckNumber)(chartAttr.legendborderradius, roundEdges ? 3 : 0);

    // extra attr on hc JSON added for fc attr support
    config.legendAllowDrag = Boolean((0, _lib.pluckNumber)(chartAttr.legendallowdrag, 0));
    config.title.text = config.title.oriText = (0, _lib.parseUnsafeString)((0, _lib.getFirstValue)(chartAttr.legendcaption, _lib.BLANKSTRING));
    config.legendScrollBgColor = (0, _lib.getFirstColor)((0, _lib.pluck)(chartAttr.legendscrollbgcolor, chartAttr.scrollcolor, colorM.getColor('altHGridColor')));
    config.legendScrollBarColor = (0, _lib.pluck)(chartAttr.legendscrollbarcolor, borderColor);
    config.legendScrollBtnColor = (0, _lib.pluck)(chartAttr.legendscrollbtncolor, borderColor);
    config.minimiseWrappingInLegend = (0, _lib.pluckNumber)(chartAttr.minimisewrappinginlegend, 0);
    config.flatScrollBars = (0, _lib.pluckNumber)(chartAttr.flatscrollbars, 0);
    config.scrollBar3DLighting = (0, _lib.pluckNumber)(chartAttr.scrollbar3dlighting, 1);

    config.orderReversed = false;
  };

  Legend.prototype._drawPointLegendItem = function _drawPointLegendItem() {
    var legend = this,
        chart = legend.getFromEnv('chart'),
        hasSubDataset = chart.hasSubDataset,
        chartConfig = chart.config,

    // animationObj = chart.get(configStr, animationObjStr),
    // transposeAnimDuration = animationObj.transposeAnimDuration,
    // animType = animationObj.animType,
    // dummyAnimElem = animationObj.dummyObj,
    // dummyAnimObj = animationObj.animObj,
    datasetArr = chart.getChildren('dataset'),
        paper = chart.getFromEnv('paper'),
        config = legend.config,
        reverseLegend = config.reversed,
        items = legend.config.items || [],
        symbolBoxW = config.legendHeight,
        symbolPadding = config.symbolPadding,
        symbolWidth = config.symbolWidth,
        interactiveLegend = config.interactiveLegend,
        textPadding = config.textPadding || 2,
        padding = (0, _lib.pluckNumber)(config.padding, 4),
        textDirection = chartConfig.textDirection,
        itemHiddenStyle = config.itemHiddenStyle,
        itemStyle = config.itemStyle,
        itemHoverStyle = config.itemHoverStyle,
        lineWidth = config.lineWidth,

    // item3dlighting = config.symbol3DLighting,
    itemTextColor = itemStyle.color,
        hiddenColor = itemHiddenStyle && itemHiddenStyle.color || '#CCCCCC',
        graphics = legend.graphics,
        itemGroup = legend.getGraphicalElement('itemGroup'),
        drawCustomLegendIcon = config.drawCustomLegendIcon,
        customLegendConfig = config.customLegendConfig,
        legendItemAnimElems = [],

    // animObj = {
    //     initial: {
    //         data: []
    //     },
    //     plot: {
    //         data: []
    //     },
    //     final: {
    //         data: []
    //     }
    // },
    savedLegendItem,
        initialItemX,
        initialItemY,
        legendItem,
        visible,
        cy,
        legendItemText,
        type,
        attr,
        itemX,
        itemY,
        itemHeight,
        i,
        ln,
        dataObj,

    // itemColor,
    legendItemLine,
        symbolConfig,
        itemConfig,
        legendItemSymbol,

    // marker,
    // mLineColor,
    cx,
        radius,
        dip,

    // symbolColor,
    symbol,
        strokeWidth,
        configuration,
        strokeColor,
        fillColor,
        anchorSide,
        drawLine,
        lineColor,
        symbolStr,
        customBgColor,
        customBgAlpha,
        customBorderColor,
        customBorderAlpha,
        color,
        bdColor,
        legendItemBackground,
        symbolCosmetics,
        drawItemLine,
        symbolAttr,
        itemClickEventFN = function itemClickEventFN(e) {
      var legendItem = this.data('legendItem'),
          config = legendItem.configuration,
          dataset = config.datasetObj || legendItem.dataset,
          eventArgs = dataset.getEventArgs ? dataset.getEventArgs(legendItem) : {},

      // interactivityCancelled,
      cord = (0, _lib.getMouseCoordinate)(chart.chartInstance, e);
      eventArgs.chartX = cord.chartX;
      eventArgs.chartY = cord.chartY;
      eventArgs.pageX = cord.pageX;
      eventArgs.pageY = cord.pageY;
      eventArgs.legendItemIndex = legendItem.index;
      eventArgs.legendItemId = legendItem.legendItemId;
      // eventArgs.preventDefaults = function () {
      //   interactivityCancelled = true;
      // };
      /**
       * This event is fired when user clicks on individual legend items. By default, the legend items on
       * a chart are configured to toggle the visibility of the dataset (series) that the legend item
       * points to.
       *
       * @see FusionCharts#event:legendItemRollover
       * @see FusionCharts#event:legendItemRollout
       * @event FusionCharts#legendItemClicked
       * @group legend
       *
       * @param {number} minRange - Minimum value of the color range represented by the legend item.
       * @param {number} maxRange - Maximum value of the color range represented by the legend item.
       *
       */
      (0, _eventApi.triggerEvent)(LEGENDITEMCLICKED, chart.chartInstance, eventArgs);
    },
        itemRollOver = function itemRollOver(e) {
      var legendItem = this.data('legendItem') || {},
          config = legendItem.configuration,
          dataset = config.datasetObj || legendItem.dataset,
          interactiveLegend = this.data('interactive'),
          eventArgs = dataset.getEventArgs ? dataset.getEventArgs(legendItem) : {},
          cord = (0, _lib.getMouseCoordinate)(chart.chartInstance, e, chart),
          itemHoverStyle = this.data('itemHoverStyle'),
          visible = legendItem.dataset.getState('visible') !== false,
          legendItemText = legendItem.graphics && legendItem.graphics.legendItemText;
      if (visible && interactiveLegend) {
        legendItemText && legendItemText.attr({
          fill: itemHoverStyle.color
        });
      }
      eventArgs.chartX = cord.chartX;
      eventArgs.chartY = cord.chartY;
      eventArgs.pageX = cord.pageX;
      eventArgs.pageY = cord.pageY;
      eventArgs.legendItemIndex = legendItem.index;
      eventArgs.legendItemId = legendItem.legendItemId;
      /**
       * This event is fired when the mouse pointer is moved over any individual legend item.
       *
       * @see FusionCharts#event:legendItemRollout
       * @see FusionCharts#event:legendItemClicked
       *
       * @event FusionCharts#legendItemRollover
       * @group legend
       *
       * @param {number} chartX - The relative X-Cordinate to chart container where the legend item was
       * hovered.
       * @param {number} chartY - The relative Y-Cordinate to chart container where the legend item was
       * hovered
       * @param {number} datasetIndex - The index of the dataset
       * @param {string} datasetName - The name of the dataset
       * @param {string} id - User-defined Id of the dataset.
       * @param {number} pageX - The relative X-Cordinate to screen where the legend item was hovered.
       * @param {number} pageY - The relative Y-Cordinate to screen where the legend item was hovered.
       * @param {boolean} visible - `true` if the legend item is visible in the chart or false if it is
       * hidden.
       */
      (0, _eventApi.triggerEvent)(LEGENDITEMROLLOVER, chart.chartInstance, eventArgs);
    },
        itemRollOut = function itemRollOut(e) {
      var legendItem = this.data('legendItem') || {},
          config = legendItem.configuration,
          dataset = config.datasetObj || legendItem.dataset,
          interactiveLegend = this.data('interactive'),
          eventArgs = dataset.getEventArgs ? dataset.getEventArgs(legendItem) : {},
          cord = (0, _lib.getMouseCoordinate)(chart.chartInstance, e, chart),
          visible = legendItem.dataset.getState('visible') !== false,
          itemStyle = this.data('itemStyle'),
          legendItemText = legendItem.graphics && legendItem.graphics.legendItemText;
      if (visible && interactiveLegend) {
        legendItemText && legendItemText.attr({
          fill: itemStyle.color
        });
      }

      eventArgs.chartX = cord.chartX;
      eventArgs.chartY = cord.chartY;
      eventArgs.pageX = cord.pageX;
      eventArgs.pageY = cord.pageY;
      eventArgs.legendItemIndex = legendItem.index;
      eventArgs.legendItemId = legendItem.legendItemId;
      /**
       * This event is fired when the mouse is hovered out of the chart's legend item.
       *
       * @see FusionCharts#event:legendItemRollover
       * @see FusionCharts#event:legendItemClicked
       * @event FusionCharts#legendItemRollout
       * @group legend
       *
       * @param {number} chartX - The relative X-Cordinate to chart container where the mouse is hovered
       * out of legend item.
       * @param {number} chartY - The relative Y-Cordinate to chart container where the mouse is hovered
       * out of legend item.
       * @param {number} datasetIndex - The index of the dataset.
       * @param {string} datasetName - The name of the dataset.
       * @param {string} id - User-defined Id of the dataset.
       * @param {number} pageX - The relative X-Cordinate to screen where the mouse is hovered out of
       * legend item.
       * @param {number} pageY - The relative Y-Cordinate to screen where the mouse is hovered out of
       * legend item.
       * @param {boolean} visible - `true` if the legend item is visible in the chart or false if it is
       * hidden.
       */
      (0, _eventApi.triggerEvent)(LEGENDITEMROLLOUT, chart.chartInstance, eventArgs);
    },
        itemClickFN = function itemClickFN(e) {
      var legendItem = this.data('legendItem'),
          dataObj = legendItem.dataset,
          interactiveLegend = this.data('interactive');
      interactiveLegend && legendItem.legendClickFN.call(legend, dataObj, legendItem, datasetArr);
      itemClickEventFN.call(this, e);
    },
        drawAnchor = function drawAnchor() {
      radius = symbolWidth * 0.5;
      cx = itemX + symbolPadding + radius;
      cy = itemY + (itemConfig._markerYGutter || 0) + symbolPadding + radius;

      if (drawItemLine) {
        radius *= 0.6;
      }
      symbolStr = mapSymbolName(configuration.anchorSide);
      symbol = configuration.symbol = symbolStr && symbolStr.split('_') || [];
      dip = symbol[0] === 'spoke' ? 1 : 0;

      symbolAttr = {
        polypath: [symbol[1] || 2, cx, cy, radius, configuration.startAngle, configuration.spoke || dip]
      };
      symbolCosmetics = {
        cursor: itemStyle.cursor || POINTER,
        stroke: visible ? strokeColor : hiddenColor,
        fill: visible ? fillColor : hiddenColor,
        'stroke-width': strokeWidth,
        ishot: interactiveLegend
      };
    },
        lineAttr,
        lineCosmetics = {},
        setLineItemData = function setLineItemData() {
      this.show();
      this.data('legendItem', itemConfig);
    },
        lineItemHook = function lineItemHook() {
      this.attr(lineAttr);
      this.attr(lineCosmetics);
    },
        hideLineItem = function hideLineItem() {
      this.hide();
    },
        backgroundAttr,
        xPos,
        yPos,
        backgroundCosmetics;
    initialItemX = config.initialItemX || 0;
    initialItemY = config.initialItemY || 0;

    // If legend is disabled then return
    if (config.enabled === false || !config.showLegend) {
      return;
    }

    itemGroup.css(itemStyle);
    // draw all items
    // chart._addCSSDefinition ('.fusioncharts-legend .fusioncharts-legenditem', config.itemStyle);
    for (i = 0, ln = items.length; i < ln; i += 1) {
      legendItem = items[i];
      if (legend.getFromEnv('savedLegendItems')) {
        savedLegendItem = legend.getFromEnv('savedLegendItems')[i];
      }
      legendItem.index = i;
      configuration = legendItem.configuration;
      type = configuration.type;
      itemConfig = legendItem.config = legendItem.config || (legendItem.config = {});
      graphics = legendItem.graphics || (legendItem.graphics = {});
      dataObj = legendItem.dataset;
      dataObj.graphics && (dataObj.graphics.legendGraphics = graphics);
      strokeColor = itemConfig.strokeColor = configuration.strokeColor || '000000';
      fillColor = itemConfig.fillColor = configuration.fillColor || '000000';
      itemConfig.interactiveLegend = configuration.interactiveLegend;
      if (configuration.legendBackgroundColor) {
        itemConfig.legendBackgroundColor = (0, _lib.toRaphaelColor)({
          color: configuration.legendBackgroundColor,
          alpha: 20
        });
      } else {
        itemConfig.legendBackgroundColor = (0, _lib.toRaphaelColor)(TRACKER_FILL);
      }
      anchorSide = configuration.anchorSide;
      drawLine = itemConfig.drawLine = configuration.drawLine;
      lineWidth = configuration.lineWidth || lineWidth;
      lineColor = configuration.lineColor || strokeColor;
      itemX = initialItemX + itemConfig._legendX + padding;
      itemY = initialItemY + itemConfig._legendY - padding;
      strokeWidth = itemConfig.strokeWidth = configuration.strokeWidth || 0.5;
      itemHeight = itemConfig._legendH;
      visible = dataObj.getState('visible') !== false;

      legendItemBackground = graphics.legendItemBackground;
      legendItemText = graphics.legendItemText;
      legendItemLine = graphics.legendItemLine;
      legendItemSymbol = graphics.legendItemSymbol;
      interactiveLegend = (0, _lib.pluck)(itemConfig.interactiveLegend, interactiveLegend);
      !interactiveLegend && (itemStyle.cursor = 'default');
      if (itemConfig.enabled !== 0) {
        xPos = itemX + symbolBoxW + textPadding - 2;
        yPos = itemY + (itemConfig._legendTestY || 0);

        attr = {
          text: itemConfig.name,
          fill: visible ? itemTextColor : hiddenColor,
          'text-anchor': _lib.POSITION_START,
          'vertical-align': _lib.POSITION_TOP,
          cursor: itemStyle.cursor || POINTER,
          direction: textDirection,
          'line-height': itemStyle.lineHeight
        };

        symbolAttr = null;
        lineAttr = null;

        itemConfig.textAttr = attr;
        if (!legendItemText) {
          attr.x = xPos;
          attr.y = yPos;
          legendItemText = graphics.legendItemText = paper.text(attr, itemGroup).data('legendItem', itemConfig);
          legendItemText.attr({
            'opacity': 0,
            'fill-opacity': 0,
            'stroke-opacity': 0
          });
          legendItemAnimElems.push({
            el: legendItemText,
            attrs: {
              'opacity': 1,
              'fill-opacity': 1,
              'stroke-opacity': 1
            },
            animType: 'linear',
            animConfig: [{
              syncWith: 'initial',
              start: 0,
              end: 1
            }]
          });
        } else {
          // replaced animateWith-with-attr
          legendItemText.show().attr({
            x: xPos,
            y: yPos
          });
          legendItemText.attr(attr);
        }
        drawItemLine = false;

        if (drawCustomLegendIcon && configuration.customLegendIcon !== false) {
          customBorderColor = customLegendConfig.borderColor;
          customBorderAlpha = (0, _lib.pluck)(customLegendConfig.borderAlpha);
          customBgColor = customLegendConfig.bgColor;
          customBgAlpha = (0, _lib.pluck)(customLegendConfig.bgAlpha, '100');

          if (anchorSide || type === 'line' || drawLine || type === 'spline') {
            bdColor = (0, _lib.hashify)(configuration.rawStrokeColor);
            configuration.rawFillColor = (0, _lib.hashify)(configuration.rawFillColor);
            fillColor = (0, _lib.pluck)(customBgColor, configuration.rawFillColor, itemConfig.color);
            if (/^#/.test(fillColor)) {
              fillColor = convertColor(fillColor, customBgAlpha);
            }
            lineColor = (0, _lib.pluck)(customBorderColor, bdColor, itemConfig.strokeColor);
            lineColor = convertColor(lineColor, customBorderAlpha);

            itemConfig.anchorSide = customLegendConfig.sides;
          } else {
            color = (0, _lib.pluck)(configuration.rawFillColor, itemConfig.fillColor);
            fillColor = (0, _lib.pluck)(customBgColor, color);
            fillColor = convertColor(fillColor, customBgAlpha);

            if (customLegendConfig.borderColor) {
              lineColor = convertColor(customLegendConfig.borderColor, customBorderAlpha);
            } else {
              if (/rgb/.test(color)) {
                color = rgbaToHex(color);
              }
              lineColor = getLightColor(color, 60).replace(dropHash, _lib.HASHSTRING);
              lineColor = convertColor(lineColor, customBorderAlpha);
            }
          }

          itemConfig.fillColor = fillColor;
          itemConfig.strokeColor = lineColor;
          radius = symbolWidth * 0.5;
          cx = itemX + symbolPadding + radius;
          cy = itemY + (itemConfig._markerYGutter || 0) + symbolPadding + radius;

          symbolStr = mapSymbolName(customLegendConfig.sides);
          symbol = symbolStr && mapSymbolName(customLegendConfig.sides).split('_') || [];
          dip = symbol[0] === 'spoke' ? 1 : 0;

          symbolAttr = {
            polypath: [symbol[1] || 2, cx, cy, radius, customLegendConfig.startAngle, dip]
          };

          symbolCosmetics = {
            cursor: itemStyle.cursor || POINTER,
            stroke: visible ? lineColor : hiddenColor,
            fill: visible ? fillColor : hiddenColor,
            'stroke-width': (0, _lib.pluckNumber)(customLegendConfig.borderThickness, 1),
            ishot: interactiveLegend
          };
        } else if (type === 'line' || drawLine) {
          // drawing line legend or when other legends have line in it
          cy = itemY + (itemConfig._markerYGutter || 0) + symbolPadding + symbolWidth * 0.5;

          lineAttr = {
            path: [M, itemX + symbolPadding, cy, L, itemX + symbolPadding + symbolWidth, cy]
          };
          drawItemLine = true;
          lineCosmetics = {
            'stroke-width': lineWidth,
            stroke: visible ? lineColor : hiddenColor,
            cursor: itemStyle.cursor || POINTER,
            ishot: interactiveLegend
          };

          if (anchorSide) {
            drawAnchor();
          }
        } else if (anchorSide) {
          // draw  polypath legend
          drawAnchor();
        } else if (type !== 'line') {
          // drawing the remaining legends
          legendItemSymbol = graphics.legendItemSymbol;
          symbolConfig = _getSymbolPath(itemX + symbolPadding, itemY + (itemConfig._markerYGutter || 0) + symbolPadding, symbolWidth, symbolWidth, type);

          symbolAttr = {
            path: symbolConfig.path
          };

          symbolCosmetics = {
            'stroke-width': 0.5,
            stroke: visible ? strokeColor : hiddenColor,
            fill: visible ? fillColor : hiddenColor,
            cursor: itemStyle.cursor || POINTER,
            ishot: interactiveLegend
          };
        }

        if (lineAttr && drawItemLine) {
          itemConfig.lineAttr = lineCosmetics;
          if (!legendItemLine) {
            legendItemLine = graphics.legendItemLine = paper.path(itemGroup);
            // legendItemLine.attr({
            //     'opacity': 0
            // });
            legendItemAnimElems.push({
              el: legendItemLine,
              callback: setLineItemData,
              type: 'fadeIn',
              animConfig: [{
                hookFn: lineItemHook.bind(legendItemLine),
                syncWith: 'initial'
              }]
            });
            // legendItemLine.show();
            // legendItemLine.attr(lineAttr);
            // legendItemLine.attr(lineCosmetics);
            // legendItemLine.data ('legendItem', itemConfig);
          } else {
            legendItemAnimElems.push({
              el: legendItemLine,
              callback: setLineItemData,
              type: 'fadeIn',
              animConfig: [{
                hookFn: lineItemHook.bind(legendItemLine),
                syncWith: 'initial'
              }]
            });
          }
        } else {
          if (legendItemLine) {
            legendItemAnimElems.push({
              el: legendItemLine,
              type: 'fadeOut',
              callback: hideLineItem
            });
          }
        }

        if (symbolAttr) {
          itemConfig.symbolAttr = symbolCosmetics;
          if (!legendItemSymbol) {
            legendItemSymbol = graphics.legendItemSymbol = paper.polypath(itemGroup);
            legendItemSymbol.attr(symbolAttr);
            legendItemSymbol.attr(symbolCosmetics);
            legendItemSymbol.data('legendItem', itemConfig);
            legendItemSymbol.attr({
              'opacity': 0,
              'fill-opacity': 0,
              'stroke-opacity': 0,
              'fill': 'rgba(255, 255, 255, 0)'
            });
            legendItemAnimElems.push({
              el: legendItemSymbol,
              attrs: {
                'opacity': 1,
                'fill-opacity': 1,
                'stroke-opacity': 1,
                'fill': fillColor
              },
              animType: 'linear',
              animConfig: [{
                syncWith: 'initial',
                start: 0,
                end: 1
              }]
            });
          } else {
            legendItemSymbol.attr(symbolAttr);
            legendItemSymbol.attr(symbolCosmetics);
            legendItemSymbol.data('legendItem', itemConfig);
            if (savedLegendItem && isDifferent(savedLegendItem.graphics.legendItemSymbol.attr(), symbolCosmetics)) {
              legendItemSymbol.attr({
                'opacity': 0,
                'fill-opacity': 0,
                'stroke-opacity': 0,
                'fill': 'rgba(255, 255, 255, 0)'
              });
              legendItemAnimElems.push({
                el: legendItemSymbol,
                attrs: {
                  'opacity': 1,
                  'fill-opacity': 1,
                  'stroke-opacity': 1,
                  'fill': fillColor
                },
                animType: 'linear',
                animConfig: [{
                  syncWith: 'initial',
                  start: 0,
                  end: 1
                }]
              });
            }
          }
        } else {
          legendItemSymbol && legendItemSymbol.hide();
        }

        backgroundAttr = {
          x: itemX,
          y: itemY, // text gutter
          width: itemConfig._totalWidth,
          height: itemHeight
        };

        backgroundCosmetics = {
          r: 0,
          fill: itemConfig.legendBackgroundColor,
          'stroke-width': 1,
          stroke: NONE,
          cursor: itemStyle.cursor || POINTER,
          ishot: interactiveLegend
        };
        // draw background
        if (!legendItemBackground) {
          legendItemBackground = graphics.legendItemBackground = paper.rect(itemGroup);
          legendItemBackground.attr(backgroundAttr).mouseover(itemRollOver).mouseout(itemRollOut).click(itemClickFN);
        }
        // replaced animateWith-with-attr
        legendItemBackground.show().attr(backgroundAttr);
        legendItemBackground.attr(backgroundCosmetics);
        legendItemBackground.data('legendItem', legendItem).data('interactive', interactiveLegend).data('itemHoverStyle', itemHoverStyle).data('itemStyle', itemStyle);
      } else {
        legendItemText && legendItemText.hide();
        legendItemBackground && legendItemBackground.hide();
        legendItemSymbol && legendItemSymbol.hide();
        legendItemLine && legendItemLine.hide();
      }
    }

    legend.addToEnv('savedLegendItems', items);

    this.getFromEnv('animationManager').registerAnimation([{
      data: legendItemAnimElems,
      animType: 'linear',
      animConfig: [{
        syncWith: 'initial',
        start: 0,
        end: 1
      }]
    }], 'initial');

    // Reset the order
    !hasSubDataset && reverseLegend && items.reverse();
  };

  Legend.prototype.emptyItems = function emptyItems(index, stretch) {
    var legend = this,
        config = legend.config,
        items = config.items || (config.items = []),
        graphics,
        atomicGraphicsName,
        atomicGraphicsElement,
        length = stretch !== UNDEF ? stretch : items.length,
        removalArr = items.splice(index, length);

    for (index = 0, length = removalArr.length; index < length; index += 1) {
      graphics = (removalArr[index] || (removalArr[index] = {})).graphics;
      for (atomicGraphicsName in graphics) {
        atomicGraphicsElement = graphics[atomicGraphicsName];

        atomicGraphicsElement && atomicGraphicsElement.remove && typeof atomicGraphicsElement.remove === 'function' && atomicGraphicsElement.remove();
      }
    }
  };

  Legend.prototype.removeItem = function removeItem(id) {
    var legend = this,
        items = legend.getItems() || [],
        len = items.length,
        animElems = [],
        disposeLegendItem = function disposeLegendItem(legendItem) {
      _lib.componentDispose.call(legendItem);
    },
        legendGraphics,
        graphic,
        index,
        item,
        lId;

    for (index = 0; index < len; index++) {
      item = items[index];
      lId = item.legendItemId;
      if (id === lId) {
        legendGraphics = item.graphics;
        item.state = 'remove';
        for (graphic in legendGraphics) {
          if (legendGraphics.hasOwnProperty(graphic)) {
            animElems.push({
              el: legendGraphics[graphic],
              callback: disposeLegendItem.bind(this, item),
              type: 'fadeOut'
            });
          }
        }
        items.splice(index, 1);
        break;
      }
    }
    this.getFromEnv('animationManager').registerAnimation([{
      data: animElems
    }], 'initial');
  };

  Legend.prototype.addItems = function addItems(dataset, legendClickFN, configuration) {
    var legend = this,
        idIndex,
        strArr,
        config = legend.config,
        lastItemId = config.lastItemId,
        legendItemId = (0, _lib.pluck)(dataset.legendItemId, configuration.legendItemId),
        items = config.items || (config.items = []);
    if (legendItemId !== UNDEF) {
      legend.configureItems(legendItemId, {
        legendClickFN: legendClickFN,
        configuration: configuration,
        dataset: dataset
      });
      lastItemId = legendItemId;
    } else {
      if (lastItemId === UNDEF) {
        legend.config.lastItemId = lastItemId = LEGENDNAME + 0;
      } else {
        strArr = lastItemId.split('_');
        idIndex = strArr && strArr[1];
        legend.config.lastItemId = lastItemId = LEGENDNAME + ++idIndex;
      }
      items.push({
        legendItemId: lastItemId,
        dataset: dataset,
        legendClickFN: legendClickFN,
        configuration: configuration || {}
      });
    }

    return lastItemId;
  };

  Legend.prototype.configureItems = function configureItems(legendItemId, itemProps) {
    var legend = this,
        config = legend.config,
        items = config.items,
        prop,
        i,
        len = items.length,
        id,
        itemObj;
    for (i = 0; i < len; i++) {
      itemObj = items[i];
      if (!itemObj.dataset) {
        continue;
      }
      id = (0, _lib.pluck)(itemObj.dataset.legendItemId, itemObj.legendItemId);
      if (id === legendItemId) {
        break;
      }
    }
    for (prop in itemObj) {
      if (prop in itemProps) {
        switch (prop) {
          case 'configuration':
            mergeConf(itemProps[prop], itemObj[prop]);
            break;
          default:
            itemObj[prop] = itemProps[prop];
        }
      }
    }
  };

  Legend.prototype.getItems = function getItems() {
    return this.config.items;
  };

  Legend.prototype.hide = function hide() {
    var legend = this,
        chart = legend.getFromEnv('chart'),
        legendGroup = chart.getChildContainer().legendGroup;
    legendGroup.hide();
  };

  return Legend;
}(_componentInterface2['default']);

exports['default'] = Legend;

/***/ }),
/* 414 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _lib = __webpack_require__(5);

var _domEvent = __webpack_require__(34);

var _domEvent2 = _interopRequireDefault(_domEvent);

var _componentInterface = __webpack_require__(6);

var _componentInterface2 = _interopRequireDefault(_componentInterface);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */

/**
* A derived event generated as a result of a sequence of actual events.
* @typedef {Object} DerivedEvent
* @property {boolean} fireOut Indicates whether the event results in the mouse moving out of a
*                             component
* @property {Array}   events  The sequence of events that led to this derived event
*/

var SPACE = ' ',

// minTimeGapBtwnClicks = 300,
MOUSEOVER = 'mouseover',
    MOUSEDOWN = 'mousedown',
    TOUCHSTART = 'touchstart',
    MOUSEUP = 'mouseup',
    TOUCHEND = 'touchend',
    MOUSEMOVE = 'mousemove',
    TOUCHMOVE = 'touchmove',
    MOUSEOUT = 'mouseout',
    CLICK = 'click';

/**
 * The MouseTracker component is responsible for attching mouse events on the chart and deciding
 * what event to fire under which situation. For example, it tracks mouse movement inside the chart
 * and when the mouse moves inside one plot and out of another, it derives that the mouse has
 * entered on plot and left another.
 * @class
 */

var MouseTracker = function (_ComponentInterface) {
  _inherits(MouseTracker, _ComponentInterface);

  /**
   * When instantiating MouseTracker, it needs to be provided an instance of the chart on which it
   * will add events.
   * @param  {Object} chart An instance of the chart
   */
  function MouseTracker(chart) {
    _classCallCheck(this, MouseTracker);

    var _this = _possibleConstructorReturn(this, _ComponentInterface.call(this));

    _this.pIndex = 1;
    _this.chart = chart;
    // this.eventsList: [ MOUSEOVER, MOUSEOUT, MOUSEDOWN, TOUCHSTART, MOUSEUP, TOUCHEND, MOUSEMOVE,
    //   TOUCHMOVE, CLICK];
    _this.eventsList = [MOUSEDOWN, TOUCHSTART, MOUSEUP, TOUCHEND, MOUSEMOVE, TOUCHMOVE];
    _this.config = {};
    return _this;
  }

  /**
   * This method delegates the handling of  mouse event to the chart's event handler
   * @param  {Object} e The Event Object
   * @private
   */


  MouseTracker._mouseEvtHandler = function _mouseEvtHandler(e) {
    // Making _mouseEvtHandler chart specific
    e.data.chart._mouseEvtHandler(e);
  };

  /**
   * Given the event object, the index of the dataset and the index of the plot in the dataset, this
   * method determines which event has occured on a dataset's plot
   * @param {Event} e original mouse event that is being trapped
   * @param {number} datasetIndex Index of the dataset that is being interacted
   * @param {number} plotIndex Index of the plot that is being interacted
   * @return {DerivedEvent} An object containg the details of the mouse events that need to be fired
   * @todo has scope to reduce no of line
   */


  MouseTracker.prototype.getMouseEvents = function getMouseEvents(e, datasetIndex, plotIndex) {
    var mouseTracker = this,
        lastDatasetIndex = mouseTracker._lastDatasetIndex,
        lastPointIndex = mouseTracker._lastPointIndex,
        derivedEvensInfo = {
      fireOut: false,
      events: []
    };

    switch (e.type) {
      case CLICK:
        derivedEvensInfo.events.push(CLICK);
        break;
      case TOUCHMOVE:
        /* jshint ignore:start */
        mouseTracker.touchMove = true;
      // eslint-disable-next-line no-fallthrough
      case MOUSEMOVE:
        if (lastDatasetIndex === datasetIndex && lastPointIndex === plotIndex) {
          derivedEvensInfo.events.push(MOUSEMOVE);
        } else {
          derivedEvensInfo.events.push(MOUSEOVER);
          derivedEvensInfo.fireOut = true;
        }

        break;
      case TOUCHSTART:
        mouseTracker.touchMove = false;
        mouseTracker.touchStart = true;
      // eslint-disable-next-line no-fallthrough
      case MOUSEDOWN:
        if (lastDatasetIndex !== datasetIndex || lastPointIndex !== plotIndex) {
          derivedEvensInfo.fireOut = true;
          derivedEvensInfo.events.push(MOUSEOVER);
        }
        derivedEvensInfo.events.push(MOUSEDOWN);
        break;

      case TOUCHEND:
        if (mouseTracker.touchStart && !mouseTracker.touchMove) {
          derivedEvensInfo.events.push(CLICK);
          mouseTracker.touchMove = false;
          mouseTracker.touchStart = false;
        }
      /* jshint ignore:end */
      // eslint-disable-next-line no-fallthrough
      case MOUSEUP:
        derivedEvensInfo.events.push(MOUSEUP);
        // @todo: implement clcik from mouseend as well
        break;

      case MOUSEOUT:
        if (lastDatasetIndex !== datasetIndex || lastPointIndex !== plotIndex) {
          derivedEvensInfo.fireOut = true;
          derivedEvensInfo.events.push(MOUSEOVER);
        }
    }
    return derivedEvensInfo;
  };

  /**
   * This method simply removes previously added listeners and adds all events in its event list to
   * the chart
   */


  MouseTracker.prototype.addEvents = function addEvents() {
    var mouseTracker = this,
        chart = mouseTracker.chart,
        container = chart.getFromEnv('chart-container'),
        eventsList = mouseTracker.eventsList;

    chart.config.enableMouseOutEvent && eventsList.push(MOUSEOUT);
    !_lib.hasTouch && eventsList.push(CLICK);

    // Remove old listners
    mouseTracker._removeListners();

    // Attach all related mouse / touch events.
    _domEvent2['default'].listen(container, eventsList.join(SPACE), MouseTracker._mouseEvtHandler, {
      chart: chart,
      mouseTracker: mouseTracker
    });
  };

  /**
   * Removes all event listeners added to the chart, if any
   * @private
   */


  MouseTracker.prototype._removeListners = function _removeListners() {
    var mouseTracker = this,
        chart = mouseTracker.chart,
        container = chart.getFromEnv('chart-container'),
        eventsList = mouseTracker.eventsList,
        i,
        l = eventsList.length;

    // remove all previously attached events
    for (i = 0; i < l; i += 1) {
      _domEvent2['default'].unlisten(container, eventsList[i], MouseTracker._mouseEvtHandler);
    }
  };

  /**
   * This method is used to remove all event listeners attached by MouseTracker to the chart.
   */


  MouseTracker.prototype.dispose = function dispose() {
    this._removeListners();
  };

  return MouseTracker;
}(_componentInterface2['default']);

exports['default'] = MouseTracker;

/***/ }),
/* 415 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _componentInterface = __webpack_require__(6);

var _componentInterface2 = _interopRequireDefault(_componentInterface);

var _domEvent = __webpack_require__(34);

var _domEvent2 = _interopRequireDefault(_domEvent);

var _lib = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); }

var ENTER_CODE = 13,
    ESCAPE_CODE = 27;

var linkedAxis = void 0;

function getCharCode(e) {
  return typeof e.which === 'number' ? e.which : e.keyCode;
}

function doAxisUpdate(value, oldvalue, isMax) {
  var success = false,
      axisParent = linkedAxis.getLinkedParent();
  // do not update if value has not changed
  if (value === oldvalue + '') {
    return;
  }

  if (isMax) {
    success = axisParent.changeUpperLimits && axisParent.changeUpperLimits(Number(value));
  } else {
    success = axisParent.changeLowerLimits && axisParent.changeLowerLimits(Number(value));
  }

  // if (!success && showRangeError) {
  //   chart.showMessage('Sorry! Not enough range gap to modify axis limit to ' +
  //     (Number(value) || '0') +
  //     '.<br />Please modify the data values to be within range.<br />&nbsp;<br />' +
  //     '(click anywhere on the chart to close this message)', true);
  // }

  return success;
}

function onFocus() {
  var ele = this,
      styleObj = {
    opacity: 1,
    filter: 'alpha(opacity=100)' // IE opacity
  },
      item;

  for (item in styleObj) {
    ele.style[item] = styleObj[item];
  }

  // ele.justFocussed = true;
  // ele.hasFocus = true;
  ele.axisLabel && ele.axisLabel.hide();
  // if (!chart.graphics.hiddenAxisLabels) {
  //   chart.graphics.hiddenAxisLabels = [];
  // }
  // chart.graphics.hiddenAxisLabels.push(ele.axisLabel);
}

function onBlur() {
  var ele = this,
      newValue = ele.value,
      oldValue = ele.oldValue,
      isMaxLabel = ele.isMaxLabel;
  // success = doAxisUpdate(newValue, oldValue, isMaxLabel);

  doAxisUpdate(newValue, oldValue, isMaxLabel);
  // if (success !== true) {
  ele.style.opacity = 0;
  ele.style.filter = 'alpha(opacity=0)';
  // IE opacity
  ele.axisLabel && ele.axisLabel.show();
  // }

  if (_lib.isIE) {
    // To call the actual blur on the element in case of IE
    document.getElementsByTagName('body')[0].focus && document.getElementsByTagName('body')[0].focus();
  }

  // ele.justFocussed = false;
  // ele.hasFocus = false;
}

function onKeyUp(e) {
  var ele = this,
      keyCode = getCharCode(e.originalEvent);
  // newValue = ele.value,
  // oldValue = ele.oldValue,
  // isMaxLabel = ele.isMaxLabel,
  // success;

  if (keyCode === ENTER_CODE) {
    // success = doAxisUpdate(newValue, oldValue, isMaxLabel);
    // if (success === false) {
    //   ele.style.color = '#dd0000';
    // }
    // else {
    _domEvent2['default'].fire(ele, 'blur', e);
    // }
  } else if (keyCode === ESCAPE_CODE) {
    // ele.value = oldValue;
    _domEvent2['default'].fire(ele, 'blur', e);
  }
}

function defaultHandler(inputElement) {
  return function (e) {
    if (inputElement.parentNode) {
      _domEvent2['default'].fire(inputElement, 'blur', e);
    }
  };
}

function defaultIEHandler(inputElement) {
  return function (e) {
    if (e.srcElement !== inputElement && inputElement.hasFocus) {
      _domEvent2['default'].fire(inputElement, 'blur', e);
    }
  };
}

function destroyHandler(inputElement, defaultAction) {
  return function () {
    _domEvent2['default'].unlisten(linkedAxis.getLinkedParent(), 'defaultprevented', defaultAction);
    inputElement.parentNode.removeChild(inputElement);
  };
}

function destroyIEHandler(inputElement, defaultAction) {
  return function () {
    _domEvent2['default'].unlisten(linkedAxis.getLinkedParent().getLinkedItem('container'), 'mousedown', defaultAction);
    inputElement.parentNode.removeChild(inputElement);
  };
}

var LimitUpdater = function (_ComponentInterface) {
  _inherits(LimitUpdater, _ComponentInterface);

  function LimitUpdater() {
    _classCallCheck(this, LimitUpdater);

    return _possibleConstructorReturn(this, _ComponentInterface.apply(this, arguments));
  }

  LimitUpdater.prototype.configure = function configure() {
    this.config.linkedAxis = this.getLinkedParent();
    linkedAxis = this.config.linkedAxis;
  };

  LimitUpdater.prototype.draw = function draw() {
    // draw this component;
    var limitUpdater = this,
        axis = limitUpdater.config.linkedAxis,
        extremeLabels = axis.getAxisConfig('extremeLabels'),
        axisLimits = axis.getLimit(),
        chartContainer = limitUpdater.getFromEnv('chart-container'),
        chartCanvasStyle = limitUpdater.getFromEnv('style').inCanvasStyle,
        inputStyle = (0, _lib.extend2)({
      outline: 'none', // prevent chrome outlining
      '-webkit-appearance': 'none', // disable ios background
      filter: 'alpha(opacity=0)', // IE opacity
      position: 'absolute',
      background: 'transparent',
      border: '1px solid #cccccc',
      textAlign: 'right',
      top: 0,
      left: 0,
      width: 50,
      zIndex: 20,
      opacity: 0,
      borderRadius: 0,
      display: 'block'
    }, chartCanvasStyle),
        labelObj = {
      max: {
        element: extremeLabels.lastLabel.graphic,
        value: axisLimits.max
      },
      min: {
        element: extremeLabels.firstLabel.graphic,
        value: axisLimits.min
      }
    },
        inputElement = void 0,
        inputElementName = void 0,
        labelElement = void 0,
        key = void 0,
        styleKey = void 0,
        labelBox = void 0,
        isMaxLabel = void 0,
        labelValue = void 0,
        closedDefaultHandler = void 0,
        closedDefaultIEHandler = void 0;

    inputStyle.color = (0, _lib.hashify)(inputStyle.color);
    inputStyle.fontSize = inputStyle.fontSize + 'px';

    for (key in labelObj) {
      if (labelObj.hasOwnProperty(key)) {
        labelElement = labelObj[key].element;
        labelBox = labelElement.getBBox();
        labelValue = labelObj[key].value;
        isMaxLabel = key === 'max';
        // inputWidth = labelBox.x + labelBox.width;
        // inputLeft = labelBox.x;

        inputElementName = key + 'Input';
        inputElement = limitUpdater.getGraphicalElement(inputElementName);
        if (!inputElement) {
          inputElement = limitUpdater.addGraphicalElement(inputElementName, (0, _lib.createElement)('input', {
            type: 'text',
            value: labelValue,
            id: 'fc-updater-' + key
          }, chartContainer));
        }

        // Add events to make the textboxes visible on focus and hide when not.
        _domEvent2['default'].listen(inputElement, ['focus', 'blur', 'keyup'], [onFocus, onBlur, onKeyUp]);

        if (_lib.hasSVG) {
          _domEvent2['default'].listen(chartContainer, 'defaultprevented', closedDefaultHandler = defaultHandler(inputElement));
          // cleanup handlers
          _domEvent2['default'].listen(chartContainer, 'destroy', destroyHandler(inputElement, closedDefaultHandler));
        } else {
          _domEvent2['default'].listen(chartContainer, 'mousedown', closedDefaultIEHandler = defaultIEHandler(inputElement));
          // cleanup handlers
          _domEvent2['default'].listen(chartContainer, 'destroy', destroyIEHandler(inputElement, closedDefaultIEHandler));
        }

        inputStyle.top = labelBox.y + 'px';
        inputStyle.left = labelBox.x + 'px';
        inputStyle.width = labelBox.width + 'px';

        for (styleKey in inputStyle) {
          if (inputStyle.hasOwnProperty(styleKey)) {
            inputElement.style[styleKey] = inputStyle[styleKey];
          }
        }

        inputElement.dataValue = labelValue;
        inputElement.value = labelValue;
        inputElement.oldValue = labelValue;
        inputElement.name = labelValue || '';
        inputElement.axisLabel = labelElement;
        inputElement.isMaxLabel = isMaxLabel;
      }
    }
  };

  return LimitUpdater;
}(_componentInterface2['default']);

exports['default'] = LimitUpdater;

/***/ }),
/* 416 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.ToolbarFactory = undefined;

var _storeInstance = __webpack_require__(215);

var _horizontalToolbar = __webpack_require__(417);

var _horizontalToolbar2 = _interopRequireDefault(_horizontalToolbar);

var _componentgroup = __webpack_require__(418);

var _componentgroup2 = _interopRequireDefault(_componentgroup);

var _symbolClass = __webpack_require__(92);

var _symbolClass2 = _interopRequireDefault(_symbolClass);

var _checkboxSymbol = __webpack_require__(419);

var _checkboxSymbol2 = _interopRequireDefault(_checkboxSymbol);

var _scroller = __webpack_require__(420);

var _scroller2 = _interopRequireDefault(_scroller);

var _symbolWithContext = __webpack_require__(216);

var _symbolWithContext2 = _interopRequireDefault(_symbolWithContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var ToolbarFactory = {
  getAPIInstances: function getAPIInstances() {
    return {
      HorizontalToolbar: _horizontalToolbar2['default'],
      ComponentGroup: _componentgroup2['default'],
      Symbol: _symbolClass2['default'],
      CheckboxSymbol: _checkboxSymbol2['default'],
      Scroller: _scroller2['default'],
      SymbolWithContext: _symbolWithContext2['default'],
      getInstanceById: _storeInstance.StoreInstance.getInstanceById
    };
  }
}; /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */

exports.ToolbarFactory = ToolbarFactory;

/***/ }),
/* 417 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _helper = __webpack_require__(26);

var _toolBarFactoryHelper = __webpack_require__(25);

var _storeInstance = __webpack_require__(215);

var _componentInterface = __webpack_require__(6);

var _componentInterface2 = _interopRequireDefault(_componentInterface);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */

var UNDEF = void 0;

/**
 * Creates HorizontalToolbar class
 */

var HorizontalToolbar = function (_ComponentInterface) {
  _inherits(HorizontalToolbar, _ComponentInterface);

  /**
   * Constructor fn of HorizontalToolbar class
   * @param {number} id toolbox id
   * @param {number} poolId toolbox pool id
   */
  function HorizontalToolbar(id, poolId) {
    _classCallCheck(this, HorizontalToolbar);

    var _this = _possibleConstructorReturn(this, _ComponentInterface.call(this));

    _this.id = 'TB_MASTER' + id || (0, _helper.hashCode)(new Date().getTime());
    _storeInstance.StoreInstance.setNewInstance(_this.id, _this);
    _this.toolbarRect = UNDEF;
    _this.componentGroups = [];
    _this.toolbarConfig = _toolBarFactoryHelper.defaultHToolbarConf;
    _this.group = UNDEF;
    _this.pId = poolId;
    return _this;
  }
  /**
   * Returns Component id
   * @return {number} Component id
   */


  HorizontalToolbar.prototype.getId = function getId() {
    return this.id;
  };
  /**
   * Add Component group to the component
   * @param {Object} componentGroup componentGroup instance
   */


  HorizontalToolbar.prototype.addComponent = function addComponent(componentGroup) {
    this.componentGroups.push(componentGroup);
  };
  /**
   * Draws the component
   * @param {number} x [description]
   * @param {number} y [description]
   * @param {Object} options Configuration object
   * @return {Object} Dimension taken by the component (width, height)
   */


  HorizontalToolbar.prototype.draw = function draw(x, y, options) {
    var componentsGroups = this.componentGroups,
        group,
        index,
        length,
        allToolbarLayers,
        thisToolbarLayer,
        id = this.id,
        startX = x,
        startY = y,
        toolbarRect,
        toolbarConf = this.toolbarConfig,
        effectiveWidth,
        effectiveHeight,
        measurementTaken,
        groupSpacing,
        maxHeight = Number.NEGATIVE_INFINITY,
        instanceFn,
        layers = _toolBarFactoryHelper.ToolBarFactoryHelper.getOptions().graphics,
        componentPool = _toolBarFactoryHelper.ToolBarFactoryHelper.getComponentPool(),
        keys = componentPool.getKeys();

    options = options || {};

    allToolbarLayers = layers.toolbar = options.parentGroup || layers.toolbar || {};

    instanceFn = componentPool.getComponent(this.id, this.pId, keys.KEY_GROUP, true);
    this.group = thisToolbarLayer = instanceFn(id, allToolbarLayers);

    instanceFn = componentPool.getComponent(this.id, this.pId, keys.KEY_RECT, true);
    toolbarRect = this.toolbarRect = instanceFn(thisToolbarLayer).attr({
      height: 0,
      width: 0,
      x: startX,
      y: startY
    });

    startX += toolbarConf.hPadding;
    startY += toolbarConf.vPadding;

    for (index = 0, length = componentsGroups.length; index < length; index++) {
      group = componentsGroups[index];
      groupSpacing = group.groupConfig.spacing || 1;
      measurementTaken = group.draw(thisToolbarLayer, { x: startX, y: startY }, index);

      // lastStartX = startX;
      startX += measurementTaken.width + groupSpacing;

      maxHeight = maxHeight > measurementTaken.height ? maxHeight : measurementTaken.height;
    }

    effectiveHeight = maxHeight;
    effectiveWidth = startX - groupSpacing - toolbarConf.hPadding - x;

    isFinite(effectiveHeight) || (effectiveHeight = 0);
    isFinite(effectiveWidth) || (effectiveWidth = 0);

    toolbarRect.attr({
      height: effectiveHeight = effectiveHeight + 2 * toolbarConf.vPadding,
      width: effectiveWidth = effectiveWidth + 2 * toolbarConf.hPadding
    }).attr({
      fill: toolbarConf.fill,
      r: toolbarConf.radius,
      stroke: toolbarConf.borderColor,
      'stroke-width': toolbarConf.borderThickness
    });

    return {
      height: effectiveHeight,
      width: effectiveWidth
    };
  };
  /**
   * Decides space needed for Symbol
   * @return {Object} Consists of width, height
   */


  HorizontalToolbar.prototype.getLogicalSpace = function getLogicalSpace() {
    var componentsGroups = this.componentGroups,
        index,
        length,
        group,
        height = 0,
        width = 0,
        maxHeight = Number.NEGATIVE_INFINITY,
        groupSpacing,
        gLogicalSpace,
        groupWidth = 0;

    for (index = 0, length = componentsGroups.length; index < length; index++) {
      group = componentsGroups[index];
      gLogicalSpace = group.getLogicalSpace();

      groupSpacing = group.groupConfig.spacing || 1;

      width += gLogicalSpace.width + groupSpacing;
      groupWidth += gLogicalSpace.width;

      maxHeight = maxHeight < gLogicalSpace.height ? gLogicalSpace.height : maxHeight;
    }

    // @todo api should not include dirty check like this, but this is the need of the time.
    // if no components are created with spacing but hidden, returns 0
    if (!groupWidth) {
      return {
        width: 0,
        height: 0
      };
    }

    width -= groupSpacing - 2 * this.toolbarConfig.hPadding;
    height = maxHeight + 2 * this.toolbarConfig.vPadding;

    return {
      width: width,
      height: height
    };
  };
  /**
   * Disposes graphics of comonents
   */


  HorizontalToolbar.prototype.dispose = function dispose() {
    var componentPool = _toolBarFactoryHelper.ToolBarFactoryHelper.getComponentPool(),
        componentGroups = this.componentGroups,
        index = 0,
        length = componentGroups.length;

    for (; index < length; index++) {
      componentGroups[index].dispose();
    }

    componentGroups.length = 0;

    this.toolbarRect.remove();
    componentPool.emptyPool(this.pId);
  };

  return HorizontalToolbar;
}(_componentInterface2['default']);

exports['default'] = HorizontalToolbar;

/***/ }),
/* 418 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _lib = __webpack_require__(5);

var _toolbox = __webpack_require__(67);

var _toolBarFactoryHelper = __webpack_require__(25);

var _helper = __webpack_require__(26);

var _componentInterface = __webpack_require__(6);

var _componentInterface2 = _interopRequireDefault(_componentInterface);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */

var UNDEF = void 0;
/**
 * Creates ComponentGroup class
 */

var ComponentGroup = function (_ComponentInterface) {
  _inherits(ComponentGroup, _ComponentInterface);

  /**
   * Constructor fn of ComponentGroup class
   * @param {number} id toolbox id
   * @param {number} poolId pool component id
   */
  function ComponentGroup(id, poolId) {
    _classCallCheck(this, ComponentGroup);

    var _this = _possibleConstructorReturn(this, _ComponentInterface.call(this));

    _this.preId = id || 0;
    _this.id = UNDEF;
    _this.symbolList = [];
    _this.groupRect = UNDEF;
    _this.pId = poolId;
    (0, _lib.extend2)(_this.btnConfig = {}, _toolbox.btnSpecAttr);
    (0, _lib.extend2)(_this.groupConfig = {}, _toolBarFactoryHelper.defaultGroupConf);
    return _this;
  }
  /**
   * Add symbol component in group component
   * @param {Object} instance Symbols to be added
   * @param {boolean} prepend Value to determine whether to append or prepend
   */


  ComponentGroup.prototype.addSymbol = function addSymbol(instance, prepend) {
    var symbolList = this.symbolList;
    if (prepend) {
      symbolList.unshift(instance);
    } else {
      symbolList.push(instance);
    }
  };
  /**
   * Configure component
   * @param {Object} conf Configuration object
   */


  ComponentGroup.prototype.setConfiguaration = function setConfiguaration(conf) {
    var ovrdBtnConf = conf.buttons,
        ovrdGroupConf = conf.group;

    if (ovrdBtnConf) {
      (0, _helper.mergeConf)(ovrdBtnConf, this.btnConfig);
    }
    if (ovrdGroupConf) {
      (0, _helper.mergeConf)(ovrdGroupConf, this.groupConfig);
    }
  };
  /**
   * Draws componet
   * @param {Object} parentLayer Container graphics
   * @param {Object} drawCoord x,y coordinates
   * @param {number} postId attached with id
   * @return {Object} Dimension taken by the componet
   */


  ComponentGroup.prototype.draw = function draw(parentLayer, drawCoord, postId) {
    var preId = this.preId,
        thisToolBarGroupLayers,
        symbolList = this.symbolList,
        index,
        length,
        symbol,
        groupConfig = this.groupConfig,
        btnConfig = this.btnConfig,
        startX = drawCoord.x,
        startY = drawCoord.y,
        groupRect,
        effectiveHeight = 0,
        effectiveWidth = 0,
        bBox,
        maxHeight = Number.NEGATIVE_INFINITY,
        extraCount,
        buttonElem,
        instanceFn,
        id,
        layers = _toolBarFactoryHelper.ToolBarFactoryHelper.getOptions().graphics,
        componentPool = _toolBarFactoryHelper.ToolBarFactoryHelper.getComponentPool(),
        keys = componentPool.getKeys();

    id = this.id = preId.toString() + postId;

    layers.toolbarGroup = layers.toolbar || {};

    instanceFn = componentPool.getComponent(this.id, this.pId, keys.KEY_GROUP);
    thisToolBarGroupLayers = instanceFn('toolbar-group' + id, parentLayer).trackTooltip(true);

    instanceFn = componentPool.getComponent(this.id, this.pId, keys.KEY_RECT);
    groupRect = this.groupRect = instanceFn(thisToolBarGroupLayers).attr({
      height: 0,
      width: 0,
      x: startX,
      y: startY
    });

    startX += groupConfig.hPadding;
    startY += groupConfig.vPadding;

    effectiveWidth += groupConfig.hPadding;
    effectiveHeight += groupConfig.vPadding;

    for (index = 0, length = symbolList.length; index < length; index++) {
      symbol = symbolList[index];
      symbol._setConfiguaration(btnConfig);

      buttonElem = symbol.draw(startX, startY, {
        parentLayer: thisToolBarGroupLayers
      });

      bBox = buttonElem.getBBox();

      if (maxHeight < bBox.height) {
        maxHeight = bBox.height;
      }

      startX += bBox.width + (extraCount = btnConfig.spacing);
    }

    effectiveWidth += startX + groupConfig.hPadding - drawCoord.x - extraCount - groupConfig.offsetAdjustment;
    effectiveHeight += maxHeight + groupConfig.vPadding + groupConfig.offsetAdjustment;

    isFinite(effectiveHeight) || (effectiveHeight = 0);
    isFinite(effectiveWidth) || (effectiveWidth = 0);

    groupRect.attr({
      height: effectiveHeight,
      width: effectiveWidth
    }).attr({
      fill: groupConfig.fill,
      r: groupConfig.radius,
      stroke: groupConfig.borderColor,
      'stroke-width': groupConfig.borderThickness
    });

    bBox = groupRect.getBBox();

    return {
      height: bBox.height,
      width: bBox.width
    };
  };
  /**
   * Decides space needed for Component
   * @return {Object} Consists of width, height
   */


  ComponentGroup.prototype.getLogicalSpace = function getLogicalSpace() {
    var symbolList = this.symbolList,
        symbol,
        index,
        length,
        height = 0,
        width = 0,
        maxHeight = Number.NEGATIVE_INFINITY,
        symbolWidth = 0,
        measurement;

    for (index = 0, length = symbolList.length; index < length; index++) {
      symbol = symbolList[index];
      symbol._setConfiguaration(this.btnConfig);

      measurement = symbol.getLogicalSpace();

      width += measurement.width + this.btnConfig.spacing;
      symbolWidth += measurement.width;

      maxHeight = maxHeight < measurement.height ? measurement.height : maxHeight;
    }

    // @todo api should not include dirty check like this, but this is the need of the time.
    // if no components are created with spacing but hidden, returns 0
    if (!symbolWidth) {
      return {
        width: 0,
        height: 0
      };
    }

    if (maxHeight !== Number.NEGATIVE_INFINITY && width) {
      width -= this.btnConfig.spacing - 2 * this.groupConfig.hPadding - this.groupConfig.offsetAdjustment;
      height = maxHeight + 2 * this.groupConfig.vPadding + this.groupConfig.offsetAdjustment;
    }

    return {
      width: width,
      height: height
    };
  };
  /**
   * Disposes component
   */


  ComponentGroup.prototype.dispose = function dispose() {
    var symbols = this.symbolList,
        index = 0,
        length = symbols.length;

    for (; index < length; index++) {
      symbols[index].dispose();
    }

    symbols.length = 0;

    this.groupRect.remove();
  };

  return ComponentGroup;
}(_componentInterface2['default']);

exports['default'] = ComponentGroup;

/***/ }),
/* 419 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _lib = __webpack_require__(5);

var _symbolClass = __webpack_require__(92);

var _symbolClass2 = _interopRequireDefault(_symbolClass);

var _toolBarFactoryHelper = __webpack_require__(25);

var _helper = __webpack_require__(26);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */

var TEXTBOX_SYMBOL = 'Internal_CB',
    convertColor = _lib.graphics.convertColor,
    TRANSPARENT_FILL = convertColor('FFFFFF', 0),
    UNDEF = void 0;
/**
 * Creates CheckboxSymbol class
 */

var CheckboxSymbol = function (_SymbolClass) {
  _inherits(CheckboxSymbol, _SymbolClass);

  /**
   * Constructor fn of CheckboxSymbol class
   * @param {string} text label of checkbox
   * @param {boolean} isChecked whether the checkbox will be checked or not
   * @param {number} idCount toolbox id
   * @param {number} poolId pool id
   */
  function CheckboxSymbol(text, isChecked, idCount, poolId) {
    _classCallCheck(this, CheckboxSymbol);

    var _this = _possibleConstructorReturn(this, _SymbolClass.call(this, TEXTBOX_SYMBOL));

    _this._id = 'TB_CBSYMBOL' + (idCount || 0);
    _this.symbol = TEXTBOX_SYMBOL;
    _this.text = {
      plaintext: text,
      node: UNDEF,
      style: _toolBarFactoryHelper.defTextStyle
    };
    _this.pId = poolId;
    _this.checked = !!isChecked;
    _this.textNode = UNDEF;
    _this.interPadding = 3;
    _this.pos = {};
    _this.regSymbolCmd = UNDEF;

    if (_this.checked) {
      _this.check();
    } else {
      _this.uncheck();
    }
    return _this;
  }
  /**
   * Make checkbox checked
   */


  CheckboxSymbol.prototype.check = function check() {
    var pos = this.pos;

    this.checked = true;
    this.regSymbolCmd = _helper.RSymbolFns.CB_CHECKED;

    if (this.node) {
      this.registerSymbol(this.regSymbolCmd);
      this.node.attr({ 'button-repaint': [pos.x, pos.y, pos.width, pos.height, pos.r] });
    }
  };
  /**
   * Make checkbox unchecked
   */


  CheckboxSymbol.prototype.uncheck = function uncheck() {
    var pos = this.pos;

    this.checked = false;
    this.regSymbolCmd = _helper.RSymbolFns.CB_NOT_CHECKED;
    if (this.node) {
      this.registerSymbol(this.regSymbolCmd);
      this.node.attr({ 'button-repaint': [pos.x, pos.y, pos.width, pos.height, pos.r] });
    }
  };
  /**
   * Click handler
   */


  CheckboxSymbol.prototype.click = function click() {
    if (this.checked) {
      this.uncheck();
    } else {
      this.check();
    }
  };
  /**
   * Attach events to component
   * @param {Object} eventMap event callback fn
   */


  CheckboxSymbol.prototype.attachEventHandlers = function attachEventHandlers(eventMap) {
    var self = this,
        clickHandler = function clickHandler() {
      self.click();
    };

    _symbolClass2['default'].prototype.attachEventHandlers.apply(this, [eventMap, {
      click: clickHandler
    }]);
  };
  /**
   * Decides space needed for component
   * @return {Object} Consists of width, height
   */


  CheckboxSymbol.prototype.getLogicalSpace = function getLogicalSpace() {
    var chart = _toolBarFactoryHelper.ToolBarFactoryHelper.getOptions().chart,
        smartLabel = chart.linkedItems.smartLabel,
        textStyle = this.text.style,
        smartText,
        symbolMeasurement;

    symbolMeasurement = _symbolClass2['default'].prototype.getLogicalSpace.apply(this, arguments);

    smartLabel.useEllipsesOnOverflow(chart.config.useEllipsesWhenOverflow);
    smartLabel.setStyle(textStyle);
    smartText = smartLabel.getSmartText(this.text.plaintext);

    return {
      width: smartText.width + this.interPadding + symbolMeasurement.width,
      height: Math.max(symbolMeasurement.height, smartText.height)
    };
  };
  /**
   * Draws the component
   * @param {number} x x coordinate
   * @param {number} y y coordinate
   * @param {Object} options Configuration object
   * @return {Object} Bounding dimension taken by element
   */


  CheckboxSymbol.prototype.draw = function draw(x, y, options) {
    var cbElem,
        btnConfig = this.conf,
        bBox,
        smartText,
        chart = _toolBarFactoryHelper.ToolBarFactoryHelper.getOptions().chart,
        smartLabel = chart.getFromEnv('smartLabel'),
        colorManager = chart.getFromEnv('color-manager'),
        plaintext = this.text.plaintext,
        boundingheight,
        boundingRect,
        textStyle,
        instanceFn,
        componentPool = _toolBarFactoryHelper.ToolBarFactoryHelper.getComponentPool(),
        keys = componentPool.getKeys();

    this.registerSymbol(this.regSymbolCmd);
    cbElem = this.node = _symbolClass2['default'].prototype.draw.apply(this, arguments);

    this.pos = {
      x: x,
      y: y,
      width: btnConfig.width,
      height: btnConfig.height,
      r: btnConfig.radius
    };

    textStyle = this.text.style;
    textStyle.fill = textStyle.fill || '#' + colorManager.getColor('baseFontColor');

    smartLabel.useEllipsesOnOverflow(chart.config.useEllipsesWhenOverflow);
    smartLabel.setStyle(textStyle);
    smartText = smartLabel.getSmartText(plaintext);

    bBox = cbElem.getBBox();

    instanceFn = componentPool.getComponent(this._id, this.pId, keys.KEY_TEXT);
    this.textNode = instanceFn(options.parentLayer).attr({
      text: plaintext,
      x: bBox.x + bBox.width + smartText.width / 2 + this.interPadding,
      y: bBox.y + bBox.height / 2
    }).css(textStyle);

    boundingheight = btnConfig.height > smartText.height ? btnConfig.height : smartText.height;

    instanceFn = componentPool.getComponent(this._id, this.pId, keys.KEY_RECT);
    boundingRect = instanceFn(options.parentLayer).attr({
      height: boundingheight,
      width: bBox.width + smartText.width + this.interPadding,
      x: x,
      y: y,
      stroke: TRANSPARENT_FILL
    });

    return boundingRect;
  };
  /**
   * Disposes the component
   */


  CheckboxSymbol.prototype.dispose = function dispose() {
    this.textNode && this.textNode.remove();
    this.textNode = UNDEF;
    _SymbolClass.prototype.dispose.call(this);
  };

  return CheckboxSymbol;
}(_symbolClass2['default']);

exports['default'] = CheckboxSymbol;

/***/ }),
/* 420 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _lib = __webpack_require__(5);

var _symbolClass = __webpack_require__(92);

var _symbolClass2 = _interopRequireDefault(_symbolClass);

var _toolbox = __webpack_require__(67);

var _toolBarFactoryHelper = __webpack_require__(25);

var _helper = __webpack_require__(26);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */

var UNDEF = void 0;
/**
 * Creates Scroller class
 */

var Scroller = function (_SymbolClass) {
  _inherits(Scroller, _SymbolClass);

  /**
   * Constructor function of Scroller class
   * @param {Object} conf configuration object
   * @param {number} id toolbox id
   * @param {number} poolId toolbox pool id
   */
  function Scroller(conf, id, poolId) {
    _classCallCheck(this, Scroller);

    var _this = _possibleConstructorReturn(this, _SymbolClass.call(this));

    _this._id = 'TB_SCROLLER' + (id || 0);
    _this.pId = poolId;
    _this.conf = {};
    _this.userConf = _toolbox.scrollerSpecAttr;
    _this.setConfiguaration(conf);
    _this.evt.scroll = _lib.stubFN;
    return _this;
  }
  /**
   * Sets configuration of the component
   * @param {Object} conf configuration object
   */


  Scroller.prototype.setConfiguaration = function setConfiguaration(conf) {
    var chart = _toolBarFactoryHelper.ToolBarFactoryHelper.getOptions().chart,
        colorManager = chart.getFromEnv('color-manager');

    _toolbox.scrollerSpecAttr.color || (_toolbox.scrollerSpecAttr.color = '#' + colorManager.getColor('altHGridColor'));
    (0, _helper.mergeConf)(_toolbox.scrollerSpecAttr, this.conf);
    (0, _helper.mergeConf)(conf, this.conf);
  };
  /**
   * Decides space needed for Symbol
   * @return {Object} Consists of width, height
   */


  Scroller.prototype.getLogicalSpace = function getLogicalSpace() {
    var conf = this.conf,
        preperaedScrollerSpecAttr = {};

    (0, _helper.mergeConf)(_toolbox.scrollerSpecAttr, preperaedScrollerSpecAttr);

    (0, _helper.mergeConf)(preperaedScrollerSpecAttr, conf);
    return _symbolClass2['default'].prototype.getLogicalSpace.call(this);
  };
  /**
   * Returns default graphics layer
   * @return {Object} Graphics layer
   */


  Scroller.prototype.getDefaultLayer = function getDefaultLayer() {
    var componentPool = _toolBarFactoryHelper.ToolBarFactoryHelper.getComponentPool(),
        keys = componentPool.getKeys(),
        instanceFn,
        defLayer;
    instanceFn = componentPool.getComponent(this._id, this.pId, keys.KEY_GROUP);
    defLayer = instanceFn('scroll');
    return defLayer;
  };
  /**
   * Draws the component
   * @return {Object} node element of graphics
   */


  Scroller.prototype.draw = function draw() {
    var x,
        y,
        height,
        width,
        options,
        isHorizontal,
        parentLayer,
        scrollRatio,
        showButtons,
        displayFlat,
        fullCanvasWidth,
        windowedCanvasWidth,
        color,
        roundEdges,
        createScrollerLayer,
        argObj,
        scrollLayer,
        startPercent,
        conf = this.conf,
        repaintFn,
        instanceFn,
        componentPool = _toolBarFactoryHelper.ToolBarFactoryHelper.getComponentPool(),
        keys = componentPool.getKeys(),
        repaintObj = {},
        newCreated,
        preperaedScrollerSpecAttr = {};

    if (arguments.length === 1) {
      argObj = arguments[0];

      x = argObj.x;
      y = argObj.y;
      parentLayer = argObj.parentLayer;
      createScrollerLayer = !!argObj.sepLayer;
    } else {
      x = arguments[0];
      y = arguments[1];
      options = arguments[2];

      if (conf && options) {
        (0, _helper.mergeConf)(options, conf);
      } else {
        options = {};
      }

      parentLayer = options.parentLayer;
      createScrollerLayer = !!options.sepLayer;
      argObj = conf;
    }

    (0, _helper.mergeConf)(_toolbox.scrollerSpecAttr, preperaedScrollerSpecAttr);

    if (argObj.isHorizontal) {
      delete preperaedScrollerSpecAttr.width;
    } else {
      delete preperaedScrollerSpecAttr.height;
    }

    (0, _helper.mergeConf)(preperaedScrollerSpecAttr, argObj);

    y += argObj.padding;

    height = argObj.height;
    width = argObj.width;
    isHorizontal = argObj.isHorizontal;
    repaintFn = 'scroll-repaint';
    startPercent = argObj.startPercent;
    scrollRatio = argObj.scrollRatio;
    showButtons = argObj.showButtons;
    displayFlat = argObj.displayFlat;
    fullCanvasWidth = argObj.fullCanvasWidth;
    windowedCanvasWidth = argObj.windowedCanvasWidth;
    color = argObj.color;
    roundEdges = argObj.roundEdges;

    repaintObj[repaintFn] = [x, y, width, height];

    parentLayer = parentLayer || this.getDefaultLayer();

    instanceFn = componentPool.getComponent(this._id, this.pId, keys.KEY_RECT);
    scrollLayer = createScrollerLayer ? instanceFn('scroll-child') : parentLayer;

    instanceFn = componentPool.getComponent(this._id, this.pId, keys.KEY_SCROLLER);
    this.node = instanceFn(x, y, width, height, isHorizontal, {
      scrollPosition: argObj.scrollPosition || (0, _lib.pluckNumber)(startPercent, 0),
      displayStyleFlat: displayFlat,
      showButtons: showButtons
    }, scrollLayer);
    this.node.data('fullCanvasWidth', fullCanvasWidth).data('windowedCanvasWidth', windowedCanvasWidth).attr({
      'scroll-ratio': scrollRatio,
      'fill': color,
      r: roundEdges && 2 || 0
    }).scroll(this.evt.scroll);

    newCreated = componentPool.getCreationStatus();

    if (!newCreated) {
      this.node.undrag();

      // this.node.animateWith(dummyObj, animObj, repaintObj, animationDuration, animationObj.animType);
      this.node.attr(repaintObj);
      this.node.attr({
        'scroll-display-style': displayFlat ? 'flat' : '3d',
        'scroll-position': argObj.scrollPosition || (0, _lib.pluckNumber)(startPercent, 0)
      }).scroll(this.evt.scroll);
    }

    return this.node;
  };
  /**
   * Attach events
   * @param {Object} eventMap object of callback fn
   * @return {Object} instance of the component
   */


  Scroller.prototype.attachEventHandlers = function attachEventHandlers(eventMap) {
    var scroller = this;
    if (eventMap && eventMap.scroll && typeof eventMap.scroll === 'function') {
      this.evt.scroll = eventMap.scroll;
    }

    _SymbolClass.prototype.attachEventHandlers.call(this, arguments);
    return scroller;
  };

  return Scroller;
}(_symbolClass2['default']);

Scroller.registerSymbol = UNDEF;

Scroller._setConfiguaration = _lib.stubFN;

exports['default'] = Scroller;

/***/ }),
/* 421 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _toolBarFactoryHelper = __webpack_require__(25);

var _listContainer = __webpack_require__(217);

var _listContainer2 = _interopRequireDefault(_listContainer);

var _atomicList = __webpack_require__(218);

var _atomicList2 = _interopRequireDefault(_atomicList);

var _lib = __webpack_require__(5);

var _componentInterface = __webpack_require__(6);

var _componentInterface2 = _interopRequireDefault(_componentInterface);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */

var UNDEF = void 0,
    DIV = 'div',
    doc = window.document;
/**
 * Creates ListContainerManager class
 */

var ListContainerManager = function (_ComponentInterface) {
  _inherits(ListContainerManager, _ComponentInterface);

  /**
   * Constructor function of ListContainerManager class
   * @param {Object} measurement dimension object
   */
  function ListContainerManager(measurement) {
    _classCallCheck(this, ListContainerManager);

    var _this = _possibleConstructorReturn(this, _ComponentInterface.call(this));

    _this.container = UNDEF;
    _this.listContainer = UNDEF;
    _this.measurement = measurement;
    return _this;
  }
  /**
   * initialize the component
   * @param {number} pId toolbox id
   * @return {Object} Component instance
   */


  ListContainerManager.prototype.init = function init(pId) {
    var componentPool = _toolBarFactoryHelper.ToolBarFactoryHelper.getComponentPool(),
        keys = componentPool.getKeys(),
        instanceFn,
        container;

    if (!this.container) {
      instanceFn = componentPool.getComponent('div0', pId, keys.KEY_DIV);
      container = instanceFn();
      container && (container.innerHTML = '');
      this.container = new _listContainer2['default'](container, this.measurement);
    }
    return this;
  };
  /**
   * Returns graphics container of component
   * @return {Object} Graphics container
   */


  ListContainerManager.prototype.getFirstContainer = function getFirstContainer() {
    return this.container;
  };
  /**
   * Appends the list objects
   * @param {Array} rawDS list of objects needed to append in list
   * @param {Object} refTo Graphics container to append lists
   * @return {Object} Graphics container
   */


  ListContainerManager.prototype.appendAsList = function appendAsList(rawDS, refTo) {
    var self = this,
        con,
        hoverOverStyle = self.container.hoverOverStyle,
        hoverOutStyle = self.container.hoverOutStyle;

    (function recursiveParser(items, fCon) {
      var listItems,
          index = 0,
          length,
          thisItem,
          atomicList,
          key,
          value,
          handler,
          container,
          refContainer;

      container = fCon || self.container;

      if (items instanceof Array) {
        listItems = items;
      } else {
        listItems = [items];
      }

      for (length = listItems.length; index < length; index++) {
        thisItem = listItems[index];
        atomicList = new _atomicList2['default']({
          'hoverOverStyle': hoverOverStyle,
          'hoverOutStyle': hoverOutStyle
        });
        for (key in thisItem) {
          atomicList.name = key;
          value = thisItem[key];
          atomicList.action = value.action;
          atomicList.setStyle(value.style);

          if (key.search(/^<[^<]+>$/) !== -1) {
            atomicList.hoverOverStyle = {};
            atomicList.hoverOutStyle = {};
            value.handler = _lib.stubFN;
          }

          handler = value.handler;

          if (typeof handler !== 'function') {
            refContainer = recursiveParser(handler, new _listContainer2['default'](doc.createElement(DIV)));
          } else {
            atomicList.handler = value.handler;
          }
        }
        container.addAtomicListItem(atomicList);
        if (refContainer) {
          refContainer.parentListCon = container;
          container.refContainers.push(refContainer);
          atomicList.assignSubContainer(refContainer);
        }

        refContainer = UNDEF;
      }

      return con = container;
    })(rawDS, refTo);

    return con;
  };
  /**
   * Dispose function to dispose the elements of the component
   */


  ListContainerManager.prototype.dispose = function dispose() {
    this.container.dispose();
    this.container = UNDEF;
  };

  return ListContainerManager;
}(_componentInterface2['default']);

exports['default'] = ListContainerManager;

/***/ }),
/* 422 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(1);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(2);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertyNames = __webpack_require__(3);

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _setPrototypeOf = __webpack_require__(4);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(0);

var _create2 = _interopRequireDefault(_create);

var _pool2 = __webpack_require__(423);

var _pool3 = _interopRequireDefault(_pool2);

var _componentInterface = __webpack_require__(6);

var _componentInterface2 = _interopRequireDefault(_componentInterface);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defaults(obj, defaults) { var keys = (0, _getOwnPropertyNames2['default'])(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = (0, _getOwnPropertyDescriptor2['default'])(defaults, key); if (value && value.configurable && obj[key] === undefined) { (0, _defineProperty2['default'])(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = (0, _create2['default'])(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2['default'] ? (0, _setPrototypeOf2['default'])(subClass, superClass) : _defaults(subClass, superClass); } /* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */


var doc = window.document,
    DIV = 'div';
/**
 * Creates ComponentPool class
 */

var ComponentPool = function (_ComponentInterface) {
  _inherits(ComponentPool, _ComponentInterface);

  /**
   * Constructor fn of ComponentPool class
   * @param {Object} chart chart component object
   * @param {number} id [description] toolbox id
   */
  function ComponentPool(chart, id) {
    _classCallCheck(this, ComponentPool);

    var actions = void 0,
        pool = void 0,
        elemTypes = void 0,
        cachedState = void 0,
        cache = void 0;

    var _this = _possibleConstructorReturn(this, _ComponentInterface.call(this));

    elemTypes = _this.elemTypes = {
      KEY_RECT: 'rect',
      KEY_TEXT: 'text',
      KEY_GROUP: 'group',
      KEY_SCROLLER: 'scoller',
      KEY_BUTTON: 'button',
      KEY_PATH: 'path',
      KEY_DIV: 'div'
    };

    cachedState = _this.cachedState = {};
    actions = _this.actions = {};

    actions[elemTypes.KEY_DIV] = function () {
      return doc.createElement(DIV);
    };

    actions[elemTypes.KEY_RECT] = function (group) {
      return chart.getFromEnv('paper').rect(group);
    };

    actions[elemTypes.KEY_TEXT] = function (group) {
      return chart.getFromEnv('paper').text(group);
    };

    actions[elemTypes.KEY_GROUP] = function (groupName, parentGroup) {
      return chart.getFromEnv('paper').group(groupName, parentGroup);
    };

    actions[elemTypes.KEY_SCROLLER] = function (x, y, width, height, isHorizontal, confObj, group) {
      return chart.getFromEnv('paper').scroller(x, y, width, height, isHorizontal, confObj, group);
    };

    actions[elemTypes.KEY_BUTTON] = function (x, y, text, symbol, conf, group) {
      return chart.getFromEnv('paper').button(x, y, text, symbol, conf, group);
    };

    actions[elemTypes.KEY_PATH] = function (pathStr, group) {
      return chart.getFromEnv('paper').path(pathStr, group);
    };

    cache = _this.cache = cachedState[id] || (cachedState[id] = {});

    ComponentPool._hideRecursive(cache.pool);
    if (cache.initialized) {
      return _possibleConstructorReturn(_this);
    }

    pool = cache.pool = new _pool3['default']().pool;
    pool._tmp = id;

    cache.initialized = true;
    return _this;
  }

  /**
   * Hides all toolbox components
   * @param {Object} _pool pool object stored
   */


  ComponentPool._hideRecursive = function _hideRecursive(_pool) {
    var keyLevel1, keyLevel2, objLevel1, val, index, length;

    if (!_pool) {
      return;
    }

    for (keyLevel1 in _pool) {
      objLevel1 = _pool[keyLevel1];

      for (keyLevel2 in objLevel1) {
        val = objLevel1[keyLevel2];

        if (val instanceof Array) {
          for (index = 0, length = val.length; index < length; index++) {
            val[index].hide && val[index].hide();
          }
        } else {
          val.hide && val.hide();
        }
      }
    }
  };

  /**
   * Empties pool items
   * @param {number} id pool component id
   */


  ComponentPool.prototype.emptyPool = function emptyPool(id) {
    var cache;
    cache = this.cachedState[id] || {};
    cache.pool && (cache.pool = {});
  };
  /**
   * Returns boolean value whether the component is initialized or not
   * @return {boolean} value whether the component is initialized or not
   */


  ComponentPool.prototype.isInitialized = function isInitialized() {
    return this.initialized;
  };
  /**
   * Returns status of pool creation
   * @return {boolean} Value to determine pool creation
   */


  ComponentPool.prototype.getCreationStatus = function getCreationStatus() {
    return this.newCreationDataFlag;
  };
  /**
   * Recursively hides all components in pool
   * @param {number} id pool component id
   */


  ComponentPool.prototype.hideRecursive = function hideRecursive(id) {
    var cache;
    cache = this.cachedState[id] || {};
    ComponentPool._hideRecursive(cache.pool);
  };
  /**
   * Returns graphics element types
   * @return {Object} Types of graphics elements
   */


  ComponentPool.prototype.getKeys = function getKeys() {
    return this.elemTypes;
  };
  /**
   * [getComponent description]
   * @param {string} id Element id
   * @param {number} poolId pool component id
   * @param {string} elemType Element type
   * @param {boolean} storeTillReCall [description]
   * @return {Function} [description]
   */


  ComponentPool.prototype.getComponent = function getComponent(id, poolId, elemType, storeTillReCall) {
    var cache = this.cachedState[poolId || 0] || {},
        pool = cache.pool,
        idSpecificPool = pool[id],
        multiInstance,
        instance,
        inst,
        actions = this.actions,
        instanceRetrieved = 0;

    if (!idSpecificPool) {
      idSpecificPool = pool[id] = {};
    }

    instance = idSpecificPool[elemType];

    if (instance && !(instance instanceof Array) || instance instanceof Array && instance.length > 0) {
      return function () {
        cache.newCreationDataFlag = false;
        if (storeTillReCall) {
          inst = instance[instanceRetrieved++];
          if (inst) {
            return inst.show();
          } else {
            return instance[instanceRetrieved] = actions[elemType].apply(cache, arguments);
          }
        }

        return instance.show && typeof instance.show === 'function' && instance.show() || instance;
      };
    }
    return function () {
      cache.newCreationDataFlag = true;
      if (storeTillReCall) {
        multiInstance = idSpecificPool[elemType] || (idSpecificPool[elemType] = []);
        instance = actions[elemType].apply(cache, arguments);
        multiInstance.push(instance);

        return instance.show && typeof instance.show === 'function' && instance.show() || instance;
      }

      return idSpecificPool[elemType] = actions[elemType].apply(cache, arguments);
    };
  };

  return ComponentPool;
}(_componentInterface2['default']);

exports['default'] = ComponentPool;

/***/ }),
/* 423 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* eslint require-jsdoc: 'error', valid-jsdoc: 'error' */

/**
 * Creates Pool Class
 */
var Pool =
/**
 * Constructor function of Pool class
 */
function Pool() {
  _classCallCheck(this, Pool);

  this.pool = {};
};

exports["default"] = Pool;

/***/ }),
/* 424 */,
/* 425 */,
/* 426 */,
/* 427 */,
/* 428 */,
/* 429 */,
/* 430 */,
/* 431 */,
/* 432 */,
/* 433 */,
/* 434 */,
/* 435 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(436);
module.exports = __webpack_require__(82).Array.isArray;

/***/ }),
/* 436 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = __webpack_require__(52);

$export($export.S, 'Array', {isArray: __webpack_require__(194)});

/***/ }),
/* 437 */,
/* 438 */,
/* 439 */,
/* 440 */,
/* 441 */,
/* 442 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = __webpack_require__(52);

$export($export.P, 'Array', {fill: __webpack_require__(443)});

__webpack_require__(130)('fill');

/***/ }),
/* 443 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)

var toObject = __webpack_require__(191)
  , toIndex  = __webpack_require__(444)
  , toLength = __webpack_require__(192);
module.exports = function fill(value /*, start = 0, end = @length */){
  var O      = toObject(this)
    , length = toLength(O.length)
    , aLen   = arguments.length
    , index  = toIndex(aLen > 1 ? arguments[1] : undefined, length)
    , end    = aLen > 2 ? arguments[2] : undefined
    , endPos = end === undefined ? length : toIndex(end, length);
  while(endPos > index)O[index++] = value;
  return O;
};

/***/ }),
/* 444 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(193)
  , max       = Math.max
  , min       = Math.min;
module.exports = function(index, length){
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

/***/ }),
/* 445 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(52)
  , $map    = __webpack_require__(84)(1);

$export($export.P + $export.F * !__webpack_require__(196)([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */){
    return $map(this, callbackfn, arguments[1]);
  }
});

/***/ })
/******/ ])["default"];
});
//# sourceMappingURL=fusioncharts.js.map